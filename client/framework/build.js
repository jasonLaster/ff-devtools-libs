var Toolbox =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	const MAX_ORDINAL = 99;
	const ZOOM_PREF = "devtools.toolbox.zoomValue";
	const SPLITCONSOLE_ENABLED_PREF = "devtools.toolbox.splitconsoleEnabled";
	const SPLITCONSOLE_HEIGHT_PREF = "devtools.toolbox.splitconsoleHeight";
	const MIN_ZOOM = 0.5;
	const MAX_ZOOM = 2;
	const OS_HISTOGRAM = "DEVTOOLS_OS_ENUMERATED_PER_USER";
	const OS_IS_64_BITS = "DEVTOOLS_OS_IS_64_BITS_PER_USER";
	const SCREENSIZE_HISTOGRAM = "DEVTOOLS_SCREEN_RESOLUTION_ENUMERATED_PER_USER";

	var _require = __webpack_require__(1);

	var Cc = _require.Cc;
	var Ci = _require.Ci;
	var Cu = _require.Cu;

	var promise = __webpack_require__(6);
	var EventEmitter = __webpack_require__(7);
	var Telemetry = __webpack_require__(8);
	// var HUDService = require("devtools/client/webconsole/hudservice");
	// var sourceUtils = require("devtools/client/shared/source-utils");

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	var _require3 = __webpack_require__(16);

	const gDevTools = _require3.gDevTools;

	var _require4 = __webpack_require__(38);

	const Task = _require4.Task;

	const bundle = Services.strings.createBundle(__webpack_require__(92));

	var toolboxStrings = function (name, ...args) {
	  try {
	    if (!args.length) {
	      return bundle.GetStringFromName(name);
	    }
	    return bundle.formatStringFromName(name, args, args.length);
	  } catch (ex) {
	    console.error("Error reading '" + name + "'");
	    return null;
	  }
	};

	var _require5 = __webpack_require__(95);

	const getHighlighterUtils = _require5.getHighlighterUtils;

	var _require6 = __webpack_require__(96);

	const Hosts = _require6.Hosts;

	var _require7 = __webpack_require__(98);

	const Selection = _require7.Selection;

	var _require8 = __webpack_require__(99);

	const InspectorFront = _require8.InspectorFront;

	const DevToolsUtils = __webpack_require__(19);
	// const { showDoorhanger } = require("devtools/client/shared/doorhanger");
	// const { createPerformanceFront } = require("devtools/server/actors/performance");
	// const system = require("devtools/shared/system");
	// loader.lazyGetter(this, "osString", () => {
	//   return Cc("@mozilla.org/xre/app-info;1").getService(Ci.nsIXULRuntime).OS;
	// });
	// loader.lazyGetter(this, "registerHarOverlay", () => {
	//   return require("devtools/client/netmonitor/har/toolbox-overlay").register;
	// });

	// White-list buttons that can be toggled to prevent adding prefs for
	// addons that have manually inserted toolbarbuttons into DOM.
	// (By default, supported target is only local tab)
	const ToolboxButtons = exports.ToolboxButtons = [{ id: "command-button-pick",
	  isTargetSupported: function (target) {
	    return target.getTrait("highlightable");
	  }
	}, { id: "command-button-frames",
	  isTargetSupported: function (target) {
	    return target.activeTab && target.activeTab.traits.frames;
	  }
	}, { id: "command-button-splitconsole",
	  isTargetSupported: function (target) {
	    return !target.isAddon;
	  } }, { id: "command-button-responsive" }, { id: "command-button-paintflashing" }, { id: "command-button-tilt",
	  commands: "devtools/client/tilt/tilt-commands" }, { id: "command-button-scratchpad" }, { id: "command-button-eyedropper" }, { id: "command-button-screenshot" }, { id: "command-button-rulers" }, { id: "command-button-measure" }];

	exports.getWSTarget = Task.async(function* () {
	  var _require9 = __webpack_require__(18);

	  let DebuggerClient = _require9.DebuggerClient;

	  var _require10 = __webpack_require__(107);

	  let DebuggerTransport = _require10.DebuggerTransport;

	  var _require11 = __webpack_require__(38);

	  let Task = _require11.Task;

	  var _require12 = __webpack_require__(17);

	  let TargetFactory = _require12.TargetFactory;

	  var _require13 = __webpack_require__(99);

	  let InspectorFront = _require13.InspectorFront;

	  let socket = new WebSocket("ws://localhost:9000");
	  let transport = new DebuggerTransport(socket);
	  let client = new DebuggerClient(transport);
	  yield client.connect();

	  let response = yield client.listTabs();
	  let tab = response.tabs[response.selected];

	  let options = {
	    form: tab,
	    client,
	    chrome: false
	  };
	  let target = yield TargetFactory.forRemoteTab(options);
	  return target;
	});

	/**
	 * A "Toolbox" is the component that holds all the tools for one specific
	 * target. Visually, it's a document that includes the tools tabs and all
	 * the iframes where the tool panels will be living in.
	 *
	 * @param {object} target
	 *        The object the toolbox is debugging.
	 * @param {string} selectedTool
	 *        Tool to select initially
	 * @param {Toolbox.HostType} hostType
	 *        Type of host that will host the toolbox (e.g. sidebar, window)
	 * @param {object} hostOptions
	 *        Options for host specifically
	 */
	function Toolbox(target, selectedTool, hostType, hostOptions) {
	  this._target = target;
	  this._toolPanels = new Map();
	  this._telemetry = new Telemetry();

	  this._initInspector = null;
	  this._inspector = null;

	  this._toolRegistered = this._toolRegistered.bind(this);
	  this._toolUnregistered = this._toolUnregistered.bind(this);
	  this._refreshHostTitle = this._refreshHostTitle.bind(this);
	  this.selectFrame = this.selectFrame.bind(this);
	  this._updateFrames = this._updateFrames.bind(this);
	  this._splitConsoleOnKeypress = this._splitConsoleOnKeypress.bind(this);
	  this.destroy = this.destroy.bind(this);
	  this.highlighterUtils = getHighlighterUtils(this);
	  this._highlighterReady = this._highlighterReady.bind(this);
	  this._highlighterHidden = this._highlighterHidden.bind(this);
	  this._prefChanged = this._prefChanged.bind(this);
	  this._saveSplitConsoleHeight = this._saveSplitConsoleHeight.bind(this);
	  this._onFocus = this._onFocus.bind(this);
	  this._showDevEditionPromo = this._showDevEditionPromo.bind(this);
	  this._updateTextboxMenuItems = this._updateTextboxMenuItems.bind(this);
	  this._onBottomHostMinimized = this._onBottomHostMinimized.bind(this);
	  this._onBottomHostMaximized = this._onBottomHostMaximized.bind(this);
	  this._onToolSelectWhileMinimized = this._onToolSelectWhileMinimized.bind(this);
	  this._onPerformanceFrontEvent = this._onPerformanceFrontEvent.bind(this);
	  this._onBottomHostWillChange = this._onBottomHostWillChange.bind(this);
	  this._toggleMinimizeMode = this._toggleMinimizeMode.bind(this);

	  this._target.on("close", this.destroy);

	  if (!hostType) {
	    hostType = Services.prefs.getCharPref(this._prefs.LAST_HOST);
	  }
	  if (!selectedTool) {
	    selectedTool = Services.prefs.getCharPref(this._prefs.LAST_TOOL);
	  }
	  this._defaultToolId = selectedTool;

	  this._hostOptions = hostOptions;
	  this._host = this._createHost(hostType, hostOptions);

	  EventEmitter.decorate(this);

	  this._target.on("navigate", this._refreshHostTitle);
	  this._target.on("frame-update", this._updateFrames);

	  this.on("host-changed", this._refreshHostTitle);
	  this.on("select", this._refreshHostTitle);

	  this.on("ready", this._showDevEditionPromo);

	  gDevTools.on("tool-registered", this._toolRegistered);
	  gDevTools.on("tool-unregistered", this._toolUnregistered);
	}
	exports.Toolbox = Toolbox;

	/**
	 * The toolbox can be 'hosted' either embedded in a browser window
	 * or in a separate window.
	 */
	Toolbox.HostType = {
	  BOTTOM: "bottom",
	  SIDE: "side",
	  WINDOW: "window",
	  CUSTOM: "custom"
	};

	Toolbox.prototype = {
	  _URL: "toolbox.xhtml",

	  _prefs: {
	    LAST_HOST: "devtools.toolbox.host",
	    LAST_TOOL: "devtools.toolbox.selectedTool",
	    SIDE_ENABLED: "devtools.toolbox.sideEnabled",
	    PREVIOUS_HOST: "devtools.toolbox.previousHost"
	  },

	  currentToolId: null,
	  lastUsedToolId: null,

	  /**
	   * Returns a *copy* of the _toolPanels collection.
	   *
	   * @return {Map} panels
	   *         All the running panels in the toolbox
	   */
	  getToolPanels: function () {
	    return new Map(this._toolPanels);
	  },

	  /**
	   * Access the panel for a given tool
	   */
	  getPanel: function (id) {
	    return this._toolPanels.get(id);
	  },

	  /**
	   * Get the panel instance for a given tool once it is ready.
	   * If the tool is already opened, the promise will resolve immediately,
	   * otherwise it will wait until the tool has been opened before resolving.
	   *
	   * Note that this does not open the tool, use selectTool if you'd
	   * like to select the tool right away.
	   *
	   * @param  {String} id
	   *         The id of the panel, for example "jsdebugger".
	   * @returns Promise
	   *          A promise that resolves once the panel is ready.
	   */
	  getPanelWhenReady: function (id) {
	    let deferred = promise.defer();
	    let panel = this.getPanel(id);
	    if (panel) {
	      deferred.resolve(panel);
	    } else {
	      this.on(id + "-ready", function (e, panel) {
	        deferred.resolve(panel);
	      });
	    }

	    return deferred.promise;
	  },

	  /**
	   * This is a shortcut for getPanel(currentToolId) because it is much more
	   * likely that we're going to want to get the panel that we've just made
	   * visible
	   */
	  getCurrentPanel: function () {
	    return this._toolPanels.get(this.currentToolId);
	  },

	  /**
	   * Get/alter the target of a Toolbox so we're debugging something different.
	   * See Target.jsm for more details.
	   * TODO: Do we allow |toolbox.target = null;| ?
	   */
	  get target() {
	    return this._target;
	  },

	  /**
	   * Get/alter the host of a Toolbox, i.e. is it in browser or in a separate
	   * tab. See HostType for more details.
	   */
	  get hostType() {
	    return this._host.type;
	  },

	  /**
	   * Get the iframe containing the toolbox UI.
	   */
	  get frame() {
	    return this._host.frame;
	  },

	  /**
	   * Shortcut to the document containing the toolbox UI
	   */
	  get doc() {
	    return this.frame.contentDocument;
	  },

	  /**
	   * Get current zoom level of toolbox
	   */
	  get zoomValue() {
	    return parseFloat(Services.prefs.getCharPref(ZOOM_PREF));
	  },

	  /**
	   * Get the toolbox highlighter front. Note that it may not always have been
	   * initialized first. Use `initInspector()` if needed.
	   * Consider using highlighterUtils instead, it exposes the highlighter API in
	   * a useful way for the toolbox panels
	   */
	  get highlighter() {
	    return this._highlighter;
	  },

	  /**
	   * Get the toolbox's performance front. Note that it may not always have been
	   * initialized first. Use `initPerformance()` if needed.
	   */
	  get performance() {
	    return this._performance;
	  },

	  /**
	   * Get the toolbox's inspector front. Note that it may not always have been
	   * initialized first. Use `initInspector()` if needed.
	   */
	  get inspector() {
	    return this._inspector;
	  },

	  /**
	   * Get the toolbox's walker front. Note that it may not always have been
	   * initialized first. Use `initInspector()` if needed.
	   */
	  get walker() {
	    return this._walker;
	  },

	  /**
	   * Get the toolbox's node selection. Note that it may not always have been
	   * initialized first. Use `initInspector()` if needed.
	   */
	  get selection() {
	    return this._selection;
	  },

	  /**
	   * Get the toggled state of the split console
	   */
	  get splitConsole() {
	    return this._splitConsole;
	  },
	  /**
	   * Get the focused state of the split console
	   */
	  isSplitConsoleFocused: function () {
	    if (!this._splitConsole) {
	      return false;
	    }
	    let focusedWin = Services.focus.focusedWindow;
	    return focusedWin && focusedWin === this.doc.querySelector("#toolbox-panel-iframe-webconsole").contentWindow;
	  },

	  /**
	   * Open the toolbox
	   */
	  open: function () {
	    return Task.spawn((function* () {
	      var _this = this;

	      let iframe = yield this._host.create();

	      // Load the toolbox-level actor fronts and utilities now
	      yield this._target.makeRemote();
	      yield new Promise(function (resolve) {
	        iframe.setAttribute("src", _this._URL);
	        iframe.setAttribute("aria-label", toolboxStrings("toolbox.label"));
	        iframe.onload = resolve;
	      });

	      this.isReady = true;
	      let framesPromise = this._listFrames();

	      this.closeButton = this.doc.getElementById("toolbox-close");
	      this.closeButton.addEventListener("click", this.destroy, true);

	      gDevTools.on("pref-changed", this._prefChanged);

	      let framesMenu = this.doc.getElementById("command-button-frames");
	      framesMenu.addEventListener("click", this.selectFrame, true);

	      this.textboxContextMenuPopup = this.doc.getElementById("toolbox-textbox-context-popup");
	      this.textboxContextMenuPopup.addEventListener("popupshowing", this._updateTextboxMenuItems, true);

	      this._buildDockButtons();
	      this._buildOptions();
	      this._buildTabs();
	      this._applyCacheSettings();
	      this._applyServiceWorkersTestingSettings();
	      this._addKeysToWindow();
	      this._addReloadKeys();
	      this._addHostListeners();
	      this._registerOverlays();
	      if (this._hostOptions && this._hostOptions.zoom === false) {
	        this._disableZoomKeys();
	      } else {
	        this._addZoomKeys();
	        this._loadInitialZoom();
	      }

	      this.webconsolePanel = this.doc.querySelector("#toolbox-panel-webconsole");
	      this.webconsolePanel.height = Services.prefs.getIntPref(SPLITCONSOLE_HEIGHT_PREF);
	      this.webconsolePanel.addEventListener("resize", this._saveSplitConsoleHeight);

	      let buttonsPromise = this._buildButtons();

	      this._pingTelemetry();

	      // The isTargetSupported check needs to happen after the target is
	      // remoted, otherwise we could have done it in the toolbox constructor
	      // (bug 1072764).
	      let toolDef = gDevTools.getToolDefinition(this._defaultToolId);
	      if (!toolDef || !toolDef.isTargetSupported(this._target)) {
	        this._defaultToolId = "webconsole";
	      }

	      yield this.selectTool(this._defaultToolId);

	      // Wait until the original tool is selected so that the split
	      // console input will receive focus.
	      let splitConsolePromise = promise.resolve();
	      if (Services.prefs.getBoolPref(SPLITCONSOLE_ENABLED_PREF)) {
	        splitConsolePromise = this.openSplitConsole();
	      }

	      yield promise.all([splitConsolePromise, buttonsPromise, framesPromise]);

	      // Lazily connect to the profiler here and don't wait for it to complete,
	      // used to intercept console.profile calls before the performance tools are open.
	      let performanceFrontConnection = this.initPerformance();

	      // If in testing environment, wait for performance connection to finish,
	      // so we don't have to explicitly wait for this in tests; ideally, all tests
	      // will handle this on their own, but each have their own tear down function.
	      if (DevToolsUtils.testing) {
	        yield performanceFrontConnection;
	      }

	      this.emit("ready");
	    }).bind(this)).then(null, console.error.bind(console));
	  },

	  _pingTelemetry: function () {
	    this._telemetry.toolOpened("toolbox");

	    // this._telemetry.logOncePerBrowserVersion(OS_HISTOGRAM, system.getOSCPU());
	    // this._telemetry.logOncePerBrowserVersion(OS_IS_64_BITS, system.is64Bit ? 1 : 0);
	    // this._telemetry.logOncePerBrowserVersion(SCREENSIZE_HISTOGRAM, system.getScreenDimensions());
	  },

	  /**
	   * Because our panels are lazy loaded this is a good place to watch for
	   * "pref-changed" events.
	   * @param  {String} event
	   *         The event type, "pref-changed".
	   * @param  {Object} data
	   *         {
	   *           newValue: The new value
	   *           oldValue:  The old value
	   *           pref: The name of the preference that has changed
	   *         }
	   */
	  _prefChanged: function (event, data) {
	    switch (data.pref) {
	      case "devtools.cache.disabled":
	        this._applyCacheSettings();
	        break;
	      case "devtools.serviceWorkers.testing.enabled":
	        this._applyServiceWorkersTestingSettings();
	        break;
	    }
	  },

	  _buildOptions: function () {
	    var _this2 = this;

	    let selectOptions = function () {
	      // Flip back to the last used panel if we are already
	      // on the options panel.
	      if (_this2.currentToolId === "options" && gDevTools.getToolDefinition(_this2.lastUsedToolId)) {
	        _this2.selectTool(_this2.lastUsedToolId);
	      } else {
	        _this2.selectTool("options");
	      }
	    };
	    let key = this.doc.getElementById("toolbox-options-key");
	    key.addEventListener("command", selectOptions, true);
	    let key2 = this.doc.getElementById("toolbox-options-key2");
	    key2.addEventListener("command", selectOptions, true);
	  },

	  _splitConsoleOnKeypress: function (e) {
	    if (e.keyCode === e.DOM_VK_ESCAPE) {
	      this.toggleSplitConsole();
	      // If the debugger is paused, don't let the ESC key stop any pending
	      // navigation.
	      let jsdebugger = this.getPanel("jsdebugger");
	      if (jsdebugger && jsdebugger.panelWin.gThreadClient.state == "paused") {
	        e.preventDefault();
	      }
	    }
	  },
	  /**
	   * Add a shortcut key that should work when a split console
	   * has focus to the toolbox.
	   *
	   * @param {element} keyElement
	   *        They <key> XUL element describing the shortcut key
	   * @param {string} whichTool
	   *        The tool the key belongs to. The corresponding command
	   *        will only trigger if this tool is active.
	   */
	  useKeyWithSplitConsole: function (keyElement, whichTool) {
	    var _this3 = this;

	    let cloned = keyElement.cloneNode();
	    cloned.setAttribute("oncommand", "void(0)");
	    cloned.removeAttribute("command");
	    cloned.addEventListener("command", function (e) {
	      // Only forward the command if the tool is active
	      if (_this3.currentToolId === whichTool && _this3.isSplitConsoleFocused()) {
	        keyElement.doCommand();
	      }
	    }, true);
	    this.doc.getElementById("toolbox-keyset").appendChild(cloned);
	  },

	  _addReloadKeys: function () {
	    var _this4 = this;

	    [["toolbox-reload-key", false], ["toolbox-reload-key2", false], ["toolbox-force-reload-key", true], ["toolbox-force-reload-key2", true]].forEach(function ([id, force]) {
	      _this4.doc.getElementById(id).addEventListener("command", function () {
	        _this4.reloadTarget(force);
	      }, true);
	    });
	  },

	  _addHostListeners: function () {
	    let nextKey = this.doc.getElementById("toolbox-next-tool-key");
	    nextKey.addEventListener("command", this.selectNextTool.bind(this), true);

	    let prevKey = this.doc.getElementById("toolbox-previous-tool-key");
	    prevKey.addEventListener("command", this.selectPreviousTool.bind(this), true);

	    let minimizeKey = this.doc.getElementById("toolbox-minimize-key");
	    minimizeKey.addEventListener("command", this._toggleMinimizeMode, true);

	    let toggleKey = this.doc.getElementById("toolbox-toggle-host-key");
	    toggleKey.addEventListener("command", this.switchToPreviousHost.bind(this), true);

	    if (Services.prefs.prefHasUserValue("devtools.loader.srcdir")) {
	      let reloadKey = this.doc.getElementById("tools-reload-key");
	      reloadKey.addEventListener("command", this.reload.bind(this), true);
	    }

	    // Split console uses keypress instead of command so the event can be
	    // cancelled with stopPropagation on the keypress, and not preventDefault.
	    this.doc.addEventListener("keypress", this._splitConsoleOnKeypress, false);

	    this.doc.addEventListener("focus", this._onFocus, true);
	  },

	  _registerOverlays: function () {
	    // registerHarOverlay(this);
	  },

	  _saveSplitConsoleHeight: function () {
	    Services.prefs.setIntPref(SPLITCONSOLE_HEIGHT_PREF, this.webconsolePanel.height);
	  },

	  /**
	   * Make sure that the console is showing up properly based on all the
	   * possible conditions.
	   *   1) If the console tab is selected, then regardless of split state
	   *      it should take up the full height of the deck, and we should
	   *      hide the deck and splitter.
	   *   2) If the console tab is not selected and it is split, then we should
	   *      show the splitter, deck, and console.
	   *   3) If the console tab is not selected and it is *not* split,
	   *      then we should hide the console and splitter, and show the deck
	   *      at full height.
	   */
	  _refreshConsoleDisplay: function () {
	    let deck = this.doc.getElementById("toolbox-deck");
	    let webconsolePanel = this.webconsolePanel;
	    let splitter = this.doc.getElementById("toolbox-console-splitter");
	    let openedConsolePanel = this.currentToolId === "webconsole";

	    if (openedConsolePanel) {
	      deck.setAttribute("collapsed", "true");
	      splitter.setAttribute("hidden", "true");
	      webconsolePanel.removeAttribute("collapsed");
	    } else {
	      deck.removeAttribute("collapsed");
	      if (this.splitConsole) {
	        webconsolePanel.removeAttribute("collapsed");
	        splitter.removeAttribute("hidden");
	      } else {
	        webconsolePanel.setAttribute("collapsed", "true");
	        splitter.setAttribute("hidden", "true");
	      }
	    }
	  },

	  /**
	   * Wire up the listeners for the zoom keys.
	   */
	  _addZoomKeys: function () {
	    let inKey = this.doc.getElementById("toolbox-zoom-in-key");
	    inKey.addEventListener("command", this.zoomIn.bind(this), true);

	    let inKey2 = this.doc.getElementById("toolbox-zoom-in-key2");
	    inKey2.addEventListener("command", this.zoomIn.bind(this), true);

	    let inKey3 = this.doc.getElementById("toolbox-zoom-in-key3");
	    inKey3.addEventListener("command", this.zoomIn.bind(this), true);

	    let outKey = this.doc.getElementById("toolbox-zoom-out-key");
	    outKey.addEventListener("command", this.zoomOut.bind(this), true);

	    let outKey2 = this.doc.getElementById("toolbox-zoom-out-key2");
	    outKey2.addEventListener("command", this.zoomOut.bind(this), true);

	    let resetKey = this.doc.getElementById("toolbox-zoom-reset-key");
	    resetKey.addEventListener("command", this.zoomReset.bind(this), true);

	    let resetKey2 = this.doc.getElementById("toolbox-zoom-reset-key2");
	    resetKey2.addEventListener("command", this.zoomReset.bind(this), true);
	  },

	  _disableZoomKeys: function () {
	    let inKey = this.doc.getElementById("toolbox-zoom-in-key");
	    inKey.setAttribute("disabled", "true");

	    let inKey2 = this.doc.getElementById("toolbox-zoom-in-key2");
	    inKey2.setAttribute("disabled", "true");

	    let inKey3 = this.doc.getElementById("toolbox-zoom-in-key3");
	    inKey3.setAttribute("disabled", "true");

	    let outKey = this.doc.getElementById("toolbox-zoom-out-key");
	    outKey.setAttribute("disabled", "true");

	    let outKey2 = this.doc.getElementById("toolbox-zoom-out-key2");
	    outKey2.setAttribute("disabled", "true");

	    let resetKey = this.doc.getElementById("toolbox-zoom-reset-key");
	    resetKey.setAttribute("disabled", "true");

	    let resetKey2 = this.doc.getElementById("toolbox-zoom-reset-key2");
	    resetKey2.setAttribute("disabled", "true");
	  },

	  /**
	   * Set zoom on toolbox to whatever the last setting was.
	   */
	  _loadInitialZoom: function () {
	    this.setZoom(this.zoomValue);
	  },

	  /**
	   * Increase zoom level of toolbox window - make things bigger.
	   */
	  zoomIn: function () {
	    this.setZoom(this.zoomValue + 0.1);
	  },

	  /**
	   * Decrease zoom level of toolbox window - make things smaller.
	   */
	  zoomOut: function () {
	    this.setZoom(this.zoomValue - 0.1);
	  },

	  /**
	   * Reset zoom level of the toolbox window.
	   */
	  zoomReset: function () {
	    this.setZoom(1);
	  },

	  /**
	   * Set zoom level of the toolbox window.
	   *
	   * @param {number} zoomValue
	   *        Zoom level e.g. 1.2
	   */
	  setZoom: function (zoomValue) {
	    // cap zoom value
	    zoomValue = Math.max(zoomValue, MIN_ZOOM);
	    zoomValue = Math.min(zoomValue, MAX_ZOOM);

	    // let contViewer = this.frame.docShell.contentViewer;
	    // contViewer.fullZoom = zoomValue;
	    // Services.prefs.setCharPref(ZOOM_PREF, zoomValue);
	  },

	  /**
	   * Adds the keys and commands to the Toolbox Window in window mode.
	   */
	  _addKeysToWindow: function () {
	    var _this5 = this;

	    if (this.hostType != Toolbox.HostType.WINDOW) {
	      return;
	    }

	    let doc = this.doc.defaultView.parent.document;

	    for (let _ref of gDevTools.getToolDefinitionMap()) {
	      var _ref2 = _slicedToArray(_ref, 2);

	      let id = _ref2[0];
	      let toolDefinition = _ref2[1];

	      // Prevent multiple entries for the same tool.
	      if (!toolDefinition.key || doc.getElementById("key_" + id)) {
	        continue;
	      }

	      let toolId = id;
	      let key = doc.createElement("key");

	      key.id = "key_" + toolId;

	      if (toolDefinition.key.startsWith("VK_")) {
	        key.setAttribute("keycode", toolDefinition.key);
	      } else {
	        key.setAttribute("key", toolDefinition.key);
	      }

	      key.setAttribute("modifiers", toolDefinition.modifiers);
	      // needed. See bug 371900
	      key.setAttribute("oncommand", "void(0);");
	      key.addEventListener("command", function () {
	        _this5.selectTool(toolId).then(function () {
	          return _this5.fireCustomKey(toolId);
	        });
	      }, true);
	      doc.getElementById("toolbox-keyset").appendChild(key);
	    }

	    // Add key for toggling the browser console from the detached window
	    if (!doc.getElementById("key_browserconsole")) {
	      let key = doc.createElement("key");
	      key.id = "key_browserconsole";

	      key.setAttribute("key", toolboxStrings("browserConsoleCmd.commandkey"));
	      key.setAttribute("modifiers", "accel,shift");
	      // needed. See bug 371900
	      key.setAttribute("oncommand", "void(0)");
	      key.addEventListener("command", function () {
	        HUDService.toggleBrowserConsole();
	      }, true);
	      doc.getElementById("toolbox-keyset").appendChild(key);
	    }
	  },

	  /**
	   * Handle any custom key events.  Returns true if there was a custom key
	   * binding run.
	   * @param {string} toolId Which tool to run the command on (skip if not
	   * current)
	   */
	  fireCustomKey: function (toolId) {
	    let toolDefinition = gDevTools.getToolDefinition(toolId);

	    if (toolDefinition.onkey && (this.currentToolId === toolId || toolId == "webconsole" && this.splitConsole)) {
	      toolDefinition.onkey(this.getCurrentPanel(), this);
	    }
	  },

	  /**
	   * Build the buttons for changing hosts. Called every time
	   * the host changes.
	   */
	  _buildDockButtons: function () {
	    var _this6 = this;

	    let dockBox = this.doc.getElementById("toolbox-dock-buttons");

	    while (dockBox.firstChild) {
	      dockBox.removeChild(dockBox.firstChild);
	    }

	    if (!this._target.isLocalTab) {
	      return;
	    }

	    // Bottom-type host can be minimized, add a button for this.
	    if (this.hostType == Toolbox.HostType.BOTTOM) {
	      let minimizeBtn = this.doc.createElement("button");
	      minimizeBtn.id = "toolbox-dock-bottom-minimize";
	      minimizeBtn.className = "devtools-button";

	      minimizeBtn.addEventListener("click", this._toggleMinimizeMode);
	      dockBox.appendChild(minimizeBtn);
	      // Show the button in its maximized state.
	      this._onBottomHostMaximized();

	      // Update the label and icon when the state changes.
	      this._host.on("minimized", this._onBottomHostMinimized);
	      this._host.on("maximized", this._onBottomHostMaximized);
	      // Maximize again when a tool gets selected.
	      this.on("before-select", this._onToolSelectWhileMinimized);
	      // Maximize and stop listening before the host type changes.
	      this.once("host-will-change", this._onBottomHostWillChange);
	    }

	    if (this.hostType == Toolbox.HostType.WINDOW) {
	      this.closeButton.setAttribute("hidden", "true");
	    } else {
	      this.closeButton.removeAttribute("hidden");
	    }

	    let sideEnabled = Services.prefs.getBoolPref(this._prefs.SIDE_ENABLED);

	    for (let type in Toolbox.HostType) {
	      let position = Toolbox.HostType[type];
	      if (position == this.hostType || position == Toolbox.HostType.CUSTOM || !sideEnabled && position == Toolbox.HostType.SIDE) {
	        continue;
	      }

	      let button = this.doc.createElement("button");
	      button.id = "toolbox-dock-" + position;
	      button.className = "toolbox-dock-button devtools-button";
	      button.setAttribute("tooltiptext", toolboxStrings("toolboxDockButtons." + position + ".tooltip"));
	      button.addEventListener("click", function () {
	        _this6.switchHost(position);
	      });

	      dockBox.appendChild(button);
	    }
	  },

	  _getMinimizeButtonShortcutTooltip: function () {
	    let key = this.doc.getElementById("toolbox-minimize-key").getAttribute("key");
	    return "(" + (osString == "Darwin" ? "Cmd+Shift+" : "Ctrl+Shift+") + key.toUpperCase() + ")";
	  },

	  _onBottomHostMinimized: function () {
	    let btn = this.doc.querySelector("#toolbox-dock-bottom-minimize");
	    btn.className = "minimized";

	    btn.setAttribute("tooltiptext", toolboxStrings("toolboxDockButtons.bottom.maximize") + " " + this._getMinimizeButtonShortcutTooltip());
	  },

	  _onBottomHostMaximized: function () {
	    let btn = this.doc.querySelector("#toolbox-dock-bottom-minimize");
	    btn.className = "maximized";

	    btn.setAttribute("tooltiptext", toolboxStrings("toolboxDockButtons.bottom.minimize") + " " + this._getMinimizeButtonShortcutTooltip());
	  },

	  _onToolSelectWhileMinimized: function () {
	    this._host.maximize();
	  },

	  _onBottomHostWillChange: function () {
	    this._host.maximize();

	    this._host.off("minimized", this._onBottomHostMinimized);
	    this._host.off("maximized", this._onBottomHostMaximized);
	    this.off("before-select", this._onToolSelectWhileMinimized);
	  },

	  _toggleMinimizeMode: function () {
	    if (this.hostType !== Toolbox.HostType.BOTTOM) {
	      return;
	    }

	    // Calculate the height to which the host should be minimized so the
	    // tabbar is still visible.
	    let toolbarHeight = this.doc.querySelector(".devtools-tabbar").getBoxQuads({ box: "content" })[0].bounds.height;
	    this._host.toggleMinimizeMode(toolbarHeight);
	  },

	  /**
	   * Add tabs to the toolbox UI for registered tools
	   */
	  _buildTabs: function () {
	    for (let definition of gDevTools.getToolDefinitionArray()) {
	      this._buildTabForTool(definition);
	    }
	  },

	  /**
	   * Add buttons to the UI as specified in the devtools.toolbox.toolbarSpec pref
	   */
	  _buildButtons: function () {
	    var _this7 = this;

	    if (!this.target.isAddon) {
	      this._buildPickerButton();
	    }

	    this.setToolboxButtonsVisibility();

	    // Old servers don't have a GCLI Actor, so just return
	    if (!this.target.hasActor("gcli")) {
	      return promise.resolve();
	    }
	    return promise.resolve();

	    const options = {
	      environment: CommandUtils.createEnvironment(this, '_target')
	    };
	    return CommandUtils.createRequisition(this.target, options).then(function (requisition) {
	      _this7._requisition = requisition;

	      const spec = CommandUtils.getCommandbarSpec("devtools.toolbox.toolbarSpec");
	      return CommandUtils.createButtons(spec, _this7.target, _this7.doc, requisition).then(function (buttons) {
	        let container = _this7.doc.getElementById("toolbox-buttons");
	        buttons.forEach(function (button) {
	          if (button) {
	            container.appendChild(button);
	          }
	        });
	        _this7.setToolboxButtonsVisibility();
	      });
	    });
	  },

	  /**
	   * Adding the element picker button is done here unlike the other buttons
	   * since we want it to work for remote targets too
	   */
	  _buildPickerButton: function () {
	    this._pickerButton = this.doc.createElement("button");
	    this._pickerButton.id = "command-button-pick";
	    this._pickerButton.className = "command-button command-button-invertable devtools-button";
	    this._pickerButton.setAttribute("tooltiptext", toolboxStrings("pickButton.tooltip"));
	    this._pickerButton.setAttribute("hidden", "true");

	    let container = this.doc.querySelector("#toolbox-picker-container");
	    container.appendChild(this._pickerButton);

	    this._togglePicker = this.highlighterUtils.togglePicker.bind(this.highlighterUtils);
	    this._pickerButton.addEventListener("click", this._togglePicker, false);
	  },

	  /**
	   * Apply the current cache setting from devtools.cache.disabled to this
	   * toolbox's tab.
	   */
	  _applyCacheSettings: function () {
	    let pref = "devtools.cache.disabled";
	    let cacheDisabled = Services.prefs.getBoolPref(pref);

	    if (this.target.activeTab) {
	      this.target.activeTab.reconfigure({ "cacheDisabled": cacheDisabled });
	    }
	  },

	  /**
	   * Apply the current service workers testing setting from
	   * devtools.serviceWorkers.testing.enabled to this toolbox's tab.
	   */
	  _applyServiceWorkersTestingSettings: function () {
	    let pref = "devtools.serviceWorkers.testing.enabled";
	    let serviceWorkersTestingEnabled = Services.prefs.getBoolPref(pref) || false;

	    if (this.target.activeTab) {
	      this.target.activeTab.reconfigure({
	        "serviceWorkersTestingEnabled": serviceWorkersTestingEnabled
	      });
	    }
	  },

	  /**
	   * Setter for the checked state of the picker button in the toolbar
	   * @param {Boolean} isChecked
	   */
	  set pickerButtonChecked(isChecked) {
	    if (isChecked) {
	      this._pickerButton.setAttribute("checked", "true");
	    } else {
	      this._pickerButton.removeAttribute("checked");
	    }
	  },

	  /**
	   * Return all toolbox buttons (command buttons, plus any others that were
	   * added manually).
	   */
	  get toolboxButtons() {
	    var _this8 = this;

	    return ToolboxButtons.map(function (options) {
	      let button = _this8.doc.getElementById(options.id);
	      // Some buttons may not exist inside of Browser Toolbox
	      if (!button) {
	        return false;
	      }

	      // Disable tilt in E10S mode. Removing it from the list of toolbox buttons
	      // allows a bunch of tests to pass without modification.
	      if (_this8.target.isMultiProcess && options.id === "command-button-tilt") {
	        return false;
	      }

	      return {
	        id: options.id,
	        button: button,
	        label: button.getAttribute("tooltiptext"),
	        visibilityswitch: "devtools." + options.id + ".enabled",
	        isTargetSupported: options.isTargetSupported ? options.isTargetSupported : function (target) {
	          return target.isLocalTab;
	        }
	      };
	    }).filter(function (button) {
	      return button;
	    });
	  },

	  /**
	   * Ensure the visibility of each toolbox button matches the
	   * preference value.  Simply hide buttons that are preffed off.
	   */
	  setToolboxButtonsVisibility: function () {
	    var _this9 = this;

	    this.toolboxButtons.forEach(function (buttonSpec) {
	      let visibilityswitch = buttonSpec.visibilityswitch;
	      let button = buttonSpec.button;
	      let isTargetSupported = buttonSpec.isTargetSupported;

	      let on = true;
	      try {
	        on = Services.prefs.getBoolPref(visibilityswitch);
	      } catch (ex) {}

	      on = on && isTargetSupported(_this9.target);

	      if (button) {
	        if (on) {
	          button.removeAttribute("hidden");
	        } else {
	          button.setAttribute("hidden", "true");
	        }
	      }
	    });

	    // Tilt is handled separately because it is disabled in E10S mode. Because
	    // we have removed tilt from toolboxButtons we have to deal with it here.
	    let tiltEnabled = !this.target.isMultiProcess && Services.prefs.getBoolPref("devtools.command-button-tilt.enabled");
	    let tiltButton = this.doc.getElementById("command-button-tilt");
	    // Remote toolboxes don't add the button to the DOM at all
	    if (!tiltButton) {
	      return;
	    }

	    if (tiltEnabled) {
	      tiltButton.removeAttribute("hidden");
	    } else {
	      tiltButton.setAttribute("hidden", "true");
	    }
	  },

	  /**
	   * Build a tab for one tool definition and add to the toolbox
	   *
	   * @param {string} toolDefinition
	   *        Tool definition of the tool to build a tab for.
	   */
	  _buildTabForTool: function (toolDefinition) {
	    var _this10 = this;

	    if (!toolDefinition.isTargetSupported(this._target)) {
	      return;
	    }

	    let tabs = this.doc.getElementById("toolbox-tabs");
	    let deck = this.doc.getElementById("toolbox-deck");

	    let id = toolDefinition.id;

	    if (toolDefinition.ordinal == undefined || toolDefinition.ordinal < 0) {
	      toolDefinition.ordinal = MAX_ORDINAL;
	    }

	    let radio = this.doc.createElement("box");
	    // The radio element is not being used in the conventional way, thus
	    // the devtools-tab class replaces the radio XBL binding with its base
	    // binding (the control-item binding).
	    radio.className = "devtools-tab";
	    radio.id = "toolbox-tab-" + id;
	    radio.setAttribute("toolid", id);
	    radio.setAttribute("ordinal", toolDefinition.ordinal);
	    radio.setAttribute("tooltiptext", toolDefinition.tooltip);
	    if (toolDefinition.invertIconForLightTheme) {
	      radio.setAttribute("icon-invertable", "true");
	    }

	    radio.addEventListener("click", function () {
	      _this10.selectTool(id);
	    });

	    // spacer lets us center the image and label, while allowing cropping
	    let spacer = this.doc.createElement("spacer");
	    spacer.setAttribute("flex", "1");
	    radio.appendChild(spacer);

	    if (toolDefinition.icon) {
	      let image = this.doc.createElement("img");
	      image.className = "default-icon";
	      image.setAttribute("src", toolDefinition.icon || toolDefinition.highlightedicon);
	      radio.appendChild(image);
	      // Adding the highlighted icon image
	      image = this.doc.createElement("img");
	      image.className = "highlighted-icon";
	      image.setAttribute("src", toolDefinition.highlightedicon || toolDefinition.icon);
	      radio.appendChild(image);
	    }

	    if (toolDefinition.label && !toolDefinition.iconOnly) {
	      let label = this.doc.createElement("label");
	      label.textContent = toolDefinition.label;
	      // label.setAttribute("crop", "end");
	      label.setAttribute("flex", "1");
	      radio.appendChild(label);
	      radio.setAttribute("flex", "1");
	    }

	    if (!toolDefinition.bgTheme) {
	      toolDefinition.bgTheme = "theme-toolbar";
	    }
	    let vbox = this.doc.createElement("vbox");
	    vbox.className = "toolbox-panel " + toolDefinition.bgTheme;

	    // There is already a container for the webconsole frame.
	    if (!this.doc.getElementById("toolbox-panel-" + id)) {
	      vbox.id = "toolbox-panel-" + id;
	    }

	    if (id === "options") {
	      // Options panel is special.  It doesn't belong in the same container as
	      // the other tabs.
	      radio.setAttribute("role", "button");
	      let optionTabContainer = this.doc.getElementById("toolbox-option-container");
	      optionTabContainer.appendChild(radio);
	      deck.appendChild(vbox);
	    } else {
	      radio.setAttribute("role", "tab");

	      // If there is no tab yet, or the ordinal to be added is the largest one.
	      if (tabs.childNodes.length == 0 || tabs.lastChild.getAttribute("ordinal") <= toolDefinition.ordinal) {
	        tabs.appendChild(radio);
	        deck.appendChild(vbox);
	      } else {
	        // else, iterate over all the tabs to get the correct location.
	        Array.some(tabs.childNodes, function (node, i) {
	          if (+node.getAttribute("ordinal") > toolDefinition.ordinal) {
	            tabs.insertBefore(radio, node);
	            deck.insertBefore(vbox, deck.childNodes[i]);
	            return true;
	          }
	          return false;
	        });
	      }
	    }

	    this._addKeysToWindow();
	  },

	  /**
	   * Ensure the tool with the given id is loaded.
	   *
	   * @param {string} id
	   *        The id of the tool to load.
	   */
	  loadTool: function (id) {
	    var _this11 = this;

	    if (id === "inspector" && !this._inspector) {
	      return this.initInspector().then(function () {
	        return _this11.loadTool(id);
	      });
	    }

	    let deferred = promise.defer();
	    let iframe = this.doc.getElementById("toolbox-panel-iframe-" + id);

	    if (iframe) {
	      let panel = this._toolPanels.get(id);
	      if (panel) {
	        deferred.resolve(panel);
	      } else {
	        this.once(id + "-ready", function (panel) {
	          deferred.resolve(panel);
	        });
	      }
	      return deferred.promise;
	    }

	    let definition = gDevTools.getToolDefinition(id);
	    if (!definition) {
	      deferred.reject(new Error("no such tool id " + id));
	      return deferred.promise;
	    }

	    iframe = this.doc.createElement("iframe");
	    iframe.className = "toolbox-panel-iframe";
	    iframe.id = "toolbox-panel-iframe-" + id;
	    iframe.setAttribute("flex", 1);
	    iframe.setAttribute("forceOwnRefreshDriver", "");
	    iframe.tooltip = "aHTMLTooltip";
	    iframe.style.visibility = "hidden";

	    gDevTools.emit(id + "-init", this, iframe);
	    this.emit(id + "-init", iframe);

	    // If no parent yet, append the frame into default location.
	    if (!iframe.parentNode) {
	      let vbox = this.doc.getElementById("toolbox-panel-" + id);
	      vbox.appendChild(iframe);
	    }

	    let onLoad = function () {
	      // Prevent flicker while loading by waiting to make visible until now.
	      iframe.style.visibility = "visible";

	      // The build method should return a panel instance, so events can
	      // be fired with the panel as an argument. However, in order to keep
	      // backward compatibility with existing extensions do a check
	      // for a promise return value.
	      let built = definition.build(iframe.contentWindow, _this11);
	      if (!(built instanceof Promise)) {
	        let panel = built;
	        iframe.panel = panel;

	        // The panel instance is expected to fire (and listen to) various
	        // framework events, so make sure it's properly decorated with
	        // appropriate API (on, off, once, emit).
	        // In this case we decorate panel instances directly returned by
	        // the tool definition 'build' method.
	        if (typeof panel.emit == "undefined") {
	          EventEmitter.decorate(panel);
	        }

	        gDevTools.emit(id + "-build", _this11, panel);
	        _this11.emit(id + "-build", panel);

	        // The panel can implement an 'open' method for asynchronous
	        // initialization sequence.
	        if (typeof panel.open == "function") {
	          built = panel.open();
	        } else {
	          let deferred = promise.defer();
	          deferred.resolve(panel);
	          built = deferred.promise;
	        }
	      }

	      // Wait till the panel is fully ready and fire 'ready' events.
	      promise.resolve(built).then(function (panel) {
	        _this11._toolPanels.set(id, panel);

	        // Make sure to decorate panel object with event API also in case
	        // where the tool definition 'build' method returns only a promise
	        // and the actual panel instance is available as soon as the
	        // promise is resolved.
	        if (typeof panel.emit == "undefined") {
	          EventEmitter.decorate(panel);
	        }

	        gDevTools.emit(id + "-ready", _this11, panel);
	        _this11.emit(id + "-ready", panel);

	        deferred.resolve(panel);
	      }, console.error);
	    };

	    iframe.setAttribute("src", definition.url);
	    if (definition.panelLabel) {
	      iframe.setAttribute("aria-label", definition.panelLabel);
	    }
	    iframe.onload = onLoad;

	    return deferred.promise;
	  },

	  /**
	   * Switch to the tool with the given id
	   *
	   * @param {string} id
	   *        The id of the tool to switch to
	   */
	  selectTool: function (id) {
	    var _this12 = this;

	    this.emit("before-select", id);

	    let selected = this.doc.querySelector(".devtools-tab[selected]");
	    if (selected) {
	      selected.removeAttribute("selected");
	      selected.setAttribute("aria-selected", "false");
	    }

	    let tab = this.doc.getElementById("toolbox-tab-" + id);
	    tab.setAttribute("selected", "true");
	    tab.setAttribute("aria-selected", "true");

	    // If options is selected, the separator between it and the
	    // command buttons should be hidden.
	    let sep = this.doc.getElementById("toolbox-controls-separator");
	    if (id === "options") {
	      sep.setAttribute("invisible", "true");
	    } else {
	      sep.removeAttribute("invisible");
	    }

	    if (this.currentToolId == id) {
	      // re-focus tool to get key events again
	      this.focusTool(id);

	      // Return the existing panel in order to have a consistent return value.
	      return promise.resolve(this._toolPanels.get(id));
	    }

	    if (!this.isReady) {
	      throw new Error("Can't select tool, wait for toolbox 'ready' event");
	    }

	    tab = this.doc.getElementById("toolbox-tab-" + id);

	    if (tab) {
	      if (this.currentToolId) {
	        this._telemetry.toolClosed(this.currentToolId);
	      }
	      this._telemetry.toolOpened(id);
	    } else {
	      throw new Error("No tool found");
	    }

	    let tabstrip = this.doc.getElementById("toolbox-tabs");

	    // select the right tab, making 0th index the default tab if right tab not
	    // found.
	    tabstrip.selectedItem = tab || tabstrip.childNodes[0];

	    // and select the right iframe
	    let deck = this.doc.getElementById("toolbox-deck");
	    let panel = this.doc.getElementById("toolbox-panel-" + id);

	    // Hack to work around no <deck>
	    // deck.selectedPanel = panel;
	    if (this.selectedPanel) {
	      this.selectedPanel.classList.remove("visible");
	    }
	    this.selectedPanel = panel;
	    panel.classList.add("visible");

	    this.lastUsedToolId = this.currentToolId;
	    this.currentToolId = id;
	    this._refreshConsoleDisplay();
	    if (id != "options") {
	      Services.prefs.setCharPref(this._prefs.LAST_TOOL, id);
	    }

	    return this.loadTool(id).then(function (panel) {
	      // focus the tool's frame to start receiving key events
	      _this12.focusTool(id);

	      _this12.emit("select", id);
	      _this12.emit(id + "-selected", panel);
	      return panel;
	    });
	  },

	  /**
	   * Focus a tool's panel by id
	   * @param  {string} id
	   *         The id of tool to focus
	   */
	  focusTool: function (id) {
	    let iframe = this.doc.getElementById("toolbox-panel-iframe-" + id);
	    iframe.focus();
	  },

	  /**
	   * Focus split console's input line
	   */
	  focusConsoleInput: function () {
	    let consolePanel = this.getPanel("webconsole");
	    if (consolePanel) {
	      consolePanel.focusInput();
	    }
	  },

	  /**
	   * If the console is split and we are focusing an element outside
	   * of the console, then store the newly focused element, so that
	   * it can be restored once the split console closes.
	   */
	  _onFocus: function ({ originalTarget }) {
	    // Ignore any non element nodes, or any elements contained
	    // within the webconsole frame.
	    let webconsoleURL = gDevTools.getToolDefinition("webconsole").url;
	    if (originalTarget.nodeType !== 1 || originalTarget.baseURI === webconsoleURL) {
	      return;
	    }

	    this._lastFocusedElement = originalTarget;
	  },

	  /**
	   * Opens the split console.
	   *
	   * @returns {Promise} a promise that resolves once the tool has been
	   *          loaded and focused.
	   */
	  openSplitConsole: function () {
	    var _this13 = this;

	    this._splitConsole = true;
	    Services.prefs.setBoolPref(SPLITCONSOLE_ENABLED_PREF, true);
	    this._refreshConsoleDisplay();
	    this.emit("split-console");

	    return this.loadTool("webconsole").then(function () {
	      _this13.focusConsoleInput();
	    });
	  },

	  /**
	   * Closes the split console.
	   *
	   * @returns {Promise} a promise that resolves once the tool has been
	   *          closed.
	   */
	  closeSplitConsole: function () {
	    this._splitConsole = false;
	    Services.prefs.setBoolPref(SPLITCONSOLE_ENABLED_PREF, false);
	    this._refreshConsoleDisplay();
	    this.emit("split-console");

	    if (this._lastFocusedElement) {
	      this._lastFocusedElement.focus();
	    }
	    return promise.resolve();
	  },

	  /**
	   * Toggles the split state of the webconsole.  If the webconsole panel
	   * is already selected then this command is ignored.
	   *
	   * @returns {Promise} a promise that resolves once the tool has been
	   *          opened or closed.
	   */
	  toggleSplitConsole: function () {
	    if (this.currentToolId !== "webconsole") {
	      return this.splitConsole ? this.closeSplitConsole() : this.openSplitConsole();
	    }

	    return promise.resolve();
	  },

	  /**
	   * Tells the target tab to reload.
	   */
	  reloadTarget: function (force) {
	    this.target.activeTab.reload({ force: force });
	  },

	  /**
	   * Loads the tool next to the currently selected tool.
	   */
	  selectNextTool: function () {
	    let tools = this.doc.querySelectorAll(".devtools-tab");
	    let selected = this.doc.querySelector(".devtools-tab[selected]");
	    let nextIndex = [...tools].indexOf(selected) + 1;
	    let next = tools[nextIndex] || tools[0];
	    let tool = next.getAttribute("toolid");
	    return this.selectTool(tool);
	  },

	  /**
	   * Loads the tool just left to the currently selected tool.
	   */
	  selectPreviousTool: function () {
	    let tools = this.doc.querySelectorAll(".devtools-tab");
	    let selected = this.doc.querySelector(".devtools-tab[selected]");
	    let prevIndex = [...tools].indexOf(selected) - 1;
	    let prev = tools[prevIndex] || tools[tools.length - 1];
	    let tool = prev.getAttribute("toolid");
	    return this.selectTool(tool);
	  },

	  /**
	   * Highlights the tool's tab if it is not the currently selected tool.
	   *
	   * @param {string} id
	   *        The id of the tool to highlight
	   */
	  highlightTool: function (id) {
	    let tab = this.doc.getElementById("toolbox-tab-" + id);
	    tab && tab.setAttribute("highlighted", "true");
	  },

	  /**
	   * De-highlights the tool's tab.
	   *
	   * @param {string} id
	   *        The id of the tool to unhighlight
	   */
	  unhighlightTool: function (id) {
	    let tab = this.doc.getElementById("toolbox-tab-" + id);
	    tab && tab.removeAttribute("highlighted");
	  },

	  /**
	   * Raise the toolbox host.
	   */
	  raise: function () {
	    this._host.raise();
	  },

	  /**
	   * Refresh the host's title.
	   */
	  _refreshHostTitle: function () {
	    let toolName;
	    let toolDef = gDevTools.getToolDefinition(this.currentToolId);
	    if (toolDef) {
	      toolName = toolDef.label;
	    } else {
	      // no tool is selected
	      toolName = toolboxStrings("toolbox.defaultTitle");
	    }
	    let title = toolboxStrings("toolbox.titleTemplate", toolName, this.target.name || this.target.url);
	    this._host.setTitle(title);
	  },

	  _listFrames: function (event) {
	    var _this14 = this;

	    if (!this._target.activeTab || !this._target.activeTab.traits.frames) {
	      // We are not targetting a regular TabActor
	      // it can be either an addon or browser toolbox actor
	      return promise.resolve();
	    }
	    let packet = {
	      to: this._target.form.actor,
	      type: "listFrames"
	    };
	    return this._target.client.request(packet, function (resp) {
	      _this14._updateFrames(null, { frames: resp.frames });
	    });
	  },

	  selectFrame: function (event) {
	    let windowId = event.target.getAttribute("data-window-id");
	    let packet = {
	      to: this._target.form.actor,
	      type: "switchToFrame",
	      windowId: windowId
	    };
	    this._target.client.request(packet);
	    // Wait for frameUpdate event to update the UI
	  },

	  _updateFrames: function (event, data) {
	    var _this15 = this;

	    // XXX: Don't deal with frames yet
	    if (true) {
	      return;
	    }

	    // We may receive this event before the toolbox is ready.
	    if (!this.isReady) {
	      return;
	    }

	    let menu = this.doc.getElementById("command-button-frames");

	    if (data.destroyAll) {
	      let menupopup = menu.firstChild;
	      while (menupopup.firstChild) {
	        menupopup.firstChild.remove();
	      }
	      return;
	    } else if (data.selected) {
	      let item = menu.querySelector("menuitem[data-window-id=\"" + data.selected + "\"]");
	      if (!item) {
	        return;
	      }
	      // Toggle the toolbarbutton if we selected a non top-level frame
	      if (item.hasAttribute("data-parent-id")) {
	        menu.setAttribute("checked", "true");
	      } else {
	        menu.removeAttribute("checked");
	      }
	      // Uncheck the previously selected frame
	      let selected = menu.querySelector("menuitem[checked=true]");
	      if (selected) {
	        selected.removeAttribute("checked");
	      }
	      // Check the new one
	      item.setAttribute("checked", "true");
	    } else if (data.frames) {
	      data.frames.forEach(function (win) {
	        let item = menu.querySelector("menuitem[data-window-id=\"" + win.id + "\"]");
	        if (win.destroy) {
	          if (item) {
	            item.remove();
	          }
	          return;
	        }
	        if (!item) {
	          item = _this15.doc.createElement("menuitem");
	          item.setAttribute("type", "radio");
	          item.setAttribute("data-window-id", win.id);
	          if (win.parentID) {
	            item.setAttribute("data-parent-id", win.parentID);
	          }
	          // If we register a root docshell and we don't have any selected,
	          // consider it as the currently targeted one.
	          if (!win.parentID && !menu.querySelector("menuitem[checked=true]")) {
	            item.setAttribute("checked", "true");
	            menu.removeAttribute("checked");
	          }
	          menu.firstChild.appendChild(item);
	        }
	        item.setAttribute("label", win.url);
	      });
	    }
	  },

	  /**
	   * Create a host object based on the given host type.
	   *
	   * Warning: some hosts require that the toolbox target provides a reference to
	   * the attached tab. Not all Targets have a tab property - make sure you
	   * correctly mix and match hosts and targets.
	   *
	   * @param {string} hostType
	   *        The host type of the new host object
	   *
	   * @return {Host} host
	   *        The created host object
	   */
	  _createHost: function (hostType, options) {
	    if (!Hosts[hostType]) {
	      throw new Error("Unknown hostType: " + hostType);
	    }

	    // clean up the toolbox if its window is closed
	    let newHost = new Hosts[hostType](this.target.tab, options);
	    newHost.on("window-closed", this.destroy);
	    return newHost;
	  },

	  reload: function () {
	    var _Cu$import = Cu.import("resource://devtools/shared/Loader.jsm", {});

	    const devtools = _Cu$import.devtools;

	    devtools.reload(true);
	  },

	  /**
	   * Switch to the last used host for the toolbox UI.
	   * This is determined by the devtools.toolbox.previousHost pref.
	   */
	  switchToPreviousHost: function () {
	    let hostType = Services.prefs.getCharPref(this._prefs.PREVIOUS_HOST);

	    // Handle the case where the previous host happens to match the current
	    // host. If so, switch to bottom if it's not already used, and side if not.
	    if (hostType === this._host.type) {
	      if (hostType === Toolbox.HostType.BOTTOM) {
	        hostType = Toolbox.HostType.SIDE;
	      } else {
	        hostType = Toolbox.HostType.BOTTOM;
	      }
	    }

	    return this.switchHost(hostType);
	  },

	  /**
	   * Switch to a new host for the toolbox UI. E.g. bottom, sidebar, window,
	   * and focus the window when done.
	   *
	   * @param {string} hostType
	   *        The host type of the new host object
	   */
	  switchHost: function (hostType) {
	    var _this16 = this;

	    if (hostType == this._host.type || !this._target.isLocalTab) {
	      return null;
	    }

	    this.emit("host-will-change", hostType);

	    let newHost = this._createHost(hostType);
	    return newHost.create().then(function (iframe) {
	      // change toolbox document's parent to the new host
	      iframe.QueryInterface(Ci.nsIFrameLoaderOwner);
	      iframe.swapFrameLoaders(_this16.frame);

	      // See bug 1022726, most probably because of swapFrameLoaders we need to
	      // first focus the window here, and then once again further below to make
	      // sure focus actually happens.
	      _this16.frame.contentWindow.focus();

	      _this16._host.off("window-closed", _this16.destroy);
	      _this16.destroyHost();

	      let prevHostType = _this16._host.type;
	      _this16._host = newHost;

	      if (_this16.hostType != Toolbox.HostType.CUSTOM) {
	        Services.prefs.setCharPref(_this16._prefs.LAST_HOST, _this16._host.type);
	        Services.prefs.setCharPref(_this16._prefs.PREVIOUS_HOST, prevHostType);
	      }

	      _this16._buildDockButtons();
	      _this16._addKeysToWindow();

	      // Focus the contentWindow to make sure keyboard shortcuts work straight
	      // away.
	      _this16.frame.contentWindow.focus();

	      _this16.emit("host-changed");
	    });
	  },

	  /**
	   * Handler for the tool-registered event.
	   * @param  {string} event
	   *         Name of the event ("tool-registered")
	   * @param  {string} toolId
	   *         Id of the tool that was registered
	   */
	  _toolRegistered: function (event, toolId) {
	    let tool = gDevTools.getToolDefinition(toolId);
	    this._buildTabForTool(tool);
	  },

	  /**
	   * Handler for the tool-unregistered event.
	   * @param  {string} event
	   *         Name of the event ("tool-unregistered")
	   * @param  {string|object} toolId
	   *         Definition or id of the tool that was unregistered. Passing the
	   *         tool id should be avoided as it is a temporary measure.
	   */
	  _toolUnregistered: function (event, toolId) {
	    if (typeof toolId != "string") {
	      toolId = toolId.id;
	    }

	    if (this._toolPanels.has(toolId)) {
	      let instance = this._toolPanels.get(toolId);
	      instance.destroy();
	      this._toolPanels.delete(toolId);
	    }

	    let radio = this.doc.getElementById("toolbox-tab-" + toolId);
	    let panel = this.doc.getElementById("toolbox-panel-" + toolId);

	    if (radio) {
	      if (this.currentToolId == toolId) {
	        let nextToolName = null;
	        if (radio.nextSibling) {
	          nextToolName = radio.nextSibling.getAttribute("toolid");
	        }
	        if (radio.previousSibling) {
	          nextToolName = radio.previousSibling.getAttribute("toolid");
	        }
	        if (nextToolName) {
	          this.selectTool(nextToolName);
	        }
	      }
	      radio.parentNode.removeChild(radio);
	    }

	    if (panel) {
	      panel.parentNode.removeChild(panel);
	    }

	    if (this.hostType == Toolbox.HostType.WINDOW) {
	      let doc = this.doc.defaultView.parent.document;
	      let key = doc.getElementById("key_" + toolId);
	      if (key) {
	        key.parentNode.removeChild(key);
	      }
	    }
	  },

	  /**
	   * Initialize the inspector/walker/selection/highlighter fronts.
	   * Returns a promise that resolves when the fronts are initialized
	   */
	  initInspector: function () {
	    if (!this._initInspector) {
	      this._initInspector = Task.spawn((function* () {
	        this._inspector = InspectorFront(this._target.client, this._target.form);
	        this._walker = yield this._inspector.getWalker({ showAllAnonymousContent: Services.prefs.getBoolPref("devtools.inspector.showAllAnonymousContent") });
	        this._selection = new Selection(this._walker);

	        if (this.highlighterUtils.isRemoteHighlightable()) {
	          this.walker.on("highlighter-ready", this._highlighterReady);
	          this.walker.on("highlighter-hide", this._highlighterHidden);

	          let autohide = !DevToolsUtils.testing;
	          this._highlighter = yield this._inspector.getHighlighter(autohide);
	        }
	      }).bind(this));
	    }
	    return this._initInspector;
	  },

	  /**
	   * Destroy the inspector/walker/selection fronts
	   * Returns a promise that resolves when the fronts are destroyed
	   */
	  destroyInspector: function () {
	    if (this._destroyingInspector) {
	      return this._destroyingInspector;
	    }

	    return this._destroyingInspector = Task.spawn((function* () {
	      if (!this._inspector) {
	        return;
	      }

	      // Releasing the walker (if it has been created)
	      // This can fail, but in any case, we want to continue destroying the
	      // inspector/highlighter/selection
	      // FF42+: Inspector actor starts managing Walker actor and auto destroy it.
	      if (this._walker && !this.walker.traits.autoReleased) {
	        try {
	          yield this._walker.release();
	        } catch (e) {}
	      }

	      yield this.highlighterUtils.stopPicker();
	      yield this._inspector.destroy();
	      if (this._highlighter) {
	        // Note that if the toolbox is closed, this will work fine, but will fail
	        // in case the browser is closed and will trigger a noSuchActor message.
	        // We ignore the promise that |_hideBoxModel| returns, since we should still
	        // proceed with the rest of destruction if it fails.
	        // FF42+ now does the cleanup from the actor.
	        if (!this.highlighter.traits.autoHideOnDestroy) {
	          this.highlighterUtils.unhighlight();
	        }
	        yield this._highlighter.destroy();
	      }
	      if (this._selection) {
	        this._selection.destroy();
	      }

	      if (this.walker) {
	        this.walker.off("highlighter-ready", this._highlighterReady);
	        this.walker.off("highlighter-hide", this._highlighterHidden);
	      }

	      this._inspector = null;
	      this._highlighter = null;
	      this._selection = null;
	      this._walker = null;
	    }).bind(this));
	  },

	  /**
	   * Get the toolbox's notification box
	   *
	   * @return The notification box element.
	   */
	  getNotificationBox: function () {
	    return this.doc.getElementById("toolbox-notificationbox");
	  },

	  /**
	   * Destroy the current host, and remove event listeners from its frame.
	   *
	   * @return {promise} to be resolved when the host is destroyed.
	   */
	  destroyHost: function () {
	    // The host iframe's contentDocument may already be gone.
	    if (this.doc) {
	      this.doc.removeEventListener("keypress", this._splitConsoleOnKeypress, false);
	      this.doc.removeEventListener("focus", this._onFocus, true);
	    }
	    return this._host.destroy();
	  },

	  /**
	   * Remove all UI elements, detach from target and clear up
	   */
	  destroy: function () {
	    var _this17 = this;

	    // If several things call destroy then we give them all the same
	    // destruction promise so we're sure to destroy only once
	    if (this._destroyer) {
	      return this._destroyer;
	    }

	    this.emit("destroy");

	    this._target.off("navigate", this._refreshHostTitle);
	    this._target.off("frame-update", this._updateFrames);
	    this.off("select", this._refreshHostTitle);
	    this.off("host-changed", this._refreshHostTitle);
	    this.off("ready", this._showDevEditionPromo);

	    gDevTools.off("tool-registered", this._toolRegistered);
	    gDevTools.off("tool-unregistered", this._toolUnregistered);

	    gDevTools.off("pref-changed", this._prefChanged);

	    this._lastFocusedElement = null;

	    if (this.webconsolePanel) {
	      this._saveSplitConsoleHeight();
	      this.webconsolePanel.removeEventListener("resize", this._saveSplitConsoleHeight);
	    }
	    this.closeButton.removeEventListener("click", this.destroy, true);
	    this.textboxContextMenuPopup.removeEventListener("popupshowing", this._updateTextboxMenuItems, true);

	    let outstanding = [];
	    for (let _ref3 of this._toolPanels) {
	      var _ref4 = _slicedToArray(_ref3, 2);

	      let id = _ref4[0];
	      let panel = _ref4[1];

	      try {
	        gDevTools.emit(id + "-destroy", this, panel);
	        this.emit(id + "-destroy", panel);

	        outstanding.push(panel.destroy());
	      } catch (e) {
	        // We don't want to stop here if any panel fail to close.
	        console.error("Panel " + id + ":", e);
	      }
	    }

	    // Now that we are closing the toolbox we can re-enable the cache settings
	    // and disable the service workers testing settings for the current tab.
	    // FF41+ automatically cleans up state in actor on disconnect.
	    if (this.target.activeTab && !this.target.activeTab.traits.noTabReconfigureOnClose) {
	      this.target.activeTab.reconfigure({
	        "cacheDisabled": false,
	        "serviceWorkersTestingEnabled": false
	      });
	    }

	    // Destroying the walker and inspector fronts
	    outstanding.push(this.destroyInspector().then(function () {
	      // Removing buttons
	      if (_this17._pickerButton) {
	        _this17._pickerButton.removeEventListener("click", _this17._togglePicker, false);
	        _this17._pickerButton = null;
	      }
	    }));

	    // Destroy the profiler connection
	    outstanding.push(this.destroyPerformance());

	    // We need to grab a reference to win before this._host is destroyed.
	    let win = this.frame.ownerGlobal;

	    if (this._requisition) {
	      // CommandUtils.destroyRequisition(this._requisition, this.target);
	    }
	    this._telemetry.toolClosed("toolbox");
	    this._telemetry.destroy();

	    // Finish all outstanding tasks (which means finish destroying panels and
	    // then destroying the host, successfully or not) before destroying the
	    // target.
	    this._destroyer = DevToolsUtils.settleAll(outstanding).catch(console.error).then(function () {
	      return _this17.destroyHost();
	    }).catch(console.error).then(function () {
	      // Targets need to be notified that the toolbox is being torn down.
	      // This is done after other destruction tasks since it may tear down
	      // fronts and the debugger transport which earlier destroy methods may
	      // require to complete.
	      if (!_this17._target) {
	        return null;
	      }
	      let target = _this17._target;
	      _this17._target = null;
	      _this17.highlighterUtils.release();
	      target.off("close", _this17.destroy);
	      return target.destroy();
	    }, console.error).then(function () {
	      _this17.emit("destroyed");

	      // Free _host after the call to destroyed in order to let a chance
	      // to destroyed listeners to still query toolbox attributes
	      _this17._host = null;
	      _this17._toolPanels.clear();

	      // Force GC to prevent long GC pauses when running tests and to free up
	      // memory in general when the toolbox is closed.
	      if (DevToolsUtils.testing) {
	        win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).garbageCollect();
	      }
	    }).then(null, console.error);

	    let leakCheckObserver = function ({ wrappedJSObject: barrier }) {
	      // Make the leak detector wait until this toolbox is properly destroyed.
	      barrier.client.addBlocker("DevTools: Wait until toolbox is destroyed", _this17._destroyer);
	    };

	    let topic = "shutdown-leaks-before-check";
	    Services.obs.addObserver(leakCheckObserver, topic, false);
	    this._destroyer.then(function () {
	      Services.obs.removeObserver(leakCheckObserver, topic);
	    });

	    return this._destroyer;
	  },

	  _highlighterReady: function () {
	    this.emit("highlighter-ready");
	  },

	  _highlighterHidden: function () {
	    this.emit("highlighter-hide");
	  },

	  /**
	   * For displaying the promotional Doorhanger on first opening of
	   * the developer tools, promoting the Developer Edition.
	   */
	  _showDevEditionPromo: function () {
	    // Do not display in browser toolbox
	    if (this.target.chrome) {
	      return;
	    }
	    let window = this.frame.contentWindow;
	    showDoorhanger({ window, type: "deveditionpromo" });
	  },

	  /**
	   * Enable / disable necessary textbox menu items using globalOverlay.js.
	   */
	  _updateTextboxMenuItems: function () {
	    let window = this.doc.defaultView;
	    ["cmd_undo", "cmd_delete", "cmd_cut", "cmd_copy", "cmd_paste", "cmd_selectAll"].forEach(window.goUpdateCommand);
	  },

	  /**
	   * Connects to the SPS profiler when the developer tools are open. This is
	   * necessary because of the WebConsole's `profile` and `profileEnd` methods.
	   */
	  initPerformance: Task.async(function* () {
	    // If target does not have profiler actor (addons), do not
	    // even register the shared performance connection.
	    if (!this.target.hasActor("profiler")) {
	      return;
	    }

	    if (this._performanceFrontConnection) {
	      return this._performanceFrontConnection.promise;
	    }

	    this._performanceFrontConnection = promise.defer();
	    this._performance = createPerformanceFront(this._target);
	    yield this.performance.connect();

	    // Emit an event when connected, but don't wait on startup for this.
	    this.emit("profiler-connected");

	    this.performance.on("*", this._onPerformanceFrontEvent);
	    this._performanceFrontConnection.resolve(this.performance);
	    return this._performanceFrontConnection.promise;
	  }),

	  /**
	   * Disconnects the underlying Performance actor. If the connection
	   * has not finished initializing, as opening a toolbox does not wait,
	   * the performance connection destroy method will wait for it on its own.
	   */
	  destroyPerformance: Task.async(function* () {
	    if (!this.performance) {
	      return;
	    }
	    // If still connecting to performance actor, allow the
	    // actor to resolve its connection before attempting to destroy.
	    if (this._performanceFrontConnection) {
	      yield this._performanceFrontConnection.promise;
	    }
	    this.performance.off("*", this._onPerformanceFrontEvent);
	    yield this.performance.destroy();
	    this._performance = null;
	  }),

	  /**
	   * Called when any event comes from the PerformanceFront. If the performance tool is already
	   * loaded when the first event comes in, immediately unbind this handler, as this is
	   * only used to queue up observed recordings before the performance tool can handle them,
	   * which will only occur when `console.profile()` recordings are started before the tool loads.
	   */
	  _onPerformanceFrontEvent: Task.async(function* (eventName, recording) {
	    if (this.getPanel("performance")) {
	      this.performance.off("*", this._onPerformanceFrontEvent);
	      return;
	    }

	    let recordings = this._performanceQueuedRecordings = this._performanceQueuedRecordings || [];

	    // Before any console recordings, we'll get a `console-profile-start` event
	    // warning us that a recording will come later (via `recording-started`), so
	    // start to boot up the tool and populate the tool with any other recordings
	    // observed during that time.
	    if (eventName === "console-profile-start" && !this._performanceToolOpenedViaConsole) {
	      this._performanceToolOpenedViaConsole = this.loadTool("performance");
	      let panel = yield this._performanceToolOpenedViaConsole;
	      yield panel.open();

	      panel.panelWin.PerformanceController.populateWithRecordings(recordings);
	      this.performance.off("*", this._onPerformanceFrontEvent);
	    }

	    // Otherwise, if it's a recording-started event, we've already started loading
	    // the tool, so just store this recording in our array to be later populated
	    // once the tool loads.
	    if (eventName === "recording-started") {
	      recordings.push(recording);
	    }
	  }),

	  /**
	   * Returns gViewSourceUtils for viewing source.
	   */
	  get gViewSourceUtils() {
	    return this.frame.contentWindow.gViewSourceUtils;
	  },

	  /**
	   * Opens source in style editor. Falls back to plain "view-source:".
	   * @see devtools/client/shared/source-utils.js
	   */
	  viewSourceInStyleEditor: function (sourceURL, sourceLine) {
	    return sourceUtils.viewSourceInStyleEditor(this, sourceURL, sourceLine);
	  },

	  /**
	   * Opens source in debugger. Falls back to plain "view-source:".
	   * @see devtools/client/shared/source-utils.js
	   */
	  viewSourceInDebugger: function (sourceURL, sourceLine) {
	    return sourceUtils.viewSourceInDebugger(this, sourceURL, sourceLine);
	  },

	  /**
	   * Opens source in scratchpad. Falls back to plain "view-source:".
	   * TODO The `sourceURL` for scratchpad instances are like `Scratchpad/1`.
	   * If instances are scoped one-per-browser-window, then we should be able
	   * to infer the URL from this toolbox, or use the built in scratchpad IN
	   * the toolbox.
	   *
	   * @see devtools/client/shared/source-utils.js
	   */
	  viewSourceInScratchpad: function (sourceURL, sourceLine) {
	    return sourceUtils.viewSourceInScratchpad(sourceURL, sourceLine);
	  },

	  /**
	   * Opens source in plain "view-source:".
	   * @see devtools/client/shared/source-utils.js
	   */
	  viewSource: function (sourceURL, sourceLine) {
	    return sourceUtils.viewSource(this, sourceURL, sourceLine);
	  }
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/*
	 * A sham for https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/chrome
	 */

	var inDOMUtils = __webpack_require__(2);

	var ourServices = {
	  inIDOMUtils: inDOMUtils,
	  nsIClipboardHelper: {
	    copyString: function () {}
	  },
	  nsIXULChromeRegistry: {
	    isLocaleRTL: function () {
	      return false;
	    }
	  }
	};

	module.exports = {
	  Cc: function (name) {
	    console.log('Sham for', name);
	    return {
	      getService: function (name) {
	        return ourServices[name];
	      }
	    };
	  },
	  Ci: {
	    nsIThread: {
	      "DISPATCH_NORMAL": 0,
	      "DISPATCH_SYNC": 1
	    },
	    nsIDOMNode: HTMLElement,
	    nsIFocusManager: {
	      MOVEFOCUS_BACKWARD: 2,
	      MOVEFOCUS_FORWARD: 1
	    },
	    nsIDOMKeyEvent: {},
	    inIDOMUtils: "inIDOMUtils",
	    nsIClipboardHelper: "nsIClipboardHelper",
	    nsIXULChromeRegistry: "nsIXULChromeRegistry"
	  },
	  Cu: {
	    reportError: function (msg) {
	      return console.error(msg);
	    },
	    callFunctionWithAsyncStack: function (fn) {
	      return fn();
	    }
	  },
	  Cr: {},
	  components: {
	    isSuccessCode: function () {
	      return (returnCode & 0x80000000) === 0;
	    }
	  }
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// A sham for inDOMUtils.

	"use strict";

	var _require = __webpack_require__(3);

	var CSSLexer = _require.CSSLexer;

	var _require2 = __webpack_require__(4);

	var cssColors = _require2.cssColors;

	var _require3 = __webpack_require__(5);

	var cssProperties = _require3.cssProperties;

	var cssRGBMap;

	// From inIDOMUtils.idl.
	var EXCLUDE_SHORTHANDS = 1 << 0;
	var INCLUDE_ALIASES = 1 << 1;
	var TYPE_LENGTH = 0;
	var TYPE_PERCENTAGE = 1;
	var TYPE_COLOR = 2;
	var TYPE_URL = 3;
	var TYPE_ANGLE = 4;
	var TYPE_FREQUENCY = 5;
	var TYPE_TIME = 6;
	var TYPE_GRADIENT = 7;
	var TYPE_TIMING_FUNCTION = 8;
	var TYPE_IMAGE_RECT = 9;
	var TYPE_NUMBER = 10;

	function getCSSLexer(text) {
	  return new CSSLexer(text);
	}

	function rgbToColorName(r, g, b) {
	  if (!cssRGBMap) {
	    cssRGBMap = new Map();
	    for (let name in cssColors) {
	      cssRGBMap.set(JSON.stringify(cssColors[name]), name);
	    }
	  }
	  let value = cssRGBMap.get(JSON.stringify([r, g, b]));
	  if (!value) {
	    throw new Error("no such color");
	  }
	  return value;
	}

	// Taken from dom/tests/mochitest/ajax/mochikit/MochiKit/Color.js
	function _hslValue(n1, n2, hue) {
	  if (hue > 6.0) {
	    hue -= 6.0;
	  } else if (hue < 0.0) {
	    hue += 6.0;
	  }
	  var val;
	  if (hue < 1.0) {
	    val = n1 + (n2 - n1) * hue;
	  } else if (hue < 3.0) {
	    val = n2;
	  } else if (hue < 4.0) {
	    val = n1 + (n2 - n1) * (4.0 - hue);
	  } else {
	    val = n1;
	  }
	  return val;
	}

	// Taken from dom/tests/mochitest/ajax/mochikit/MochiKit/Color.js
	// and then modified.
	function hslToRGB([hue, saturation, lightness]) {
	  var red;
	  var green;
	  var blue;
	  if (saturation === 0) {
	    red = lightness;
	    green = lightness;
	    blue = lightness;
	  } else {
	    var m2;
	    if (lightness <= 0.5) {
	      m2 = lightness * (1.0 + saturation);
	    } else {
	      m2 = lightness + saturation - lightness * saturation;
	    }
	    var m1 = 2.0 * lightness - m2;
	    var f = _hslValue;
	    var h6 = hue * 6.0;
	    red = f(m1, m2, h6 + 2);
	    green = f(m1, m2, h6);
	    blue = f(m1, m2, h6 - 2);
	  }
	  return [red, green, blue];
	}

	function colorToRGBA(name) {
	  name = name.trim().toLowerCase();
	  if (name in cssColors) {
	    return cssColors[name];
	  }

	  if (name === "transparent") {
	    return [0, 0, 0, 0];
	  }

	  let lexer = getCSSLexer(name);

	  let getToken = function () {
	    while (true) {
	      let token = lexer.nextToken();
	      if (!token || token.tokenType !== "comment" || token.tokenType !== "whitespace") {
	        return token;
	      }
	    }
	  };

	  let requireComma = function (token) {
	    if (token.tokenType !== "symbol" || token.text !== ",") {
	      return null;
	    }
	    return getToken();
	  };

	  let func = getToken();
	  if (!func || func.tokenType !== "function") {
	    return null;
	  }
	  let alpha = false;
	  if (func.text === "rgb" || func.text === "hsl") {
	    // Nothing.
	  } else if (func.text === "rgba" || func.text === "hsla") {
	      alpha = true;
	    } else {
	      return null;
	    }

	  let vals = [];
	  for (let i = 0; i < 3; ++i) {
	    let token = getToken();
	    if (i > 0) {
	      token = requireComma(token);
	    }
	    if (token.tokenType !== "number" || !token.isInteger) {
	      return null;
	    }
	    let num = token.number;
	    if (num < 0) {
	      num = 0;
	    } else if (num > 255) {
	      num = 255;
	    }
	    vals.push(num);
	  }

	  if (func.text === "hsl" || func.text === "hsla") {
	    vals = hslToRGB(vals);
	  }

	  if (alpha) {
	    let token = requireComma(getToken());
	    if (token.tokenType !== "number") {
	      return null;
	    }
	    let num = token.number;
	    if (num < 0) {
	      num = 0;
	    } else if (num > 1) {
	      num = 1;
	    }
	    vals.push(num);
	  } else {
	    vals.push(1);
	  }

	  let parenToken = getToken();
	  if (!parenToken || parenToken.tokenType !== "symbol" || parenToken.text !== ")") {
	    return null;
	  }
	  if (getToken() !== null) {
	    return null;
	  }

	  return vals;
	}

	function isValidCSSColor(name) {
	  return colorToRGBA(name) !== null;
	}

	function isVariable(name) {
	  return name.startsWith("--");
	}

	function cssPropertyIsShorthand(name) {
	  if (isVariable(name)) {
	    return false;
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return !!cssProperties[name].subproperties;
	}

	function getSubpropertiesForCSSProperty(name) {
	  if (isVariable(name)) {
	    return [name];
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  if ("subproperties" in cssProperties[name]) {
	    return cssProperties[name].subproperties.slice();
	  }
	  return [name];
	}

	function getCSSValuesForProperty(name) {
	  if (isVariable(name)) {
	    return ["initial", "inherit", "unset"];
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return cssProperties[name].values.slice();
	}

	function getCSSPropertyNames(flags) {
	  let names = Object.keys(cssProperties);
	  if ((flags & EXCLUDE_SHORTHANDS) !== 0) {
	    names = names.filter(function (name) {
	      return cssProperties[name].subproperties;
	    });
	  }
	  if ((flags & INCLUDE_ALIASES) === 0) {
	    names = names.filter(function (name) {
	      return !cssProperties[name].alias;
	    });
	  }
	  return names;
	}

	function cssPropertySupportsType(name, type) {
	  if (isVariable(name)) {
	    return false;
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return (cssProperties[name].supports & 1 << type) !== 0;
	}

	function isInheritedProperty(name) {
	  if (isVariable(name)) {
	    return true;
	  }
	  if (!(name in cssProperties)) {
	    return false;
	  }
	  return cssProperties[name].inherited;
	}

	function cssPropertyIsValid(name, value) {
	  if (isVariable(name)) {
	    return true;
	  }
	  if (!(name in cssProperties)) {
	    return false;
	  }
	  let elt = document.createElement("div");
	  elt.style = name + ":" + value;
	  return elt.style.length > 0;
	}

	module.exports = {
	  getCSSLexer,
	  rgbToColorName,
	  colorToRGBA,
	  isValidCSSColor,
	  cssPropertyIsShorthand,
	  getSubpropertiesForCSSProperty,
	  getCSSValuesForProperty,
	  getCSSPropertyNames,
	  cssPropertySupportsType,
	  isInheritedProperty,
	  cssPropertyIsValid,

	  // Constants.
	  EXCLUDE_SHORTHANDS,
	  INCLUDE_ALIASES,
	  TYPE_LENGTH,
	  TYPE_PERCENTAGE,
	  TYPE_COLOR,
	  TYPE_URL,
	  TYPE_ANGLE,
	  TYPE_FREQUENCY,
	  TYPE_TIME,
	  TYPE_GRADIENT,
	  TYPE_TIMING_FUNCTION,
	  TYPE_IMAGE_RECT,
	  TYPE_NUMBER
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	(function (root, factory) {
		// Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
		// Rhino, and plain browser loading.
		if (true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports !== 'undefined') {
			factory(exports);
		} else {
			factory(root);
		}
	})(this, function (exports) {

		function between(num, first, last) {
			return num >= first && num <= last;
		}
		function digit(code) {
			return between(code, 0x30, 0x39);
		}
		function hexdigit(code) {
			return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66);
		}
		function uppercaseletter(code) {
			return between(code, 0x41, 0x5a);
		}
		function lowercaseletter(code) {
			return between(code, 0x61, 0x7a);
		}
		function letter(code) {
			return uppercaseletter(code) || lowercaseletter(code);
		}
		function nonascii(code) {
			return code >= 0x80;
		}
		function namestartchar(code) {
			return letter(code) || nonascii(code) || code == 0x5f;
		}
		function namechar(code) {
			return namestartchar(code) || digit(code) || code == 0x2d;
		}
		function nonprintable(code) {
			return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f;
		}
		function newline(code) {
			return code == 0xa;
		}
		function whitespace(code) {
			return newline(code) || code == 9 || code == 0x20;
		}

		var maximumallowedcodepoint = 0x10ffff;

		var InvalidCharacterError = function (message) {
			this.message = message;
		};
		InvalidCharacterError.prototype = new Error();
		InvalidCharacterError.prototype.name = 'InvalidCharacterError';

		function stringFromCode(code) {
			if (code <= 0xffff) return String.fromCharCode(code);
			// Otherwise, encode astral char as surrogate pair.
			code -= Math.pow(2, 20);
			var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;
			var trail = code % Math.pow(2, 10) + 0xdc00;
			return String.fromCharCode(lead) + String.fromCharCode(trail);
		}

		function* tokenize(str, options) {
			if (options === undefined) {
				options = {};
			}
			if (options.loc === undefined) {
				options.loc = false;
			}
			if (options.offsets === undefined) {
				options.offsets = false;
			}
			if (options.keepComments === undefined) {
				options.keepComments = false;
			}
			if (options.startOffset === undefined) {
				options.startOffset = 0;
			}

			var i = options.startOffset - 1;
			var code;

			// Line number information.
			var line = 0;
			var column = 0;
			// The only use of lastLineLength is in reconsume().
			var lastLineLength = 0;
			var incrLineno = function () {
				line += 1;
				lastLineLength = column;
				column = 0;
			};
			var locStart = { line: line, column: column };
			var offsetStart = i;

			var codepoint = function (i) {
				if (i >= str.length) {
					return -1;
				}
				return str.charCodeAt(i);
			};
			var next = function (num) {
				if (num === undefined) num = 1;
				if (num > 3) throw "Spec Error: no more than three codepoints of lookahead.";

				var rcode;
				for (var offset = i + 1; num-- > 0; ++offset) {
					rcode = codepoint(offset);
					if (rcode === 0xd && codepoint(offset + 1) === 0xa) {
						++offset;
						rcode = 0xa;
					} else if (rcode === 0xd || rcode === 0xc) {
						rcode = 0xa;
					} else if (rcode === 0x0) {
						rcode = 0xfffd;
					}
				}

				return rcode;
			};
			var consume = function (num) {
				if (num === undefined) num = 1;
				while (num-- > 0) {
					++i;
					code = codepoint(i);
					if (code === 0xd && codepoint(i + 1) === 0xa) {
						++i;
						code = 0xa;
					} else if (code === 0xd || code === 0xc) {
						code = 0xa;
					} else if (code === 0x0) {
						code = 0xfffd;
					}
					if (newline(code)) incrLineno();else column++;
				}
				return true;
			};
			var reconsume = function () {
				i -= 1; // This is ok even in the \r\n case.
				if (newline(code)) {
					line -= 1;
					column = lastLineLength;
				} else {
					column -= 1;
				}
				return true;
			};
			var eof = function (codepoint) {
				if (codepoint === undefined) codepoint = code;
				return codepoint == -1;
			};
			var donothing = function () {};
			var parseerror = function () {
				console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");return true;
			};

			var consumeAToken = function () {
				consume();
				if (!options.keepComments) {
					while (code == 0x2f && next() == 0x2a) {
						consumeAComment();
						consume();
					}
				}
				locStart.line = line;
				locStart.column = column;
				offsetStart = i;
				if (whitespace(code)) {
					while (whitespace(next())) consume();
					return new WhitespaceToken();
				} else if (code == 0x2f && next() == 0x2a) return consumeAComment();else if (code == 0x22) return consumeAStringToken();else if (code == 0x23) {
					if (namechar(next()) || areAValidEscape(next(1), next(2))) {
						var token = new HashToken();
						if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
							token.type = "id";
							token.tokenType = "id";
						}
						token.value = consumeAName();
						token.text = token.value;
						return token;
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x24) {
					if (next() == 0x3d) {
						consume();
						return new SuffixMatchToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x27) return consumeAStringToken();else if (code == 0x28) return new OpenParenToken();else if (code == 0x29) return new CloseParenToken();else if (code == 0x2a) {
					if (next() == 0x3d) {
						consume();
						return new SubstringMatchToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x2b) {
					if (startsWithANumber()) {
						reconsume();
						return consumeANumericToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x2c) return new CommaToken();else if (code == 0x2d) {
					if (startsWithANumber()) {
						reconsume();
						return consumeANumericToken();
					} else if (next(1) == 0x2d && next(2) == 0x3e) {
						consume(2);
						return new CDCToken();
					} else if (startsWithAnIdentifier()) {
						reconsume();
						return consumeAnIdentlikeToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x2e) {
					if (startsWithANumber()) {
						reconsume();
						return consumeANumericToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x3a) return new ColonToken();else if (code == 0x3b) return new SemicolonToken();else if (code == 0x3c) {
					if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {
						consume(3);
						return new CDOToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x40) {
					if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
						return new AtKeywordToken(consumeAName());
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x5b) return new OpenSquareToken();else if (code == 0x5c) {
					if (startsWithAValidEscape()) {
						reconsume();
						return consumeAnIdentlikeToken();
					} else {
						parseerror();
						return new DelimToken(code);
					}
				} else if (code == 0x5d) return new CloseSquareToken();else if (code == 0x5e) {
					if (next() == 0x3d) {
						consume();
						return new PrefixMatchToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x7b) return new OpenCurlyToken();else if (code == 0x7c) {
					if (next() == 0x3d) {
						consume();
						return new DashMatchToken();
						// } else if(next() == 0x7c) {
						// 	consume();
						// 	return new ColumnToken();
					} else {
							return new DelimToken(code);
						}
				} else if (code == 0x7d) return new CloseCurlyToken();else if (code == 0x7e) {
					if (next() == 0x3d) {
						consume();
						return new IncludeMatchToken();
					} else {
						return new DelimToken(code);
					}
				} else if (digit(code)) {
					reconsume();
					return consumeANumericToken();
				} else if (namestartchar(code)) {
					reconsume();
					return consumeAnIdentlikeToken();
				} else if (eof()) return new EOFToken();else return new DelimToken(code);
			};

			var consumeAComment = function () {
				consume();
				var comment = "";
				while (true) {
					consume();
					if (code == 0x2a && next() == 0x2f) {
						consume();
						break;
					} else if (eof()) {
						break;
					}
					comment += stringFromCode(code);
				}
				return new CommentToken(comment);
			};

			var consumeANumericToken = function () {
				var num = consumeANumber();
				var token;
				if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
					token = new DimensionToken();
					token.value = num.value;
					token.repr = num.repr;
					token.type = num.type;
					token.unit = consumeAName();
					token.text = token.unit;
				} else if (next() == 0x25) {
					consume();
					token = new PercentageToken();
					token.value = num.value;
					token.repr = num.repr;
				} else {
					var token = new NumberToken();
					token.value = num.value;
					token.repr = num.repr;
					token.type = num.type;
				}
				token.number = token.value;
				token.isInteger = token.type === "integer";
				// FIXME hasSign
				return token;
			};

			var consumeAnIdentlikeToken = function () {
				var str = consumeAName();
				if (str.toLowerCase() == "url" && next() == 0x28) {
					consume();
					while (whitespace(next(1)) && whitespace(next(2))) consume();
					if (next() == 0x22 || next() == 0x27 || whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {
						while (whitespace(next())) consume();
						consume();
						let str = consumeAStringToken();
						while (whitespace(next())) consume();
						// The closing paren.
						consume();
						return new URLToken(str.text);
					} else {
						return consumeAURLToken();
					}
				} else if (next() == 0x28) {
					consume();
					return new FunctionToken(str);
				} else {
					return new IdentToken(str);
				}
			};

			var consumeAStringToken = function (endingCodePoint) {
				if (endingCodePoint === undefined) endingCodePoint = code;
				var string = "";
				while (consume()) {
					if (code == endingCodePoint || eof()) {
						return new StringToken(string);
					} else if (newline(code)) {
						reconsume();
						return new BadStringToken(string);
					} else if (code == 0x5c) {
						if (eof(next())) {
							donothing();
						} else if (newline(next())) {
							consume();
						} else {
							string += stringFromCode(consumeEscape());
						}
					} else {
						string += stringFromCode(code);
					}
				}
			};

			var consumeAURLToken = function () {
				var token = new URLToken("");
				while (whitespace(next())) consume();
				if (eof(next())) return token;
				while (consume()) {
					if (code == 0x29 || eof()) {
						break;
					} else if (whitespace(code)) {
						while (whitespace(next())) consume();
						if (next() == 0x29 || eof(next())) {
							consume();
							break;
						} else {
							consumeTheRemnantsOfABadURL();
							return new BadURLToken();
						}
					} else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {
						parseerror();
						consumeTheRemnantsOfABadURL();
						return new BadURLToken();
					} else if (code == 0x5c) {
						if (startsWithAValidEscape()) {
							token.value += stringFromCode(consumeEscape());
						} else {
							parseerror();
							consumeTheRemnantsOfABadURL();
							return new BadURLToken();
						}
					} else {
						token.value += stringFromCode(code);
					}
				}
				token.text = token.value;
				return token;
			};

			var consumeEscape = function () {
				// Assume the the current character is the \
				// and the next code point is not a newline.
				consume();
				if (hexdigit(code)) {
					// Consume 1-6 hex digits
					var digits = [code];
					for (var total = 0; total < 5; total++) {
						if (hexdigit(next())) {
							consume();
							digits.push(code);
						} else {
							break;
						}
					}
					if (whitespace(next())) consume();
					var value = parseInt(digits.map(function (x) {
						return String.fromCharCode(x);
					}).join(''), 16);
					if (value > maximumallowedcodepoint) value = 0xfffd;
					return value;
				} else if (eof()) {
					return 0xfffd;
				} else {
					return code;
				}
			};

			var areAValidEscape = function (c1, c2) {
				if (c1 != 0x5c) return false;
				if (newline(c2)) return false;
				return true;
			};
			var startsWithAValidEscape = function () {
				return areAValidEscape(code, next());
			};

			var wouldStartAnIdentifier = function (c1, c2, c3) {
				if (c1 == 0x2d) {
					return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);
				} else if (namestartchar(c1)) {
					return true;
				} else if (c1 == 0x5c) {
					return areAValidEscape(c1, c2);
				} else {
					return false;
				}
			};
			var startsWithAnIdentifier = function () {
				return wouldStartAnIdentifier(code, next(1), next(2));
			};

			var wouldStartANumber = function (c1, c2, c3) {
				if (c1 == 0x2b || c1 == 0x2d) {
					if (digit(c2)) return true;
					if (c2 == 0x2e && digit(c3)) return true;
					return false;
				} else if (c1 == 0x2e) {
					if (digit(c2)) return true;
					return false;
				} else if (digit(c1)) {
					return true;
				} else {
					return false;
				}
			};
			var startsWithANumber = function () {
				return wouldStartANumber(code, next(1), next(2));
			};

			var consumeAName = function () {
				var result = "";
				while (consume()) {
					if (namechar(code)) {
						result += stringFromCode(code);
					} else if (startsWithAValidEscape()) {
						result += stringFromCode(consumeEscape());
					} else {
						reconsume();
						return result;
					}
				}
			};

			var consumeANumber = function () {
				var repr = [];
				var type = "integer";
				if (next() == 0x2b || next() == 0x2d) {
					consume();
					repr += stringFromCode(code);
				}
				while (digit(next())) {
					consume();
					repr += stringFromCode(code);
				}
				if (next(1) == 0x2e && digit(next(2))) {
					consume();
					repr += stringFromCode(code);
					consume();
					repr += stringFromCode(code);
					type = "number";
					while (digit(next())) {
						consume();
						repr += stringFromCode(code);
					}
				}
				var c1 = next(1),
				    c2 = next(2),
				    c3 = next(3);
				if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {
					consume();
					repr += stringFromCode(code);
					consume();
					repr += stringFromCode(code);
					type = "number";
					while (digit(next())) {
						consume();
						repr += stringFromCode(code);
					}
				} else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {
					consume();
					repr += stringFromCode(code);
					consume();
					repr += stringFromCode(code);
					consume();
					repr += stringFromCode(code);
					type = "number";
					while (digit(next())) {
						consume();
						repr += stringFromCode(code);
					}
				}
				var value = convertAStringToANumber(repr);
				return { type: type, value: value, repr: repr };
			};

			var convertAStringToANumber = function (string) {
				// CSS's number rules are identical to JS, afaik.
				return +string;
			};

			var consumeTheRemnantsOfABadURL = function () {
				while (consume()) {
					if (code == 0x2d || eof()) {
						return;
					} else if (startsWithAValidEscape()) {
						consumeEscape();
						donothing();
					} else {
						donothing();
					}
				}
			};

			var iterationCount = 0;
			while (!eof(next())) {
				var token = consumeAToken();
				if (options.loc) {
					token.loc = {};
					token.loc.start = { line: locStart.line, column: locStart.column };
					token.loc.end = { line: line, column: column };
				}
				if (options.offsets) {
					token.startOffset = offsetStart;
					token.endOffset = i + 1;
				}
				yield token;
				iterationCount++;
				if (iterationCount > str.length * 2) return "I'm infinite-looping!";
			}
		}

		function CSSParserToken() {
			throw "Abstract Base Class";
		}
		CSSParserToken.prototype.toJSON = function () {
			return { token: this.tokenType };
		};
		CSSParserToken.prototype.toString = function () {
			return this.tokenType;
		};
		CSSParserToken.prototype.toSource = function () {
			return '' + this;
		};

		function BadStringToken(text) {
			this.text = text;
			return this;
		}
		BadStringToken.prototype = Object.create(CSSParserToken.prototype);
		BadStringToken.prototype.tokenType = "bad_string";

		function BadURLToken() {
			return this;
		}
		BadURLToken.prototype = Object.create(CSSParserToken.prototype);
		BadURLToken.prototype.tokenType = "bad_url";

		function WhitespaceToken() {
			return this;
		}
		WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
		WhitespaceToken.prototype.tokenType = "whitespace";
		WhitespaceToken.prototype.toString = function () {
			return "WS";
		};
		WhitespaceToken.prototype.toSource = function () {
			return " ";
		};

		function CDOToken() {
			return this;
		}
		CDOToken.prototype = Object.create(CSSParserToken.prototype);
		CDOToken.prototype.tokenType = "htmlcomment";
		CDOToken.prototype.toSource = function () {
			return "<!--";
		};

		function CDCToken() {
			return this;
		}
		CDCToken.prototype = Object.create(CSSParserToken.prototype);
		CDCToken.prototype.tokenType = "htmlcomment";
		CDCToken.prototype.toSource = function () {
			return "-->";
		};

		function ColonToken() {
			return this;
		}
		ColonToken.prototype = Object.create(CSSParserToken.prototype);
		ColonToken.prototype.tokenType = "symbol";
		ColonToken.prototype.text = ":";

		function SemicolonToken() {
			return this;
		}
		SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
		SemicolonToken.prototype.tokenType = "symbol";
		SemicolonToken.prototype.text = ";";

		function CommaToken() {
			return this;
		}
		CommaToken.prototype = Object.create(CSSParserToken.prototype);
		CommaToken.prototype.tokenType = "symbol";
		CommaToken.prototype.text = ",";

		function GroupingToken() {
			throw "Abstract Base Class";
		}
		GroupingToken.prototype = Object.create(CSSParserToken.prototype);

		function OpenCurlyToken() {
			this.value = "{";this.mirror = "}";return this;
		}
		OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
		OpenCurlyToken.prototype.tokenType = "symbol";
		OpenCurlyToken.prototype.text = "{";

		function CloseCurlyToken() {
			this.value = "}";this.mirror = "{";return this;
		}
		CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
		CloseCurlyToken.prototype.tokenType = "symbol";
		CloseCurlyToken.prototype.text = "}";

		function OpenSquareToken() {
			this.value = "[";this.mirror = "]";return this;
		}
		OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
		OpenSquareToken.prototype.tokenType = "symbol";
		OpenSquareToken.prototype.text = "[";

		function CloseSquareToken() {
			this.value = "]";this.mirror = "[";return this;
		}
		CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
		CloseSquareToken.prototype.tokenType = "symbol";
		CloseSquareToken.prototype.text = "]";

		function OpenParenToken() {
			this.value = "(";this.mirror = ")";return this;
		}
		OpenParenToken.prototype = Object.create(GroupingToken.prototype);
		OpenParenToken.prototype.tokenType = "symbol";
		OpenParenToken.prototype.text = "(";

		function CloseParenToken() {
			this.value = ")";this.mirror = "(";return this;
		}
		CloseParenToken.prototype = Object.create(GroupingToken.prototype);
		CloseParenToken.prototype.tokenType = "symbol";
		CloseParenToken.prototype.text = ")";

		function IncludeMatchToken() {
			return this;
		}
		IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
		IncludeMatchToken.prototype.tokenType = "includes";

		function DashMatchToken() {
			return this;
		}
		DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
		DashMatchToken.prototype.tokenType = "dashmatch";

		function PrefixMatchToken() {
			return this;
		}
		PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
		PrefixMatchToken.prototype.tokenType = "beginsmatch";

		function SuffixMatchToken() {
			return this;
		}
		SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
		SuffixMatchToken.prototype.tokenType = "endsmatch";

		function SubstringMatchToken() {
			return this;
		}
		SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
		SubstringMatchToken.prototype.tokenType = "containsmatch";

		function ColumnToken() {
			return this;
		}
		ColumnToken.prototype = Object.create(CSSParserToken.prototype);
		ColumnToken.prototype.tokenType = "||";

		function EOFToken() {
			return this;
		}
		EOFToken.prototype = Object.create(CSSParserToken.prototype);
		EOFToken.prototype.tokenType = "EOF";
		EOFToken.prototype.toSource = function () {
			return "";
		};

		function DelimToken(code) {
			this.value = stringFromCode(code);
			this.text = this.value;
			return this;
		}
		DelimToken.prototype = Object.create(CSSParserToken.prototype);
		DelimToken.prototype.tokenType = "symbol";
		DelimToken.prototype.toString = function () {
			return "DELIM(" + this.value + ")";
		};
		DelimToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			return json;
		};
		DelimToken.prototype.toSource = function () {
			if (this.value == "\\") return "\\\n";else return this.value;
		};

		function StringValuedToken() {
			throw "Abstract Base Class";
		}
		StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
		StringValuedToken.prototype.ASCIIMatch = function (str) {
			return this.value.toLowerCase() == str.toLowerCase();
		};
		StringValuedToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			return json;
		};

		function IdentToken(val) {
			this.value = val;
			this.text = val;
		}
		IdentToken.prototype = Object.create(StringValuedToken.prototype);
		IdentToken.prototype.tokenType = "ident";
		IdentToken.prototype.toString = function () {
			return "IDENT(" + this.value + ")";
		};
		IdentToken.prototype.toSource = function () {
			return escapeIdent(this.value);
		};

		function FunctionToken(val) {
			this.value = val;
			this.text = val;
			this.mirror = ")";
		}
		FunctionToken.prototype = Object.create(StringValuedToken.prototype);
		FunctionToken.prototype.tokenType = "function";
		FunctionToken.prototype.toString = function () {
			return "FUNCTION(" + this.value + ")";
		};
		FunctionToken.prototype.toSource = function () {
			return escapeIdent(this.value) + "(";
		};

		function AtKeywordToken(val) {
			this.value = val;
			this.text = val;
		}
		AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
		AtKeywordToken.prototype.tokenType = "at";
		AtKeywordToken.prototype.toString = function () {
			return "AT(" + this.value + ")";
		};
		AtKeywordToken.prototype.toSource = function () {
			return "@" + escapeIdent(this.value);
		};

		function HashToken(val) {
			this.value = val;
			this.text = val;
			this.type = "unrestricted";
		}
		HashToken.prototype = Object.create(StringValuedToken.prototype);
		HashToken.prototype.tokenType = "hash";
		HashToken.prototype.toString = function () {
			return "HASH(" + this.value + ")";
		};
		HashToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			json.type = this.type;
			return json;
		};
		HashToken.prototype.toSource = function () {
			if (this.type == "id") {
				return "#" + escapeIdent(this.value);
			} else {
				return "#" + escapeHash(this.value);
			}
		};

		function StringToken(val) {
			this.value = val;
			this.text = val;
		}
		StringToken.prototype = Object.create(StringValuedToken.prototype);
		StringToken.prototype.tokenType = "string";
		StringToken.prototype.toString = function () {
			return '"' + escapeString(this.value) + '"';
		};

		function CommentToken(val) {
			this.value = val;
		}
		CommentToken.prototype = Object.create(StringValuedToken.prototype);
		CommentToken.prototype.tokenType = "comment";
		CommentToken.prototype.toString = function () {
			return '/*' + this.value + '*/';
		};
		CommentToken.prototype.toSource = CommentToken.prototype.toString;

		function URLToken(val) {
			this.value = val;
			this.text = val;
		}
		URLToken.prototype = Object.create(StringValuedToken.prototype);
		URLToken.prototype.tokenType = "url";
		URLToken.prototype.toString = function () {
			return "URL(" + this.value + ")";
		};
		URLToken.prototype.toSource = function () {
			return 'url("' + escapeString(this.value) + '")';
		};

		function NumberToken() {
			this.value = null;
			this.type = "integer";
			this.repr = "";
		}
		NumberToken.prototype = Object.create(CSSParserToken.prototype);
		NumberToken.prototype.tokenType = "number";
		NumberToken.prototype.toString = function () {
			if (this.type == "integer") return "INT(" + this.value + ")";
			return "NUMBER(" + this.value + ")";
		};
		NumberToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			json.type = this.type;
			json.repr = this.repr;
			return json;
		};
		NumberToken.prototype.toSource = function () {
			return this.repr;
		};

		function PercentageToken() {
			this.value = null;
			this.repr = "";
		}
		PercentageToken.prototype = Object.create(CSSParserToken.prototype);
		PercentageToken.prototype.tokenType = "percentage";
		PercentageToken.prototype.toString = function () {
			return "PERCENTAGE(" + this.value + ")";
		};
		PercentageToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			json.repr = this.repr;
			return json;
		};
		PercentageToken.prototype.toSource = function () {
			return this.repr + "%";
		};

		function DimensionToken() {
			this.value = null;
			this.type = "integer";
			this.repr = "";
			this.unit = "";
		}
		DimensionToken.prototype = Object.create(CSSParserToken.prototype);
		DimensionToken.prototype.tokenType = "dimension";
		DimensionToken.prototype.toString = function () {
			return "DIM(" + this.value + "," + this.unit + ")";
		};
		DimensionToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			json.type = this.type;
			json.repr = this.repr;
			json.unit = this.unit;
			return json;
		};
		DimensionToken.prototype.toSource = function () {
			var source = this.repr;
			var unit = escapeIdent(this.unit);
			if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 0x30, 0x39))) {
				// Unit is ambiguous with scinot
				// Remove the leading "e", replace with escape.
				unit = "\\65 " + unit.slice(1, unit.length);
			}
			return source + unit;
		};

		function escapeIdent(string) {
			string = '' + string;
			var result = '';
			var firstcode = string.charCodeAt(0);
			for (var i = 0; i < string.length; i++) {
				var code = string.charCodeAt(i);
				if (code === 0x0) {
					throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
				}

				if (between(code, 0x1, 0x1f) || code == 0x7f || i === 0 && between(code, 0x30, 0x39) || i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d) {
					result += '\\' + code.toString(16) + ' ';
				} else if (code >= 0x80 || code == 0x2d || code == 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) {
					result += string[i];
				} else {
					result += '\\' + string[i];
				}
			}
			return result;
		}

		function escapeHash(string) {
			// Escapes the contents of "unrestricted"-type hash tokens.
			// Won't preserve the ID-ness of "id"-type hash tokens;
			// use escapeIdent() for that.
			string = '' + string;
			var result = '';
			for (var i = 0; i < string.length; i++) {
				var code = string.charCodeAt(i);
				if (code === 0x0) {
					throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
				}

				if (code >= 0x80 || code == 0x2d || code == 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) {
					result += string[i];
				} else {
					result += '\\' + code.toString(16) + ' ';
				}
			}
			return result;
		}

		function escapeString(string) {
			string = '' + string;
			var result = '';
			for (var i = 0; i < string.length; i++) {
				var code = string.charCodeAt(i);

				if (code === 0x0) {
					throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
				}

				if (between(code, 0x1, 0x1f) || code == 0x7f) {
					result += '\\' + code.toString(16) + ' ';
				} else if (code == 0x22 || code == 0x5c) {
					result += '\\' + string[i];
				} else {
					result += string[i];
				}
			}
			return result;
		}

		// Exportation.
		exports.tokenize = tokenize;
		exports.IdentToken = IdentToken;
		exports.FunctionToken = FunctionToken;
		exports.AtKeywordToken = AtKeywordToken;
		exports.HashToken = HashToken;
		exports.StringToken = StringToken;
		exports.BadStringToken = BadStringToken;
		exports.URLToken = URLToken;
		exports.BadURLToken = BadURLToken;
		exports.DelimToken = DelimToken;
		exports.NumberToken = NumberToken;
		exports.PercentageToken = PercentageToken;
		exports.DimensionToken = DimensionToken;
		exports.IncludeMatchToken = IncludeMatchToken;
		exports.DashMatchToken = DashMatchToken;
		exports.PrefixMatchToken = PrefixMatchToken;
		exports.SuffixMatchToken = SuffixMatchToken;
		exports.SubstringMatchToken = SubstringMatchToken;
		exports.ColumnToken = ColumnToken;
		exports.WhitespaceToken = WhitespaceToken;
		exports.CDOToken = CDOToken;
		exports.CDCToken = CDCToken;
		exports.ColonToken = ColonToken;
		exports.SemicolonToken = SemicolonToken;
		exports.CommaToken = CommaToken;
		exports.OpenParenToken = OpenParenToken;
		exports.CloseParenToken = CloseParenToken;
		exports.OpenSquareToken = OpenSquareToken;
		exports.CloseSquareToken = CloseSquareToken;
		exports.OpenCurlyToken = OpenCurlyToken;
		exports.CloseCurlyToken = CloseCurlyToken;
		exports.EOFToken = EOFToken;
		exports.CSSParserToken = CSSParserToken;
		exports.GroupingToken = GroupingToken;

		function TokenStream(tokens) {
			// Assume that tokens is a iterator.
			this.tokens = tokens;
			this.token = undefined;
			this.stored = [];
		}
		TokenStream.prototype.consume = function (num) {
			if (num === undefined) num = 1;
			while (num-- > 0) {
				if (this.stored.length > 0) {
					this.token = this.stored.shift();
				} else {
					var n = this.tokens.next();
					while (!n.done && n.value instanceof CommentToken) {
						n = this.tokens.next();
					}
					if (n.done) {
						this.token = new EOFToken();
						break;
					}
					this.token = n.value;
				}
			}
			//console.log(this.i, this.token);
			return true;
		};
		TokenStream.prototype.next = function () {
			if (this.stored.length === 0) {
				var n = this.tokens.next();
				while (!n.done && n.value instanceof CommentToken) {
					n = this.tokens.next();
				}
				if (n.done) return new EOFToken();
				this.stored.push(n.value);
			}
			return this.stored[0];
		};
		TokenStream.prototype.reconsume = function () {
			this.stored.unshift(this.token);
		};

		function parseerror(s, msg) {
			console.log("Parse error at token " + s.i + ": " + s.token + ".\n" + msg);
			return true;
		}
		function donothing() {
			return true;
		}

		function consumeAListOfRules(s, topLevel) {
			var rules = [];
			var rule;
			while (s.consume()) {
				if (s.token instanceof WhitespaceToken) {
					continue;
				} else if (s.token instanceof EOFToken) {
					return rules;
				} else if (s.token instanceof CDOToken || s.token instanceof CDCToken) {
					if (topLevel == "top-level") continue;
					s.reconsume();
					if (rule = consumeAQualifiedRule(s)) rules.push(rule);
				} else if (s.token instanceof AtKeywordToken) {
					s.reconsume();
					if (rule = consumeAnAtRule(s)) rules.push(rule);
				} else {
					s.reconsume();
					if (rule = consumeAQualifiedRule(s)) rules.push(rule);
				}
			}
		}

		function consumeAnAtRule(s) {
			s.consume();
			var rule = new AtRule(s.token.value);
			while (s.consume()) {
				if (s.token instanceof SemicolonToken || s.token instanceof EOFToken) {
					return rule;
				} else if (s.token instanceof OpenCurlyToken) {
					rule.value = consumeASimpleBlock(s);
					return rule;
				} else {
					s.reconsume();
					rule.prelude.push(consumeAComponentValue(s));
				}
			}
		}

		function consumeAQualifiedRule(s) {
			var rule = new QualifiedRule();
			while (s.consume()) {
				if (s.token instanceof EOFToken) {
					parseerror(s, "Hit EOF when trying to parse the prelude of a qualified rule.");
					return;
				} else if (s.token instanceof OpenCurlyToken) {
					rule.value = consumeASimpleBlock(s);
					return rule;
				} else {
					s.reconsume();
					rule.prelude.push(consumeAComponentValue(s));
				}
			}
		}

		function consumeAListOfDeclarations(s) {
			var decls = [];
			while (s.consume()) {
				if (s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {
					donothing();
				} else if (s.token instanceof EOFToken) {
					return decls;
				} else if (s.token instanceof AtKeywordToken) {
					s.reconsume();
					decls.push(consumeAnAtRule(s));
				} else if (s.token instanceof IdentToken) {
					var temp = [s.token];
					while (!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken)) temp.push(consumeAComponentValue(s));
					var decl;
					if (decl = consumeADeclaration(new TokenStream(temp))) decls.push(decl);
				} else {
					parseerror(s);
					s.reconsume();
					while (!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken)) consumeAComponentValue(s);
				}
			}
		}

		function consumeADeclaration(s) {
			// Assumes that the next input token will be an ident token.
			s.consume();
			var decl = new Declaration(s.token.value);
			while (s.next() instanceof WhitespaceToken) s.consume();
			if (!(s.next() instanceof ColonToken)) {
				parseerror(s);
				return;
			} else {
				s.consume();
			}
			while (!(s.next() instanceof EOFToken)) {
				decl.value.push(consumeAComponentValue(s));
			}
			var foundImportant = false;
			for (var i = decl.value.length - 1; i >= 0; i--) {
				if (decl.value[i] instanceof WhitespaceToken) {
					continue;
				} else if (decl.value[i] instanceof IdentToken && decl.value[i].ASCIIMatch("important")) {
					foundImportant = true;
				} else if (foundImportant && decl.value[i] instanceof DelimToken && decl.value[i].value == "!") {
					decl.value.splice(i, decl.value.length);
					decl.important = true;
					break;
				} else {
					break;
				}
			}
			return decl;
		}

		function consumeAComponentValue(s) {
			s.consume();
			if (s.token instanceof OpenCurlyToken || s.token instanceof OpenSquareToken || s.token instanceof OpenParenToken) return consumeASimpleBlock(s);
			if (s.token instanceof FunctionToken) return consumeAFunction(s);
			return s.token;
		}

		function consumeASimpleBlock(s) {
			var mirror = s.token.mirror;
			var block = new SimpleBlock(s.token.value);
			block.startToken = s.token;
			while (s.consume()) {
				if (s.token instanceof EOFToken || s.token instanceof GroupingToken && s.token.value == mirror) return block;else {
					s.reconsume();
					block.value.push(consumeAComponentValue(s));
				}
			}
		}

		function consumeAFunction(s) {
			var func = new Func(s.token.value);
			while (s.consume()) {
				if (s.token instanceof EOFToken || s.token instanceof CloseParenToken) return func;else {
					s.reconsume();
					func.value.push(consumeAComponentValue(s));
				}
			}
		}

		function normalizeInput(input) {
			if (typeof input == "string") return new TokenStream(tokenize(input));
			if (input instanceof TokenStream) return input;
			if (typeof input.next == "function") return new TokenStream(input);
			if (input.length !== undefined) return new TokenStream(input[Symbol.iterator]());else throw SyntaxError(input);
		}

		function parseAStylesheet(s) {
			s = normalizeInput(s);
			var sheet = new Stylesheet();
			sheet.value = consumeAListOfRules(s, "top-level");
			return sheet;
		}

		function parseAListOfRules(s) {
			s = normalizeInput(s);
			return consumeAListOfRules(s);
		}

		function parseARule(s) {
			s = normalizeInput(s);
			while (s.next() instanceof WhitespaceToken) s.consume();
			if (s.next() instanceof EOFToken) throw SyntaxError();
			var rule;
			var startToken = s.next();
			if (startToken instanceof AtKeywordToken) {
				rule = consumeAnAtRule(s);
			} else {
				rule = consumeAQualifiedRule(s);
				if (!rule) throw SyntaxError();
			}
			rule.startToken = startToken;
			rule.endToken = s.token;
			return rule;
		}

		function parseADeclaration(s) {
			s = normalizeInput(s);
			while (s.next() instanceof WhitespaceToken) s.consume();
			if (!(s.next() instanceof IdentToken)) throw SyntaxError();
			var decl = consumeADeclaration(s);
			if (decl) return decl;else throw SyntaxError();
		}

		function parseAListOfDeclarations(s) {
			s = normalizeInput(s);
			return consumeAListOfDeclarations(s);
		}

		function parseAComponentValue(s) {
			s = normalizeInput(s);
			while (s.next() instanceof WhitespaceToken) s.consume();
			if (s.next() instanceof EOFToken) throw SyntaxError();
			var val = consumeAComponentValue(s);
			if (!val) throw SyntaxError();
			while (s.next() instanceof WhitespaceToken) s.consume();
			if (s.next() instanceof EOFToken) return val;
			throw SyntaxError();
		}

		function parseAListOfComponentValues(s) {
			s = normalizeInput(s);
			var vals = [];
			while (true) {
				var val = consumeAComponentValue(s);
				if (val instanceof EOFToken) return vals;else vals.push(val);
			}
		}

		function parseACommaSeparatedListOfComponentValues(s) {
			s = normalizeInput(s);
			var listOfCVLs = [];
			while (true) {
				var vals = [];
				while (true) {
					var val = consumeAComponentValue(s);
					if (val instanceof EOFToken) {
						listOfCVLs.push(vals);
						return listOfCVLs;
					} else if (val instanceof CommaToken) {
						listOfCVLs.push(vals);
						break;
					} else {
						vals.push(val);
					}
				}
			}
		}

		function CSSParserRule() {
			throw "Abstract Base Class";
		}
		CSSParserRule.prototype.toString = function (indent) {
			return JSON.stringify(this, null, indent);
		};
		CSSParserRule.prototype.toJSON = function () {
			return { type: this.type, value: this.value };
		};

		function Stylesheet() {
			this.value = [];
			return this;
		}
		Stylesheet.prototype = Object.create(CSSParserRule.prototype);
		Stylesheet.prototype.type = "STYLESHEET";

		function AtRule(name) {
			this.name = name;
			this.prelude = [];
			this.value = null;
			return this;
		}
		AtRule.prototype = Object.create(CSSParserRule.prototype);
		AtRule.prototype.type = "AT-RULE";
		AtRule.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.name = this.name;
			json.prelude = this.prelude;
			return json;
		};

		function QualifiedRule() {
			this.prelude = [];
			this.value = [];
			return this;
		}
		QualifiedRule.prototype = Object.create(CSSParserRule.prototype);
		QualifiedRule.prototype.type = "QUALIFIED-RULE";
		QualifiedRule.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.prelude = this.prelude;
			return json;
		};

		function Declaration(name) {
			this.name = name;
			this.value = [];
			this.important = false;
			return this;
		}
		Declaration.prototype = Object.create(CSSParserRule.prototype);
		Declaration.prototype.type = "DECLARATION";
		Declaration.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.name = this.name;
			json.important = this.important;
			return json;
		};

		function SimpleBlock(type) {
			this.name = type;
			this.value = [];
			return this;
		}
		SimpleBlock.prototype = Object.create(CSSParserRule.prototype);
		SimpleBlock.prototype.type = "BLOCK";
		SimpleBlock.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.name = this.name;
			return json;
		};

		function Func(name) {
			this.name = name;
			this.value = [];
			return this;
		}
		Func.prototype = Object.create(CSSParserRule.prototype);
		Func.prototype.type = "FUNCTION";
		Func.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.name = this.name;
			return json;
		};

		function CSSLexer(text) {
			this.stream = tokenize(text, {
				loc: true,
				offsets: true,
				keepComments: true
			});
			this.lineNumber = 0;
			this.columnNumber = 0;
			return this;
		}

		CSSLexer.prototype.performEOFFixup = function (input, preserveBackslash) {
			// Just lie for now.
			return "";
		};

		CSSLexer.prototype.nextToken = function () {
			if (!this.stream) {
				return null;
			}
			let v = this.stream.next();
			if (v.done || v.value.tokenType === "EOF") {
				this.stream = null;
				return null;
			}
			this.lineNumber = v.value.loc.start.line;
			this.columnNumber = v.value.loc.start.column;
			return v.value;
		};

		// Exportation.
		exports.CSSParserRule = CSSParserRule;
		exports.Stylesheet = Stylesheet;
		exports.AtRule = AtRule;
		exports.QualifiedRule = QualifiedRule;
		exports.Declaration = Declaration;
		exports.SimpleBlock = SimpleBlock;
		exports.Func = Func;
		exports.parseAStylesheet = parseAStylesheet;
		exports.parseAListOfRules = parseAListOfRules;
		exports.parseARule = parseARule;
		exports.parseADeclaration = parseADeclaration;
		exports.parseAListOfDeclarations = parseAListOfDeclarations;
		exports.parseAComponentValue = parseAComponentValue;
		exports.parseAListOfComponentValues = parseAListOfComponentValues;
		exports.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues;
		exports.CSSLexer = CSSLexer;
	});

/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";

	// auto-generated from nsColorNameList.h
	var cssColors = {
	  aliceblue: [240, 248, 255],
	  antiquewhite: [250, 235, 215],
	  aqua: [0, 255, 255],
	  aquamarine: [127, 255, 212],
	  azure: [240, 255, 255],
	  beige: [245, 245, 220],
	  bisque: [255, 228, 196],
	  black: [0, 0, 0],
	  blanchedalmond: [255, 235, 205],
	  blue: [0, 0, 255],
	  blueviolet: [138, 43, 226],
	  brown: [165, 42, 42],
	  burlywood: [222, 184, 135],
	  cadetblue: [95, 158, 160],
	  chartreuse: [127, 255, 0],
	  chocolate: [210, 105, 30],
	  coral: [255, 127, 80],
	  cornflowerblue: [100, 149, 237],
	  cornsilk: [255, 248, 220],
	  crimson: [220, 20, 60],
	  cyan: [0, 255, 255],
	  darkblue: [0, 0, 139],
	  darkcyan: [0, 139, 139],
	  darkgoldenrod: [184, 134, 11],
	  darkgray: [169, 169, 169],
	  darkgreen: [0, 100, 0],
	  darkgrey: [169, 169, 169],
	  darkkhaki: [189, 183, 107],
	  darkmagenta: [139, 0, 139],
	  darkolivegreen: [85, 107, 47],
	  darkorange: [255, 140, 0],
	  darkorchid: [153, 50, 204],
	  darkred: [139, 0, 0],
	  darksalmon: [233, 150, 122],
	  darkseagreen: [143, 188, 143],
	  darkslateblue: [72, 61, 139],
	  darkslategray: [47, 79, 79],
	  darkslategrey: [47, 79, 79],
	  darkturquoise: [0, 206, 209],
	  darkviolet: [148, 0, 211],
	  deeppink: [255, 20, 147],
	  deepskyblue: [0, 191, 255],
	  dimgray: [105, 105, 105],
	  dimgrey: [105, 105, 105],
	  dodgerblue: [30, 144, 255],
	  firebrick: [178, 34, 34],
	  floralwhite: [255, 250, 240],
	  forestgreen: [34, 139, 34],
	  fuchsia: [255, 0, 255],
	  gainsboro: [220, 220, 220],
	  ghostwhite: [248, 248, 255],
	  gold: [255, 215, 0],
	  goldenrod: [218, 165, 32],
	  gray: [128, 128, 128],
	  grey: [128, 128, 128],
	  green: [0, 128, 0],
	  greenyellow: [173, 255, 47],
	  honeydew: [240, 255, 240],
	  hotpink: [255, 105, 180],
	  indianred: [205, 92, 92],
	  indigo: [75, 0, 130],
	  ivory: [255, 255, 240],
	  khaki: [240, 230, 140],
	  lavender: [230, 230, 250],
	  lavenderblush: [255, 240, 245],
	  lawngreen: [124, 252, 0],
	  lemonchiffon: [255, 250, 205],
	  lightblue: [173, 216, 230],
	  lightcoral: [240, 128, 128],
	  lightcyan: [224, 255, 255],
	  lightgoldenrodyellow: [250, 250, 210],
	  lightgray: [211, 211, 211],
	  lightgreen: [144, 238, 144],
	  lightgrey: [211, 211, 211],
	  lightpink: [255, 182, 193],
	  lightsalmon: [255, 160, 122],
	  lightseagreen: [32, 178, 170],
	  lightskyblue: [135, 206, 250],
	  lightslategray: [119, 136, 153],
	  lightslategrey: [119, 136, 153],
	  lightsteelblue: [176, 196, 222],
	  lightyellow: [255, 255, 224],
	  lime: [0, 255, 0],
	  limegreen: [50, 205, 50],
	  linen: [250, 240, 230],
	  magenta: [255, 0, 255],
	  maroon: [128, 0, 0],
	  mediumaquamarine: [102, 205, 170],
	  mediumblue: [0, 0, 205],
	  mediumorchid: [186, 85, 211],
	  mediumpurple: [147, 112, 219],
	  mediumseagreen: [60, 179, 113],
	  mediumslateblue: [123, 104, 238],
	  mediumspringgreen: [0, 250, 154],
	  mediumturquoise: [72, 209, 204],
	  mediumvioletred: [199, 21, 133],
	  midnightblue: [25, 25, 112],
	  mintcream: [245, 255, 250],
	  mistyrose: [255, 228, 225],
	  moccasin: [255, 228, 181],
	  navajowhite: [255, 222, 173],
	  navy: [0, 0, 128],
	  oldlace: [253, 245, 230],
	  olive: [128, 128, 0],
	  olivedrab: [107, 142, 35],
	  orange: [255, 165, 0],
	  orangered: [255, 69, 0],
	  orchid: [218, 112, 214],
	  palegoldenrod: [238, 232, 170],
	  palegreen: [152, 251, 152],
	  paleturquoise: [175, 238, 238],
	  palevioletred: [219, 112, 147],
	  papayawhip: [255, 239, 213],
	  peachpuff: [255, 218, 185],
	  peru: [205, 133, 63],
	  pink: [255, 192, 203],
	  plum: [221, 160, 221],
	  powderblue: [176, 224, 230],
	  purple: [128, 0, 128],
	  rebeccapurple: [102, 51, 153],
	  red: [255, 0, 0],
	  rosybrown: [188, 143, 143],
	  royalblue: [65, 105, 225],
	  saddlebrown: [139, 69, 19],
	  salmon: [250, 128, 114],
	  sandybrown: [244, 164, 96],
	  seagreen: [46, 139, 87],
	  seashell: [255, 245, 238],
	  sienna: [160, 82, 45],
	  silver: [192, 192, 192],
	  skyblue: [135, 206, 235],
	  slateblue: [106, 90, 205],
	  slategray: [112, 128, 144],
	  slategrey: [112, 128, 144],
	  snow: [255, 250, 250],
	  springgreen: [0, 255, 127],
	  steelblue: [70, 130, 180],
	  tan: [210, 180, 140],
	  teal: [0, 128, 128],
	  thistle: [216, 191, 216],
	  tomato: [255, 99, 71],
	  turquoise: [64, 224, 208],
	  violet: [238, 130, 238],
	  wheat: [245, 222, 179],
	  white: [255, 255, 255],
	  whitesmoke: [245, 245, 245],
	  yellow: [255, 255, 0],
	  yellowgreen: [154, 205, 50]
	};
	module.exports = { cssColors };

/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict"; // auto-generated by means you would rather not know
	var cssProperties={"-moz-appearance":{inherited:false,supports:0,values:["-moz-gtk-info-bar","-moz-mac-disclosure-button-closed","-moz-mac-disclosure-button-open","-moz-mac-fullscreen-button","-moz-mac-help-button","-moz-mac-vibrancy-dark","-moz-mac-vibrancy-light","-moz-win-borderless-glass","-moz-win-browsertabbar-toolbox","-moz-win-communications-toolbox","-moz-win-exclude-glass","-moz-win-glass","-moz-win-media-toolbox","-moz-window-button-box","-moz-window-button-box-maximized","-moz-window-button-close","-moz-window-button-maximize","-moz-window-button-minimize","-moz-window-button-restore","-moz-window-frame-bottom","-moz-window-frame-left","-moz-window-frame-right","-moz-window-titlebar","-moz-window-titlebar-maximized","button","button-arrow-down","button-arrow-next","button-arrow-previous","button-arrow-up","button-bevel","button-focus","caret","checkbox","checkbox-container","checkbox-label","checkmenuitem","dialog","dualbutton","groupbox","inherit","initial","listbox","listitem","menuarrow","menubar","menucheckbox","menuimage","menuitem","menuitemtext","menulist","menulist-button","menulist-text","menulist-textfield","menupopup","menuradio","menuseparator","meterbar","meterchunk","none","number-input","progressbar","progressbar-vertical","progresschunk","progresschunk-vertical","radio","radio-container","radio-label","radiomenuitem","range","range-thumb","resizer","resizerpanel","scale-horizontal","scale-vertical","scalethumb-horizontal","scalethumb-vertical","scalethumbend","scalethumbstart","scalethumbtick","scrollbar","scrollbar-small","scrollbarbutton-down","scrollbarbutton-left","scrollbarbutton-right","scrollbarbutton-up","scrollbarthumb-horizontal","scrollbarthumb-vertical","scrollbartrack-horizontal","scrollbartrack-vertical","searchfield","separator","spinner","spinner-downbutton","spinner-textfield","spinner-upbutton","splitter","statusbar","statusbarpanel","tab","tab-scroll-arrow-back","tab-scroll-arrow-forward","tabpanel","tabpanels","textfield","textfield-multiline","toolbar","toolbarbutton","toolbarbutton-dropdown","toolbargripper","toolbox","tooltip","treeheader","treeheadercell","treeheadersortarrow","treeitem","treeline","treetwisty","treetwistyopen","treeview","unset","window"]},"-moz-outline-radius-topleft":{inherited:false,supports:3,values:["inherit","initial","unset"]},"-moz-outline-radius-topright":{inherited:false,supports:3,values:["inherit","initial","unset"]},"-moz-outline-radius-bottomright":{inherited:false,supports:3,values:["inherit","initial","unset"]},"-moz-outline-radius-bottomleft":{inherited:false,supports:3,values:["inherit","initial","unset"]},"-moz-tab-size":{inherited:true,supports:1024,values:["inherit","initial","unset"]},"animation-delay":{inherited:false,supports:64,values:["inherit","initial","unset"]},"animation-direction":{inherited:false,supports:0,values:["alternate","alternate-reverse","inherit","initial","normal","reverse","unset"]},"animation-duration":{inherited:false,supports:64,values:["inherit","initial","unset"]},"animation-fill-mode":{inherited:false,supports:0,values:["backwards","both","forwards","inherit","initial","none","unset"]},"animation-iteration-count":{inherited:false,supports:1024,values:["infinite","inherit","initial","unset"]},"animation-name":{inherited:false,supports:0,values:["inherit","initial","none","unset"]},"animation-play-state":{inherited:false,supports:0,values:["inherit","initial","paused","running","unset"]},"animation-timing-function":{inherited:false,supports:256,values:["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"background-attachment":{inherited:false,supports:0,values:["fixed","inherit","initial","local","scroll","unset"]},"background-clip":{inherited:false,supports:0,values:["border-box","content-box","inherit","initial","padding-box","unset"]},"background-color":{inherited:false,supports:4,values:["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"background-image":{inherited:false,supports:648,values:["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"background-blend-mode":{inherited:false,supports:0,values:["color","color-burn","color-dodge","darken","difference","exclusion","hard-light","hue","inherit","initial","lighten","luminosity","multiply","normal","overlay","saturation","screen","soft-light","unset"]},"background-origin":{inherited:false,supports:0,values:["border-box","content-box","inherit","initial","padding-box","unset"]},"background-position":{inherited:false,supports:3,values:["inherit","initial","unset"]},"background-repeat":{inherited:false,supports:0,values:["inherit","initial","no-repeat","repeat","repeat-x","repeat-y","unset"]},"background-size":{inherited:false,supports:3,values:["inherit","initial","unset"]},"-moz-binding":{inherited:false,supports:8,values:["inherit","initial","none","unset","url"]},"block-size":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"border-block-end-color":{inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-block-end-style":{inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-block-end-width":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-block-start-color":{inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-block-start-style":{inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-block-start-width":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-bottom-color":{inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"-moz-border-bottom-colors":{inherited:false,supports:4,values:["inherit","initial","unset"]},"border-bottom-style":{inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-bottom-width":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-collapse":{inherited:true,supports:0,values:["collapse","inherit","initial","separate","unset"]},"border-image-source":{inherited:false,supports:648,values:["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"border-image-slice":{inherited:false,supports:1026,values:["inherit","initial","unset"]},"border-image-width":{inherited:false,supports:1027,values:["inherit","initial","unset"]},"border-image-outset":{inherited:false,supports:1025,values:["inherit","initial","unset"]},"border-image-repeat":{inherited:false,supports:0,values:["inherit","initial","unset"]},"border-inline-end-color":{inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-inline-end-style":{inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-inline-end-width":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-inline-start-color":{inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-inline-start-style":{inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-inline-start-width":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-left-color":{inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"-moz-border-left-colors":{inherited:false,supports:4,values:["inherit","initial","unset"]},"border-left-style":{inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-left-width":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-right-color":{inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"-moz-border-right-colors":{inherited:false,supports:4,values:["inherit","initial","unset"]},"border-right-style":{inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-right-width":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-spacing":{inherited:true,supports:1,values:["inherit","initial","unset"]},"border-top-color":{inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"-moz-border-top-colors":{inherited:false,supports:4,values:["inherit","initial","unset"]},"border-top-style":{inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-top-width":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-top-left-radius":{inherited:false,supports:3,values:["inherit","initial","unset"]},"border-top-right-radius":{inherited:false,supports:3,values:["inherit","initial","unset"]},"border-bottom-right-radius":{inherited:false,supports:3,values:["inherit","initial","unset"]},"border-bottom-left-radius":{inherited:false,supports:3,values:["inherit","initial","unset"]},"bottom":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"box-decoration-break":{inherited:false,supports:0,values:["clone","inherit","initial","slice","unset"]},"box-shadow":{inherited:false,supports:5,values:["inherit","initial","unset"]},"box-sizing":{inherited:false,supports:0,values:["border-box","content-box","inherit","initial","padding-box","unset"]},"caption-side":{inherited:true,supports:0,values:["bottom","bottom-outside","inherit","initial","left","right","top","top-outside","unset"]},"clear":{inherited:false,supports:0,values:["both","inherit","initial","inline-end","inline-start","left","none","right","unset"]},"clip":{inherited:false,supports:0,values:["inherit","initial","unset"]},"color":{inherited:true,supports:4,values:["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"-moz-column-count":{inherited:false,supports:1024,values:["auto","inherit","initial","unset"]},"-moz-column-fill":{inherited:false,supports:0,values:["auto","balance","inherit","initial","unset"]},"-moz-column-width":{inherited:false,supports:1,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"-moz-column-gap":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","normal","unset"]},"-moz-column-rule-color":{inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"-moz-column-rule-style":{inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"-moz-column-rule-width":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"contain":{inherited:false,supports:0,values:["inherit","initial","layout","none","paint","strict","style","unset"]},"content":{inherited:false,supports:8,values:["inherit","initial","unset"]},"-moz-control-character-visibility":{inherited:true,supports:0,values:["hidden","inherit","initial","unset","visible"]},"counter-increment":{inherited:false,supports:0,values:["inherit","initial","unset"]},"counter-reset":{inherited:false,supports:0,values:["inherit","initial","unset"]},"cursor":{inherited:true,supports:8,values:["inherit","initial","unset"]},"direction":{inherited:true,supports:0,values:["inherit","initial","ltr","rtl","unset"]},"display":{inherited:false,supports:0,values:["-moz-box","-moz-deck","-moz-grid","-moz-grid-group","-moz-grid-line","-moz-groupbox","-moz-inline-box","-moz-inline-grid","-moz-inline-stack","-moz-popup","-moz-stack","block","contents","flex","grid","inherit","initial","inline","inline-block","inline-flex","inline-grid","inline-table","list-item","none","ruby","ruby-base","ruby-base-container","ruby-text","ruby-text-container","table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row","table-row-group","unset"]},"empty-cells":{inherited:true,supports:0,values:["hide","inherit","initial","show","unset"]},"align-content":{inherited:false,supports:0,values:["inherit","initial","unset"]},"align-items":{inherited:false,supports:0,values:["inherit","initial","unset"]},"align-self":{inherited:false,supports:0,values:["inherit","initial","unset"]},"flex-basis":{inherited:false,supports:3,values:["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"flex-direction":{inherited:false,supports:0,values:["column","column-reverse","inherit","initial","row","row-reverse","unset"]},"flex-grow":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"flex-shrink":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"flex-wrap":{inherited:false,supports:0,values:["inherit","initial","nowrap","unset","wrap","wrap-reverse"]},"order":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"justify-content":{inherited:false,supports:0,values:["inherit","initial","unset"]},"justify-items":{inherited:false,supports:0,values:["inherit","initial","unset"]},"justify-self":{inherited:false,supports:0,values:["inherit","initial","unset"]},"float":{inherited:false,supports:0,values:["inherit","initial","inline-end","inline-start","left","none","right","unset"]},"-moz-float-edge":{inherited:false,supports:0,values:["content-box","inherit","initial","margin-box","unset"]},"font-family":{inherited:true,supports:0,values:["inherit","initial","unset"]},"font-feature-settings":{inherited:true,supports:0,values:["inherit","initial","unset"]},"font-kerning":{inherited:true,supports:0,values:["auto","inherit","initial","none","normal","unset"]},"font-language-override":{inherited:true,supports:0,values:["inherit","initial","normal","unset"]},"font-size":{inherited:true,supports:3,values:["-moz-calc","calc","inherit","initial","large","larger","medium","small","smaller","unset","x-large","x-small","xx-large","xx-small"]},"font-size-adjust":{inherited:true,supports:1024,values:["inherit","initial","none","unset"]},"font-stretch":{inherited:true,supports:0,values:["condensed","expanded","extra-condensed","extra-expanded","inherit","initial","normal","semi-condensed","semi-expanded","ultra-condensed","ultra-expanded","unset"]},"font-style":{inherited:true,supports:0,values:["inherit","initial","italic","normal","oblique","unset"]},"font-synthesis":{inherited:true,supports:0,values:["inherit","initial","unset"]},"font-variant-alternates":{inherited:true,supports:0,values:["inherit","initial","unset"]},"font-variant-caps":{inherited:true,supports:0,values:["all-petite-caps","all-small-caps","inherit","initial","normal","petite-caps","small-caps","titling-caps","unicase","unset"]},"font-variant-east-asian":{inherited:true,supports:0,values:["inherit","initial","unset"]},"font-variant-ligatures":{inherited:true,supports:0,values:["inherit","initial","unset"]},"font-variant-numeric":{inherited:true,supports:0,values:["inherit","initial","unset"]},"font-variant-position":{inherited:true,supports:0,values:["inherit","initial","normal","sub","super","unset"]},"font-weight":{inherited:true,supports:1024,values:["inherit","initial","unset"]},"-moz-force-broken-image-icon":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"grid-auto-flow":{inherited:false,supports:0,values:["inherit","initial","unset"]},"grid-auto-columns":{inherited:false,supports:3,values:["inherit","initial","unset"]},"grid-auto-rows":{inherited:false,supports:3,values:["inherit","initial","unset"]},"grid-template-areas":{inherited:false,supports:0,values:["inherit","initial","unset"]},"grid-template-columns":{inherited:false,supports:3,values:["inherit","initial","unset"]},"grid-template-rows":{inherited:false,supports:3,values:["inherit","initial","unset"]},"grid-column-start":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"grid-column-end":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"grid-row-start":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"grid-row-end":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"grid-column-gap":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","unset"]},"grid-row-gap":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","unset"]},"height":{inherited:false,supports:3,values:["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"image-orientation":{inherited:true,supports:16,values:["inherit","initial","unset"]},"-moz-image-region":{inherited:true,supports:0,values:["inherit","initial","unset"]},"ime-mode":{inherited:false,supports:0,values:["active","auto","disabled","inactive","inherit","initial","normal","unset"]},"inline-size":{inherited:false,supports:3,values:["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"left":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"letter-spacing":{inherited:true,supports:1,values:["-moz-calc","calc","inherit","initial","normal","unset"]},"line-height":{inherited:true,supports:1027,values:["-moz-block-height","inherit","initial","normal","unset"]},"list-style-image":{inherited:true,supports:8,values:["inherit","initial","none","unset","url"]},"list-style-position":{inherited:true,supports:0,values:["inherit","initial","inside","outside","unset"]},"list-style-type":{inherited:true,supports:0,values:["inherit","initial","unset"]},"margin-block-end":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-block-start":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-bottom":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-inline-end":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-inline-start":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-left":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-right":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-top":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"marker-offset":{inherited:false,supports:1,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"max-block-size":{inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","none","unset"]},"max-height":{inherited:false,supports:3,values:["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","calc","inherit","initial","none","unset"]},"max-inline-size":{inherited:false,supports:3,values:["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","calc","inherit","initial","none","unset"]},"max-width":{inherited:false,supports:3,values:["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","calc","inherit","initial","none","unset"]},"min-height":{inherited:false,supports:3,values:["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"min-block-size":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"min-inline-size":{inherited:false,supports:3,values:["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"min-width":{inherited:false,supports:3,values:["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"mix-blend-mode":{inherited:false,supports:0,values:["color","color-burn","color-dodge","darken","difference","exclusion","hard-light","hue","inherit","initial","lighten","luminosity","multiply","normal","overlay","saturation","screen","soft-light","unset"]},"isolation":{inherited:false,supports:0,values:["auto","inherit","initial","isolate","unset"]},"object-fit":{inherited:false,supports:0,values:["contain","cover","fill","inherit","initial","none","scale-down","unset"]},"object-position":{inherited:false,supports:3,values:["inherit","initial","unset"]},"offset-block-end":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"offset-block-start":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"offset-inline-end":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"offset-inline-start":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"opacity":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"-moz-orient":{inherited:false,supports:0,values:["block","horizontal","inherit","initial","inline","unset","vertical"]},"outline-color":{inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"outline-style":{inherited:false,supports:0,values:["auto","dashed","dotted","double","groove","inherit","initial","inset","none","outset","ridge","solid","unset"]},"outline-width":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"outline-offset":{inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","unset"]},"overflow-x":{inherited:false,supports:0,values:["-moz-hidden-unscrollable","auto","hidden","inherit","initial","scroll","unset","visible"]},"overflow-y":{inherited:false,supports:0,values:["-moz-hidden-unscrollable","auto","hidden","inherit","initial","scroll","unset","visible"]},"padding-block-end":{inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"padding-block-start":{inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"padding-bottom":{inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"padding-inline-end":{inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"padding-inline-start":{inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"padding-left":{inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"padding-right":{inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"padding-top":{inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"page-break-after":{inherited:false,supports:0,values:["always","auto","avoid","inherit","initial","left","right","unset"]},"page-break-before":{inherited:false,supports:0,values:["always","auto","avoid","inherit","initial","left","right","unset"]},"page-break-inside":{inherited:false,supports:0,values:["auto","avoid","inherit","initial","unset"]},"paint-order":{inherited:true,supports:0,values:["inherit","initial","unset"]},"pointer-events":{inherited:true,supports:0,values:["all","auto","fill","inherit","initial","none","painted","stroke","unset","visible","visiblefill","visiblepainted","visiblestroke"]},"position":{inherited:false,supports:0,values:["absolute","fixed","inherit","initial","relative","static","sticky","unset"]},"quotes":{inherited:true,supports:0,values:["inherit","initial","unset"]},"resize":{inherited:false,supports:0,values:["both","horizontal","inherit","initial","none","unset","vertical"]},"right":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"ruby-align":{inherited:true,supports:0,values:["center","inherit","initial","space-around","space-between","start","unset"]},"ruby-position":{inherited:true,supports:0,values:["inherit","initial","over","under","unset"]},"scroll-behavior":{inherited:false,supports:0,values:["auto","inherit","initial","smooth","unset"]},"scroll-snap-coordinate":{inherited:false,supports:3,values:["inherit","initial","unset"]},"scroll-snap-destination":{inherited:false,supports:3,values:["inherit","initial","unset"]},"scroll-snap-points-x":{inherited:false,supports:0,values:["inherit","initial","unset"]},"scroll-snap-points-y":{inherited:false,supports:0,values:["inherit","initial","unset"]},"scroll-snap-type-x":{inherited:false,supports:0,values:["inherit","initial","mandatory","none","proximity","unset"]},"scroll-snap-type-y":{inherited:false,supports:0,values:["inherit","initial","mandatory","none","proximity","unset"]},"table-layout":{inherited:false,supports:0,values:["auto","fixed","inherit","initial","unset"]},"text-align":{inherited:true,supports:0,values:["-moz-center","-moz-left","-moz-right","center","end","inherit","initial","justify","left","right","start","unset"]},"-moz-text-align-last":{inherited:true,supports:0,values:["auto","center","end","inherit","initial","justify","left","right","start","unset"]},"text-decoration-color":{inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"text-decoration-line":{inherited:false,supports:0,values:["inherit","initial","unset"]},"text-decoration-style":{inherited:false,supports:0,values:["-moz-none","dashed","dotted","double","inherit","initial","solid","unset","wavy"]},"text-indent":{inherited:true,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"text-orientation":{inherited:true,supports:0,values:["inherit","initial","mixed","sideways","sideways-right","unset","upright"]},"text-overflow":{inherited:false,supports:0,values:["inherit","initial","unset"]},"text-shadow":{inherited:true,supports:5,values:["inherit","initial","unset"]},"-moz-text-size-adjust":{inherited:true,supports:0,values:["auto","inherit","initial","none","unset"]},"text-transform":{inherited:true,supports:0,values:["capitalize","full-width","inherit","initial","lowercase","none","unset","uppercase"]},"transform":{inherited:false,supports:0,values:["inherit","initial","unset"]},"transform-box":{inherited:false,supports:0,values:["border-box","fill-box","inherit","initial","unset","view-box"]},"transform-origin":{inherited:false,supports:3,values:["inherit","initial","unset"]},"perspective-origin":{inherited:false,supports:3,values:["inherit","initial","unset"]},"perspective":{inherited:false,supports:1,values:["inherit","initial","none","unset"]},"transform-style":{inherited:false,supports:0,values:["flat","inherit","initial","preserve-3d","unset"]},"backface-visibility":{inherited:false,supports:0,values:["hidden","inherit","initial","unset","visible"]},"top":{inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"transition-delay":{inherited:false,supports:64,values:["inherit","initial","unset"]},"transition-duration":{inherited:false,supports:64,values:["inherit","initial","unset"]},"transition-property":{inherited:false,supports:0,values:["all","inherit","initial","none","unset"]},"transition-timing-function":{inherited:false,supports:256,values:["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"unicode-bidi":{inherited:false,supports:0,values:["-moz-isolate","-moz-isolate-override","-moz-plaintext","bidi-override","embed","inherit","initial","normal","unset"]},"-moz-user-focus":{inherited:true,supports:0,values:["ignore","inherit","initial","none","normal","select-after","select-all","select-before","select-menu","select-same","unset"]},"-moz-user-input":{inherited:true,supports:0,values:["auto","disabled","enabled","inherit","initial","none","unset"]},"-moz-user-modify":{inherited:true,supports:0,values:["inherit","initial","read-only","read-write","unset","write-only"]},"-moz-user-select":{inherited:false,supports:0,values:["-moz-all","-moz-none","-moz-text","all","auto","element","elements","inherit","initial","none","text","toggle","tri-state","unset"]},"vertical-align":{inherited:false,supports:3,values:["-moz-calc","-moz-middle-with-baseline","baseline","bottom","calc","inherit","initial","middle","sub","super","text-bottom","text-top","top","unset"]},"visibility":{inherited:true,supports:0,values:["collapse","hidden","inherit","initial","unset","visible"]},"white-space":{inherited:true,supports:0,values:["-moz-pre-space","inherit","initial","normal","nowrap","pre","pre-line","pre-wrap","unset"]},"width":{inherited:false,supports:3,values:["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"-moz-window-dragging":{inherited:true,supports:0,values:["drag","inherit","initial","no-drag","unset"]},"word-break":{inherited:true,supports:0,values:["break-all","inherit","initial","keep-all","normal","unset"]},"word-spacing":{inherited:true,supports:3,values:["-moz-calc","calc","inherit","initial","normal","unset"]},"word-wrap":{inherited:true,supports:0,values:["break-word","inherit","initial","normal","unset"]},"hyphens":{inherited:true,supports:0,values:["auto","inherit","initial","manual","none","unset"]},"writing-mode":{inherited:true,supports:0,values:["horizontal-tb","inherit","initial","lr","lr-tb","rl","rl-tb","sideways-lr","sideways-rl","tb","tb-rl","unset","vertical-lr","vertical-rl"]},"z-index":{inherited:false,supports:1024,values:["auto","inherit","initial","unset"]},"-moz-box-align":{inherited:false,supports:0,values:["baseline","center","end","inherit","initial","start","stretch","unset"]},"-moz-box-direction":{inherited:false,supports:0,values:["inherit","initial","normal","reverse","unset"]},"-moz-box-flex":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"-moz-box-orient":{inherited:false,supports:0,values:["block-axis","horizontal","inherit","initial","inline-axis","unset","vertical"]},"-moz-box-pack":{inherited:false,supports:0,values:["center","end","inherit","initial","justify","start","unset"]},"-moz-box-ordinal-group":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"-moz-stack-sizing":{inherited:false,supports:0,values:["ignore","inherit","initial","stretch-to-fit","unset"]},"clip-path":{inherited:false,supports:8,values:["inherit","initial","unset"]},"clip-rule":{inherited:true,supports:0,values:["evenodd","inherit","initial","nonzero","unset"]},"color-interpolation":{inherited:true,supports:0,values:["auto","inherit","initial","linearrgb","srgb","unset"]},"color-interpolation-filters":{inherited:true,supports:0,values:["auto","inherit","initial","linearrgb","srgb","unset"]},"dominant-baseline":{inherited:false,supports:0,values:["alphabetic","auto","central","hanging","ideographic","inherit","initial","mathematical","middle","no-change","reset-size","text-after-edge","text-before-edge","unset","use-script"]},"fill":{inherited:true,supports:12,values:["inherit","initial","unset"]},"fill-opacity":{inherited:true,supports:1024,values:["inherit","initial","unset"]},"fill-rule":{inherited:true,supports:0,values:["evenodd","inherit","initial","nonzero","unset"]},"filter":{inherited:false,supports:8,values:["inherit","initial","unset"]},"flood-color":{inherited:false,supports:4,values:["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"flood-opacity":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"image-rendering":{inherited:true,supports:0,values:["-moz-crisp-edges","auto","inherit","initial","optimizequality","optimizespeed","unset"]},"lighting-color":{inherited:false,supports:4,values:["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"marker-end":{inherited:true,supports:8,values:["inherit","initial","none","unset","url"]},"marker-mid":{inherited:true,supports:8,values:["inherit","initial","none","unset","url"]},"marker-start":{inherited:true,supports:8,values:["inherit","initial","none","unset","url"]},"mask":{inherited:false,supports:8,values:["inherit","initial","none","unset","url"]},"mask-type":{inherited:false,supports:0,values:["alpha","inherit","initial","luminance","unset"]},"shape-rendering":{inherited:true,supports:0,values:["auto","crispedges","geometricprecision","inherit","initial","optimizespeed","unset"]},"stop-color":{inherited:false,supports:4,values:["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"stop-opacity":{inherited:false,supports:1024,values:["inherit","initial","unset"]},"stroke":{inherited:true,supports:12,values:["inherit","initial","unset"]},"stroke-dasharray":{inherited:true,supports:1027,values:["inherit","initial","unset"]},"stroke-dashoffset":{inherited:true,supports:1027,values:["inherit","initial","unset"]},"stroke-linecap":{inherited:true,supports:0,values:["butt","inherit","initial","round","square","unset"]},"stroke-linejoin":{inherited:true,supports:0,values:["bevel","inherit","initial","miter","round","unset"]},"stroke-miterlimit":{inherited:true,supports:1024,values:["inherit","initial","unset"]},"stroke-opacity":{inherited:true,supports:1024,values:["inherit","initial","unset"]},"stroke-width":{inherited:true,supports:1027,values:["inherit","initial","unset"]},"text-anchor":{inherited:true,supports:0,values:["end","inherit","initial","middle","start","unset"]},"text-rendering":{inherited:true,supports:0,values:["auto","geometricprecision","inherit","initial","optimizelegibility","optimizespeed","unset"]},"vector-effect":{inherited:false,supports:0,values:["inherit","initial","non-scaling-stroke","none","unset"]},"will-change":{inherited:false,supports:0,values:["inherit","initial","unset"]},"-moz-outline-radius":{subproperties:["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],inherited:false,supports:3,values:["inherit","initial","unset"]},"all":{subproperties:["-moz-appearance","-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft","-moz-tab-size","-x-system-font","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","background-attachment","background-clip","background-color","background-image","background-blend-mode","background-origin","background-position","background-repeat","background-size","-moz-binding","block-size","border-block-end-color","border-block-end-style","border-block-end-width","border-block-start-color","border-block-start-style","border-block-start-width","border-bottom-color","-moz-border-bottom-colors","border-bottom-style","border-bottom-width","border-collapse","border-image-source","border-image-slice","border-image-width","border-image-outset","border-image-repeat","border-inline-end-color","border-inline-end-style","border-inline-end-width","border-inline-start-color","border-inline-start-style","border-inline-start-width","border-left-color","-moz-border-left-colors","border-left-style","border-left-width","border-right-color","-moz-border-right-colors","border-right-style","border-right-width","border-spacing","border-top-color","-moz-border-top-colors","border-top-style","border-top-width","border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius","bottom","box-decoration-break","box-shadow","box-sizing","caption-side","clear","clip","color","-moz-column-count","-moz-column-fill","-moz-column-width","-moz-column-gap","-moz-column-rule-color","-moz-column-rule-style","-moz-column-rule-width","contain","content","-moz-control-character-visibility","counter-increment","counter-reset","cursor","display","empty-cells","align-content","align-items","align-self","flex-basis","flex-direction","flex-grow","flex-shrink","flex-wrap","order","justify-content","justify-items","justify-self","float","-moz-float-edge","font-family","font-feature-settings","font-kerning","font-language-override","font-size","font-size-adjust","-moz-osx-font-smoothing","font-stretch","font-style","font-synthesis","font-variant-alternates","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position","font-weight","-moz-force-broken-image-icon","grid-auto-flow","grid-auto-columns","grid-auto-rows","grid-template-areas","grid-template-columns","grid-template-rows","grid-column-start","grid-column-end","grid-row-start","grid-row-end","grid-column-gap","grid-row-gap","height","image-orientation","-moz-image-region","ime-mode","inline-size","left","letter-spacing","line-height","list-style-image","list-style-position","list-style-type","margin-block-end","margin-block-start","margin-bottom","margin-inline-end","margin-inline-start","margin-left","margin-right","margin-top","marker-offset","max-block-size","max-height","max-inline-size","max-width","-moz-min-font-size-ratio","min-height","min-block-size","min-inline-size","min-width","mix-blend-mode","isolation","object-fit","object-position","offset-block-end","offset-block-start","offset-inline-end","offset-inline-start","opacity","-moz-orient","outline-color","outline-style","outline-width","outline-offset","overflow-clip-box","overflow-x","overflow-y","padding-block-end","padding-block-start","padding-bottom","padding-inline-end","padding-inline-start","padding-left","padding-right","padding-top","page-break-after","page-break-before","page-break-inside","paint-order","pointer-events","position","quotes","resize","right","ruby-align","ruby-position","scroll-behavior","scroll-snap-coordinate","scroll-snap-destination","scroll-snap-points-x","scroll-snap-points-y","scroll-snap-type-x","scroll-snap-type-y","table-layout","text-align","-moz-text-align-last","text-combine-upright","text-decoration-color","text-decoration-line","text-decoration-style","text-indent","text-orientation","text-overflow","text-shadow","-moz-text-size-adjust","text-transform","transform","transform-box","transform-origin","perspective-origin","perspective","transform-style","backface-visibility","top","-moz-top-layer","touch-action","transition-delay","transition-duration","transition-property","transition-timing-function","-moz-user-focus","-moz-user-input","-moz-user-modify","-moz-user-select","vertical-align","visibility","white-space","width","-moz-window-dragging","-moz-window-shadow","word-break","word-spacing","word-wrap","hyphens","writing-mode","z-index","-moz-box-align","-moz-box-direction","-moz-box-flex","-moz-box-orient","-moz-box-pack","-moz-box-ordinal-group","-moz-stack-sizing","clip-path","clip-rule","color-interpolation","color-interpolation-filters","dominant-baseline","fill","fill-opacity","fill-rule","filter","flood-color","flood-opacity","image-rendering","lighting-color","marker-end","marker-mid","marker-start","mask","mask-type","shape-rendering","stop-color","stop-opacity","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","text-anchor","text-rendering","vector-effect","will-change"],inherited:false,supports:2015,values:["-moz-all","-moz-available","-moz-block-height","-moz-box","-moz-calc","-moz-center","-moz-crisp-edges","-moz-deck","-moz-element","-moz-fit-content","-moz-grid","-moz-grid-group","-moz-grid-line","-moz-groupbox","-moz-gtk-info-bar","-moz-hidden-unscrollable","-moz-image-rect","-moz-inline-box","-moz-inline-grid","-moz-inline-stack","-moz-left","-moz-linear-gradient","-moz-mac-disclosure-button-closed","-moz-mac-disclosure-button-open","-moz-mac-fullscreen-button","-moz-mac-help-button","-moz-mac-vibrancy-dark","-moz-mac-vibrancy-light","-moz-max-content","-moz-middle-with-baseline","-moz-min-content","-moz-none","-moz-popup","-moz-pre-space","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","-moz-right","-moz-stack","-moz-text","-moz-use-text-color","-moz-win-borderless-glass","-moz-win-browsertabbar-toolbox","-moz-win-communications-toolbox","-moz-win-exclude-glass","-moz-win-glass","-moz-win-media-toolbox","-moz-window-button-box","-moz-window-button-box-maximized","-moz-window-button-close","-moz-window-button-maximize","-moz-window-button-minimize","-moz-window-button-restore","-moz-window-frame-bottom","-moz-window-frame-left","-moz-window-frame-right","-moz-window-titlebar","-moz-window-titlebar-maximized","absolute","active","aliceblue","all","all-petite-caps","all-small-caps","alpha","alphabetic","alternate","alternate-reverse","always","antiquewhite","aqua","aquamarine","auto","avoid","azure","backwards","balance","baseline","beige","bevel","bisque","black","blanchedalmond","block","block-axis","blue","blueviolet","border-box","both","bottom","bottom-outside","break-all","break-word","brown","burlywood","butt","button","button-arrow-down","button-arrow-next","button-arrow-previous","button-arrow-up","button-bevel","button-focus","cadetblue","calc","capitalize","caret","center","central","chartreuse","checkbox","checkbox-container","checkbox-label","checkmenuitem","chocolate","clone","collapse","color","color-burn","color-dodge","column","column-reverse","condensed","contain","content-box","contents","coral","cornflowerblue","cornsilk","cover","crimson","crispedges","cubic-bezier","currentColor","cyan","darkblue","darkcyan","darken","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dialog","difference","dimgray","dimgrey","disabled","dodgerblue","dotted","double","drag","dualbutton","ease","ease-in","ease-in-out","ease-out","element","elements","enabled","end","evenodd","exclusion","expanded","extra-condensed","extra-expanded","fill","fill-box","firebrick","fixed","flat","flex","floralwhite","forestgreen","forwards","fuchsia","full-width","gainsboro","geometricprecision","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","grid","groove","groupbox","hanging","hard-light","hidden","hide","honeydew","horizontal","horizontal-tb","hotpink","hsl","hsla","hue","ideographic","ignore","inactive","indianred","indigo","infinite","inherit","initial","inline","inline-axis","inline-block","inline-end","inline-flex","inline-grid","inline-start","inline-table","inset","inside","isolate","italic","ivory","justify","keep-all","khaki","large","larger","lavender","lavenderblush","lawngreen","layout","left","lemonchiffon","lightblue","lightcoral","lightcyan","lighten","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linear","linear-gradient","linearrgb","linen","list-item","listbox","listitem","local","lowercase","lr","lr-tb","luminance","luminosity","magenta","mandatory","manual","margin-box","maroon","mathematical","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","menuarrow","menubar","menucheckbox","menuimage","menuitem","menuitemtext","menulist","menulist-button","menulist-text","menulist-textfield","menupopup","menuradio","menuseparator","meterbar","meterchunk","middle","midnightblue","mintcream","mistyrose","miter","mixed","moccasin","multiply","navajowhite","navy","no-change","no-drag","no-repeat","non-scaling-stroke","none","nonzero","normal","nowrap","number-input","oblique","oldlace","olive","olivedrab","optimizelegibility","optimizequality","optimizespeed","orange","orangered","orchid","outset","outside","over","overlay","padding-box","paint","painted","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","paused","peachpuff","peru","petite-caps","pink","plum","powderblue","pre","pre-line","pre-wrap","preserve-3d","progressbar","progressbar-vertical","progresschunk","progresschunk-vertical","proximity","purple","radial-gradient","radio","radio-container","radio-label","radiomenuitem","range","range-thumb","read-only","read-write","rebeccapurple","red","relative","repeat","repeat-x","repeat-y","repeating-linear-gradient","repeating-radial-gradient","reset-size","resizer","resizerpanel","reverse","rgb","rgba","ridge","right","rl","rl-tb","rosybrown","round","row","row-reverse","royalblue","ruby","ruby-base","ruby-base-container","ruby-text","ruby-text-container","running","saddlebrown","salmon","sandybrown","saturation","scale-down","scale-horizontal","scale-vertical","scalethumb-horizontal","scalethumb-vertical","scalethumbend","scalethumbstart","scalethumbtick","screen","scroll","scrollbar","scrollbar-small","scrollbarbutton-down","scrollbarbutton-left","scrollbarbutton-right","scrollbarbutton-up","scrollbarthumb-horizontal","scrollbarthumb-vertical","scrollbartrack-horizontal","scrollbartrack-vertical","seagreen","searchfield","seashell","select-after","select-all","select-before","select-menu","select-same","semi-condensed","semi-expanded","separate","separator","show","sideways","sideways-lr","sideways-right","sideways-rl","sienna","silver","skyblue","slateblue","slategray","slategrey","slice","small","small-caps","smaller","smooth","snow","soft-light","solid","space-around","space-between","spinner","spinner-downbutton","spinner-textfield","spinner-upbutton","splitter","springgreen","square","srgb","start","static","statusbar","statusbarpanel","steelblue","step-end","step-start","steps","sticky","stretch","stretch-to-fit","strict","stroke","style","sub","super","tab","tab-scroll-arrow-back","tab-scroll-arrow-forward","table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row","table-row-group","tabpanel","tabpanels","tan","tb","tb-rl","teal","text","text-after-edge","text-before-edge","text-bottom","text-top","textfield","textfield-multiline","thick","thin","thistle","titling-caps","toggle","tomato","toolbar","toolbarbutton","toolbarbutton-dropdown","toolbargripper","toolbox","tooltip","top","top-outside","transparent","treeheader","treeheadercell","treeheadersortarrow","treeitem","treeline","treetwisty","treetwistyopen","treeview","tri-state","turquoise","ultra-condensed","ultra-expanded","under","unicase","unset","uppercase","upright","url","use-script","vertical","vertical-lr","vertical-rl","view-box","violet","visible","visiblefill","visiblepainted","visiblestroke","wavy","wheat","white","whitesmoke","window","wrap","wrap-reverse","write-only","x-large","x-small","xx-large","xx-small","yellow","yellowgreen"]},"animation":{subproperties:["animation-duration","animation-timing-function","animation-delay","animation-direction","animation-fill-mode","animation-iteration-count","animation-play-state","animation-name"],inherited:false,supports:1344,values:["alternate","alternate-reverse","backwards","both","cubic-bezier","ease","ease-in","ease-in-out","ease-out","forwards","infinite","inherit","initial","linear","none","normal","paused","reverse","running","step-end","step-start","steps","unset"]},"background":{subproperties:["background-color","background-image","background-repeat","background-attachment","background-position","background-clip","background-origin","background-size"],inherited:false,supports:655,values:["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","border-box","brown","burlywood","cadetblue","chartreuse","chocolate","content-box","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","fixed","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linear-gradient","linen","local","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","no-repeat","none","oldlace","olive","olivedrab","orange","orangered","orchid","padding-box","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","radial-gradient","rebeccapurple","red","repeat","repeat-x","repeat-y","repeating-linear-gradient","repeating-radial-gradient","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","scroll","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","url","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border":{subproperties:["border-top-width","border-right-width","border-bottom-width","border-left-width","border-top-style","border-right-style","border-bottom-style","border-left-style","border-top-color","border-right-color","border-bottom-color","border-left-color","-moz-border-top-colors","-moz-border-right-colors","-moz-border-bottom-colors","-moz-border-left-colors","border-image-source","border-image-slice","border-image-width","border-image-outset","border-image-repeat"],inherited:false,supports:5,values:["-moz-calc","-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linear-gradient","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","radial-gradient","rebeccapurple","red","repeating-linear-gradient","repeating-radial-gradient","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","url","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-block-end":{subproperties:["border-block-end-width","border-block-end-style","border-block-end-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-block-start":{subproperties:["border-block-start-width","border-block-start-style","border-block-start-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-bottom":{subproperties:["border-bottom-width","border-bottom-style","border-bottom-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-color":{subproperties:["border-top-color","border-right-color","border-bottom-color","border-left-color"],inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-image":{subproperties:["border-image-source","border-image-slice","border-image-width","border-image-outset","border-image-repeat"],inherited:false,supports:1675,values:["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"border-inline-end":{subproperties:["border-inline-end-width","border-inline-end-style","border-inline-end-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-inline-start":{subproperties:["border-inline-start-width","border-inline-start-style","border-inline-start-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-left":{subproperties:["border-left-width","border-left-style","border-left-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-right":{subproperties:["border-right-width","border-right-style","border-right-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-style":{subproperties:["border-top-style","border-right-style","border-bottom-style","border-left-style"],inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-top":{subproperties:["border-top-width","border-top-style","border-top-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"border-width":{subproperties:["border-top-width","border-right-width","border-bottom-width","border-left-width"],inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-radius":{subproperties:["border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius"],inherited:false,supports:3,values:["inherit","initial","unset"]},"-moz-columns":{subproperties:["-moz-column-count","-moz-column-width"],inherited:false,supports:1025,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"-moz-column-rule":{subproperties:["-moz-column-rule-width","-moz-column-rule-style","-moz-column-rule-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"flex":{subproperties:["flex-grow","flex-shrink","flex-basis"],inherited:false,supports:1027,values:["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"flex-flow":{subproperties:["flex-direction","flex-wrap"],inherited:false,supports:0,values:["column","column-reverse","inherit","initial","nowrap","row","row-reverse","unset","wrap","wrap-reverse"]},"font":{subproperties:["font-family","font-style","font-weight","font-size","line-height","font-size-adjust","font-stretch","-x-system-font","font-feature-settings","font-language-override","font-kerning","font-synthesis","font-variant-alternates","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position"],inherited:true,supports:1027,values:["-moz-block-height","-moz-calc","all-petite-caps","all-small-caps","auto","calc","condensed","expanded","extra-condensed","extra-expanded","inherit","initial","italic","large","larger","medium","none","normal","oblique","petite-caps","semi-condensed","semi-expanded","small","small-caps","smaller","sub","super","titling-caps","ultra-condensed","ultra-expanded","unicase","unset","x-large","x-small","xx-large","xx-small"]},"font-variant":{subproperties:["font-variant-alternates","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position"],inherited:true,supports:0,values:["all-petite-caps","all-small-caps","inherit","initial","normal","petite-caps","small-caps","sub","super","titling-caps","unicase","unset"]},"grid-template":{subproperties:["grid-template-areas","grid-template-columns","grid-template-rows"],inherited:false,supports:3,values:["inherit","initial","unset"]},"grid":{subproperties:["grid-template-areas","grid-template-columns","grid-template-rows","grid-auto-flow","grid-auto-columns","grid-auto-rows","grid-column-gap","grid-row-gap"],inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"grid-column":{subproperties:["grid-column-start","grid-column-end"],inherited:false,supports:1024,values:["inherit","initial","unset"]},"grid-row":{subproperties:["grid-row-start","grid-row-end"],inherited:false,supports:1024,values:["inherit","initial","unset"]},"grid-area":{subproperties:["grid-row-start","grid-column-start","grid-row-end","grid-column-end"],inherited:false,supports:1024,values:["inherit","initial","unset"]},"grid-gap":{subproperties:["grid-column-gap","grid-row-gap"],inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","unset"]},"list-style":{subproperties:["list-style-type","list-style-image","list-style-position"],inherited:true,supports:8,values:["inherit","initial","inside","none","outside","unset","url"]},"margin":{subproperties:["margin-top","margin-right","margin-bottom","margin-left"],inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"outline":{subproperties:["outline-width","outline-style","outline-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","auto","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"overflow":{subproperties:["overflow-x","overflow-y"],inherited:false,supports:0,values:["-moz-hidden-unscrollable","auto","hidden","inherit","initial","scroll","unset","visible"]},"padding":{subproperties:["padding-top","padding-right","padding-bottom","padding-left"],inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"scroll-snap-type":{subproperties:["scroll-snap-type-x","scroll-snap-type-y"],inherited:false,supports:0,values:["inherit","initial","mandatory","none","proximity","unset"]},"text-decoration":{subproperties:["text-decoration-color","text-decoration-line","text-decoration-style"],inherited:false,supports:4,values:["-moz-none","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wavy","wheat","white","whitesmoke","yellow","yellowgreen"]},"transition":{subproperties:["transition-property","transition-duration","transition-timing-function","transition-delay"],inherited:false,supports:320,values:["all","cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","none","step-end","step-start","steps","unset"]},"marker":{subproperties:["marker-start","marker-mid","marker-end"],inherited:true,supports:8,values:["inherit","initial","none","unset","url"]},"-moz-transform":{alias:true,subproperties:["transform"],inherited:false,supports:0,values:["inherit","initial","unset"]},"-moz-transform-origin":{alias:true,inherited:false,supports:3,values:["inherit","initial","unset"]},"-moz-perspective-origin":{alias:true,inherited:false,supports:3,values:["inherit","initial","unset"]},"-moz-perspective":{alias:true,inherited:false,supports:1,values:["inherit","initial","none","unset"]},"-moz-transform-style":{alias:true,inherited:false,supports:0,values:["flat","inherit","initial","preserve-3d","unset"]},"-moz-backface-visibility":{alias:true,inherited:false,supports:0,values:["hidden","inherit","initial","unset","visible"]},"-moz-border-image":{alias:true,subproperties:["border-image-source","border-image-slice","border-image-width","border-image-outset","border-image-repeat"],inherited:false,supports:1675,values:["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"-moz-transition":{alias:true,subproperties:["transition-property","transition-duration","transition-timing-function","transition-delay"],inherited:false,supports:320,values:["all","cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","none","step-end","step-start","steps","unset"]},"-moz-transition-delay":{alias:true,inherited:false,supports:64,values:["inherit","initial","unset"]},"-moz-transition-duration":{alias:true,inherited:false,supports:64,values:["inherit","initial","unset"]},"-moz-transition-property":{alias:true,inherited:false,supports:0,values:["all","inherit","initial","none","unset"]},"-moz-transition-timing-function":{alias:true,inherited:false,supports:256,values:["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-moz-animation":{alias:true,subproperties:["animation-duration","animation-timing-function","animation-delay","animation-direction","animation-fill-mode","animation-iteration-count","animation-play-state","animation-name"],inherited:false,supports:1344,values:["alternate","alternate-reverse","backwards","both","cubic-bezier","ease","ease-in","ease-in-out","ease-out","forwards","infinite","inherit","initial","linear","none","normal","paused","reverse","running","step-end","step-start","steps","unset"]},"-moz-animation-delay":{alias:true,inherited:false,supports:64,values:["inherit","initial","unset"]},"-moz-animation-direction":{alias:true,inherited:false,supports:0,values:["alternate","alternate-reverse","inherit","initial","normal","reverse","unset"]},"-moz-animation-duration":{alias:true,inherited:false,supports:64,values:["inherit","initial","unset"]},"-moz-animation-fill-mode":{alias:true,inherited:false,supports:0,values:["backwards","both","forwards","inherit","initial","none","unset"]},"-moz-animation-iteration-count":{alias:true,inherited:false,supports:1024,values:["infinite","inherit","initial","unset"]},"-moz-animation-name":{alias:true,inherited:false,supports:0,values:["inherit","initial","none","unset"]},"-moz-animation-play-state":{alias:true,inherited:false,supports:0,values:["inherit","initial","paused","running","unset"]},"-moz-animation-timing-function":{alias:true,inherited:false,supports:256,values:["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-moz-box-sizing":{alias:true,inherited:false,supports:0,values:["border-box","content-box","inherit","initial","padding-box","unset"]},"-moz-font-feature-settings":{alias:true,inherited:true,supports:0,values:["inherit","initial","unset"]},"-moz-font-language-override":{alias:true,inherited:true,supports:0,values:["inherit","initial","normal","unset"]},"-moz-padding-end":{alias:true,inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"-moz-padding-start":{alias:true,inherited:false,supports:3,values:["-moz-calc","calc","inherit","initial","unset"]},"-moz-margin-end":{alias:true,inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"-moz-margin-start":{alias:true,inherited:false,supports:3,values:["-moz-calc","auto","calc","inherit","initial","unset"]},"-moz-border-end":{alias:true,subproperties:["border-inline-end-width","border-inline-end-style","border-inline-end-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"-moz-border-end-color":{alias:true,inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"-moz-border-end-style":{alias:true,inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"-moz-border-end-width":{alias:true,inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"-moz-border-start":{alias:true,subproperties:["border-inline-start-width","border-inline-start-style","border-inline-start-color"],inherited:false,supports:5,values:["-moz-calc","-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","calc","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","dashed","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","dotted","double","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","groove","hidden","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","inset","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","medium","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","none","oldlace","olive","olivedrab","orange","orangered","orchid","outset","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","ridge","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","solid","springgreen","steelblue","tan","teal","thick","thin","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"-moz-border-start-color":{alias:true,inherited:false,supports:4,values:["-moz-use-text-color","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","currentColor","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","hsl","hsla","indianred","indigo","inherit","initial","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rgb","rgba","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","unset","violet","wheat","white","whitesmoke","yellow","yellowgreen"]},"-moz-border-start-style":{alias:true,inherited:false,supports:0,values:["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"-moz-border-start-width":{alias:true,inherited:false,supports:1,values:["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"-moz-hyphens":{alias:true,inherited:true,supports:0,values:["auto","inherit","initial","manual","none","unset"]},"-webkit-animation":{alias:true,subproperties:["animation-duration","animation-timing-function","animation-delay","animation-direction","animation-fill-mode","animation-iteration-count","animation-play-state","animation-name"],inherited:false,supports:1344,values:["alternate","alternate-reverse","backwards","both","cubic-bezier","ease","ease-in","ease-in-out","ease-out","forwards","infinite","inherit","initial","linear","none","normal","paused","reverse","running","step-end","step-start","steps","unset"]},"-webkit-animation-delay":{alias:true,inherited:false,supports:64,values:["inherit","initial","unset"]},"-webkit-animation-direction":{alias:true,inherited:false,supports:0,values:["alternate","alternate-reverse","inherit","initial","normal","reverse","unset"]},"-webkit-animation-duration":{alias:true,inherited:false,supports:64,values:["inherit","initial","unset"]},"-webkit-animation-fill-mode":{alias:true,inherited:false,supports:0,values:["backwards","both","forwards","inherit","initial","none","unset"]},"-webkit-animation-iteration-count":{alias:true,inherited:false,supports:1024,values:["infinite","inherit","initial","unset"]},"-webkit-animation-name":{alias:true,inherited:false,supports:0,values:["inherit","initial","none","unset"]},"-webkit-animation-play-state":{alias:true,inherited:false,supports:0,values:["inherit","initial","paused","running","unset"]},"-webkit-animation-timing-function":{alias:true,inherited:false,supports:256,values:["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-webkit-text-size-adjust":{alias:true,inherited:true,supports:0,values:["auto","inherit","initial","none","unset"]},"-webkit-transform":{alias:true,inherited:false,supports:0,values:["inherit","initial","unset"]},"-webkit-transform-origin":{alias:true,inherited:false,supports:3,values:["inherit","initial","unset"]},"-webkit-transform-style":{alias:true,inherited:false,supports:0,values:["flat","inherit","initial","preserve-3d","unset"]},"-webkit-backface-visibility":{alias:true,inherited:false,supports:0,values:["hidden","inherit","initial","unset","visible"]},"-webkit-perspective":{alias:true,inherited:false,supports:1,values:["inherit","initial","none","unset"]},"-webkit-perspective-origin":{alias:true,inherited:false,supports:3,values:["inherit","initial","unset"]},"-webkit-transition":{alias:true,subproperties:["transition-property","transition-duration","transition-timing-function","transition-delay"],inherited:false,supports:320,values:["all","cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","none","step-end","step-start","steps","unset"]},"-webkit-transition-delay":{alias:true,inherited:false,supports:64,values:["inherit","initial","unset"]},"-webkit-transition-duration":{alias:true,inherited:false,supports:64,values:["inherit","initial","unset"]},"-webkit-transition-property":{alias:true,inherited:false,supports:0,values:["all","inherit","initial","none","unset"]},"-webkit-transition-timing-function":{alias:true,inherited:false,supports:256,values:["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-webkit-border-radius":{alias:true,subproperties:["border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius"],inherited:false,supports:3,values:["inherit","initial","unset"]},"-webkit-border-top-left-radius":{alias:true,inherited:false,supports:3,values:["inherit","initial","unset"]},"-webkit-border-top-right-radius":{alias:true,inherited:false,supports:3,values:["inherit","initial","unset"]},"-webkit-border-bottom-left-radius":{alias:true,inherited:false,supports:3,values:["inherit","initial","unset"]},"-webkit-border-bottom-right-radius":{alias:true,inherited:false,supports:3,values:["inherit","initial","unset"]},"-webkit-appearance":{alias:true,inherited:false,supports:0,values:["-moz-gtk-info-bar","-moz-mac-disclosure-button-closed","-moz-mac-disclosure-button-open","-moz-mac-fullscreen-button","-moz-mac-help-button","-moz-mac-vibrancy-dark","-moz-mac-vibrancy-light","-moz-win-borderless-glass","-moz-win-browsertabbar-toolbox","-moz-win-communications-toolbox","-moz-win-exclude-glass","-moz-win-glass","-moz-win-media-toolbox","-moz-window-button-box","-moz-window-button-box-maximized","-moz-window-button-close","-moz-window-button-maximize","-moz-window-button-minimize","-moz-window-button-restore","-moz-window-frame-bottom","-moz-window-frame-left","-moz-window-frame-right","-moz-window-titlebar","-moz-window-titlebar-maximized","button","button-arrow-down","button-arrow-next","button-arrow-previous","button-arrow-up","button-bevel","button-focus","caret","checkbox","checkbox-container","checkbox-label","checkmenuitem","dialog","dualbutton","groupbox","inherit","initial","listbox","listitem","menuarrow","menubar","menucheckbox","menuimage","menuitem","menuitemtext","menulist","menulist-button","menulist-text","menulist-textfield","menupopup","menuradio","menuseparator","meterbar","meterchunk","none","number-input","progressbar","progressbar-vertical","progresschunk","progresschunk-vertical","radio","radio-container","radio-label","radiomenuitem","range","range-thumb","resizer","resizerpanel","scale-horizontal","scale-vertical","scalethumb-horizontal","scalethumb-vertical","scalethumbend","scalethumbstart","scalethumbtick","scrollbar","scrollbar-small","scrollbarbutton-down","scrollbarbutton-left","scrollbarbutton-right","scrollbarbutton-up","scrollbarthumb-horizontal","scrollbarthumb-vertical","scrollbartrack-horizontal","scrollbartrack-vertical","searchfield","separator","spinner","spinner-downbutton","spinner-textfield","spinner-upbutton","splitter","statusbar","statusbarpanel","tab","tab-scroll-arrow-back","tab-scroll-arrow-forward","tabpanel","tabpanels","textfield","textfield-multiline","toolbar","toolbarbutton","toolbarbutton-dropdown","toolbargripper","toolbox","tooltip","treeheader","treeheadercell","treeheadersortarrow","treeitem","treeline","treetwisty","treetwistyopen","treeview","unset","window"]},"-webkit-background-clip":{alias:true,inherited:false,supports:0,values:["border-box","content-box","inherit","initial","padding-box","unset"]},"-webkit-background-origin":{alias:true,inherited:false,supports:0,values:["border-box","content-box","inherit","initial","padding-box","unset"]},"-webkit-background-size":{alias:true,inherited:false,supports:3,values:["inherit","initial","unset"]},"-webkit-border-image":{alias:true,subproperties:["border-image-source","border-image-slice","border-image-width","border-image-outset","border-image-repeat"],inherited:false,supports:1675,values:["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"-webkit-border-image-outset":{alias:true,inherited:false,supports:1025,values:["inherit","initial","unset"]},"-webkit-border-image-repeat":{alias:true,inherited:false,supports:0,values:["inherit","initial","unset"]},"-webkit-border-image-slice":{alias:true,inherited:false,supports:1026,values:["inherit","initial","unset"]},"-webkit-border-image-source":{alias:true,inherited:false,supports:648,values:["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"-webkit-border-image-width":{alias:true,inherited:false,supports:1027,values:["inherit","initial","unset"]},"-webkit-box-shadow":{alias:true,inherited:false,supports:5,values:["inherit","initial","unset"]},"-webkit-box-sizing":{alias:true,inherited:false,supports:0,values:["border-box","content-box","inherit","initial","padding-box","unset"]},"-webkit-box-flex":{alias:true,inherited:false,supports:1024,values:["inherit","initial","unset"]},"-webkit-box-ordinal-group":{alias:true,inherited:false,supports:1024,values:["inherit","initial","unset"]},"-webkit-box-align":{alias:true,inherited:false,supports:0,values:["inherit","initial","unset"]},"-webkit-box-pack":{alias:true,inherited:false,supports:0,values:["inherit","initial","unset"]},"-webkit-user-select":{alias:true,inherited:false,supports:0,values:["-moz-all","-moz-none","-moz-text","all","auto","element","elements","inherit","initial","none","text","toggle","tri-state","unset"]}};module.exports = {cssProperties};

/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/Promise.jsm
	 */

	/**
	 * Promise.jsm is mostly the Promise web API with a `defer` method. Just drop this in here,
	 * and use the native web API (although building with webpack/babel, it may replace this
	 * with it's own version if we want to target environments that do not have `Promise`.
	 */
	Promise.defer = function defer() {
	  var resolve, reject;
	  var promise = new Promise(function () {
	    resolve = arguments[0];
	    reject = arguments[1];
	  });
	  return {
	    resolve: resolve,
	    reject: reject,
	    promise: promise
	  };
	};

	module.exports = Promise;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * EventEmitter.
	 */

	var EventEmitter = function EventEmitter() {};
	module.exports = EventEmitter;

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;

	const promise = __webpack_require__(6);

	/**
	 * Decorate an object with event emitter functionality.
	 *
	 * @param Object aObjectToDecorate
	 *        Bind all public methods of EventEmitter to
	 *        the aObjectToDecorate object.
	 */
	EventEmitter.decorate = function EventEmitter_decorate(aObjectToDecorate) {
	  let emitter = new EventEmitter();
	  aObjectToDecorate.on = emitter.on.bind(emitter);
	  aObjectToDecorate.off = emitter.off.bind(emitter);
	  aObjectToDecorate.once = emitter.once.bind(emitter);
	  aObjectToDecorate.emit = emitter.emit.bind(emitter);
	};

	EventEmitter.prototype = {
	  /**
	   * Connect a listener.
	   *
	   * @param string aEvent
	   *        The event name to which we're connecting.
	   * @param function aListener
	   *        Called when the event is fired.
	   */
	  on: function EventEmitter_on(aEvent, aListener) {
	    if (!this._eventEmitterListeners) this._eventEmitterListeners = new Map();
	    if (!this._eventEmitterListeners.has(aEvent)) {
	      this._eventEmitterListeners.set(aEvent, []);
	    }
	    this._eventEmitterListeners.get(aEvent).push(aListener);
	  },

	  /**
	   * Listen for the next time an event is fired.
	   *
	   * @param string aEvent
	   *        The event name to which we're connecting.
	   * @param function aListener
	   *        (Optional) Called when the event is fired. Will be called at most
	   *        one time.
	   * @return promise
	   *        A promise which is resolved when the event next happens. The
	   *        resolution value of the promise is the first event argument. If
	   *        you need access to second or subsequent event arguments (it's rare
	   *        that this is needed) then use aListener
	   */
	  once: function EventEmitter_once(aEvent, aListener) {
	    var _this = this;

	    let deferred = promise.defer();

	    let handler = function (aEvent, aFirstArg, ...aRest) {
	      _this.off(aEvent, handler);
	      if (aListener) {
	        aListener.apply(null, [aEvent, aFirstArg, ...aRest]);
	      }
	      deferred.resolve(aFirstArg);
	    };

	    handler._originalListener = aListener;
	    this.on(aEvent, handler);

	    return deferred.promise;
	  },

	  /**
	   * Remove a previously-registered event listener.  Works for events
	   * registered with either on or once.
	   *
	   * @param string aEvent
	   *        The event name whose listener we're disconnecting.
	   * @param function aListener
	   *        The listener to remove.
	   */
	  off: function EventEmitter_off(aEvent, aListener) {
	    if (!this._eventEmitterListeners) return;
	    let listeners = this._eventEmitterListeners.get(aEvent);
	    if (listeners) {
	      this._eventEmitterListeners.set(aEvent, listeners.filter(function (l) {
	        return l !== aListener && l._originalListener !== aListener;
	      }));
	    }
	  },

	  /**
	   * Emit an event.  All arguments to this method will
	   * be sent to listener functions.
	   */
	  emit: function EventEmitter_emit(aEvent) {
	    if (!this._eventEmitterListeners || !this._eventEmitterListeners.has(aEvent)) {
	      return;
	    }

	    let originalListeners = this._eventEmitterListeners.get(aEvent);
	    for (let listener of this._eventEmitterListeners.get(aEvent)) {
	      // If the object was destroyed during event emission, stop
	      // emitting.
	      if (!this._eventEmitterListeners) {
	        break;
	      }

	      // If listeners were removed during emission, make sure the
	      // event handler we're going to fire wasn't removed.
	      if (originalListeners === this._eventEmitterListeners.get(aEvent) || this._eventEmitterListeners.get(aEvent).some(function (l) {
	        return l === listener;
	      })) {
	        try {
	          listener.apply(null, arguments);
	        } catch (ex) {
	          // Prevent a bad listener from interfering with the others.
	          let msg = ex + ": " + ex.stack;
	          Cu.reportError(msg);
	          dump(msg + "\n");
	        }
	      }
	    }
	  }
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Telemetry.
	 *
	 * To add metrics for a tool:
	 *
	 * 1. Create boolean, flag and exponential entries in
	 *    toolkit/components/telemetry/Histograms.json. Each type is optional but it
	 *    is best if all three can be included.
	 *
	 * 2. Add your chart entries to devtools/client/shared/telemetry.js
	 *    (Telemetry.prototype._histograms):
	 *    mytoolname: {
	 *      histogram: "DEVTOOLS_MYTOOLNAME_OPENED_BOOLEAN",
	 *      userHistogram: "DEVTOOLS_MYTOOLNAME_OPENED_PER_USER_FLAG",
	 *      timerHistogram: "DEVTOOLS_MYTOOLNAME_TIME_ACTIVE_SECONDS"
	 *    },
	 *
	 * 3. Include this module at the top of your tool. Use:
	 *      let Telemetry = require("devtools/client/shared/telemetry")
	 *
	 * 4. Create a telemetry instance in your tool's constructor:
	 *      this._telemetry = new Telemetry();
	 *
	 * 5. When your tool is opened call:
	 *      this._telemetry.toolOpened("mytoolname");
	 *
	 * 6. When your tool is closed call:
	 *      this._telemetry.toolClosed("mytoolname");
	 *
	 * Note:
	 * You can view telemetry stats for your local Firefox instance via
	 * about:telemetry.
	 *
	 * You can view telemetry stats for large groups of Firefox users at
	 * telemetry.mozilla.org.
	 */

	const TOOLS_OPENED_PREF = "devtools.telemetry.tools.opened.version";

	var Telemetry = function () {
	  // Bind pretty much all functions so that callers do not need to.
	  this.toolOpened = this.toolOpened.bind(this);
	  this.toolClosed = this.toolClosed.bind(this);
	  this.log = this.log.bind(this);
	  this.logOncePerBrowserVersion = this.logOncePerBrowserVersion.bind(this);
	  this.destroy = this.destroy.bind(this);

	  this._timers = new Map();
	};

	module.exports = Telemetry;

	var _require = __webpack_require__(1);

	var Cc = _require.Cc;
	var Ci = _require.Ci;
	var Cu = _require.Cu;

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	var _require3 = __webpack_require__(15);

	const XPCOMUtils = _require3.XPCOMUtils;

	Telemetry.prototype = {
	  _histograms: {
	    toolbox: {
	      histogram: "DEVTOOLS_TOOLBOX_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_TOOLBOX_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_TOOLBOX_TIME_ACTIVE_SECONDS"
	    },
	    options: {
	      histogram: "DEVTOOLS_OPTIONS_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_OPTIONS_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_OPTIONS_TIME_ACTIVE_SECONDS"
	    },
	    webconsole: {
	      histogram: "DEVTOOLS_WEBCONSOLE_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_WEBCONSOLE_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_WEBCONSOLE_TIME_ACTIVE_SECONDS"
	    },
	    browserconsole: {
	      histogram: "DEVTOOLS_BROWSERCONSOLE_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_BROWSERCONSOLE_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_BROWSERCONSOLE_TIME_ACTIVE_SECONDS"
	    },
	    inspector: {
	      histogram: "DEVTOOLS_INSPECTOR_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_INSPECTOR_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_INSPECTOR_TIME_ACTIVE_SECONDS"
	    },
	    ruleview: {
	      histogram: "DEVTOOLS_RULEVIEW_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_RULEVIEW_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_RULEVIEW_TIME_ACTIVE_SECONDS"
	    },
	    computedview: {
	      histogram: "DEVTOOLS_COMPUTEDVIEW_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_COMPUTEDVIEW_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_COMPUTEDVIEW_TIME_ACTIVE_SECONDS"
	    },
	    layoutview: {
	      histogram: "DEVTOOLS_LAYOUTVIEW_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_LAYOUTVIEW_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_LAYOUTVIEW_TIME_ACTIVE_SECONDS"
	    },
	    fontinspector: {
	      histogram: "DEVTOOLS_FONTINSPECTOR_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_FONTINSPECTOR_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_FONTINSPECTOR_TIME_ACTIVE_SECONDS"
	    },
	    animationinspector: {
	      histogram: "DEVTOOLS_ANIMATIONINSPECTOR_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_ANIMATIONINSPECTOR_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_ANIMATIONINSPECTOR_TIME_ACTIVE_SECONDS"
	    },
	    jsdebugger: {
	      histogram: "DEVTOOLS_JSDEBUGGER_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_JSDEBUGGER_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_JSDEBUGGER_TIME_ACTIVE_SECONDS"
	    },
	    jsbrowserdebugger: {
	      histogram: "DEVTOOLS_JSBROWSERDEBUGGER_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_JSBROWSERDEBUGGER_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_JSBROWSERDEBUGGER_TIME_ACTIVE_SECONDS"
	    },
	    styleeditor: {
	      histogram: "DEVTOOLS_STYLEEDITOR_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_STYLEEDITOR_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_STYLEEDITOR_TIME_ACTIVE_SECONDS"
	    },
	    shadereditor: {
	      histogram: "DEVTOOLS_SHADEREDITOR_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_SHADEREDITOR_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_SHADEREDITOR_TIME_ACTIVE_SECONDS"
	    },
	    webaudioeditor: {
	      histogram: "DEVTOOLS_WEBAUDIOEDITOR_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_WEBAUDIOEDITOR_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_WEBAUDIOEDITOR_TIME_ACTIVE_SECONDS"
	    },
	    canvasdebugger: {
	      histogram: "DEVTOOLS_CANVASDEBUGGER_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_CANVASDEBUGGER_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_CANVASDEBUGGER_TIME_ACTIVE_SECONDS"
	    },
	    performance: {
	      histogram: "DEVTOOLS_JSPROFILER_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_JSPROFILER_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_JSPROFILER_TIME_ACTIVE_SECONDS"
	    },
	    netmonitor: {
	      histogram: "DEVTOOLS_NETMONITOR_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_NETMONITOR_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_NETMONITOR_TIME_ACTIVE_SECONDS"
	    },
	    storage: {
	      histogram: "DEVTOOLS_STORAGE_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_STORAGE_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_STORAGE_TIME_ACTIVE_SECONDS"
	    },
	    tilt: {
	      histogram: "DEVTOOLS_TILT_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_TILT_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_TILT_TIME_ACTIVE_SECONDS"
	    },
	    paintflashing: {
	      histogram: "DEVTOOLS_PAINTFLASHING_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_PAINTFLASHING_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_PAINTFLASHING_TIME_ACTIVE_SECONDS"
	    },
	    scratchpad: {
	      histogram: "DEVTOOLS_SCRATCHPAD_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_SCRATCHPAD_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_SCRATCHPAD_TIME_ACTIVE_SECONDS"
	    },
	    responsive: {
	      histogram: "DEVTOOLS_RESPONSIVE_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_RESPONSIVE_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_RESPONSIVE_TIME_ACTIVE_SECONDS"
	    },
	    eyedropper: {
	      histogram: "DEVTOOLS_EYEDROPPER_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_EYEDROPPER_OPENED_PER_USER_FLAG"
	    },
	    menueyedropper: {
	      histogram: "DEVTOOLS_MENU_EYEDROPPER_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_MENU_EYEDROPPER_OPENED_PER_USER_FLAG"
	    },
	    pickereyedropper: {
	      histogram: "DEVTOOLS_PICKER_EYEDROPPER_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_PICKER_EYEDROPPER_OPENED_PER_USER_FLAG"
	    },
	    developertoolbar: {
	      histogram: "DEVTOOLS_DEVELOPERTOOLBAR_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_DEVELOPERTOOLBAR_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_DEVELOPERTOOLBAR_TIME_ACTIVE_SECONDS"
	    },
	    aboutdebugging: {
	      histogram: "DEVTOOLS_ABOUTDEBUGGING_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_ABOUTDEBUGGING_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_ABOUTDEBUGGING_TIME_ACTIVE_SECONDS"
	    },
	    webide: {
	      histogram: "DEVTOOLS_WEBIDE_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_WEBIDE_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_WEBIDE_TIME_ACTIVE_SECONDS"
	    },
	    webideProjectEditor: {
	      histogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_TIME_ACTIVE_SECONDS"
	    },
	    webideProjectEditorSave: {
	      histogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_SAVE_BOOLEAN",
	      userHistogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_SAVE_PER_USER_FLAG"
	    },
	    webideNewProject: {
	      histogram: "DEVTOOLS_WEBIDE_NEW_PROJECT_BOOLEAN",
	      userHistogram: "DEVTOOLS_WEBIDE_NEW_PROJECT_PER_USER_FLAG"
	    },
	    webideImportProject: {
	      histogram: "DEVTOOLS_WEBIDE_IMPORT_PROJECT_BOOLEAN",
	      userHistogram: "DEVTOOLS_WEBIDE_IMPORT_PROJECT_PER_USER_FLAG"
	    },
	    custom: {
	      histogram: "DEVTOOLS_CUSTOM_OPENED_BOOLEAN",
	      userHistogram: "DEVTOOLS_CUSTOM_OPENED_PER_USER_FLAG",
	      timerHistogram: "DEVTOOLS_CUSTOM_TIME_ACTIVE_SECONDS"
	    }
	  },

	  /**
	   * Add an entry to a histogram.
	   *
	   * @param  {String} id
	   *         Used to look up the relevant histogram ID and log true to that
	   *         histogram.
	   */
	  toolOpened: function (id) {
	    let charts = this._histograms[id] || this._histograms.custom;

	    if (charts.histogram) {
	      this.log(charts.histogram, true);
	    }
	    if (charts.userHistogram) {
	      this.logOncePerBrowserVersion(charts.userHistogram, true);
	    }
	    if (charts.timerHistogram) {
	      this.startTimer(charts.timerHistogram);
	    }
	  },

	  /**
	   * Record that an action occurred.  Aliases to `toolOpened`, so it's just for
	   * readability at the call site for cases where we aren't actually opening
	   * tools.
	   */
	  actionOccurred(id) {
	    this.toolOpened(id);
	  },

	  toolClosed: function (id) {
	    let charts = this._histograms[id];

	    if (!charts || !charts.timerHistogram) {
	      return;
	    }

	    this.stopTimer(charts.timerHistogram);
	  },

	  /**
	   * Record the start time for a timing-based histogram entry.
	   *
	   * @param String histogramId
	   *        Histogram in which the data is to be stored.
	   */
	  startTimer: function (histogramId) {
	    this._timers.set(histogramId, new Date());
	  },

	  /**
	   * Stop the timer and log elasped time for a timing-based histogram entry.
	   *
	   * @param String histogramId
	   *        Histogram in which the data is to be stored.
	   * @param String key [optional]
	   *        Optional key for a keyed histogram.
	   */
	  stopTimer: function (histogramId, key) {
	    let startTime = this._timers.get(histogramId);
	    if (startTime) {
	      let time = (new Date() - startTime) / 1000;
	      if (!key) {
	        this.log(histogramId, time);
	      } else {
	        this.logKeyed(histogramId, key, time);
	      }
	      this._timers.delete(histogramId);
	    }
	  },

	  /**
	   * Log a value to a histogram.
	   *
	   * @param  {String} histogramId
	   *         Histogram in which the data is to be stored.
	   * @param  value
	   *         Value to store.
	   */
	  log: function (histogramId, value) {
	    if (histogramId) {
	      try {
	        // let histogram = Services.telemetry.getHistogramById(histogramId);
	        histogram.add(value);
	      } catch (e) {
	        dump("Warning: An attempt was made to write to the " + histogramId + " histogram, which is not defined in Histograms.json\n");
	      }
	    }
	  },

	  /**
	   * Log a value to a keyed histogram.
	   *
	   * @param  {String} histogramId
	   *         Histogram in which the data is to be stored.
	   * @param  {String} key
	   *         The key within the single histogram.
	   * @param  value
	   *         Value to store.
	   */
	  logKeyed: function (histogramId, key, value) {
	    if (histogramId) {
	      try {
	        // let histogram = Services.telemetry.getKeyedHistogramById(histogramId);
	        histogram.add(key, value);
	      } catch (e) {
	        dump("Warning: An attempt was made to write to the " + histogramId + " histogram, which is not defined in Histograms.json\n");
	      }
	    }
	  },

	  /**
	   * Log info about usage once per browser version. This allows us to discover
	   * how many individual users are using our tools for each browser version.
	   *
	   * @param  {String} perUserHistogram
	   *         Histogram in which the data is to be stored.
	   */
	  logOncePerBrowserVersion: function (perUserHistogram, value) {
	    return;
	    let currentVersion = appInfo.version;
	    let latest = Services.prefs.getCharPref(TOOLS_OPENED_PREF);
	    let latestObj = JSON.parse(latest);

	    let lastVersionHistogramUpdated = latestObj[perUserHistogram];

	    if (typeof lastVersionHistogramUpdated == "undefined" || lastVersionHistogramUpdated !== currentVersion) {
	      latestObj[perUserHistogram] = currentVersion;
	      latest = JSON.stringify(latestObj);
	      Services.prefs.setCharPref(TOOLS_OPENED_PREF, latest);
	      this.log(perUserHistogram, value);
	    }
	  },

	  destroy: function () {
	    for (let histogramId of this._timers.keys()) {
	      this.stopTimer(histogramId);
	    }
	  }
	};

	XPCOMUtils.defineLazyGetter(this, "appInfo", function () {
	  return Cc("@mozilla.org/xre/app-info;1").getService(Ci.nsIXULAppInfo);
	});

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {"use strict";

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/Services.jsm
	 */

	const L10N = __webpack_require__(12);
	const Services = {};

	Services.strings = {
	  createBundle: function (name) {
	    if (typeof name !== "object") {
	      throw new Error(`Cannot implement 'Services.strings.createBundle'. Use 'new L10N(require(${ name }))' instead, or call this with the return value of a require, like 'Services.strings.createBundle(require(${ name }))'.`);
	    }
	    return new L10N(name);
	  }
	};

	Services.appinfo = {
	  OS: 'Darwin' };

	// Probably
	Services.telemetry = {
	  getHistogramById() {
	    return {
	      add() {}
	    };
	  }
	};

	Services.obs = {
	  addObserver: function () {},
	  removeObserver: function () {}
	};
	Services.prefs = __webpack_require__(13);

	Services.tm = {
	  currentThread: {
	    dispatch: function (cb) {
	      setImmediate(cb);
	    }
	  },
	  mainThread: {
	    dispatch: function (cb) {
	      setImmediate(cb);
	    }
	  }
	};

	Services.scriptloader = {
	  /**
	   * Implements a subset of loadSubScript, to inject scripts into a window, rather
	   * than an arbitrary scope.
	   * @see https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/mozIJSSubScriptLoader#loadSubScript%28%29
	   */
	  loadSubScript: function (url, target, charset = "utf8") {
	    // Only implement scenario where target has reference to a document
	    if (!target || !target.document) {
	      throw new Error(`target in loadSubScript does not have a document.`);
	    }
	    return new Promise(function (resolve) {
	      let script = target.document.createElement("script");
	      script.src = url;
	      script.onload = resolve;
	      target.document.body.appendChild(script);
	    });
	  }
	};

	module.exports.Services = Services;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).setImmediate))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(11).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).setImmediate, __webpack_require__(10).clearImmediate))

/***/ },
/* 11 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Import a .properties file via properties-loader (just specify .properties) and pass
	 * that object into this constructor to get methods matching nsIStringBundle:
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIStringBundle
	 */

	function L10N(props) {
	  this.props = props;
	}

	L10N.prototype.GetStringFromName = function (name) {
	  return this.props[name];
	};

	L10N.prototype.formatStringFromName = function (name, values) {
	  var result = this.GetStringFromName(name);

	  for (var i = 0; i < values.length; i++) {
	    result = result.replace(/%S/, values[i]);
	  }

	  return result;
	};

	module.exports = L10N;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	let DEFAULTS = __webpack_require__(14);
	// TODO Can make this localStorage or something in the future?
	let storage = JSON.parse(JSON.stringify(DEFAULTS));

	const PREF_INVALID = exports.PREF_INVALID = 0;
	const PREF_STRING = exports.PREF_STRING = 32;
	const PREF_INT = exports.PREF_INT = 64;
	const PREF_BOOL = exports.PREF_BOOL = 128;

	/**
	 * Returns a `Pref` object containing the following properties:
	 *
	 * `value` - The primitive value of the stored preference.
	 * `type` - The enum type of the pref. Can be PREF_INVALID, PREF_STRING, PREF_INT, or PREF_BOOL.
	 */
	function findPref(pref) {
	  let branchNames = pref.split(".");
	  let branch = storage;

	  for (let branchName of branchNames) {
	    branch = branch[branchName];
	    if (!branch) {
	      branch = {};
	    }
	  }

	  return branch;
	}

	function setPrefValue(pref, value) {
	  let obj = findPref(pref);
	  obj.value = value;
	}

	function getPrefValue(pref) {
	  return findPref(pref).value;
	}

	const addObserver = exports.addObserver = function (domain, observer, holdWeak) {
	  console.error("TODO implement addObserver");
	};

	const removeObserver = exports.removeObserver = function (domain, observer, holdWeak) {
	  console.error("TODO implement removeObserver");
	};

	const resetPrefs = exports.resetPrefs = function () {
	  storage = JSON.parse(JSON.stringify(DEFAULTS));
	};

	const getPrefType = exports.getPrefType = function (pref) {
	  return findPref(pref).type;
	};

	const setBoolPref = exports.setBoolPref = function (pref, value) {
	  if (typeof value !== "boolean") {
	    throw new Error("Cannot setBoolPref without a boolean.");
	  }
	  if (getPrefType(pref) && getPrefType(pref) !== PREF_BOOL) {
	    throw new Error("Can only call setBoolPref on boolean type prefs.");
	  }
	  setPrefValue(pref, value);
	};

	exports.setCharPref = function (pref, value) {
	  if (typeof value !== "string") {
	    throw new Error("Cannot setCharPref without a string.");
	  }
	  if (getPrefType(pref) && getPrefType(pref) !== PREF_STRING) {
	    throw new Error("Can only call setCharPref on string type prefs.");
	  }
	  setPrefValue(pref, value);
	};

	exports.setIntPref = function (pref, value) {
	  if (typeof value !== "number" && parseInt(value) !== value) {
	    throw new Error("Cannot setCharPref without an integer.");
	  }
	  if (getPrefType(pref) && getPrefType(pref) !== PREF_INT) {
	    throw new Error("Can only call setIntPref on number type prefs.");
	  }
	  setPrefValue(pref, value);
	};

	exports.getBoolPref = function (pref) {
	  if (getPrefType(pref) !== PREF_BOOL) {
	    throw new Error("Can only call getBoolPref on boolean type prefs.");
	  }
	  return getPrefValue(pref);
	};

	exports.getCharPref = function (pref) {
	  if (getPrefType(pref) !== PREF_STRING) {
	    throw new Error("Can only call getCharPref on string type prefs.");
	  }
	  return getPrefValue(pref);
	};

	exports.getIntPref = function (pref) {
	  if (getPrefType(pref) !== PREF_INT) {
	    throw new Error("Can only call getIntPref on number type prefs.");
	  }
	  return getPrefValue(pref);
	};

	exports.getComplexValue = function (pref) {
	  // XXX: Implement me
	  return {
	    data: ''
	  };
	};

	exports.getBranch = function (pref) {
	  return {
	    addObserver: function () {},
	    removeObserver: function () {}
	  };
	};

	exports.prefHasUserValue = function (pref) {
	  // XXX: Implement me
	  return false;
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = {
		"devtools": {
			"devedition": {
				"promo": {
					"shown": {
						"value": false,
						"type": 128
					},
					"url": {
						"value": "https://www.mozilla.org/firefox/developer/?utm_source=firefox-dev-tools&utm_medium=firefox-browser&utm_content=betadoorhanger",
						"type": 32
					},
					"enabled": {
						"value": false,
						"type": 128
					}
				}
			},
			"errorconsole": {
				"enabled": {
					"value": false,
					"type": 128
				}
			},
			"toolbar": {
				"enabled": {
					"value": true,
					"type": 128
				},
				"visible": {
					"value": false,
					"type": 128
				}
			},
			"webide": {
				"enabled": {
					"value": true,
					"type": 128
				}
			},
			"toolbox": {
				"footer": {
					"height": {
						"value": 250,
						"type": 64
					}
				},
				"sidebar": {
					"width": {
						"value": 500,
						"type": 64
					}
				},
				"host": {
					"value": "bottom",
					"type": 32
				},
				"previousHost": {
					"value": "side",
					"type": 32
				},
				"selectedTool": {
					"value": "webconsole",
					"type": 32
				},
				"toolbarSpec": {
					"value": "[\"splitconsole\", \"paintflashing toggle\",\"tilt toggle\",\"scratchpad\",\"resize toggle\",\"eyedropper\",\"screenshot --fullpage\", \"rulers\", \"measure\"]",
					"type": 32
				},
				"sideEnabled": {
					"value": true,
					"type": 128
				},
				"zoomValue": {
					"value": "1",
					"type": 32
				},
				"splitconsoleEnabled": {
					"value": false,
					"type": 128
				},
				"splitconsoleHeight": {
					"value": 100,
					"type": 64
				}
			},
			"inspector": {
				"enabled": {
					"value": true,
					"type": 128
				},
				"activeSidebar": {
					"value": "ruleview",
					"type": 32
				},
				"remote": {
					"value": false,
					"type": 128
				},
				"show_pseudo_elements": {
					"value": false,
					"type": 128
				},
				"imagePreviewTooltipSize": {
					"value": 300,
					"type": 64
				},
				"showUserAgentStyles": {
					"value": false,
					"type": 128
				},
				"showAllAnonymousContent": {
					"value": false,
					"type": 128
				},
				"mdnDocsTooltip": {
					"enabled": {
						"value": true,
						"type": 128
					}
				}
			},
			"defaultColorUnit": {
				"value": "authored",
				"type": 32
			},
			"debugger": {
				"enabled": {
					"value": true,
					"type": 128
				},
				"workers": {
					"value": false,
					"type": 128
				},
				"promise": {
					"value": false,
					"type": 128
				},
				"source-maps-enabled": {
					"value": false,
					"type": 128
				},
				"auto-black-box": {
					"value": false,
					"type": 128
				}
			},
			"memory": {
				"enabled": {
					"value": false,
					"type": 128
				}
			},
			"performance": {
				"enabled": {
					"value": true,
					"type": 128
				},
				"ui": {
					"experimental": {
						"value": false,
						"type": 128
					}
				}
			},
			"cache": {
				"disabled": {
					"value": false,
					"type": 128
				}
			},
			"serviceWorkers": {
				"testing": {
					"enabled": {
						"value": false,
						"type": 128
					}
				}
			},
			"netmonitor": {
				"enabled": {
					"value": true,
					"type": 128
				},
				"statistics": {
					"value": true,
					"type": 128
				},
				"filters": {
					"value": "[\"all\"]",
					"type": 32
				},
				"har": {
					"defaultLogDir": {
						"value": "",
						"type": 32
					},
					"defaultFileName": {
						"value": "Archive %y-%m-%d %H-%M-%S",
						"type": 32
					},
					"jsonp": {
						"value": false,
						"type": 128
					},
					"jsonpCallback": {
						"value": "",
						"type": 32
					},
					"includeResponseBodies": {
						"value": true,
						"type": 128
					},
					"compress": {
						"value": false,
						"type": 128
					},
					"forceExport": {
						"value": false,
						"type": 128
					},
					"pageLoadedTimeout": {
						"value": 1500,
						"type": 64
					},
					"enableAutoExportToFile": {
						"value": false,
						"type": 128
					}
				}
			},
			"tilt": {
				"enabled": {
					"value": true,
					"type": 128
				},
				"intro_transition": {
					"value": true,
					"type": 128
				},
				"outro_transition": {
					"value": true,
					"type": 128
				}
			},
			"scratchpad": {
				"recentFilesMax": {
					"value": 10,
					"type": 64
				},
				"lineNumbers": {
					"value": true,
					"type": 128
				},
				"wrapText": {
					"value": false,
					"type": 128
				},
				"showTrailingSpace": {
					"value": false,
					"type": 128
				},
				"editorFontSize": {
					"value": 12,
					"type": 64
				},
				"enableAutocompletion": {
					"value": true,
					"type": 128
				}
			},
			"storage": {
				"enabled": {
					"value": false,
					"type": 128
				}
			},
			"styleeditor": {
				"enabled": {
					"value": true,
					"type": 128
				},
				"showMediaSidebar": {
					"value": true,
					"type": 128
				},
				"mediaSidebarWidth": {
					"value": 238,
					"type": 64
				},
				"navSidebarWidth": {
					"value": 245,
					"type": 64
				},
				"transitions": {
					"value": true,
					"type": 128
				}
			},
			"shadereditor": {
				"enabled": {
					"value": false,
					"type": 128
				}
			},
			"canvasdebugger": {
				"enabled": {
					"value": false,
					"type": 128
				}
			},
			"webaudioeditor": {
				"enabled": {
					"value": false,
					"type": 128
				},
				"inspectorWidth": {
					"value": 300,
					"type": 64
				}
			},
			"webconsole": {
				"filter": {
					"network": {
						"value": true,
						"type": 128
					},
					"networkinfo": {
						"value": false,
						"type": 128
					},
					"netwarn": {
						"value": true,
						"type": 128
					},
					"netxhr": {
						"value": false,
						"type": 128
					},
					"csserror": {
						"value": true,
						"type": 128
					},
					"cssparser": {
						"value": false,
						"type": 128
					},
					"csslog": {
						"value": false,
						"type": 128
					},
					"exception": {
						"value": true,
						"type": 128
					},
					"jswarn": {
						"value": true,
						"type": 128
					},
					"jslog": {
						"value": false,
						"type": 128
					},
					"error": {
						"value": true,
						"type": 128
					},
					"warn": {
						"value": true,
						"type": 128
					},
					"info": {
						"value": true,
						"type": 128
					},
					"log": {
						"value": true,
						"type": 128
					},
					"secerror": {
						"value": true,
						"type": 128
					},
					"secwarn": {
						"value": true,
						"type": 128
					},
					"serviceworkers": {
						"value": true,
						"type": 128
					},
					"sharedworkers": {
						"value": false,
						"type": 128
					},
					"windowlessworkers": {
						"value": false,
						"type": 128
					},
					"servererror": {
						"value": false,
						"type": 128
					},
					"serverwarn": {
						"value": false,
						"type": 128
					},
					"serverinfo": {
						"value": false,
						"type": 128
					},
					"serverlog": {
						"value": false,
						"type": 128
					}
				},
				"fontSize": {
					"value": 0,
					"type": 64
				},
				"inputHistoryCount": {
					"value": 50,
					"type": 64
				},
				"persistlog": {
					"value": false,
					"type": 128
				},
				"timestampMessages": {
					"value": false,
					"type": 128
				}
			},
			"browserconsole": {
				"filter": {
					"network": {
						"value": true,
						"type": 128
					},
					"networkinfo": {
						"value": false,
						"type": 128
					},
					"netwarn": {
						"value": true,
						"type": 128
					},
					"netxhr": {
						"value": false,
						"type": 128
					},
					"csserror": {
						"value": true,
						"type": 128
					},
					"cssparser": {
						"value": false,
						"type": 128
					},
					"csslog": {
						"value": false,
						"type": 128
					},
					"exception": {
						"value": true,
						"type": 128
					},
					"jswarn": {
						"value": true,
						"type": 128
					},
					"jslog": {
						"value": true,
						"type": 128
					},
					"error": {
						"value": true,
						"type": 128
					},
					"warn": {
						"value": true,
						"type": 128
					},
					"info": {
						"value": true,
						"type": 128
					},
					"log": {
						"value": true,
						"type": 128
					},
					"secerror": {
						"value": true,
						"type": 128
					},
					"secwarn": {
						"value": true,
						"type": 128
					},
					"serviceworkers": {
						"value": true,
						"type": 128
					},
					"sharedworkers": {
						"value": true,
						"type": 128
					},
					"windowlessworkers": {
						"value": true,
						"type": 128
					},
					"servererror": {
						"value": false,
						"type": 128
					},
					"serverwarn": {
						"value": false,
						"type": 128
					},
					"serverinfo": {
						"value": false,
						"type": 128
					},
					"serverlog": {
						"value": false,
						"type": 128
					}
				}
			},
			"hud": {
				"loglimit": {
					"network": {
						"value": 1000,
						"type": 64
					},
					"cssparser": {
						"value": 1000,
						"type": 64
					},
					"exception": {
						"value": 1000,
						"type": 64
					},
					"console": {
						"value": 1000,
						"type": 64
					}
				}
			},
			"eyedropper": {
				"zoom": {
					"value": 6,
					"type": 64
				}
			},
			"editor": {
				"tabsize": {
					"value": 2,
					"type": 64
				},
				"expandtab": {
					"value": true,
					"type": 128
				},
				"keymap": {
					"value": "default",
					"type": 32
				},
				"autoclosebrackets": {
					"value": true,
					"type": 128
				},
				"detectindentation": {
					"value": true,
					"type": 128
				},
				"enableCodeFolding": {
					"value": true,
					"type": 128
				},
				"autocomplete": {
					"value": true,
					"type": 128
				}
			},
			"fontinspector": {
				"enabled": {
					"value": true,
					"type": 128
				}
			},
			"telemetry": {
				"tools": {
					"opened": {
						"version": {
							"value": "{}",
							"type": 32
						}
					}
				}
			},
			"jsonview": {
				"enabled": {
					"value": false,
					"type": 128
				}
			}
		}
	};

/***/ },
/* 15 */
/***/ function(module, exports) {

	"use strict";

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/js/xpconnect/loader/XPCOMUtils.jsm
	 */

	const XPCOMUtils = {
	  defineLazyGetter: loader.lazyGetter,
	  defineLazyImporter: loader.lazyImporter,
	  defineLazyServiceGetter: loader.lazyServiceGetter,
	  generateQI: function () {}
	};

	exports.XPCOMUtils = XPCOMUtils;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var _require = __webpack_require__(15);

	const XPCOMUtils = _require.XPCOMUtils;

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	const promise = __webpack_require__(6);
	// Load target and toolbox lazily as they need gDevTools to be fully initialized

	var _require3 = __webpack_require__(17);

	const TargetFactory = _require3.TargetFactory;
	// const { Toolbox } = require("devtools/client/framework/toolbox");

	//XPCOMUtils.defineLazyModuleGetter(this, "CustomizableUI",
	//                                  "resource:///modules/CustomizableUI.jsm");
	// const { DebuggerServer } = require("devtools/server/main");
	// const { DebuggerClient } = require("devtools/shared/client/main");

	var _require4 = __webpack_require__(29);

	const DefaultTools = _require4.defaultTools;
	const DefaultThemes = _require4.defaultThemes;

	const EventEmitter = __webpack_require__(7);
	const Telemetry = __webpack_require__(8);
	// const {JsonView} = require("devtools/client/jsonview/main");

	const TABS_OPEN_PEAK_HISTOGRAM = "DEVTOOLS_TABS_OPEN_PEAK_LINEAR";
	const TABS_OPEN_AVG_HISTOGRAM = "DEVTOOLS_TABS_OPEN_AVERAGE_LINEAR";
	const TABS_PINNED_PEAK_HISTOGRAM = "DEVTOOLS_TABS_PINNED_PEAK_LINEAR";
	const TABS_PINNED_AVG_HISTOGRAM = "DEVTOOLS_TABS_PINNED_AVERAGE_LINEAR";

	const FORBIDDEN_IDS = new Set(["toolbox", ""]);
	const MAX_ORDINAL = 99;

	const bundle = Services.strings.createBundle(__webpack_require__(92));

	/**
	 * DevTools is a class that represents a set of developer tools, it holds a
	 * set of tools and keeps track of open toolboxes in the browser.
	 */
	var DevTools = function DevTools() {
	  this._tools = new Map(); // Map<toolId, tool>
	  this._themes = new Map(); // Map<themeId, theme>
	  this._toolboxes = new Map(); // Map<target, toolbox>
	  this._telemetry = new Telemetry();

	  // destroy() is an observer's handler so we need to preserve context.
	  this.destroy = this.destroy.bind(this);
	  this._teardown = this._teardown.bind(this);

	  // JSON Viewer for 'application/json' documents.
	  // JsonView.initialize();

	  EventEmitter.decorate(this);

	  Services.obs.addObserver(this._teardown, "devtools-unloaded", false);
	  Services.obs.addObserver(this.destroy, "quit-application", false);
	};

	DevTools.prototype = {
	  /**
	   * Register a new developer tool.
	   *
	   * A definition is a light object that holds different information about a
	   * developer tool. This object is not supposed to have any operational code.
	   * See it as a "manifest".
	   * The only actual code lives in the build() function, which will be used to
	   * start an instance of this tool.
	   *
	   * Each toolDefinition has the following properties:
	   * - id: Unique identifier for this tool (string|required)
	   * - visibilityswitch: Property name to allow us to hide this tool from the
	   *                     DevTools Toolbox.
	   *                     A falsy value indicates that it cannot be hidden.
	   * - icon: URL pointing to a graphic which will be used as the src for an
	   *         16x16 img tag (string|required)
	   * - invertIconForLightTheme: The icon can automatically have an inversion
	   *         filter applied (default is false).  All builtin tools are true, but
	   *         addons may omit this to prevent unwanted changes to the `icon`
	   *         image. filter: invert(1) is applied to the image (boolean|optional)
	   * - url: URL pointing to a XUL/XHTML document containing the user interface
	   *        (string|required)
	   * - label: Localized name for the tool to be displayed to the user
	   *          (string|required)
	   * - hideInOptions: Boolean indicating whether or not this tool should be
	                      shown in toolbox options or not. Defaults to false.
	   *                  (boolean)
	   * - build: Function that takes an iframe, which has been populated with the
	   *          markup from |url|, and also the toolbox containing the panel.
	   *          And returns an instance of ToolPanel (function|required)
	   */
	  registerTool: function DT_registerTool(toolDefinition) {
	    let toolId = toolDefinition.id;

	    if (!toolId || FORBIDDEN_IDS.has(toolId)) {
	      throw new Error("Invalid definition.id");
	    }

	    // Make sure that additional tools will always be able to be hidden.
	    // When being called from main.js, defaultTools has not yet been exported.
	    // But, we can assume that in this case, it is a default tool.
	    if (DefaultTools && DefaultTools.indexOf(toolDefinition) == -1) {
	      toolDefinition.visibilityswitch = "devtools." + toolId + ".enabled";
	    }

	    this._tools.set(toolId, toolDefinition);

	    this.emit("tool-registered", toolId);
	  },

	  /**
	   * Removes all tools that match the given |toolId|
	   * Needed so that add-ons can remove themselves when they are deactivated
	   *
	   * @param {string|object} tool
	   *        Definition or the id of the tool to unregister. Passing the
	   *        tool id should be avoided as it is a temporary measure.
	   * @param {boolean} isQuitApplication
	   *        true to indicate that the call is due to app quit, so we should not
	   *        cause a cascade of costly events
	   */
	  unregisterTool: function DT_unregisterTool(tool, isQuitApplication) {
	    let toolId = null;
	    if (typeof tool == "string") {
	      toolId = tool;
	      tool = this._tools.get(tool);
	    } else {
	      toolId = tool.id;
	    }
	    this._tools.delete(toolId);

	    if (!isQuitApplication) {
	      this.emit("tool-unregistered", tool);
	    }
	  },

	  /**
	   * Sorting function used for sorting tools based on their ordinals.
	   */
	  ordinalSort: function DT_ordinalSort(d1, d2) {
	    let o1 = typeof d1.ordinal == "number" ? d1.ordinal : MAX_ORDINAL;
	    let o2 = typeof d2.ordinal == "number" ? d2.ordinal : MAX_ORDINAL;
	    return o1 - o2;
	  },

	  getDefaultTools: function DT_getDefaultTools() {
	    return DefaultTools.sort(this.ordinalSort);
	  },

	  getAdditionalTools: function DT_getAdditionalTools() {
	    let tools = [];
	    for (let _ref of this._tools) {
	      var _ref2 = _slicedToArray(_ref, 2);

	      let key = _ref2[0];
	      let value = _ref2[1];

	      if (DefaultTools.indexOf(value) == -1) {
	        tools.push(value);
	      }
	    }
	    return tools.sort(this.ordinalSort);
	  },

	  /**
	   * Get a tool definition if it exists and is enabled.
	   *
	   * @param {string} toolId
	   *        The id of the tool to show
	   *
	   * @return {ToolDefinition|null} tool
	   *         The ToolDefinition for the id or null.
	   */
	  getToolDefinition: function DT_getToolDefinition(toolId) {
	    let tool = this._tools.get(toolId);
	    if (!tool) {
	      return null;
	    } else if (!tool.visibilityswitch) {
	      return tool;
	    }

	    let enabled;
	    try {
	      enabled = Services.prefs.getBoolPref(tool.visibilityswitch);
	    } catch (e) {
	      enabled = true;
	    }

	    return enabled ? tool : null;
	  },

	  /**
	   * Allow ToolBoxes to get at the list of tools that they should populate
	   * themselves with.
	   *
	   * @return {Map} tools
	   *         A map of the the tool definitions registered in this instance
	   */
	  getToolDefinitionMap: function DT_getToolDefinitionMap() {
	    let tools = new Map();

	    for (let _ref3 of this._tools) {
	      var _ref4 = _slicedToArray(_ref3, 2);

	      let id = _ref4[0];
	      let definition = _ref4[1];

	      if (this.getToolDefinition(id)) {
	        tools.set(id, definition);
	      }
	    }

	    return tools;
	  },

	  /**
	   * Tools have an inherent ordering that can't be represented in a Map so
	   * getToolDefinitionArray provides an alternative representation of the
	   * definitions sorted by ordinal value.
	   *
	   * @return {Array} tools
	   *         A sorted array of the tool definitions registered in this instance
	   */
	  getToolDefinitionArray: function DT_getToolDefinitionArray() {
	    let definitions = [];

	    for (let _ref5 of this._tools) {
	      var _ref6 = _slicedToArray(_ref5, 2);

	      let id = _ref6[0];
	      let definition = _ref6[1];

	      if (this.getToolDefinition(id)) {
	        definitions.push(definition);
	      }
	    }

	    return definitions.sort(this.ordinalSort);
	  },

	  /**
	   * Register a new theme for developer tools toolbox.
	   *
	   * A definition is a light object that holds various information about a
	   * theme.
	   *
	   * Each themeDefinition has the following properties:
	   * - id: Unique identifier for this theme (string|required)
	   * - label: Localized name for the theme to be displayed to the user
	   *          (string|required)
	   * - stylesheets: Array of URLs pointing to a CSS document(s) containing
	   *                the theme style rules (array|required)
	   * - classList: Array of class names identifying the theme within a document.
	   *              These names are set to document element when applying
	   *              the theme (array|required)
	   * - onApply: Function that is executed by the framework when the theme
	   *            is applied. The function takes the current iframe window
	   *            and the previous theme id as arguments (function)
	   * - onUnapply: Function that is executed by the framework when the theme
	   *            is unapplied. The function takes the current iframe window
	   *            and the new theme id as arguments (function)
	   */
	  registerTheme: function DT_registerTheme(themeDefinition) {
	    let themeId = themeDefinition.id;

	    if (!themeId) {
	      throw new Error("Invalid theme id");
	    }

	    if (this._themes.get(themeId)) {
	      throw new Error("Theme with the same id is already registered");
	    }

	    this._themes.set(themeId, themeDefinition);

	    this.emit("theme-registered", themeId);
	  },

	  /**
	   * Removes an existing theme from the list of registered themes.
	   * Needed so that add-ons can remove themselves when they are deactivated
	   *
	   * @param {string|object} theme
	   *        Definition or the id of the theme to unregister.
	   */
	  unregisterTheme: function DT_unregisterTheme(theme) {
	    let themeId = null;
	    if (typeof theme == "string") {
	      themeId = theme;
	      theme = this._themes.get(theme);
	    } else {
	      themeId = theme.id;
	    }

	    let currTheme = Services.prefs.getCharPref("devtools.theme");

	    // Note that we can't check if `theme` is an item
	    // of `DefaultThemes` as we end up reloading definitions
	    // module and end up with different theme objects
	    let isCoreTheme = DefaultThemes.some(function (t) {
	      return t.id === themeId;
	    });

	    // Reset the theme if an extension theme that's currently applied
	    // is being removed.
	    // Ignore shutdown since addons get disabled during that time.
	    if (!Services.startup.shuttingDown && !isCoreTheme && theme.id == currTheme) {
	      Services.prefs.setCharPref("devtools.theme", "light");

	      let data = {
	        pref: "devtools.theme",
	        newValue: "light",
	        oldValue: currTheme
	      };

	      gDevTools.emit("pref-changed", data);

	      this.emit("theme-unregistered", theme);
	    }

	    this._themes.delete(themeId);
	  },

	  /**
	   * Get a theme definition if it exists.
	   *
	   * @param {string} themeId
	   *        The id of the theme
	   *
	   * @return {ThemeDefinition|null} theme
	   *         The ThemeDefinition for the id or null.
	   */
	  getThemeDefinition: function DT_getThemeDefinition(themeId) {
	    let theme = this._themes.get(themeId);
	    if (!theme) {
	      return null;
	    }
	    return theme;
	  },

	  /**
	   * Get map of registered themes.
	   *
	   * @return {Map} themes
	   *         A map of the the theme definitions registered in this instance
	   */
	  getThemeDefinitionMap: function DT_getThemeDefinitionMap() {
	    let themes = new Map();

	    for (let _ref7 of this._themes) {
	      var _ref8 = _slicedToArray(_ref7, 2);

	      let id = _ref8[0];
	      let definition = _ref8[1];

	      if (this.getThemeDefinition(id)) {
	        themes.set(id, definition);
	      }
	    }

	    return themes;
	  },

	  /**
	   * Get registered themes definitions sorted by ordinal value.
	   *
	   * @return {Array} themes
	   *         A sorted array of the theme definitions registered in this instance
	   */
	  getThemeDefinitionArray: function DT_getThemeDefinitionArray() {
	    let definitions = [];

	    for (let _ref9 of this._themes) {
	      var _ref10 = _slicedToArray(_ref9, 2);

	      let id = _ref10[0];
	      let definition = _ref10[1];

	      if (this.getThemeDefinition(id)) {
	        definitions.push(definition);
	      }
	    }

	    return definitions.sort(this.ordinalSort);
	  },

	  /**
	   * Show a Toolbox for a target (either by creating a new one, or if a toolbox
	   * already exists for the target, by bring to the front the existing one)
	   * If |toolId| is specified then the displayed toolbox will have the
	   * specified tool selected.
	   * If |hostType| is specified then the toolbox will be displayed using the
	   * specified HostType.
	   *
	   * @param {Target} target
	   *         The target the toolbox will debug
	   * @param {string} toolId
	   *        The id of the tool to show
	   * @param {Toolbox.HostType} hostType
	   *        The type of host (bottom, window, side)
	   * @param {object} hostOptions
	   *        Options for host specifically
	   *
	   * @return {Toolbox} toolbox
	   *        The toolbox that was opened
	   */
	  showToolbox: function (target, toolId, hostType, hostOptions) {
	    var _this = this;

	    let deferred = promise.defer();

	    let toolbox = this._toolboxes.get(target);
	    if (toolbox) {

	      let hostPromise = hostType != null && toolbox.hostType != hostType ? toolbox.switchHost(hostType) : promise.resolve(null);

	      if (toolId != null && toolbox.currentToolId != toolId) {
	        hostPromise = hostPromise.then(function () {
	          return toolbox.selectTool(toolId);
	        });
	      }

	      return hostPromise.then(function () {
	        toolbox.raise();
	        return toolbox;
	      });
	    } else {
	      // No toolbox for target, create one
	      toolbox = new Toolbox(target, toolId, hostType, hostOptions);

	      this.emit("toolbox-created", toolbox);

	      this._toolboxes.set(target, toolbox);

	      toolbox.once("destroy", function () {
	        _this.emit("toolbox-destroy", target);
	      });

	      toolbox.once("destroyed", function () {
	        _this._toolboxes.delete(target);
	        _this.emit("toolbox-destroyed", target);
	      });

	      // If toolId was passed in, it will already be selected before the
	      // open promise resolves.
	      toolbox.open().then(function () {
	        deferred.resolve(toolbox);
	        _this.emit("toolbox-ready", toolbox);
	      });
	    }

	    return deferred.promise;
	  },

	  /**
	   * Return the toolbox for a given target.
	   *
	   * @param  {object} target
	   *         Target value e.g. the target that owns this toolbox
	   *
	   * @return {Toolbox} toolbox
	   *         The toolbox that is debugging the given target
	   */
	  getToolbox: function DT_getToolbox(target) {
	    return this._toolboxes.get(target);
	  },

	  /**
	   * Close the toolbox for a given target
	   *
	   * @return promise
	   *         This promise will resolve to false if no toolbox was found
	   *         associated to the target. true, if the toolbox was successfully
	   *         closed.
	   */
	  closeToolbox: function DT_closeToolbox(target) {
	    let toolbox = this._toolboxes.get(target);
	    if (toolbox == null) {
	      return promise.resolve(false);
	    }
	    return toolbox.destroy().then(function () {
	      return true;
	    });
	  },

	  _pingTelemetry: function () {
	    let mean = function (arr) {
	      if (arr.length === 0) {
	        return 0;
	      }

	      let total = arr.reduce(function (a, b) {
	        return a + b;
	      });
	      return Math.ceil(total / arr.length);
	    };

	    let tabStats = gDevToolsBrowser._tabStats;
	    this._telemetry.log(TABS_OPEN_PEAK_HISTOGRAM, tabStats.peakOpen);
	    this._telemetry.log(TABS_OPEN_AVG_HISTOGRAM, mean(tabStats.histOpen));
	    this._telemetry.log(TABS_PINNED_PEAK_HISTOGRAM, tabStats.peakPinned);
	    this._telemetry.log(TABS_PINNED_AVG_HISTOGRAM, mean(tabStats.histPinned));
	  },

	  /**
	   * Called to tear down a tools provider.
	   */
	  _teardown: function DT_teardown() {
	    for (let _ref11 of this._toolboxes) {
	      var _ref12 = _slicedToArray(_ref11, 2);

	      let target = _ref12[0];
	      let toolbox = _ref12[1];

	      toolbox.destroy();
	    }
	  },

	  /**
	   * All browser windows have been closed, tidy up remaining objects.
	   */
	  destroy: function () {
	    Services.obs.removeObserver(this.destroy, "quit-application");
	    Services.obs.removeObserver(this._teardown, "devtools-unloaded");

	    for (let _ref13 of this.getToolDefinitionMap()) {
	      var _ref14 = _slicedToArray(_ref13, 2);

	      let key = _ref14[0];
	      let tool = _ref14[1];

	      this.unregisterTool(key, true);
	    }

	    // JsonView.destroy();

	    this._pingTelemetry();
	    this._telemetry = null;

	    // Cleaning down the toolboxes: i.e.
	    //   for (let [target, toolbox] of this._toolboxes) toolbox.destroy();
	    // Is taken care of by the gDevToolsBrowser.forgetBrowserWindow
	  },

	  /**
	   * Iterator that yields each of the toolboxes.
	   */
	  *[Symbol.iterator]() {
	    for (let toolbox of this._toolboxes) {
	      yield toolbox;
	    }
	  }
	};

	/**
	 * gDevTools is a singleton that controls the Firefox Developer Tools.
	 *
	 * It is an instance of a DevTools class that holds a set of tools. It has the
	 * same lifetime as the browser.
	 */
	var gDevTools = new DevTools();
	var gDevTools = gDevTools;

	/**
	 * gDevToolsBrowser exposes functions to connect the gDevTools instance with a
	 * Firefox instance.
	 */
	var gDevToolsBrowser = {
	  /**
	   * A record of the windows whose menus we altered, so we can undo the changes
	   * as the window is closed
	   */
	  _trackedBrowserWindows: new Set(),

	  _tabStats: {
	    peakOpen: 0,
	    peakPinned: 0,
	    histOpen: [],
	    histPinned: []
	  },

	  /**
	   * This function is for the benefit of Tools:DevToolbox in
	   * browser/base/content/browser-sets.inc and should not be used outside
	   * of there
	   */
	  toggleToolboxCommand: function (gBrowser) {
	    let target = TargetFactory.forTab(gBrowser.selectedTab);
	    let toolbox = gDevTools.getToolbox(target);

	    // If a toolbox exists, using toggle from the Main window :
	    // - should close a docked toolbox
	    // - should focus a windowed toolbox
	    let isDocked = toolbox && toolbox.hostType != Toolbox.HostType.WINDOW;
	    isDocked ? toolbox.destroy() : gDevTools.showToolbox(target);
	  },

	  /**
	   * This function ensures the right commands are enabled in a window,
	   * depending on their relevant prefs. It gets run when a window is registered,
	   * or when any of the devtools prefs change.
	   */
	  updateCommandAvailability: function (win) {
	    let doc = win.document;

	    function toggleCmd(id, isEnabled) {
	      let cmd = doc.getElementById(id);
	      if (isEnabled) {
	        cmd.removeAttribute("disabled");
	        cmd.removeAttribute("hidden");
	      } else {
	        cmd.setAttribute("disabled", "true");
	        cmd.setAttribute("hidden", "true");
	      }
	    };

	    // Enable developer toolbar?
	    let devToolbarEnabled = Services.prefs.getBoolPref("devtools.toolbar.enabled");
	    toggleCmd("Tools:DevToolbar", devToolbarEnabled);
	    let focusEl = doc.getElementById("Tools:DevToolbarFocus");
	    if (devToolbarEnabled) {
	      focusEl.removeAttribute("disabled");
	    } else {
	      focusEl.setAttribute("disabled", "true");
	    }
	    if (devToolbarEnabled && Services.prefs.getBoolPref("devtools.toolbar.visible")) {
	      win.DeveloperToolbar.show(false).catch(console.error);
	    }

	    // Enable WebIDE?
	    let webIDEEnabled = Services.prefs.getBoolPref("devtools.webide.enabled");
	    toggleCmd("Tools:WebIDE", webIDEEnabled);

	    let showWebIDEWidget = Services.prefs.getBoolPref("devtools.webide.widget.enabled");
	    if (webIDEEnabled && showWebIDEWidget) {
	      gDevToolsBrowser.installWebIDEWidget();
	    } else {
	      gDevToolsBrowser.uninstallWebIDEWidget();
	    }

	    // Enable Browser Toolbox?
	    let chromeEnabled = Services.prefs.getBoolPref("devtools.chrome.enabled");
	    let devtoolsRemoteEnabled = Services.prefs.getBoolPref("devtools.debugger.remote-enabled");
	    let remoteEnabled = chromeEnabled && devtoolsRemoteEnabled;
	    toggleCmd("Tools:BrowserToolbox", remoteEnabled);
	    toggleCmd("Tools:BrowserContentToolbox", remoteEnabled && win.gMultiProcessBrowser);

	    // Enable Error Console?
	    let consoleEnabled = Services.prefs.getBoolPref("devtools.errorconsole.enabled");
	    toggleCmd("Tools:ErrorConsole", consoleEnabled);

	    // Enable DevTools connection screen, if the preference allows this.
	    toggleCmd("Tools:DevToolsConnect", devtoolsRemoteEnabled);
	  },

	  observe: function (subject, topic, prefName) {
	    if (prefName.endsWith("enabled")) {
	      for (let win of this._trackedBrowserWindows) {
	        this.updateCommandAvailability(win);
	      }
	    }
	  },

	  _prefObserverRegistered: false,

	  ensurePrefObserver: function () {
	    if (!this._prefObserverRegistered) {
	      this._prefObserverRegistered = true;
	      Services.prefs.addObserver("devtools.", this, false);
	    }
	  },

	  /**
	   * This function is for the benefit of Tools:{toolId} commands,
	   * triggered from the WebDeveloper menu and keyboard shortcuts.
	   *
	   * selectToolCommand's behavior:
	   * - if the toolbox is closed,
	   *   we open the toolbox and select the tool
	   * - if the toolbox is open, and the targeted tool is not selected,
	   *   we select it
	   * - if the toolbox is open, and the targeted tool is selected,
	   *   and the host is NOT a window, we close the toolbox
	   * - if the toolbox is open, and the targeted tool is selected,
	   *   and the host is a window, we raise the toolbox window
	   */
	  selectToolCommand: function (gBrowser, toolId) {
	    let target = TargetFactory.forTab(gBrowser.selectedTab);
	    let toolbox = gDevTools.getToolbox(target);
	    let toolDefinition = gDevTools.getToolDefinition(toolId);

	    if (toolbox && (toolbox.currentToolId == toolId || toolId == "webconsole" && toolbox.splitConsole)) {
	      toolbox.fireCustomKey(toolId);

	      if (toolDefinition.preventClosingOnKey || toolbox.hostType == Toolbox.HostType.WINDOW) {
	        toolbox.raise();
	      } else {
	        toolbox.destroy();
	      }
	      gDevTools.emit("select-tool-command", toolId);
	    } else {
	      gDevTools.showToolbox(target, toolId).then(function () {
	        let target = TargetFactory.forTab(gBrowser.selectedTab);
	        let toolbox = gDevTools.getToolbox(target);

	        toolbox.fireCustomKey(toolId);
	        gDevTools.emit("select-tool-command", toolId);
	      });
	    }
	  },

	  /**
	   * Open a tab to allow connects to a remote browser
	   */
	  openConnectScreen: function (gBrowser) {
	    gBrowser.selectedTab = gBrowser.addTab("chrome://devtools/content/framework/connect/connect.xhtml");
	  },

	  /**
	   * Open WebIDE
	   */
	  openWebIDE: function () {
	    let win = Services.wm.getMostRecentWindow("devtools:webide");
	    if (win) {
	      win.focus();
	    } else {
	      Services.ww.openWindow(null, "chrome://webide/content/", "webide", "chrome,centerscreen,resizable", null);
	    }
	  },

	  _getContentProcessTarget: function () {
	    // Create a DebuggerServer in order to connect locally to it
	    if (!DebuggerServer.initialized) {
	      DebuggerServer.init();
	      DebuggerServer.addBrowserActors();
	    }
	    DebuggerServer.allowChromeProcess = true;

	    let transport = DebuggerServer.connectPipe();
	    let client = new DebuggerClient(transport);

	    let deferred = promise.defer();
	    client.connect(function () {
	      client.mainRoot.listProcesses(function (response) {
	        // Do nothing if there is only one process, the parent process.
	        let contentProcesses = response.processes.filter(function (p) {
	          return !p.parent;
	        });
	        if (contentProcesses.length < 1) {
	          let msg = bundle.GetStringFromName("toolbox.noContentProcess.message");
	          Services.prompt.alert(null, "", msg);
	          deferred.reject("No content processes available.");
	          return;
	        }
	        // Otherwise, arbitrary connect to the unique content process.
	        client.getProcess(contentProcesses[0].id).then(function (response) {
	          let options = {
	            form: response.form,
	            client: client,
	            chrome: true,
	            isTabActor: false
	          };
	          return TargetFactory.forRemoteTab(options);
	        }).then(function (target) {
	          // Ensure closing the connection in order to cleanup
	          // the debugger client and also the server created in the
	          // content process
	          target.on("close", function () {
	            client.close();
	          });
	          deferred.resolve(target);
	        });
	      });
	    });

	    return deferred.promise;
	  },

	  openContentProcessToolbox: function () {
	    this._getContentProcessTarget().then(function (target) {
	      // Display a new toolbox, in a new window, with debugger by default
	      return gDevTools.showToolbox(target, "jsdebugger", Toolbox.HostType.WINDOW);
	    });
	  },

	  /**
	   * Install WebIDE widget
	   */
	  installWebIDEWidget: function () {
	    //    if (this.isWebIDEWidgetInstalled()) {
	    //      return;
	    //    }
	    //
	    //    let defaultArea;
	    //    if (Services.prefs.getBoolPref("devtools.webide.widget.inNavbarByDefault")) {
	    //      defaultArea = CustomizableUI.AREA_NAVBAR;
	    //    } else {
	    //      defaultArea = CustomizableUI.AREA_PANEL;
	    //    }
	    //
	    //    CustomizableUI.createWidget({
	    //      id: "webide-button",
	    //      shortcutId: "key_webide",
	    //      label: "devtools-webide-button2.label",
	    //      tooltiptext: "devtools-webide-button2.tooltiptext",
	    //      defaultArea: defaultArea,
	    //      onCommand: function(aEvent) {
	    //        gDevToolsBrowser.openWebIDE();
	    //      }
	    //    });
	  },

	  isWebIDEWidgetInstalled: function () {
	    return false;
	    //    let widgetWrapper = CustomizableUI.getWidget("webide-button");
	    //    return !!(widgetWrapper && widgetWrapper.provider == CustomizableUI.PROVIDER_API);
	  },

	  /**
	   * The deferred promise will be resolved by WebIDE's UI.init()
	   */
	  isWebIDEInitialized: promise.defer(),

	  /**
	   * Uninstall WebIDE widget
	   */
	  uninstallWebIDEWidget: function () {
	    //    if (this.isWebIDEWidgetInstalled()) {
	    //      CustomizableUI.removeWidgetFromArea("webide-button");
	    //    }
	    //    CustomizableUI.destroyWidget("webide-button");
	  },

	  /**
	   * Move WebIDE widget to the navbar
	   */
	  moveWebIDEWidgetInNavbar: function () {
	    //    CustomizableUI.addWidgetToArea("webide-button", CustomizableUI.AREA_NAVBAR);
	  },

	  /**
	   * Add this DevTools's presence to a browser window's document
	   *
	   * @param {XULDocument} doc
	   *        The document to which menuitems and handlers are to be added
	   */
	  registerBrowserWindow: function DT_registerBrowserWindow(win) {
	    this.updateCommandAvailability(win);
	    this.ensurePrefObserver();
	    gDevToolsBrowser._trackedBrowserWindows.add(win);
	    gDevToolsBrowser._addAllToolsToMenu(win.document);

	    if (this._isFirebugInstalled()) {
	      let broadcaster = win.document.getElementById("devtoolsMenuBroadcaster_DevToolbox");
	      broadcaster.removeAttribute("key");
	    }

	    let tabContainer = win.document.getElementById("tabbrowser-tabs");
	    tabContainer.addEventListener("TabSelect", this, false);
	    tabContainer.addEventListener("TabOpen", this, false);
	    tabContainer.addEventListener("TabClose", this, false);
	    tabContainer.addEventListener("TabPinned", this, false);
	    tabContainer.addEventListener("TabUnpinned", this, false);
	  },

	  /**
	   * Add a <key> to <keyset id="devtoolsKeyset">.
	   * Appending a <key> element is not always enough. The <keyset> needs
	   * to be detached and reattached to make sure the <key> is taken into
	   * account (see bug 832984).
	   *
	   * @param {XULDocument} doc
	   *        The document to which keys are to be added
	   * @param {XULElement} or {DocumentFragment} keys
	   *        Keys to add
	   */
	  attachKeybindingsToBrowser: function DT_attachKeybindingsToBrowser(doc, keys) {
	    let devtoolsKeyset = doc.getElementById("devtoolsKeyset");

	    if (!devtoolsKeyset) {
	      devtoolsKeyset = doc.createElement("keyset");
	      devtoolsKeyset.setAttribute("id", "devtoolsKeyset");
	    }
	    devtoolsKeyset.appendChild(keys);
	    let mainKeyset = doc.getElementById("mainKeyset");
	    mainKeyset.parentNode.insertBefore(devtoolsKeyset, mainKeyset);
	  },

	  /**
	   * Hook the JS debugger tool to the "Debug Script" button of the slow script
	   * dialog.
	   */
	  setSlowScriptDebugHandler: function DT_setSlowScriptDebugHandler() {
	    // let debugService = Cc("@mozilla.org/dom/slow-script-debug;1")
	    //                      .getService(Ci.nsISlowScriptDebug);
	    // let tm = Cc("@mozilla.org/thread-manager;1").getService(Ci.nsIThreadManager);

	    // function slowScriptDebugHandler(aTab, aCallback) {
	    //   let target = TargetFactory.forTab(aTab);

	    //   gDevTools.showToolbox(target, "jsdebugger").then(toolbox => {
	    //     let threadClient = toolbox.getCurrentPanel().panelWin.gThreadClient;

	    //     // Break in place, which means resuming the debuggee thread and pausing
	    //     // right before the next step happens.
	    //     switch (threadClient.state) {
	    //       case "paused":
	    //         // When the debugger is already paused.
	    //         threadClient.resumeThenPause();
	    //         aCallback();
	    //         break;
	    //       case "attached":
	    //         // When the debugger is already open.
	    //         threadClient.interrupt(() => {
	    //           threadClient.resumeThenPause();
	    //           aCallback();
	    //         });
	    //         break;
	    //       case "resuming":
	    //         // The debugger is newly opened.
	    //         threadClient.addOneTimeListener("resumed", () => {
	    //           threadClient.interrupt(() => {
	    //             threadClient.resumeThenPause();
	    //             aCallback();
	    //           });
	    //         });
	    //         break;
	    //       default:
	    //         throw Error("invalid thread client state in slow script debug handler: " +
	    //                     threadClient.state);
	    //       }
	    //   });
	    // }

	    // debugService.activationHandler = function(aWindow) {
	    //   let chromeWindow = aWindow.QueryInterface(Ci.nsIInterfaceRequestor)
	    //                             .getInterface(Ci.nsIWebNavigation)
	    //                             .QueryInterface(Ci.nsIDocShellTreeItem)
	    //                             .rootTreeItem
	    //                             .QueryInterface(Ci.nsIInterfaceRequestor)
	    //                             .getInterface(Ci.nsIDOMWindow)
	    //                             .QueryInterface(Ci.nsIDOMChromeWindow);

	    //   let setupFinished = false;
	    //   slowScriptDebugHandler(chromeWindow.gBrowser.selectedTab,
	    //                          () => { setupFinished = true; });

	    //   // Don't return from the interrupt handler until the debugger is brought
	    //   // up; no reason to continue executing the slow script.
	    //   let utils = aWindow.QueryInterface(Ci.nsIInterfaceRequestor)
	    //                      .getInterface(Ci.nsIDOMWindowUtils);
	    //   utils.enterModalState();
	    //   while (!setupFinished) {
	    //     tm.currentThread.processNextEvent(true);
	    //   }
	    //   utils.leaveModalState();
	    // };

	    // debugService.remoteActivationHandler = function(aBrowser, aCallback) {
	    //   let chromeWindow = aBrowser.ownerDocument.defaultView;
	    //   let tab = chromeWindow.gBrowser.getTabForBrowser(aBrowser);
	    //   chromeWindow.gBrowser.selected = tab;

	    //   function callback() {
	    //     aCallback.finishDebuggerStartup();
	    //   }

	    //   slowScriptDebugHandler(tab, callback);
	    // };
	  },

	  /**
	   * Unset the slow script debug handler.
	   */
	  unsetSlowScriptDebugHandler: function DT_unsetSlowScriptDebugHandler() {
	    // let debugService = Cc("@mozilla.org/dom/slow-script-debug;1")
	    //                      .getService(Ci.nsISlowScriptDebug);
	    // debugService.activationHandler = undefined;
	  },

	  /**
	   * Detect the presence of a Firebug.
	   *
	   * @return promise
	   */
	  _isFirebugInstalled: function DT_isFirebugInstalled() {
	    let bootstrappedAddons = Services.prefs.getCharPref("extensions.bootstrappedAddons");
	    return bootstrappedAddons.indexOf("firebug@software.joehewitt.com") != -1;
	  },

	  /**
	   * Add the menuitem for a tool to all open browser windows.
	   *
	   * @param {object} toolDefinition
	   *        properties of the tool to add
	   */
	  _addToolToWindows: function DT_addToolToWindows(toolDefinition) {
	    // No menu item or global shortcut is required for options panel.
	    if (!toolDefinition.inMenu) {
	      return;
	    }

	    // Skip if the tool is disabled.
	    try {
	      if (toolDefinition.visibilityswitch && !Services.prefs.getBoolPref(toolDefinition.visibilityswitch)) {
	        return;
	      }
	    } catch (e) {}

	    // We need to insert the new tool in the right place, which means knowing
	    // the tool that comes before the tool that we're trying to add
	    let allDefs = gDevTools.getToolDefinitionArray();
	    let prevDef;
	    for (let def of allDefs) {
	      if (!def.inMenu) {
	        continue;
	      }
	      if (def === toolDefinition) {
	        break;
	      }
	      prevDef = def;
	    }

	    for (let win of gDevToolsBrowser._trackedBrowserWindows) {
	      let doc = win.document;
	      let elements = gDevToolsBrowser._createToolMenuElements(toolDefinition, doc);

	      doc.getElementById("mainCommandSet").appendChild(elements.cmd);

	      if (elements.key) {
	        this.attachKeybindingsToBrowser(doc, elements.key);
	      }

	      doc.getElementById("mainBroadcasterSet").appendChild(elements.bc);

	      let amp = doc.getElementById("appmenu_webDeveloper_popup");
	      if (amp) {
	        let ref;

	        if (prevDef != null) {
	          let menuitem = doc.getElementById("appmenuitem_" + prevDef.id);
	          ref = menuitem && menuitem.nextSibling ? menuitem.nextSibling : null;
	        } else {
	          ref = doc.getElementById("appmenu_devtools_separator");
	        }

	        if (ref) {
	          amp.insertBefore(elements.appmenuitem, ref);
	        }
	      }

	      let mp = doc.getElementById("menuWebDeveloperPopup");
	      if (mp) {
	        let ref;

	        if (prevDef != null) {
	          let menuitem = doc.getElementById("menuitem_" + prevDef.id);
	          ref = menuitem && menuitem.nextSibling ? menuitem.nextSibling : null;
	        } else {
	          ref = doc.getElementById("menu_devtools_separator");
	        }

	        if (ref) {
	          mp.insertBefore(elements.menuitem, ref);
	        }
	      }
	    }

	    if (toolDefinition.id === "jsdebugger") {
	      gDevToolsBrowser.setSlowScriptDebugHandler();
	    }
	  },

	  /**
	   * Add all tools to the developer tools menu of a window.
	   *
	   * @param {XULDocument} doc
	   *        The document to which the tool items are to be added.
	   */
	  _addAllToolsToMenu: function DT_addAllToolsToMenu(doc) {
	    let fragCommands = doc.createDocumentFragment();
	    let fragKeys = doc.createDocumentFragment();
	    let fragBroadcasters = doc.createDocumentFragment();
	    let fragAppMenuItems = doc.createDocumentFragment();
	    let fragMenuItems = doc.createDocumentFragment();

	    for (let toolDefinition of gDevTools.getToolDefinitionArray()) {
	      if (!toolDefinition.inMenu) {
	        continue;
	      }

	      let elements = gDevToolsBrowser._createToolMenuElements(toolDefinition, doc);

	      if (!elements) {
	        return;
	      }

	      fragCommands.appendChild(elements.cmd);
	      if (elements.key) {
	        fragKeys.appendChild(elements.key);
	      }
	      fragBroadcasters.appendChild(elements.bc);
	      fragAppMenuItems.appendChild(elements.appmenuitem);
	      fragMenuItems.appendChild(elements.menuitem);
	    }

	    let mcs = doc.getElementById("mainCommandSet");
	    mcs.appendChild(fragCommands);

	    this.attachKeybindingsToBrowser(doc, fragKeys);

	    let mbs = doc.getElementById("mainBroadcasterSet");
	    mbs.appendChild(fragBroadcasters);

	    let amp = doc.getElementById("appmenu_webDeveloper_popup");
	    if (amp) {
	      let amps = doc.getElementById("appmenu_devtools_separator");
	      amp.insertBefore(fragAppMenuItems, amps);
	    }

	    let mp = doc.getElementById("menuWebDeveloperPopup");
	    let mps = doc.getElementById("menu_devtools_separator");
	    mp.insertBefore(fragMenuItems, mps);
	  },

	  /**
	   * Add a menu entry for a tool definition
	   *
	   * @param {string} toolDefinition
	   *        Tool definition of the tool to add a menu entry.
	   * @param {XULDocument} doc
	   *        The document to which the tool menu item is to be added.
	   */
	  _createToolMenuElements: function DT_createToolMenuElements(toolDefinition, doc) {
	    let id = toolDefinition.id;

	    // Prevent multiple entries for the same tool.
	    if (doc.getElementById("Tools:" + id)) {
	      return;
	    }

	    let cmd = doc.createElement("command");
	    cmd.id = "Tools:" + id;
	    cmd.setAttribute("oncommand", 'gDevToolsBrowser.selectToolCommand(gBrowser, "' + id + '");');

	    let key = null;
	    if (toolDefinition.key) {
	      key = doc.createElement("key");
	      key.id = "key_" + id;

	      if (toolDefinition.key.startsWith("VK_")) {
	        key.setAttribute("keycode", toolDefinition.key);
	      } else {
	        key.setAttribute("key", toolDefinition.key);
	      }

	      key.setAttribute("command", cmd.id);
	      key.setAttribute("modifiers", toolDefinition.modifiers);
	    }

	    let bc = doc.createElement("broadcaster");
	    bc.id = "devtoolsMenuBroadcaster_" + id;
	    bc.setAttribute("label", toolDefinition.menuLabel || toolDefinition.label);
	    bc.setAttribute("command", cmd.id);

	    if (key) {
	      bc.setAttribute("key", "key_" + id);
	    }

	    let appmenuitem = doc.createElement("menuitem");
	    appmenuitem.id = "appmenuitem_" + id;
	    appmenuitem.setAttribute("observes", "devtoolsMenuBroadcaster_" + id);

	    let menuitem = doc.createElement("menuitem");
	    menuitem.id = "menuitem_" + id;
	    menuitem.setAttribute("observes", "devtoolsMenuBroadcaster_" + id);

	    if (toolDefinition.accesskey) {
	      menuitem.setAttribute("accesskey", toolDefinition.accesskey);
	    }

	    return {
	      cmd: cmd,
	      key: key,
	      bc: bc,
	      appmenuitem: appmenuitem,
	      menuitem: menuitem
	    };
	  },

	  /**
	   * Update the "Toggle Tools" checkbox in the developer tools menu. This is
	   * called when a toolbox is created or destroyed.
	   */
	  _updateMenuCheckbox: function DT_updateMenuCheckbox() {
	    for (let win of gDevToolsBrowser._trackedBrowserWindows) {

	      let hasToolbox = false;
	      if (TargetFactory.isKnownTab(win.gBrowser.selectedTab)) {
	        let target = TargetFactory.forTab(win.gBrowser.selectedTab);
	        if (gDevTools._toolboxes.has(target)) {
	          hasToolbox = true;
	        }
	      }

	      let broadcaster = win.document.getElementById("devtoolsMenuBroadcaster_DevToolbox");
	      if (hasToolbox) {
	        broadcaster.setAttribute("checked", "true");
	      } else {
	        broadcaster.removeAttribute("checked");
	      }
	    }
	  },

	  /**
	   * Remove the menuitem for a tool to all open browser windows.
	   *
	   * @param {string} toolId
	   *        id of the tool to remove
	   */
	  _removeToolFromWindows: function DT_removeToolFromWindows(toolId) {
	    for (let win of gDevToolsBrowser._trackedBrowserWindows) {
	      gDevToolsBrowser._removeToolFromMenu(toolId, win.document);
	    }

	    if (toolId === "jsdebugger") {
	      gDevToolsBrowser.unsetSlowScriptDebugHandler();
	    }
	  },

	  /**
	   * Remove a tool's menuitem from a window
	   *
	   * @param {string} toolId
	   *        Id of the tool to add a menu entry for
	   * @param {XULDocument} doc
	   *        The document to which the tool menu item is to be removed from
	   */
	  _removeToolFromMenu: function DT_removeToolFromMenu(toolId, doc) {
	    let command = doc.getElementById("Tools:" + toolId);
	    if (command) {
	      command.parentNode.removeChild(command);
	    }

	    let key = doc.getElementById("key_" + toolId);
	    if (key) {
	      key.parentNode.removeChild(key);
	    }

	    let bc = doc.getElementById("devtoolsMenuBroadcaster_" + toolId);
	    if (bc) {
	      bc.parentNode.removeChild(bc);
	    }

	    let appmenuitem = doc.getElementById("appmenuitem_" + toolId);
	    if (appmenuitem) {
	      appmenuitem.parentNode.removeChild(appmenuitem);
	    }

	    let menuitem = doc.getElementById("menuitem_" + toolId);
	    if (menuitem) {
	      menuitem.parentNode.removeChild(menuitem);
	    }
	  },

	  /**
	   * Called on browser unload to remove menu entries, toolboxes and event
	   * listeners from the closed browser window.
	   *
	   * @param  {XULWindow} win
	   *         The window containing the menu entry
	   */
	  forgetBrowserWindow: function DT_forgetBrowserWindow(win) {
	    gDevToolsBrowser._trackedBrowserWindows.delete(win);

	    // Destroy toolboxes for closed window
	    for (let _ref15 of gDevTools._toolboxes) {
	      var _ref16 = _slicedToArray(_ref15, 2);

	      let target = _ref16[0];
	      let toolbox = _ref16[1];

	      if (toolbox.frame && toolbox.frame.ownerDocument.defaultView == win) {
	        toolbox.destroy();
	      }
	    }

	    let tabContainer = win.document.getElementById("tabbrowser-tabs");
	    tabContainer.removeEventListener("TabSelect", this, false);
	    tabContainer.removeEventListener("TabOpen", this, false);
	    tabContainer.removeEventListener("TabClose", this, false);
	    tabContainer.removeEventListener("TabPinned", this, false);
	    tabContainer.removeEventListener("TabUnpinned", this, false);
	  },

	  handleEvent: function (event) {
	    switch (event.type) {
	      case "TabOpen":
	      case "TabClose":
	      case "TabPinned":
	      case "TabUnpinned":
	        let open = 0;
	        let pinned = 0;

	        for (let win of this._trackedBrowserWindows) {
	          let tabContainer = win.gBrowser.tabContainer;
	          let numPinnedTabs = tabContainer.tabbrowser._numPinnedTabs;
	          let numTabs = tabContainer.itemCount - numPinnedTabs;

	          open += numTabs;
	          pinned += numPinnedTabs;
	        }

	        this._tabStats.histOpen.push(open);
	        this._tabStats.histPinned.push(pinned);
	        this._tabStats.peakOpen = Math.max(open, this._tabStats.peakOpen);
	        this._tabStats.peakPinned = Math.max(pinned, this._tabStats.peakPinned);
	        break;
	      case "TabSelect":
	        gDevToolsBrowser._updateMenuCheckbox();
	    }
	  },

	  /**
	   * All browser windows have been closed, tidy up remaining objects.
	   */
	  destroy: function () {
	    Services.prefs.removeObserver("devtools.", gDevToolsBrowser);
	    Services.obs.removeObserver(gDevToolsBrowser.destroy, "quit-application");
	  }
	};

	// this.gDevToolsBrowser = gDevToolsBrowser;

	gDevTools.on("tool-registered", function (ev, toolId) {
	  let toolDefinition = gDevTools._tools.get(toolId);
	  gDevToolsBrowser._addToolToWindows(toolDefinition);
	});

	gDevTools.on("tool-unregistered", function (ev, toolId) {
	  if (typeof toolId != "string") {
	    toolId = toolId.id;
	  }
	  gDevToolsBrowser._removeToolFromWindows(toolId);
	});

	gDevTools.on("toolbox-ready", gDevToolsBrowser._updateMenuCheckbox);
	gDevTools.on("toolbox-destroyed", gDevToolsBrowser._updateMenuCheckbox);

	Services.obs.addObserver(gDevToolsBrowser.destroy, "quit-application", false);

	// Load the browser devtools main module as the loader's main module.
	// loader.main("devtools/client/main");

	exports.gDevTools = gDevTools;
	exports.DevTools = DevTools;
	exports.gDevToolsBrowser = gDevToolsBrowser;

	DefaultTools.forEach(function (definition) {
	  return gDevTools.registerTool(definition);
	});
	DefaultThemes.forEach(function (definition) {
	  return gDevTools.registerTheme(definition);
	});

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Ci = _require.Ci;
	const Cu = _require.Cu;

	const promise = __webpack_require__(6);
	const EventEmitter = __webpack_require__(7);

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	/*const { DebuggerServer } = require("devtools/server/main");*/

	var _require3 = __webpack_require__(18);

	const DebuggerClient = _require3.DebuggerClient;

	const targets = new WeakMap();
	const promiseTargets = new WeakMap();

	/**
	 * Functions for creating Targets
	 */
	exports.TargetFactory = {
	  /**
	   * Construct a Target
	   * @param {XULTab} tab
	   *        The tab to use in creating a new target.
	   *
	   * @return A target object
	   */
	  forTab: function (tab) {
	    let target = targets.get(tab);
	    if (target == null) {
	      target = new TabTarget(tab);
	      targets.set(tab, target);
	    }
	    return target;
	  },

	  /**
	   * Return a promise of a Target for a remote tab.
	   * @param {Object} options
	   *        The options object has the following properties:
	   *        {
	   *          form: the remote protocol form of a tab,
	   *          client: a DebuggerClient instance
	   *                  (caller owns this and is responsible for closing),
	   *          chrome: true if the remote target is the whole process
	   *        }
	   *
	   * @return A promise of a target object
	   */
	  forRemoteTab: function (options) {
	    let targetPromise = promiseTargets.get(options);
	    if (targetPromise == null) {
	      let target = new TabTarget(options);
	      targetPromise = target.makeRemote().then(function () {
	        return target;
	      });
	      promiseTargets.set(options, targetPromise);
	    }
	    return targetPromise;
	  },

	  forWorker: function (workerClient) {
	    let target = targets.get(workerClient);
	    if (target == null) {
	      target = new WorkerTarget(workerClient);
	      targets.set(workerClient, target);
	    }
	    return target;
	  },

	  /**
	   * Creating a target for a tab that is being closed is a problem because it
	   * allows a leak as a result of coming after the close event which normally
	   * clears things up. This function allows us to ask if there is a known
	   * target for a tab without creating a target
	   * @return true/false
	   */
	  isKnownTab: function (tab) {
	    return targets.has(tab);
	  }
	};

	/**
	 * A Target represents something that we can debug. Targets are generally
	 * read-only. Any changes that you wish to make to a target should be done via
	 * a Tool that attaches to the target. i.e. a Target is just a pointer saying
	 * "the thing to debug is over there".
	 *
	 * Providing a generalized abstraction of a web-page or web-browser (available
	 * either locally or remotely) is beyond the scope of this class (and maybe
	 * also beyond the scope of this universe) However Target does attempt to
	 * abstract some common events and read-only properties common to many Tools.
	 *
	 * Supported read-only properties:
	 * - name, isRemote, url
	 *
	 * Target extends EventEmitter and provides support for the following events:
	 * - close: The target window has been closed. All tools attached to this
	 *          target should close. This event is not currently cancelable.
	 * - navigate: The target window has navigated to a different URL
	 *
	 * Optional events:
	 * - will-navigate: The target window will navigate to a different URL
	 * - hidden: The target is not visible anymore (for TargetTab, another tab is
	 *           selected)
	 * - visible: The target is visible (for TargetTab, tab is selected)
	 *
	 * Comparing Targets: 2 instances of a Target object can point at the same
	 * thing, so t1 !== t2 and t1 != t2 even when they represent the same object.
	 * To compare to targets use 't1.equals(t2)'.
	 */

	/**
	 * A TabTarget represents a page living in a browser tab. Generally these will
	 * be web pages served over http(s), but they don't have to be.
	 */
	function TabTarget(tab) {
	  EventEmitter.decorate(this);
	  this.destroy = this.destroy.bind(this);
	  this._handleThreadState = this._handleThreadState.bind(this);
	  this.on("thread-resumed", this._handleThreadState);
	  this.on("thread-paused", this._handleThreadState);
	  this.activeTab = this.activeConsole = null;
	  // Only real tabs need initialization here. Placeholder objects for remote
	  // targets will be initialized after a makeRemote method call.
	  if (tab && !["client", "form", "chrome"].every(tab.hasOwnProperty, tab)) {
	    this._tab = tab;
	    this._setupListeners();
	  } else {
	    this._form = tab.form;
	    this._client = tab.client;
	    this._chrome = tab.chrome;
	  }
	  // Default isTabActor to true if not explicitly specified
	  if (typeof tab.isTabActor == "boolean") {
	    this._isTabActor = tab.isTabActor;
	  } else {
	    this._isTabActor = true;
	  }
	}

	TabTarget.prototype = {
	  _webProgressListener: null,

	  /**
	   * Returns a promise for the protocol description from the root actor. Used
	   * internally with `target.actorHasMethod`. Takes advantage of caching if
	   * definition was fetched previously with the corresponding actor information.
	   * Actors are lazily loaded, so not only must the tool using a specific actor
	   * be in use, the actors are only registered after invoking a method (for
	   * performance reasons, added in bug 988237), so to use these actor detection
	   * methods, one must already be communicating with a specific actor of that
	   * type.
	   *
	   * Must be a remote target.
	   *
	   * @return {Promise}
	   * {
	   *   "category": "actor",
	   *   "typeName": "longstractor",
	   *   "methods": [{
	   *     "name": "substring",
	   *     "request": {
	   *       "type": "substring",
	   *       "start": {
	   *         "_arg": 0,
	   *         "type": "primitive"
	   *       },
	   *       "end": {
	   *         "_arg": 1,
	   *         "type": "primitive"
	   *       }
	   *     },
	   *     "response": {
	   *       "substring": {
	   *         "_retval": "primitive"
	   *       }
	   *     }
	   *   }],
	   *  "events": {}
	   * }
	   */
	  getActorDescription: function (actorName) {
	    var _this = this;

	    if (!this.client) {
	      throw new Error("TabTarget#getActorDescription() can only be called on " + "remote tabs.");
	    }

	    let deferred = promise.defer();

	    if (this._protocolDescription && this._protocolDescription.types[actorName]) {
	      deferred.resolve(this._protocolDescription.types[actorName]);
	    } else {
	      this.client.mainRoot.protocolDescription(function (description) {
	        _this._protocolDescription = description;
	        deferred.resolve(description.types[actorName]);
	      });
	    }

	    return deferred.promise;
	  },

	  /**
	   * Returns a boolean indicating whether or not the specific actor
	   * type exists. Must be a remote target.
	   *
	   * @param {String} actorName
	   * @return {Boolean}
	   */
	  hasActor: function (actorName) {
	    if (!this.client) {
	      throw new Error("TabTarget#hasActor() can only be called on remote " + "tabs.");
	    }
	    if (this.form) {
	      return !!this.form[actorName + "Actor"];
	    }
	    return false;
	  },

	  /**
	   * Queries the protocol description to see if an actor has
	   * an available method. The actor must already be lazily-loaded (read
	   * the restrictions in the `getActorDescription` comments),
	   * so this is for use inside of tool. Returns a promise that
	   * resolves to a boolean. Must be a remote target.
	   *
	   * @param {String} actorName
	   * @param {String} methodName
	   * @return {Promise}
	   */
	  actorHasMethod: function (actorName, methodName) {
	    if (!this.client) {
	      throw new Error("TabTarget#actorHasMethod() can only be called on " + "remote tabs.");
	    }
	    return this.getActorDescription(actorName).then(function (desc) {
	      if (desc && desc.methods) {
	        return !!desc.methods.find(function (method) {
	          return method.name === methodName;
	        });
	      }
	      return false;
	    });
	  },

	  /**
	   * Returns a trait from the root actor.
	   *
	   * @param {String} traitName
	   * @return {Mixed}
	   */
	  getTrait: function (traitName) {
	    if (!this.client) {
	      throw new Error("TabTarget#getTrait() can only be called on remote " + "tabs.");
	    }

	    // If the targeted actor exposes traits and has a defined value for this
	    // traits, override the root actor traits
	    if (this.form.traits && traitName in this.form.traits) {
	      return this.form.traits[traitName];
	    }

	    return this.client.traits[traitName];
	  },

	  get tab() {
	    return this._tab;
	  },

	  get form() {
	    return this._form;
	  },

	  // Get a promise of the root form returned by a listTabs request. This promise
	  // is cached.
	  get root() {
	    if (!this._root) {
	      this._root = this._getRoot();
	    }
	    return this._root;
	  },

	  _getRoot: function () {
	    var _this2 = this;

	    return new Promise(function (resolve, reject) {
	      _this2.client.listTabs(function (response) {
	        if (response.error) {
	          reject(new Error(response.error + ": " + response.message));
	          return;
	        }

	        resolve(response);
	      });
	    });
	  },

	  get client() {
	    return this._client;
	  },

	  // Tells us if we are debugging content document
	  // or if we are debugging chrome stuff.
	  // Allows to controls which features are available against
	  // a chrome or a content document.
	  get chrome() {
	    return this._chrome;
	  },

	  // Tells us if the related actor implements TabActor interface
	  // and requires to call `attach` request before being used
	  // and `detach` during cleanup
	  get isTabActor() {
	    return this._isTabActor;
	  },

	  get window() {
	    // XXX - this is a footgun for e10s - there .contentWindow will be null,
	    // and even though .contentWindowAsCPOW *might* work, it will not work
	    // in all contexts.  Consumers of .window need to be refactored to not
	    // rely on this.
	    // if (Services.appinfo.processType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT) {
	    //   Cu.reportError("The .window getter on devtools' |target| object isn't " +
	    //                  "e10s friendly!\n" + Error().stack);
	    // }
	    // Be extra careful here, since this may be called by HS_getHudByWindow
	    // during shutdown.
	    if (this._tab && this._tab.linkedBrowser) {
	      return this._tab.linkedBrowser.contentWindow;
	    }
	    return null;
	  },

	  get name() {
	    if (this._tab && this._tab.linkedBrowser.contentDocument) {
	      return this._tab.linkedBrowser.contentDocument.title;
	    }
	    if (this.isAddon) {
	      return this._form.name;
	    }
	    return this._form.title;
	  },

	  get url() {
	    return this._tab ? this._tab.linkedBrowser.currentURI.spec : this._form.url;
	  },

	  get isRemote() {
	    return !this.isLocalTab;
	  },

	  get isAddon() {
	    return !!(this._form && this._form.actor && this._form.actor.match(/conn\d+\.addon\d+/));
	  },

	  get isLocalTab() {
	    return !!this._tab;
	  },

	  get isMultiProcess() {
	    return !this.window;
	  },

	  get isThreadPaused() {
	    return !!this._isThreadPaused;
	  },

	  /**
	   * Adds remote protocol capabilities to the target, so that it can be used
	   * for tools that support the Remote Debugging Protocol even for local
	   * connections.
	   */
	  makeRemote: function () {
	    var _this3 = this;

	    if (this._remote) {
	      return this._remote.promise;
	    }

	    this._remote = promise.defer();

	    if (this.isLocalTab) {
	      // Since a remote protocol connection will be made, let's start the
	      // DebuggerServer here, once and for all tools.
	      if (!DebuggerServer.initialized) {
	        DebuggerServer.init();
	        DebuggerServer.addBrowserActors();
	      }

	      this._client = new DebuggerClient(DebuggerServer.connectPipe());
	      // A local TabTarget will never perform chrome debugging.
	      this._chrome = false;
	    }

	    this._setupRemoteListeners();

	    let attachTab = function () {
	      _this3._client.attachTab(_this3._form.actor, function (response, tabClient) {
	        if (!tabClient) {
	          _this3._remote.reject("Unable to attach to the tab");
	          return;
	        }
	        _this3.activeTab = tabClient;
	        _this3.threadActor = response.threadActor;
	        attachConsole();
	      });
	    };

	    let onConsoleAttached = function (response, consoleClient) {
	      if (!consoleClient) {
	        _this3._remote.reject("Unable to attach to the console");
	        return;
	      }
	      _this3.activeConsole = consoleClient;
	      _this3._remote.resolve(null);
	    };

	    let attachConsole = function () {
	      _this3._client.attachConsole(_this3._form.consoleActor, ["NetworkActivity"], onConsoleAttached);
	    };

	    if (this.isLocalTab) {
	      this._client.connect(function () {
	        _this3._client.getTab({ tab: _this3.tab }).then(function (response) {
	          _this3._form = response.tab;
	          attachTab();
	        });
	      });
	    } else if (this.isTabActor) {
	      // In the remote debugging case, the protocol connection will have been
	      // already initialized in the connection screen code.
	      attachTab();
	    } else {
	      // AddonActor and chrome debugging on RootActor doesn't inherits from
	      // TabActor and doesn't need to be attached.
	      attachConsole();
	    }

	    return this._remote.promise;
	  },

	  /**
	   * Listen to the different events.
	   */
	  _setupListeners: function () {
	    this._webProgressListener = new TabWebProgressListener(this);
	    this.tab.linkedBrowser.addProgressListener(this._webProgressListener);
	    this.tab.addEventListener("TabClose", this);
	    this.tab.parentNode.addEventListener("TabSelect", this);
	    this.tab.ownerDocument.defaultView.addEventListener("unload", this);
	  },

	  /**
	   * Teardown event listeners.
	   */
	  _teardownListeners: function () {
	    if (this._webProgressListener) {
	      this._webProgressListener.destroy();
	    }

	    this._tab.ownerDocument.defaultView.removeEventListener("unload", this);
	    this._tab.removeEventListener("TabClose", this);
	    this._tab.parentNode.removeEventListener("TabSelect", this);
	  },

	  /**
	   * Setup listeners for remote debugging, updating existing ones as necessary.
	   */
	  _setupRemoteListeners: function () {
	    var _this4 = this;

	    this.client.addListener("closed", this.destroy);

	    this._onTabDetached = function (aType, aPacket) {
	      // We have to filter message to ensure that this detach is for this tab
	      if (aPacket.from == _this4._form.actor) {
	        _this4.destroy();
	      }
	    };
	    this.client.addListener("tabDetached", this._onTabDetached);

	    this._onTabNavigated = function (aType, aPacket) {
	      let event = Object.create(null);
	      event.url = aPacket.url;
	      event.title = aPacket.title;
	      event.nativeConsoleAPI = aPacket.nativeConsoleAPI;
	      event.isFrameSwitching = aPacket.isFrameSwitching;
	      // Send any stored event payload (DOMWindow or nsIRequest) for backwards
	      // compatibility with non-remotable tools.
	      if (aPacket.state == "start") {
	        event._navPayload = _this4._navRequest;
	        _this4.emit("will-navigate", event);
	        _this4._navRequest = null;
	      } else {
	        event._navPayload = _this4._navWindow;
	        _this4.emit("navigate", event);
	        _this4._navWindow = null;
	      }
	    };
	    this.client.addListener("tabNavigated", this._onTabNavigated);

	    this._onFrameUpdate = function (aType, aPacket) {
	      _this4.emit("frame-update", aPacket);
	    };
	    this.client.addListener("frameUpdate", this._onFrameUpdate);
	  },

	  /**
	   * Teardown listeners for remote debugging.
	   */
	  _teardownRemoteListeners: function () {
	    this.client.removeListener("closed", this.destroy);
	    this.client.removeListener("tabNavigated", this._onTabNavigated);
	    this.client.removeListener("tabDetached", this._onTabDetached);
	    this.client.removeListener("frameUpdate", this._onFrameUpdate);
	  },

	  /**
	   * Handle tabs events.
	   */
	  handleEvent: function (event) {
	    switch (event.type) {
	      case "TabClose":
	      case "unload":
	        this.destroy();
	        break;
	      case "TabSelect":
	        if (this.tab.selected) {
	          this.emit("visible", event);
	        } else {
	          this.emit("hidden", event);
	        }
	        break;
	    }
	  },

	  /**
	   * Handle script status.
	   */
	  _handleThreadState: function (event) {
	    switch (event) {
	      case "thread-resumed":
	        this._isThreadPaused = false;
	        break;
	      case "thread-paused":
	        this._isThreadPaused = true;
	        break;
	    }
	  },

	  /**
	   * Target is not alive anymore.
	   */
	  destroy: function () {
	    var _this5 = this;

	    // If several things call destroy then we give them all the same
	    // destruction promise so we're sure to destroy only once
	    if (this._destroyer) {
	      return this._destroyer.promise;
	    }

	    this._destroyer = promise.defer();

	    // Before taking any action, notify listeners that destruction is imminent.
	    this.emit("close");

	    // First of all, do cleanup tasks that pertain to both remoted and
	    // non-remoted targets.
	    this.off("thread-resumed", this._handleThreadState);
	    this.off("thread-paused", this._handleThreadState);

	    if (this._tab) {
	      this._teardownListeners();
	    }

	    let cleanupAndResolve = function () {
	      _this5._cleanup();
	      _this5._destroyer.resolve(null);
	    };
	    // If this target was not remoted, the promise will be resolved before the
	    // function returns.
	    if (this._tab && !this._client) {
	      cleanupAndResolve();
	    } else if (this._client) {
	      // If, on the other hand, this target was remoted, the promise will be
	      // resolved after the remote connection is closed.
	      this._teardownRemoteListeners();

	      if (this.isLocalTab) {
	        // We started with a local tab and created the client ourselves, so we
	        // should close it.
	        this._client.close(cleanupAndResolve);
	      } else if (this.activeTab) {
	        // The client was handed to us, so we are not responsible for closing
	        // it. We just need to detach from the tab, if already attached.
	        // |detach| may fail if the connection is already dead, so proceed with
	        // cleanup directly after this.
	        this.activeTab.detach();
	        cleanupAndResolve();
	      } else {
	        cleanupAndResolve();
	      }
	    }

	    return this._destroyer.promise;
	  },

	  /**
	   * Clean up references to what this target points to.
	   */
	  _cleanup: function () {
	    if (this._tab) {
	      targets.delete(this._tab);
	    } else {
	      promiseTargets.delete(this._form);
	    }
	    this.activeTab = null;
	    this.activeConsole = null;
	    this._client = null;
	    this._tab = null;
	    this._form = null;
	    this._remote = null;
	  },

	  toString: function () {
	    let id = this._tab ? this._tab : this._form && this._form.actor;
	    return `TabTarget:${ id }`;
	  }
	};

	function WorkerTarget(workerClient) {
	  EventEmitter.decorate(this);
	  this._workerClient = workerClient;
	}

	/**
	 * A WorkerTarget represents a worker. Unlike TabTarget, which can represent
	 * either a local or remote tab, WorkerTarget always represents a remote worker.
	 * Moreover, unlike TabTarget, which is constructed with a placeholder object
	 * for remote tabs (from which a TabClient can then be lazily obtained),
	 * WorkerTarget is constructed with a WorkerClient directly.
	 *
	 * WorkerClient is designed to mimic the interface of TabClient as closely as
	 * possible. This allows us to debug workers as if they were ordinary tabs,
	 * requiring only minimal changes to the rest of the frontend.
	 */
	WorkerTarget.prototype = {
	  destroy: function () {},

	  get isRemote() {
	    return true;
	  },

	  get isTabActor() {
	    return true;
	  },

	  get url() {
	    return this._workerClient.url;
	  },

	  get isWorkerTarget() {
	    return true;
	  },

	  get form() {
	    return {
	      consoleActor: this._workerClient.consoleActor
	    };
	  },

	  get activeTab() {
	    return this._workerClient;
	  },

	  get client() {
	    return this._workerClient.client;
	  },

	  destroy: function () {},

	  hasActor: function (name) {
	    return false;
	  },

	  getTrait: function () {
	    return undefined;
	  },

	  makeRemote: function () {
	    return Promise.resolve();
	  }
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Ci = _require.Ci;
	const Cu = _require.Cu;
	const components = _require.components;

	const Services = __webpack_require__(9);
	const DevToolsUtils = __webpack_require__(19);

	// WARNING I swapped the sync one for the async one here
	//const promise = require("resource://devtools/shared/deprecated-sync-thenables.js", {}).Promise;
	const promise = __webpack_require__(6);

	const events = __webpack_require__(25);

	var _require2 = __webpack_require__(28);

	const WebConsoleClient = _require2.WebConsoleClient;
	/*const { DebuggerSocket } = require("devtools/shared/security/socket");*/
	/*const Authentication = require("devtools/shared/security/auth");*/

	const noop = function () {};

	/**
	 * TODO: Get rid of this API in favor of EventTarget (bug 1042642)
	 *
	 * Add simple event notification to a prototype object. Any object that has
	 * some use for event notifications or the observer pattern in general can be
	 * augmented with the necessary facilities by passing its prototype to this
	 * function.
	 *
	 * @param aProto object
	 *        The prototype object that will be modified.
	 */
	function eventSource(aProto) {
	  /**
	   * Add a listener to the event source for a given event.
	   *
	   * @param aName string
	   *        The event to listen for.
	   * @param aListener function
	   *        Called when the event is fired. If the same listener
	   *        is added more than once, it will be called once per
	   *        addListener call.
	   */
	  aProto.addListener = function (aName, aListener) {
	    if (typeof aListener != "function") {
	      throw TypeError("Listeners must be functions.");
	    }

	    if (!this._listeners) {
	      this._listeners = {};
	    }

	    this._getListeners(aName).push(aListener);
	  };

	  /**
	   * Add a listener to the event source for a given event. The
	   * listener will be removed after it is called for the first time.
	   *
	   * @param aName string
	   *        The event to listen for.
	   * @param aListener function
	   *        Called when the event is fired.
	   */
	  aProto.addOneTimeListener = function (aName, aListener) {
	    var _this = this;

	    let l = function (...args) {
	      _this.removeListener(aName, l);
	      aListener.apply(null, args);
	    };
	    this.addListener(aName, l);
	  };

	  /**
	   * Remove a listener from the event source previously added with
	   * addListener().
	   *
	   * @param aName string
	   *        The event name used during addListener to add the listener.
	   * @param aListener function
	   *        The callback to remove. If addListener was called multiple
	   *        times, all instances will be removed.
	   */
	  aProto.removeListener = function (aName, aListener) {
	    if (!this._listeners || aListener && !this._listeners[aName]) {
	      return;
	    }

	    if (!aListener) {
	      this._listeners[aName] = [];
	    } else {
	      this._listeners[aName] = this._listeners[aName].filter(function (l) {
	        return l != aListener;
	      });
	    }
	  };

	  /**
	   * Returns the listeners for the specified event name. If none are defined it
	   * initializes an empty list and returns that.
	   *
	   * @param aName string
	   *        The event name.
	   */
	  aProto._getListeners = function (aName) {
	    if (aName in this._listeners) {
	      return this._listeners[aName];
	    }
	    this._listeners[aName] = [];
	    return this._listeners[aName];
	  };

	  /**
	   * Notify listeners of an event.
	   *
	   * @param aName string
	   *        The event to fire.
	   * @param arguments
	   *        All arguments will be passed along to the listeners,
	   *        including the name argument.
	   */
	  aProto.emit = function () {
	    if (!this._listeners) {
	      return;
	    }

	    let name = arguments[0];
	    let listeners = this._getListeners(name).slice(0);

	    for (let listener of listeners) {
	      try {
	        listener.apply(null, arguments);
	      } catch (e) {
	        // Prevent a bad listener from interfering with the others.
	        DevToolsUtils.reportException("notify event '" + name + "'", e);
	      }
	    }
	  };
	}

	/**
	 * Set of protocol messages that affect thread state, and the
	 * state the actor is in after each message.
	 */
	const ThreadStateTypes = {
	  "paused": "paused",
	  "resumed": "attached",
	  "detached": "detached"
	};

	/**
	 * Set of protocol messages that are sent by the server without a prior request
	 * by the client.
	 */
	const UnsolicitedNotifications = {
	  "consoleAPICall": "consoleAPICall",
	  "eventNotification": "eventNotification",
	  "fileActivity": "fileActivity",
	  "lastPrivateContextExited": "lastPrivateContextExited",
	  "logMessage": "logMessage",
	  "networkEvent": "networkEvent",
	  "networkEventUpdate": "networkEventUpdate",
	  "newGlobal": "newGlobal",
	  "newScript": "newScript",
	  "tabDetached": "tabDetached",
	  "tabListChanged": "tabListChanged",
	  "reflowActivity": "reflowActivity",
	  "addonListChanged": "addonListChanged",
	  "workerListChanged": "workerListChanged",
	  "tabNavigated": "tabNavigated",
	  "frameUpdate": "frameUpdate",
	  "pageError": "pageError",
	  "documentLoad": "documentLoad",
	  "enteredFrame": "enteredFrame",
	  "exitedFrame": "exitedFrame",
	  "appOpen": "appOpen",
	  "appClose": "appClose",
	  "appInstall": "appInstall",
	  "appUninstall": "appUninstall",
	  "evaluationResult": "evaluationResult"
	};

	/**
	 * Set of pause types that are sent by the server and not as an immediate
	 * response to a client request.
	 */
	const UnsolicitedPauses = {
	  "resumeLimit": "resumeLimit",
	  "debuggerStatement": "debuggerStatement",
	  "breakpoint": "breakpoint",
	  "DOMEvent": "DOMEvent",
	  "watchpoint": "watchpoint",
	  "exception": "exception"
	};

	/**
	 * Creates a client for the remote debugging protocol server. This client
	 * provides the means to communicate with the server and exchange the messages
	 * required by the protocol in a traditional JavaScript API.
	 */
	const DebuggerClient = exports.DebuggerClient = function (aTransport) {
	  var _this2 = this;

	  this._transport = aTransport;
	  this._transport.hooks = this;

	  // Map actor ID to client instance for each actor type.
	  this._clients = new Map();

	  this._pendingRequests = new Map();
	  this._activeRequests = new Map();
	  this._eventsEnabled = true;

	  this.traits = {};

	  this.request = this.request.bind(this);
	  this.localTransport = this._transport.onOutputStreamReady === undefined;

	  /*
	   * As the first thing on the connection, expect a greeting packet from
	   * the connection's root actor.
	   */
	  this.mainRoot = null;
	  this.expectReply("root", function (aPacket) {
	    _this2.mainRoot = new RootClient(_this2, aPacket);
	    _this2.emit("connected", aPacket.applicationType, aPacket.traits);
	  });
	};

	/**
	 * A declarative helper for defining methods that send requests to the server.
	 *
	 * @param aPacketSkeleton
	 *        The form of the packet to send. Can specify fields to be filled from
	 *        the parameters by using the |args| function.
	 * @param telemetry
	 *        The unique suffix of the telemetry histogram id.
	 * @param before
	 *        The function to call before sending the packet. Is passed the packet,
	 *        and the return value is used as the new packet. The |this| context is
	 *        the instance of the client object we are defining a method for.
	 * @param after
	 *        The function to call after the response is received. It is passed the
	 *        response, and the return value is considered the new response that
	 *        will be passed to the callback. The |this| context is the instance of
	 *        the client object we are defining a method for.
	 */
	DebuggerClient.requester = function (aPacketSkeleton, { telemetry, before, after }) {
	  return DevToolsUtils.makeInfallible(function (...args) {
	    var _this3 = this;

	    let histogram, startTime;
	    if (telemetry) {
	      let transportType = this._transport.onOutputStreamReady === undefined ? "LOCAL_" : "REMOTE_";
	      let histogramId = "DEVTOOLS_DEBUGGER_RDP_" + transportType + telemetry + "_MS";
	      // histogram = Services.telemetry.getHistogramById(histogramId);
	      startTime = +new Date();
	    }
	    let outgoingPacket = {
	      to: aPacketSkeleton.to || this.actor
	    };

	    let maxPosition = -1;
	    for (let k of Object.keys(aPacketSkeleton)) {
	      if (aPacketSkeleton[k] instanceof DebuggerClient.Argument) {
	        let position = aPacketSkeleton[k].position;

	        outgoingPacket[k] = aPacketSkeleton[k].getArgument(args);
	        maxPosition = Math.max(position, maxPosition);
	      } else {
	        outgoingPacket[k] = aPacketSkeleton[k];
	      }
	    }

	    if (before) {
	      outgoingPacket = before.call(this, outgoingPacket);
	    }

	    return this.request(outgoingPacket, DevToolsUtils.makeInfallible(function (aResponse) {
	      if (after) {
	        var _aResponse = aResponse;
	        let from = _aResponse.from;

	        aResponse = after.call(_this3, aResponse);
	        if (!aResponse.from) {
	          aResponse.from = from;
	        }
	      }

	      // The callback is always the last parameter.
	      let thisCallback = args[maxPosition + 1];
	      if (thisCallback) {
	        thisCallback(aResponse);
	      }

	      if (histogram) {
	        histogram.add(+new Date() - startTime);
	      }
	    }, "DebuggerClient.requester request callback"));
	  }, "DebuggerClient.requester");
	};

	function args(aPos) {
	  return new DebuggerClient.Argument(aPos);
	}

	DebuggerClient.Argument = function (aPosition) {
	  this.position = aPosition;
	};

	DebuggerClient.Argument.prototype.getArgument = function (aParams) {
	  if (!(this.position in aParams)) {
	    throw new Error("Bad index into params: " + this.position);
	  }
	  return aParams[this.position];
	};

	// Expose these to save callers the trouble of importing DebuggerSocket
	DebuggerClient.socketConnect = function (options) {
	  // Defined here instead of just copying the function to allow lazy-load
	  return DebuggerSocket.connect(options);
	};
	DevToolsUtils.defineLazyGetter(DebuggerClient, "Authenticators", function () {
	  return Authentication.Authenticators;
	});
	DevToolsUtils.defineLazyGetter(DebuggerClient, "AuthenticationResult", function () {
	  return Authentication.AuthenticationResult;
	});

	DebuggerClient.prototype = {
	  /**
	   * Connect to the server and start exchanging protocol messages.
	   *
	   * @param aOnConnected function
	   *        If specified, will be called when the greeting packet is
	   *        received from the debugging server.
	   */
	  connect: function (aOnConnected) {
	    var _this4 = this;

	    let deferred = promise.defer();

	    this.emit("connect");

	    // Also emit the event on the |DebuggerServer| object (not on
	    // the instance), so it's possible to track all instances.
	    events.emit(DebuggerClient, "connect", this);

	    this.addOneTimeListener("connected", function (aName, aApplicationType, aTraits) {
	      _this4.traits = aTraits;
	      if (aOnConnected) {
	        aOnConnected(aApplicationType, aTraits);
	      }
	      deferred.resolve();
	    });

	    this._transport.ready();
	    return deferred.promise;
	  },

	  /**
	   * Shut down communication with the debugging server.
	   *
	   * @param aOnClosed function
	   *        If specified, will be called when the debugging connection
	   *        has been closed.
	   */
	  close: function (aOnClosed) {
	    var _this5 = this;

	    // Disable detach event notifications, because event handlers will be in a
	    // cleared scope by the time they run.
	    this._eventsEnabled = false;

	    let cleanup = function () {
	      _this5._transport.close();
	      _this5._transport = null;
	    };

	    // If the connection is already closed,
	    // there is no need to detach client
	    // as we won't be able to send any message.
	    if (this._closed) {
	      cleanup();
	      if (aOnClosed) {
	        aOnClosed();
	      }
	      return;
	    }

	    if (aOnClosed) {
	      this.addOneTimeListener('closed', function (aEvent) {
	        aOnClosed();
	      });
	    }

	    // Call each client's `detach` method by calling
	    // lastly registered ones first to give a chance
	    // to detach child clients first.
	    let clients = [...this._clients.values()];
	    this._clients.clear();
	    const detachClients = function () {
	      let client = clients.pop();
	      if (!client) {
	        // All clients detached.
	        cleanup();
	        return;
	      }
	      if (client.detach) {
	        client.detach(detachClients);
	        return;
	      }
	      detachClients();
	    };
	    detachClients();
	  },

	  /*
	   * This function exists only to preserve DebuggerClient's interface;
	   * new code should say 'client.mainRoot.listTabs()'.
	   */
	  listTabs: function (aOnResponse) {
	    return this.mainRoot.listTabs(aOnResponse);
	  },

	  /*
	   * This function exists only to preserve DebuggerClient's interface;
	   * new code should say 'client.mainRoot.listAddons()'.
	   */
	  listAddons: function (aOnResponse) {
	    return this.mainRoot.listAddons(aOnResponse);
	  },

	  getTab: function (aFilter) {
	    return this.mainRoot.getTab(aFilter);
	  },

	  /**
	   * Attach to a tab actor.
	   *
	   * @param string aTabActor
	   *        The actor ID for the tab to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a TabClient
	   *        (which will be undefined on error).
	   */
	  attachTab: function (aTabActor, aOnResponse = noop) {
	    var _this6 = this;

	    if (this._clients.has(aTabActor)) {
	      let cachedTab = this._clients.get(aTabActor);
	      let cachedResponse = {
	        cacheDisabled: cachedTab.cacheDisabled,
	        javascriptEnabled: cachedTab.javascriptEnabled,
	        traits: cachedTab.traits
	      };
	      DevToolsUtils.executeSoon(function () {
	        return aOnResponse(cachedResponse, cachedTab);
	      });
	      return;
	    }

	    let packet = {
	      to: aTabActor,
	      type: "attach"
	    };
	    this.request(packet, function (aResponse) {
	      let tabClient;
	      if (!aResponse.error) {
	        tabClient = new TabClient(_this6, aResponse);
	        _this6.registerClient(tabClient);
	      }
	      aOnResponse(aResponse, tabClient);
	    });
	  },

	  attachWorker: function DC_attachWorker(aWorkerActor, aOnResponse = noop) {
	    var _this7 = this;

	    let workerClient = this._clients.get(aWorkerActor);
	    if (workerClient !== undefined) {
	      DevToolsUtils.executeSoon(function () {
	        return aOnResponse({
	          from: workerClient.actor,
	          type: "attached",
	          url: workerClient.url
	        }, workerClient);
	      });
	      return;
	    }

	    this.request({ to: aWorkerActor, type: "attach" }, function (aResponse) {
	      if (aResponse.error) {
	        aOnResponse(aResponse, null);
	        return;
	      }

	      let workerClient = new WorkerClient(_this7, aResponse);
	      _this7.registerClient(workerClient);
	      aOnResponse(aResponse, workerClient);
	    });
	  },

	  /**
	   * Attach to an addon actor.
	   *
	   * @param string aAddonActor
	   *        The actor ID for the addon to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a AddonClient
	   *        (which will be undefined on error).
	   */
	  attachAddon: function DC_attachAddon(aAddonActor, aOnResponse = noop) {
	    var _this8 = this;

	    let packet = {
	      to: aAddonActor,
	      type: "attach"
	    };
	    this.request(packet, function (aResponse) {
	      let addonClient;
	      if (!aResponse.error) {
	        addonClient = new AddonClient(_this8, aAddonActor);
	        _this8.registerClient(addonClient);
	        _this8.activeAddon = addonClient;
	      }
	      aOnResponse(aResponse, addonClient);
	    });
	  },

	  /**
	   * Attach to a Web Console actor.
	   *
	   * @param string aConsoleActor
	   *        The ID for the console actor to attach to.
	   * @param array aListeners
	   *        The console listeners you want to start.
	   * @param function aOnResponse
	   *        Called with the response packet and a WebConsoleClient
	   *        instance (which will be undefined on error).
	   */
	  attachConsole: function (aConsoleActor, aListeners, aOnResponse = noop) {
	    var _this9 = this;

	    let packet = {
	      to: aConsoleActor,
	      type: "startListeners",
	      listeners: aListeners
	    };

	    this.request(packet, function (aResponse) {
	      let consoleClient;
	      if (!aResponse.error) {
	        if (_this9._clients.has(aConsoleActor)) {
	          consoleClient = _this9._clients.get(aConsoleActor);
	        } else {
	          consoleClient = new WebConsoleClient(_this9, aResponse);
	          _this9.registerClient(consoleClient);
	        }
	      }
	      aOnResponse(aResponse, consoleClient);
	    });
	  },

	  /**
	   * Attach to a global-scoped thread actor for chrome debugging.
	   *
	   * @param string aThreadActor
	   *        The actor ID for the thread to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a ThreadClient
	   *        (which will be undefined on error).
	   * @param object aOptions
	   *        Configuration options.
	   *        - useSourceMaps: whether to use source maps or not.
	   */
	  attachThread: function (aThreadActor, aOnResponse = noop, aOptions = {}) {
	    var _this10 = this;

	    if (this._clients.has(aThreadActor)) {
	      DevToolsUtils.executeSoon(function () {
	        return aOnResponse({}, _this10._clients.get(aThreadActor));
	      });
	      return;
	    }

	    let packet = {
	      to: aThreadActor,
	      type: "attach",
	      options: aOptions
	    };
	    this.request(packet, function (aResponse) {
	      if (!aResponse.error) {
	        var threadClient = new ThreadClient(_this10, aThreadActor);
	        _this10.registerClient(threadClient);
	      }
	      aOnResponse(aResponse, threadClient);
	    });
	  },

	  /**
	   * Attach to a trace actor.
	   *
	   * @param string aTraceActor
	   *        The actor ID for the tracer to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a TraceClient
	   *        (which will be undefined on error).
	   */
	  attachTracer: function (aTraceActor, aOnResponse = noop) {
	    var _this11 = this;

	    if (this._clients.has(aTraceActor)) {
	      DevToolsUtils.executeSoon(function () {
	        return aOnResponse({}, _this11._clients.get(aTraceActor));
	      });
	      return;
	    }

	    let packet = {
	      to: aTraceActor,
	      type: "attach"
	    };
	    this.request(packet, function (aResponse) {
	      if (!aResponse.error) {
	        var traceClient = new TraceClient(_this11, aTraceActor);
	        _this11.registerClient(traceClient);
	      }
	      aOnResponse(aResponse, traceClient);
	    });
	  },

	  /**
	   * Fetch the ChromeActor for the main process or ChildProcessActor for a
	   * a given child process ID.
	   *
	   * @param number aId
	   *        The ID for the process to attach (returned by `listProcesses`).
	   *        Connected to the main process if omitted, or is 0.
	   */
	  getProcess: function (aId) {
	    let packet = {
	      to: "root",
	      type: "getProcess"
	    };
	    if (typeof aId == "number") {
	      packet.id = aId;
	    }
	    return this.request(packet);
	  },

	  /**
	   * Release an object actor.
	   *
	   * @param string aActor
	   *        The actor ID to send the request to.
	   * @param aOnResponse function
	   *        If specified, will be called with the response packet when
	   *        debugging server responds.
	   */
	  release: DebuggerClient.requester({
	    to: args(0),
	    type: "release"
	  }, {
	    telemetry: "RELEASE"
	  }),

	  /**
	   * Send a request to the debugging server.
	   *
	   * @param aRequest object
	   *        A JSON packet to send to the debugging server.
	   * @param aOnResponse function
	   *        If specified, will be called with the JSON response packet when
	   *        debugging server responds.
	   * @return Request
	   *         This object emits a number of events to allow you to respond to
	   *         different parts of the request lifecycle.
	   *         It is also a Promise object, with a `then` method, that is resolved
	   *         whenever a JSON or a Bulk response is received; and is rejected
	   *         if the response is an error.
	   *         Note: This return value can be ignored if you are using JSON alone,
	   *         because the callback provided in |aOnResponse| will be bound to the
	   *         "json-reply" event automatically.
	   *
	   *         Events emitted:
	   *         * json-reply: The server replied with a JSON packet, which is
	   *           passed as event data.
	   *         * bulk-reply: The server replied with bulk data, which you can read
	   *           using the event data object containing:
	   *           * actor:  Name of actor that received the packet
	   *           * type:   Name of actor's method that was called on receipt
	   *           * length: Size of the data to be read
	   *           * stream: This input stream should only be used directly if you
	   *                     can ensure that you will read exactly |length| bytes
	   *                     and will not close the stream when reading is complete
	   *           * done:   If you use the stream directly (instead of |copyTo|
	   *                     below), you must signal completion by resolving /
	   *                     rejecting this deferred.  If it's rejected, the
	   *                     transport will be closed.  If an Error is supplied as a
	   *                     rejection value, it will be logged via |dumpn|.  If you
	   *                     do use |copyTo|, resolving is taken care of for you
	   *                     when copying completes.
	   *           * copyTo: A helper function for getting your data out of the
	   *                     stream that meets the stream handling requirements
	   *                     above, and has the following signature:
	   *             @param  output nsIAsyncOutputStream
	   *                     The stream to copy to.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  request: function (aRequest, aOnResponse) {
	    if (!this.mainRoot) {
	      throw Error("Have not yet received a hello packet from the server.");
	    }
	    let type = aRequest.type || "";
	    if (!aRequest.to) {
	      throw Error("'" + type + "' request packet has no destination.");
	    }
	    if (this._closed) {
	      let msg = "'" + type + "' request packet to " + "'" + aRequest.to + "' " + "can't be sent as the connection is closed.";
	      let resp = { error: "connectionClosed", message: msg };
	      if (aOnResponse) {
	        aOnResponse(resp);
	      }
	      return promise.reject(resp);
	    }

	    let request = new Request(aRequest);
	    request.format = "json";
	    request.stack = components.stack;
	    if (aOnResponse) {
	      request.on("json-reply", aOnResponse);
	    }

	    this._sendOrQueueRequest(request);

	    // Implement a Promise like API on the returned object
	    // that resolves/rejects on request response
	    let deferred = promise.defer();
	    function listenerJson(resp) {
	      request.off("json-reply", listenerJson);
	      request.off("bulk-reply", listenerBulk);
	      if (resp.error) {
	        deferred.reject(resp);
	      } else {
	        deferred.resolve(resp);
	      }
	    }
	    function listenerBulk(resp) {
	      request.off("json-reply", listenerJson);
	      request.off("bulk-reply", listenerBulk);
	      deferred.resolve(resp);
	    }
	    request.on("json-reply", listenerJson);
	    request.on("bulk-reply", listenerBulk);
	    request.then = deferred.promise.then.bind(deferred.promise);

	    return request;
	  },

	  /**
	   * Transmit streaming data via a bulk request.
	   *
	   * This method initiates the bulk send process by queuing up the header data.
	   * The caller receives eventual access to a stream for writing.
	   *
	   * Since this opens up more options for how the server might respond (it could
	   * send back either JSON or bulk data), and the returned Request object emits
	   * events for different stages of the request process that you may want to
	   * react to.
	   *
	   * @param request Object
	   *        This is modeled after the format of JSON packets above, but does not
	   *        actually contain the data, but is instead just a routing header:
	   *          * actor:  Name of actor that will receive the packet
	   *          * type:   Name of actor's method that should be called on receipt
	   *          * length: Size of the data to be sent
	   * @return Request
	   *         This object emits a number of events to allow you to respond to
	   *         different parts of the request lifecycle.
	   *
	   *         Events emitted:
	   *         * bulk-send-ready: Ready to send bulk data to the server, using the
	   *           event data object containing:
	   *           * stream:   This output stream should only be used directly if
	   *                       you can ensure that you will write exactly |length|
	   *                       bytes and will not close the stream when writing is
	   *                       complete
	   *           * done:     If you use the stream directly (instead of |copyFrom|
	   *                       below), you must signal completion by resolving /
	   *                       rejecting this deferred.  If it's rejected, the
	   *                       transport will be closed.  If an Error is supplied as
	   *                       a rejection value, it will be logged via |dumpn|.  If
	   *                       you do use |copyFrom|, resolving is taken care of for
	   *                       you when copying completes.
	   *           * copyFrom: A helper function for getting your data onto the
	   *                       stream that meets the stream handling requirements
	   *                       above, and has the following signature:
	   *             @param  input nsIAsyncInputStream
	   *                     The stream to copy from.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   *         * json-reply: The server replied with a JSON packet, which is
	   *           passed as event data.
	   *         * bulk-reply: The server replied with bulk data, which you can read
	   *           using the event data object containing:
	   *           * actor:  Name of actor that received the packet
	   *           * type:   Name of actor's method that was called on receipt
	   *           * length: Size of the data to be read
	   *           * stream: This input stream should only be used directly if you
	   *                     can ensure that you will read exactly |length| bytes
	   *                     and will not close the stream when reading is complete
	   *           * done:   If you use the stream directly (instead of |copyTo|
	   *                     below), you must signal completion by resolving /
	   *                     rejecting this deferred.  If it's rejected, the
	   *                     transport will be closed.  If an Error is supplied as a
	   *                     rejection value, it will be logged via |dumpn|.  If you
	   *                     do use |copyTo|, resolving is taken care of for you
	   *                     when copying completes.
	   *           * copyTo: A helper function for getting your data out of the
	   *                     stream that meets the stream handling requirements
	   *                     above, and has the following signature:
	   *             @param  output nsIAsyncOutputStream
	   *                     The stream to copy to.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  startBulkRequest: function (request) {
	    if (!this.traits.bulk) {
	      throw Error("Server doesn't support bulk transfers");
	    }
	    if (!this.mainRoot) {
	      throw Error("Have not yet received a hello packet from the server.");
	    }
	    if (!request.type) {
	      throw Error("Bulk packet is missing the required 'type' field.");
	    }
	    if (!request.actor) {
	      throw Error("'" + request.type + "' bulk packet has no destination.");
	    }
	    if (!request.length) {
	      throw Error("'" + request.type + "' bulk packet has no length.");
	    }

	    request = new Request(request);
	    request.format = "bulk";

	    this._sendOrQueueRequest(request);

	    return request;
	  },

	  /**
	   * If a new request can be sent immediately, do so.  Otherwise, queue it.
	   */
	  _sendOrQueueRequest(request) {
	    let actor = request.actor;
	    if (!this._activeRequests.has(actor)) {
	      this._sendRequest(request);
	    } else {
	      this._queueRequest(request);
	    }
	  },

	  /**
	   * Send a request.
	   * @throws Error if there is already an active request in flight for the same
	   *         actor.
	   */
	  _sendRequest(request) {
	    let actor = request.actor;
	    this.expectReply(actor, request);

	    if (request.format === "json") {
	      this._transport.send(request.request);
	      return false;
	    }

	    this._transport.startBulkSend(request.request).then(function (...args) {
	      request.emit("bulk-send-ready", ...args);
	    });
	  },

	  /**
	   * Queue a request to be sent later.  Queues are only drained when an in
	   * flight request to a given actor completes.
	   */
	  _queueRequest(request) {
	    let actor = request.actor;
	    let queue = this._pendingRequests.get(actor) || [];
	    queue.push(request);
	    this._pendingRequests.set(actor, queue);
	  },

	  /**
	   * Attempt the next request to a given actor (if any).
	   */
	  _attemptNextRequest(actor) {
	    if (this._activeRequests.has(actor)) {
	      return;
	    }
	    let queue = this._pendingRequests.get(actor);
	    if (!queue) {
	      return;
	    }
	    let request = queue.shift();
	    if (queue.length === 0) {
	      this._pendingRequests.delete(actor);
	    }
	    this._sendRequest(request);
	  },

	  /**
	   * Arrange to hand the next reply from |aActor| to the handler bound to
	   * |aRequest|.
	   *
	   * DebuggerClient.prototype.request / startBulkRequest usually takes care of
	   * establishing the handler for a given request, but in rare cases (well,
	   * greetings from new root actors, is the only case at the moment) we must be
	   * prepared for a "reply" that doesn't correspond to any request we sent.
	   */
	  expectReply: function (aActor, aRequest) {
	    if (this._activeRequests.has(aActor)) {
	      throw Error("clashing handlers for next reply from " + uneval(aActor));
	    }

	    // If a handler is passed directly (as it is with the handler for the root
	    // actor greeting), create a dummy request to bind this to.
	    if (typeof aRequest === "function") {
	      let handler = aRequest;
	      aRequest = new Request();
	      aRequest.on("json-reply", handler);
	    }

	    this._activeRequests.set(aActor, aRequest);
	  },

	  // Transport hooks.

	  /**
	   * Called by DebuggerTransport to dispatch incoming packets as appropriate.
	   *
	   * @param aPacket object
	   *        The incoming packet.
	   */
	  onPacket: function (aPacket) {
	    if (!aPacket.from) {
	      DevToolsUtils.reportException("onPacket", new Error("Server did not specify an actor, dropping packet: " + JSON.stringify(aPacket)));
	      return;
	    }

	    // If we have a registered Front for this actor, let it handle the packet
	    // and skip all the rest of this unpleasantness.
	    let front = this.getActor(aPacket.from);
	    if (front) {
	      front.onPacket(aPacket);
	      return;
	    }

	    if (this._clients.has(aPacket.from) && aPacket.type) {
	      let client = this._clients.get(aPacket.from);
	      let type = aPacket.type;
	      if (client.events.indexOf(type) != -1) {
	        client.emit(type, aPacket);
	        // we ignore the rest, as the client is expected to handle this packet.
	        return;
	      }
	    }

	    let activeRequest;
	    // See if we have a handler function waiting for a reply from this
	    // actor. (Don't count unsolicited notifications or pauses as
	    // replies.)
	    if (this._activeRequests.has(aPacket.from) && !(aPacket.type in UnsolicitedNotifications) && !(aPacket.type == ThreadStateTypes.paused && aPacket.why.type in UnsolicitedPauses)) {
	      activeRequest = this._activeRequests.get(aPacket.from);
	      this._activeRequests.delete(aPacket.from);
	    }

	    // If there is a subsequent request for the same actor, hand it off to the
	    // transport.  Delivery of packets on the other end is always async, even
	    // in the local transport case.
	    this._attemptNextRequest(aPacket.from);

	    // Packets that indicate thread state changes get special treatment.
	    if (aPacket.type in ThreadStateTypes && this._clients.has(aPacket.from) && typeof this._clients.get(aPacket.from)._onThreadState == "function") {
	      this._clients.get(aPacket.from)._onThreadState(aPacket);
	    }

	    // TODO: Bug 1151156 - Remove once Gecko 40 is on b2g-stable.
	    if (!this.traits.noNeedToFakeResumptionOnNavigation) {
	      // On navigation the server resumes, so the client must resume as well.
	      // We achieve that by generating a fake resumption packet that triggers
	      // the client's thread state change listeners.
	      if (aPacket.type == UnsolicitedNotifications.tabNavigated && this._clients.has(aPacket.from) && this._clients.get(aPacket.from).thread) {
	        let thread = this._clients.get(aPacket.from).thread;
	        let resumption = { from: thread._actor, type: "resumed" };
	        thread._onThreadState(resumption);
	      }
	    }

	    // Only try to notify listeners on events, not responses to requests
	    // that lack a packet type.
	    if (aPacket.type) {
	      this.emit(aPacket.type, aPacket);
	    }

	    if (activeRequest) {
	      let emitReply = function () {
	        return activeRequest.emit("json-reply", aPacket);
	      };
	      if (activeRequest.stack) {
	        Cu.callFunctionWithAsyncStack(emitReply, activeRequest.stack, "DevTools RDP");
	      } else {
	        emitReply();
	      }
	    }
	  },

	  /**
	   * Called by the DebuggerTransport to dispatch incoming bulk packets as
	   * appropriate.
	   *
	   * @param packet object
	   *        The incoming packet, which contains:
	   *        * actor:  Name of actor that will receive the packet
	   *        * type:   Name of actor's method that should be called on receipt
	   *        * length: Size of the data to be read
	   *        * stream: This input stream should only be used directly if you can
	   *                  ensure that you will read exactly |length| bytes and will
	   *                  not close the stream when reading is complete
	   *        * done:   If you use the stream directly (instead of |copyTo|
	   *                  below), you must signal completion by resolving /
	   *                  rejecting this deferred.  If it's rejected, the transport
	   *                  will be closed.  If an Error is supplied as a rejection
	   *                  value, it will be logged via |dumpn|.  If you do use
	   *                  |copyTo|, resolving is taken care of for you when copying
	   *                  completes.
	   *        * copyTo: A helper function for getting your data out of the stream
	   *                  that meets the stream handling requirements above, and has
	   *                  the following signature:
	   *          @param  output nsIAsyncOutputStream
	   *                  The stream to copy to.
	   *          @return Promise
	   *                  The promise is resolved when copying completes or rejected
	   *                  if any (unexpected) errors occur.
	   *                  This object also emits "progress" events for each chunk
	   *                  that is copied.  See stream-utils.js.
	   */
	  onBulkPacket: function (packet) {
	    let actor = packet.actor;
	    let type = packet.type;
	    let length = packet.length;

	    if (!actor) {
	      DevToolsUtils.reportException("onBulkPacket", new Error("Server did not specify an actor, dropping bulk packet: " + JSON.stringify(packet)));
	      return;
	    }

	    // See if we have a handler function waiting for a reply from this
	    // actor.
	    if (!this._activeRequests.has(actor)) {
	      return;
	    }

	    let activeRequest = this._activeRequests.get(actor);
	    this._activeRequests.delete(actor);

	    // If there is a subsequent request for the same actor, hand it off to the
	    // transport.  Delivery of packets on the other end is always async, even
	    // in the local transport case.
	    this._attemptNextRequest(actor);

	    activeRequest.emit("bulk-reply", packet);
	  },

	  /**
	   * Called by DebuggerTransport when the underlying stream is closed.
	   *
	   * @param aStatus nsresult
	   *        The status code that corresponds to the reason for closing
	   *        the stream.
	   */
	  onClosed: function (aStatus) {
	    this._closed = true;
	    this.emit("closed");

	    // Reject all pending and active requests
	    let reject = function (type, request, actor) {
	      // Server can send packets on its own and client only pass a callback
	      // to expectReply, so that there is no request object.
	      let msg;
	      if (request.request) {
	        msg = "'" + request.request.type + "' " + type + " request packet" + " to '" + actor + "' " + "can't be sent as the connection just closed.";
	      } else {
	        msg = "server side packet from '" + actor + "' can't be received " + "as the connection just closed.";
	      }
	      let packet = { error: "connectionClosed", message: msg };
	      request.emit("json-reply", packet);
	    };

	    this._pendingRequests.forEach(function (list, actor) {
	      list.forEach(function (request) {
	        return reject("pending", request, actor);
	      });
	    });
	    this._pendingRequests.clear();
	    this._activeRequests.forEach(reject.bind(null, "active"));
	    this._activeRequests.clear();

	    // The |_pools| array on the client-side currently is used only by
	    // protocol.js to store active fronts, mirroring the actor pools found in
	    // the server.  So, read all usages of "pool" as "protocol.js front".
	    //
	    // In the normal case where we shutdown cleanly, the toolbox tells each tool
	    // to close, and they each call |destroy| on any fronts they were using.
	    // When |destroy| or |cleanup| is called on a protocol.js front, it also
	    // removes itself from the |_pools| array.  Once the toolbox has shutdown,
	    // the connection is closed, and we reach here.  All fronts (should have
	    // been) |destroy|ed, so |_pools| should empty.
	    //
	    // If the connection instead aborts unexpectedly, we may end up here with
	    // all fronts used during the life of the connection.  So, we call |cleanup|
	    // on them clear their state, reject pending requests, and remove themselves
	    // from |_pools|.  This saves the toolbox from hanging indefinitely, in case
	    // it waits for some server response before shutdown that will now never
	    // arrive.
	    for (let pool of this._pools) {
	      pool.cleanup();
	    }
	  },

	  registerClient: function (client) {
	    let actorID = client.actor;
	    if (!actorID) {
	      throw new Error("DebuggerServer.registerClient expects " + "a client instance with an `actor` attribute.");
	    }
	    if (!Array.isArray(client.events)) {
	      throw new Error("DebuggerServer.registerClient expects " + "a client instance with an `events` attribute " + "that is an array.");
	    }
	    if (client.events.length > 0 && typeof client.emit != "function") {
	      throw new Error("DebuggerServer.registerClient expects " + "a client instance with non-empty `events` array to" + "have an `emit` function.");
	    }
	    if (this._clients.has(actorID)) {
	      throw new Error("DebuggerServer.registerClient already registered " + "a client for this actor.");
	    }
	    this._clients.set(actorID, client);
	  },

	  unregisterClient: function (client) {
	    let actorID = client.actor;
	    if (!actorID) {
	      throw new Error("DebuggerServer.unregisterClient expects " + "a Client instance with a `actor` attribute.");
	    }
	    this._clients.delete(actorID);
	  },

	  /**
	   * Actor lifetime management, echos the server's actor pools.
	   */
	  __pools: null,
	  get _pools() {
	    if (this.__pools) {
	      return this.__pools;
	    }
	    this.__pools = new Set();
	    return this.__pools;
	  },

	  addActorPool: function (pool) {
	    this._pools.add(pool);
	  },
	  removeActorPool: function (pool) {
	    this._pools.delete(pool);
	  },
	  getActor: function (actorID) {
	    let pool = this.poolFor(actorID);
	    return pool ? pool.get(actorID) : null;
	  },

	  poolFor: function (actorID) {
	    for (let pool of this._pools) {
	      if (pool.has(actorID)) return pool;
	    }
	    return null;
	  },

	  /**
	   * Currently attached addon.
	   */
	  activeAddon: null
	};

	eventSource(DebuggerClient.prototype);

	function Request(request) {
	  this.request = request;
	}

	Request.prototype = {

	  on: function (type, listener) {
	    events.on(this, type, listener);
	  },

	  off: function (type, listener) {
	    events.off(this, type, listener);
	  },

	  once: function (type, listener) {
	    events.once(this, type, listener);
	  },

	  emit: function (type, ...args) {
	    events.emit(this, type, ...args);
	  },

	  get actor() {
	    return this.request.to || this.request.actor;
	  }

	};

	/**
	 * Creates a tab client for the remote debugging protocol server. This client
	 * is a front to the tab actor created in the server side, hiding the protocol
	 * details in a traditional JavaScript API.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aForm object
	 *        The protocol form for this tab.
	 */
	function TabClient(aClient, aForm) {
	  this.client = aClient;
	  this._actor = aForm.from;
	  this._threadActor = aForm.threadActor;
	  this.javascriptEnabled = aForm.javascriptEnabled;
	  this.cacheDisabled = aForm.cacheDisabled;
	  this.thread = null;
	  this.request = this.client.request;
	  this.traits = aForm.traits || {};
	  this.events = ["workerListChanged"];
	}

	TabClient.prototype = {
	  get actor() {
	    return this._actor;
	  },
	  get _transport() {
	    return this.client._transport;
	  },

	  /**
	   * Attach to a thread actor.
	   *
	   * @param object aOptions
	   *        Configuration options.
	   *        - useSourceMaps: whether to use source maps or not.
	   * @param function aOnResponse
	   *        Called with the response packet and a ThreadClient
	   *        (which will be undefined on error).
	   */
	  attachThread: function (aOptions = {}, aOnResponse = noop) {
	    var _this12 = this;

	    if (this.thread) {
	      DevToolsUtils.executeSoon(function () {
	        return aOnResponse({}, _this12.thread);
	      });
	      return;
	    }

	    let packet = {
	      to: this._threadActor,
	      type: "attach",
	      options: aOptions
	    };
	    this.request(packet, function (aResponse) {
	      if (!aResponse.error) {
	        _this12.thread = new ThreadClient(_this12, _this12._threadActor);
	        _this12.client.registerClient(_this12.thread);
	      }
	      aOnResponse(aResponse, _this12.thread);
	    });
	  },

	  /**
	   * Detach the client from the tab actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    before: function (aPacket) {
	      if (this.thread) {
	        this.thread.detach();
	      }
	      return aPacket;
	    },
	    after: function (aResponse) {
	      this.client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "TABDETACH"
	  }),

	  /**
	   * Reload the page in this tab.
	   *
	   * @param [optional] object options
	   *        An object with a `force` property indicating whether or not
	   *        this reload should skip the cache
	   */
	  reload: function (options = { force: false }) {
	    return this._reload(options);
	  },
	  _reload: DebuggerClient.requester({
	    type: "reload",
	    options: args(0)
	  }, {
	    telemetry: "RELOAD"
	  }),

	  /**
	   * Navigate to another URL.
	   *
	   * @param string url
	   *        The URL to navigate to.
	   */
	  navigateTo: DebuggerClient.requester({
	    type: "navigateTo",
	    url: args(0)
	  }, {
	    telemetry: "NAVIGATETO"
	  }),

	  /**
	   * Reconfigure the tab actor.
	   *
	   * @param object aOptions
	   *        A dictionary object of the new options to use in the tab actor.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  reconfigure: DebuggerClient.requester({
	    type: "reconfigure",
	    options: args(0)
	  }, {
	    telemetry: "RECONFIGURETAB"
	  }),

	  listWorkers: DebuggerClient.requester({
	    type: "listWorkers"
	  }, {
	    telemetry: "LISTWORKERS"
	  }),

	  attachWorker: function (aWorkerActor, aOnResponse) {
	    this.client.attachWorker(aWorkerActor, aOnResponse);
	  }
	};

	eventSource(TabClient.prototype);

	function WorkerClient(aClient, aForm) {
	  this.client = aClient;
	  this._actor = aForm.from;
	  this._isClosed = false;
	  this._url = aForm.url;

	  this._onClose = this._onClose.bind(this);

	  this.addListener("close", this._onClose);

	  this.traits = {};
	}

	WorkerClient.prototype = {
	  get _transport() {
	    return this.client._transport;
	  },

	  get request() {
	    return this.client.request;
	  },

	  get actor() {
	    return this._actor;
	  },

	  get url() {
	    return this._url;
	  },

	  get isClosed() {
	    return this._isClosed;
	  },

	  detach: DebuggerClient.requester({ type: "detach" }, {
	    after: function (aResponse) {
	      this.client.unregisterClient(this);
	      return aResponse;
	    },

	    telemetry: "WORKERDETACH"
	  }),

	  attachThread: function (aOptions = {}, aOnResponse = noop) {
	    var _this13 = this;

	    if (this.thread) {
	      DevToolsUtils.executeSoon(function () {
	        return aOnResponse({
	          type: "connected",
	          threadActor: _this13.thread._actor,
	          consoleActor: _this13.consoleActor
	        }, _this13.thread);
	      });
	      return;
	    }

	    // The connect call on server doesn't attach the thread as of version 44.
	    this.request({
	      to: this._actor,
	      type: "connect",
	      options: aOptions
	    }, function (connectReponse) {
	      if (connectReponse.error) {
	        aOnResponse(connectReponse, null);
	        return;
	      }

	      _this13.request({
	        to: connectReponse.threadActor,
	        type: "attach"
	      }, function (attachResponse) {
	        if (attachResponse.error) {
	          aOnResponse(attachResponse, null);
	        }

	        _this13.thread = new ThreadClient(_this13, connectReponse.threadActor);
	        _this13.consoleActor = connectReponse.consoleActor;
	        _this13.client.registerClient(_this13.thread);

	        aOnResponse(connectReponse, _this13.thread);
	      });
	    });
	  },

	  _onClose: function () {
	    this.removeListener("close", this._onClose);

	    this.client.unregisterClient(this);
	    this._isClosed = true;
	  },

	  reconfigure: function () {
	    return Promise.resolve();
	  },

	  events: ["close"]
	};

	eventSource(WorkerClient.prototype);

	function AddonClient(aClient, aActor) {
	  this._client = aClient;
	  this._actor = aActor;
	  this.request = this._client.request;
	  this.events = [];
	}

	AddonClient.prototype = {
	  get actor() {
	    return this._actor;
	  },
	  get _transport() {
	    return this._client._transport;
	  },

	  /**
	   * Detach the client from the addon actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function (aResponse) {
	      if (this._client.activeAddon === this) {
	        this._client.activeAddon = null;
	      }
	      this._client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "ADDONDETACH"
	  })
	};

	/**
	 * A RootClient object represents a root actor on the server. Each
	 * DebuggerClient keeps a RootClient instance representing the root actor
	 * for the initial connection; DebuggerClient's 'listTabs' and
	 * 'listChildProcesses' methods forward to that root actor.
	 *
	 * @param aClient object
	 *      The client connection to which this actor belongs.
	 * @param aGreeting string
	 *      The greeting packet from the root actor we're to represent.
	 *
	 * Properties of a RootClient instance:
	 *
	 * @property actor string
	 *      The name of this child's root actor.
	 * @property applicationType string
	 *      The application type, as given in the root actor's greeting packet.
	 * @property traits object
	 *      The traits object, as given in the root actor's greeting packet.
	 */
	function RootClient(aClient, aGreeting) {
	  this._client = aClient;
	  this.actor = aGreeting.from;
	  this.applicationType = aGreeting.applicationType;
	  this.traits = aGreeting.traits;
	}
	exports.RootClient = RootClient;

	RootClient.prototype = {
	  constructor: RootClient,

	  /**
	   * List the open tabs.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listTabs: DebuggerClient.requester({ type: "listTabs" }, { telemetry: "LISTTABS" }),

	  /**
	   * List the installed addons.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listAddons: DebuggerClient.requester({ type: "listAddons" }, { telemetry: "LISTADDONS" }),

	  /**
	   * List the registered workers.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listWorkers: DebuggerClient.requester({ type: "listWorkers" }, { telemetry: "LISTWORKERS" }),

	  /**
	   * List the running processes.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listProcesses: DebuggerClient.requester({ type: "listProcesses" }, { telemetry: "LISTPROCESSES" }),

	  /**
	   * Fetch the TabActor for the currently selected tab, or for a specific
	   * tab given as first parameter.
	   *
	   * @param [optional] object aFilter
	   *        A dictionary object with following optional attributes:
	   *         - outerWindowID: used to match tabs in parent process
	   *         - tabId: used to match tabs in child processes
	   *         - tab: a reference to xul:tab element
	   *        If nothing is specified, returns the actor for the currently
	   *        selected tab.
	   */
	  getTab: function (aFilter) {
	    let packet = {
	      to: this.actor,
	      type: "getTab"
	    };

	    if (aFilter) {
	      if (typeof aFilter.outerWindowID == "number") {
	        packet.outerWindowID = aFilter.outerWindowID;
	      } else if (typeof aFilter.tabId == "number") {
	        packet.tabId = aFilter.tabId;
	      } else if ("tab" in aFilter) {
	        let browser = aFilter.tab.linkedBrowser;
	        if (browser.frameLoader.tabParent) {
	          // Tabs in child process
	          packet.tabId = browser.frameLoader.tabParent.tabId;
	        } else {
	          // Tabs in parent process
	          let windowUtils = browser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
	          packet.outerWindowID = windowUtils.outerWindowID;
	        }
	      } else {
	        // Throw if a filter object have been passed but without
	        // any clearly idenfified filter.
	        throw new Error("Unsupported argument given to getTab request");
	      }
	    }

	    return this.request(packet);
	  },

	  /**
	   * Description of protocol's actors and methods.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  protocolDescription: DebuggerClient.requester({ type: "protocolDescription" }, { telemetry: "PROTOCOLDESCRIPTION" }),

	  /*
	   * Methods constructed by DebuggerClient.requester require these forwards
	   * on their 'this'.
	   */
	  get _transport() {
	    return this._client._transport;
	  },
	  get request() {
	    return this._client.request;
	  }
	};

	/**
	 * Creates a thread client for the remote debugging protocol server. This client
	 * is a front to the thread actor created in the server side, hiding the
	 * protocol details in a traditional JavaScript API.
	 *
	 * @param aClient DebuggerClient|TabClient
	 *        The parent of the thread (tab for tab-scoped debuggers, DebuggerClient
	 *        for chrome debuggers).
	 * @param aActor string
	 *        The actor ID for this thread.
	 */
	function ThreadClient(aClient, aActor) {
	  this._parent = aClient;
	  this.client = aClient instanceof DebuggerClient ? aClient : aClient.client;
	  this._actor = aActor;
	  this._frameCache = [];
	  this._scriptCache = {};
	  this._pauseGrips = {};
	  this._threadGrips = {};
	  this.request = this.client.request;
	}

	ThreadClient.prototype = {
	  _state: "paused",
	  get state() {
	    return this._state;
	  },
	  get paused() {
	    return this._state === "paused";
	  },

	  _pauseOnExceptions: false,
	  _ignoreCaughtExceptions: false,
	  _pauseOnDOMEvents: null,

	  _actor: null,
	  get actor() {
	    return this._actor;
	  },

	  get _transport() {
	    return this.client._transport;
	  },

	  _assertPaused: function (aCommand) {
	    if (!this.paused) {
	      throw Error(aCommand + " command sent while not paused. Currently " + this._state);
	    }
	  },

	  /**
	   * Resume a paused thread. If the optional aLimit parameter is present, then
	   * the thread will also pause when that limit is reached.
	   *
	   * @param [optional] object aLimit
	   *        An object with a type property set to the appropriate limit (next,
	   *        step, or finish) per the remote debugging protocol specification.
	   *        Use null to specify no limit.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  _doResume: DebuggerClient.requester({
	    type: "resume",
	    resumeLimit: args(0)
	  }, {
	    before: function (aPacket) {
	      this._assertPaused("resume");

	      // Put the client in a tentative "resuming" state so we can prevent
	      // further requests that should only be sent in the paused state.
	      this._state = "resuming";

	      if (this._pauseOnExceptions) {
	        aPacket.pauseOnExceptions = this._pauseOnExceptions;
	      }
	      if (this._ignoreCaughtExceptions) {
	        aPacket.ignoreCaughtExceptions = this._ignoreCaughtExceptions;
	      }
	      if (this._pauseOnDOMEvents) {
	        aPacket.pauseOnDOMEvents = this._pauseOnDOMEvents;
	      }
	      return aPacket;
	    },
	    after: function (aResponse) {
	      if (aResponse.error) {
	        // There was an error resuming, back to paused state.
	        this._state = "paused";
	      }
	      return aResponse;
	    },
	    telemetry: "RESUME"
	  }),

	  /**
	   * Reconfigure the thread actor.
	   *
	   * @param object aOptions
	   *        A dictionary object of the new options to use in the thread actor.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  reconfigure: DebuggerClient.requester({
	    type: "reconfigure",
	    options: args(0)
	  }, {
	    telemetry: "RECONFIGURETHREAD"
	  }),

	  /**
	   * Resume a paused thread.
	   */
	  resume: function (aOnResponse) {
	    this._doResume(null, aOnResponse);
	  },

	  /**
	   * Resume then pause without stepping.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  resumeThenPause: function (aOnResponse) {
	    this._doResume({ type: "break" }, aOnResponse);
	  },

	  /**
	   * Step over a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepOver: function (aOnResponse) {
	    this._doResume({ type: "next" }, aOnResponse);
	  },

	  /**
	   * Step into a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepIn: function (aOnResponse) {
	    this._doResume({ type: "step" }, aOnResponse);
	  },

	  /**
	   * Step out of a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepOut: function (aOnResponse) {
	    this._doResume({ type: "finish" }, aOnResponse);
	  },

	  /**
	   * Immediately interrupt a running thread.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  interrupt: function (aOnResponse) {
	    this._doInterrupt(null, aOnResponse);
	  },

	  /**
	   * Pause execution right before the next JavaScript bytecode is executed.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  breakOnNext: function (aOnResponse) {
	    this._doInterrupt("onNext", aOnResponse);
	  },

	  /**
	   * Interrupt a running thread.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  _doInterrupt: DebuggerClient.requester({
	    type: "interrupt",
	    when: args(0)
	  }, {
	    telemetry: "INTERRUPT"
	  }),

	  /**
	   * Enable or disable pausing when an exception is thrown.
	   *
	   * @param boolean aFlag
	   *        Enables pausing if true, disables otherwise.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  pauseOnExceptions: function (aPauseOnExceptions, aIgnoreCaughtExceptions, aOnResponse = noop) {
	    var _this14 = this;

	    this._pauseOnExceptions = aPauseOnExceptions;
	    this._ignoreCaughtExceptions = aIgnoreCaughtExceptions;

	    // If the debuggee is paused, we have to send the flag via a reconfigure
	    // request.
	    if (this.paused) {
	      this.reconfigure({
	        pauseOnExceptions: aPauseOnExceptions,
	        ignoreCaughtExceptions: aIgnoreCaughtExceptions
	      }, aOnResponse);
	      return;
	    }
	    // Otherwise send the flag using a standard resume request.
	    this.interrupt(function (aResponse) {
	      if (aResponse.error) {
	        // Can't continue if pausing failed.
	        aOnResponse(aResponse);
	        return;
	      }
	      _this14.resume(aOnResponse);
	    });
	  },

	  /**
	   * Enable pausing when the specified DOM events are triggered. Disabling
	   * pausing on an event can be realized by calling this method with the updated
	   * array of events that doesn't contain it.
	   *
	   * @param array|string events
	   *        An array of strings, representing the DOM event types to pause on,
	   *        or "*" to pause on all DOM events. Pass an empty array to
	   *        completely disable pausing on DOM events.
	   * @param function onResponse
	   *        Called with the response packet in a future turn of the event loop.
	   */
	  pauseOnDOMEvents: function (events, onResponse = noop) {
	    var _this15 = this;

	    this._pauseOnDOMEvents = events;
	    // If the debuggee is paused, the value of the array will be communicated in
	    // the next resumption. Otherwise we have to force a pause in order to send
	    // the array.
	    if (this.paused) {
	      DevToolsUtils.executeSoon(function () {
	        return onResponse({});
	      });
	      return;
	    }
	    this.interrupt(function (response) {
	      // Can't continue if pausing failed.
	      if (response.error) {
	        onResponse(response);
	        return;
	      }
	      _this15.resume(onResponse);
	    });
	  },

	  /**
	   * Send a clientEvaluate packet to the debuggee. Response
	   * will be a resume packet.
	   *
	   * @param string aFrame
	   *        The actor ID of the frame where the evaluation should take place.
	   * @param string aExpression
	   *        The expression that will be evaluated in the scope of the frame
	   *        above.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  eval: DebuggerClient.requester({
	    type: "clientEvaluate",
	    frame: args(0),
	    expression: args(1)
	  }, {
	    before: function (aPacket) {
	      this._assertPaused("eval");
	      // Put the client in a tentative "resuming" state so we can prevent
	      // further requests that should only be sent in the paused state.
	      this._state = "resuming";
	      return aPacket;
	    },
	    after: function (aResponse) {
	      if (aResponse.error) {
	        // There was an error resuming, back to paused state.
	        this._state = "paused";
	      }
	      return aResponse;
	    },
	    telemetry: "CLIENTEVALUATE"
	  }),

	  /**
	   * Detach from the thread actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function (aResponse) {
	      this.client.unregisterClient(this);
	      this._parent.thread = null;
	      return aResponse;
	    },
	    telemetry: "THREADDETACH"
	  }),

	  /**
	   * Release multiple thread-lifetime object actors. If any pause-lifetime
	   * actors are included in the request, a |notReleasable| error will return,
	   * but all the thread-lifetime ones will have been released.
	   *
	   * @param array actors
	   *        An array with actor IDs to release.
	   */
	  releaseMany: DebuggerClient.requester({
	    type: "releaseMany",
	    actors: args(0)
	  }, {
	    telemetry: "RELEASEMANY"
	  }),

	  /**
	   * Promote multiple pause-lifetime object actors to thread-lifetime ones.
	   *
	   * @param array actors
	   *        An array with actor IDs to promote.
	   */
	  threadGrips: DebuggerClient.requester({
	    type: "threadGrips",
	    actors: args(0)
	  }, {
	    telemetry: "THREADGRIPS"
	  }),

	  /**
	   * Return the event listeners defined on the page.
	   *
	   * @param aOnResponse Function
	   *        Called with the thread's response.
	   */
	  eventListeners: DebuggerClient.requester({
	    type: "eventListeners"
	  }, {
	    telemetry: "EVENTLISTENERS"
	  }),

	  /**
	   * Request the loaded sources for the current thread.
	   *
	   * @param aOnResponse Function
	   *        Called with the thread's response.
	   */
	  getSources: DebuggerClient.requester({
	    type: "sources"
	  }, {
	    telemetry: "SOURCES"
	  }),

	  /**
	   * Clear the thread's source script cache. A scriptscleared event
	   * will be sent.
	   */
	  _clearScripts: function () {
	    if (Object.keys(this._scriptCache).length > 0) {
	      this._scriptCache = {};
	      this.emit("scriptscleared");
	    }
	  },

	  /**
	   * Request frames from the callstack for the current thread.
	   *
	   * @param aStart integer
	   *        The number of the youngest stack frame to return (the youngest
	   *        frame is 0).
	   * @param aCount integer
	   *        The maximum number of frames to return, or null to return all
	   *        frames.
	   * @param aOnResponse function
	   *        Called with the thread's response.
	   */
	  getFrames: DebuggerClient.requester({
	    type: "frames",
	    start: args(0),
	    count: args(1)
	  }, {
	    telemetry: "FRAMES"
	  }),

	  /**
	   * An array of cached frames. Clients can observe the framesadded and
	   * framescleared event to keep up to date on changes to this cache,
	   * and can fill it using the fillFrames method.
	   */
	  get cachedFrames() {
	    return this._frameCache;
	  },

	  /**
	   * true if there are more stack frames available on the server.
	   */
	  get moreFrames() {
	    return this.paused && (!this._frameCache || this._frameCache.length == 0 || !this._frameCache[this._frameCache.length - 1].oldest);
	  },

	  /**
	   * Ensure that at least aTotal stack frames have been loaded in the
	   * ThreadClient's stack frame cache. A framesadded event will be
	   * sent when the stack frame cache is updated.
	   *
	   * @param aTotal number
	   *        The minimum number of stack frames to be included.
	   * @param aCallback function
	   *        Optional callback function called when frames have been loaded
	   * @returns true if a framesadded notification should be expected.
	   */
	  fillFrames: function (aTotal, aCallback = noop) {
	    var _this16 = this;

	    this._assertPaused("fillFrames");
	    if (this._frameCache.length >= aTotal) {
	      return false;
	    }

	    let numFrames = this._frameCache.length;

	    this.getFrames(numFrames, aTotal - numFrames, function (aResponse) {
	      if (aResponse.error) {
	        aCallback(aResponse);
	        return;
	      }

	      let threadGrips = DevToolsUtils.values(_this16._threadGrips);

	      for (let i in aResponse.frames) {
	        let frame = aResponse.frames[i];
	        if (!frame.where.source) {
	          // Older servers use urls instead, so we need to resolve
	          // them to source actors
	          for (let grip of threadGrips) {
	            if (grip instanceof SourceClient && grip.url === frame.url) {
	              frame.where.source = grip._form;
	            }
	          }
	        }

	        _this16._frameCache[frame.depth] = frame;
	      }

	      // If we got as many frames as we asked for, there might be more
	      // frames available.
	      _this16.emit("framesadded");

	      aCallback(aResponse);
	    });

	    return true;
	  },

	  /**
	   * Clear the thread's stack frame cache. A framescleared event
	   * will be sent.
	   */
	  _clearFrames: function () {
	    if (this._frameCache.length > 0) {
	      this._frameCache = [];
	      this.emit("framescleared");
	    }
	  },

	  /**
	   * Return a ObjectClient object for the given object grip.
	   *
	   * @param aGrip object
	   *        A pause-lifetime object grip returned by the protocol.
	   */
	  pauseGrip: function (aGrip) {
	    if (aGrip.actor in this._pauseGrips) {
	      return this._pauseGrips[aGrip.actor];
	    }

	    let client = new ObjectClient(this.client, aGrip);
	    this._pauseGrips[aGrip.actor] = client;
	    return client;
	  },

	  /**
	   * Get or create a long string client, checking the grip client cache if it
	   * already exists.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   * @param aGripCacheName String
	   *        The property name of the grip client cache to check for existing
	   *        clients in.
	   */
	  _longString: function (aGrip, aGripCacheName) {
	    if (aGrip.actor in this[aGripCacheName]) {
	      return this[aGripCacheName][aGrip.actor];
	    }

	    let client = new LongStringClient(this.client, aGrip);
	    this[aGripCacheName][aGrip.actor] = client;
	    return client;
	  },

	  /**
	   * Return an instance of LongStringClient for the given long string grip that
	   * is scoped to the current pause.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   */
	  pauseLongString: function (aGrip) {
	    return this._longString(aGrip, "_pauseGrips");
	  },

	  /**
	   * Return an instance of LongStringClient for the given long string grip that
	   * is scoped to the thread lifetime.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   */
	  threadLongString: function (aGrip) {
	    return this._longString(aGrip, "_threadGrips");
	  },

	  /**
	   * Clear and invalidate all the grip clients from the given cache.
	   *
	   * @param aGripCacheName
	   *        The property name of the grip cache we want to clear.
	   */
	  _clearObjectClients: function (aGripCacheName) {
	    for (let id in this[aGripCacheName]) {
	      this[aGripCacheName][id].valid = false;
	    }
	    this[aGripCacheName] = {};
	  },

	  /**
	   * Invalidate pause-lifetime grip clients and clear the list of current grip
	   * clients.
	   */
	  _clearPauseGrips: function () {
	    this._clearObjectClients("_pauseGrips");
	  },

	  /**
	   * Invalidate thread-lifetime grip clients and clear the list of current grip
	   * clients.
	   */
	  _clearThreadGrips: function () {
	    this._clearObjectClients("_threadGrips");
	  },

	  /**
	   * Handle thread state change by doing necessary cleanup and notifying all
	   * registered listeners.
	   */
	  _onThreadState: function (aPacket) {
	    this._state = ThreadStateTypes[aPacket.type];
	    this._clearFrames();
	    this._clearPauseGrips();
	    aPacket.type === ThreadStateTypes.detached && this._clearThreadGrips();
	    this.client._eventsEnabled && this.emit(aPacket.type, aPacket);
	  },

	  /**
	   * Return an EnvironmentClient instance for the given environment actor form.
	   */
	  environment: function (aForm) {
	    return new EnvironmentClient(this.client, aForm);
	  },

	  /**
	   * Return an instance of SourceClient for the given source actor form.
	   */
	  source: function (aForm) {
	    if (aForm.actor in this._threadGrips) {
	      return this._threadGrips[aForm.actor];
	    }

	    return this._threadGrips[aForm.actor] = new SourceClient(this, aForm);
	  },

	  /**
	   * Request the prototype and own properties of mutlipleObjects.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   * @param actors [string]
	   *        List of actor ID of the queried objects.
	   */
	  getPrototypesAndProperties: DebuggerClient.requester({
	    type: "prototypesAndProperties",
	    actors: args(0)
	  }, {
	    telemetry: "PROTOTYPESANDPROPERTIES"
	  }),

	  events: ["newSource"]
	};

	eventSource(ThreadClient.prototype);

	/**
	 * Creates a tracing profiler client for the remote debugging protocol
	 * server. This client is a front to the trace actor created on the
	 * server side, hiding the protocol details in a traditional
	 * JavaScript API.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aActor string
	 *        The actor ID for this thread.
	 */
	function TraceClient(aClient, aActor) {
	  this._client = aClient;
	  this._actor = aActor;
	  this._activeTraces = new Set();
	  this._waitingPackets = new Map();
	  this._expectedPacket = 0;
	  this.request = this._client.request;
	  this.events = [];
	}

	TraceClient.prototype = {
	  get actor() {
	    return this._actor;
	  },
	  get tracing() {
	    return this._activeTraces.size > 0;
	  },

	  get _transport() {
	    return this._client._transport;
	  },

	  /**
	   * Detach from the trace actor.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function (aResponse) {
	      this._client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "TRACERDETACH"
	  }),

	  /**
	   * Start a new trace.
	   *
	   * @param aTrace [string]
	   *        An array of trace types to be recorded by the new trace.
	   *
	   * @param aName string
	   *        The name of the new trace.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   */
	  startTrace: DebuggerClient.requester({
	    type: "startTrace",
	    name: args(1),
	    trace: args(0)
	  }, {
	    after: function (aResponse) {
	      if (aResponse.error) {
	        return aResponse;
	      }

	      if (!this.tracing) {
	        this._waitingPackets.clear();
	        this._expectedPacket = 0;
	      }
	      this._activeTraces.add(aResponse.name);

	      return aResponse;
	    },
	    telemetry: "STARTTRACE"
	  }),

	  /**
	   * End a trace. If a name is provided, stop the named
	   * trace. Otherwise, stop the most recently started trace.
	   *
	   * @param aName string
	   *        The name of the trace to stop.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   */
	  stopTrace: DebuggerClient.requester({
	    type: "stopTrace",
	    name: args(0)
	  }, {
	    after: function (aResponse) {
	      if (aResponse.error) {
	        return aResponse;
	      }

	      this._activeTraces.delete(aResponse.name);

	      return aResponse;
	    },
	    telemetry: "STOPTRACE"
	  })
	};

	/**
	 * Grip clients are used to retrieve information about the relevant object.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip object
	 *        A pause-lifetime object grip returned by the protocol.
	 */
	function ObjectClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	exports.ObjectClient = ObjectClient;

	ObjectClient.prototype = {
	  get actor() {
	    return this._grip.actor;
	  },
	  get _transport() {
	    return this._client._transport;
	  },

	  valid: true,

	  get isFrozen() {
	    return this._grip.frozen;
	  },
	  get isSealed() {
	    return this._grip.sealed;
	  },
	  get isExtensible() {
	    return this._grip.extensible;
	  },

	  getDefinitionSite: DebuggerClient.requester({
	    type: "definitionSite"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class != "Function") {
	        throw new Error("getDefinitionSite is only valid for function grips.");
	      }
	      return aPacket;
	    }
	  }),

	  /**
	   * Request the names of a function's formal parameters.
	   *
	   * @param aOnResponse function
	   *        Called with an object of the form:
	   *        { parameterNames:[<parameterName>, ...] }
	   *        where each <parameterName> is the name of a parameter.
	   */
	  getParameterNames: DebuggerClient.requester({
	    type: "parameterNames"
	  }, {
	    before: function (aPacket) {
	      if (this._grip["class"] !== "Function") {
	        throw new Error("getParameterNames is only valid for function grips.");
	      }
	      return aPacket;
	    },
	    telemetry: "PARAMETERNAMES"
	  }),

	  /**
	   * Request the names of the properties defined on the object and not its
	   * prototype.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getOwnPropertyNames: DebuggerClient.requester({
	    type: "ownPropertyNames"
	  }, {
	    telemetry: "OWNPROPERTYNAMES"
	  }),

	  /**
	   * Request the prototype and own properties of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getPrototypeAndProperties: DebuggerClient.requester({
	    type: "prototypeAndProperties"
	  }, {
	    telemetry: "PROTOTYPEANDPROPERTIES"
	  }),

	  /**
	   * Request a PropertyIteratorClient instance to ease listing
	   * properties for this object.
	   *
	   * @param options Object
	   *        A dictionary object with various boolean attributes:
	   *        - ignoreSafeGetters Boolean
	   *          If true, do not iterate over safe getters.
	   *        - ignoreIndexedProperties Boolean
	   *          If true, filters out Array items.
	   *          e.g. properties names between `0` and `object.length`.
	   *        - ignoreNonIndexedProperties Boolean
	   *          If true, filters out items that aren't array items
	   *          e.g. properties names that are not a number between `0`
	   *          and `object.length`.
	   *        - sort Boolean
	   *          If true, the iterator will sort the properties by name
	   *          before dispatching them.
	   * @param aOnResponse function Called with the client instance.
	   */
	  enumProperties: DebuggerClient.requester({
	    type: "enumProperties",
	    options: args(0)
	  }, {
	    after: function (aResponse) {
	      if (aResponse.iterator) {
	        return { iterator: new PropertyIteratorClient(this._client, aResponse.iterator) };
	      }
	      return aResponse;
	    },
	    telemetry: "ENUMPROPERTIES"
	  }),

	  /**
	   * Request the property descriptor of the object's specified property.
	   *
	   * @param aName string The name of the requested property.
	   * @param aOnResponse function Called with the request's response.
	   */
	  getProperty: DebuggerClient.requester({
	    type: "property",
	    name: args(0)
	  }, {
	    telemetry: "PROPERTY"
	  }),

	  /**
	   * Request the prototype of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getPrototype: DebuggerClient.requester({
	    type: "prototype"
	  }, {
	    telemetry: "PROTOTYPE"
	  }),

	  /**
	   * Request the display string of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getDisplayString: DebuggerClient.requester({
	    type: "displayString"
	  }, {
	    telemetry: "DISPLAYSTRING"
	  }),

	  /**
	   * Request the scope of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getScope: DebuggerClient.requester({
	    type: "scope"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class !== "Function") {
	        throw new Error("scope is only valid for function grips.");
	      }
	      return aPacket;
	    },
	    telemetry: "SCOPE"
	  }),

	  /**
	   * Request the promises directly depending on the current promise.
	   */
	  getDependentPromises: DebuggerClient.requester({
	    type: "dependentPromises"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getDependentPromises is only valid for promise " + "grips.");
	      }
	      return aPacket;
	    }
	  }),

	  /**
	   * Request the stack to the promise's allocation point.
	   */
	  getPromiseAllocationStack: DebuggerClient.requester({
	    type: "allocationStack"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getAllocationStack is only valid for promise grips.");
	      }
	      return aPacket;
	    }
	  }),

	  /**
	   * Request the stack to the promise's fulfillment point.
	   */
	  getPromiseFulfillmentStack: DebuggerClient.requester({
	    type: "fulfillmentStack"
	  }, {
	    before: function (packet) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getPromiseFulfillmentStack is only valid for " + "promise grips.");
	      }
	      return packet;
	    }
	  }),

	  /**
	   * Request the stack to the promise's rejection point.
	   */
	  getPromiseRejectionStack: DebuggerClient.requester({
	    type: "rejectionStack"
	  }, {
	    before: function (packet) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getPromiseRejectionStack is only valid for " + "promise grips.");
	      }
	      return packet;
	    }
	  })
	};

	/**
	 * A PropertyIteratorClient provides a way to access to property names and
	 * values of an object efficiently, slice by slice.
	 * Note that the properties can be sorted in the backend,
	 * this is controled while creating the PropertyIteratorClient
	 * from ObjectClient.enumProperties.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip Object
	 *        A PropertyIteratorActor grip returned by the protocol via
	 *        TabActor.enumProperties request.
	 */
	function PropertyIteratorClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}

	PropertyIteratorClient.prototype = {
	  get actor() {
	    return this._grip.actor;
	  },

	  /**
	   * Get the total number of properties available in the iterator.
	   */
	  get count() {
	    return this._grip.count;
	  },

	  /**
	   * Get one or more property names that correspond to the positions in the
	   * indexes parameter.
	   *
	   * @param indexes Array
	   *        An array of property indexes.
	   * @param aCallback Function
	   *        The function called when we receive the property names.
	   */
	  names: DebuggerClient.requester({
	    type: "names",
	    indexes: args(0)
	  }, {}),

	  /**
	   * Get a set of following property value(s).
	   *
	   * @param start Number
	   *        The index of the first property to fetch.
	   * @param count Number
	   *        The number of properties to fetch.
	   * @param aCallback Function
	   *        The function called when we receive the property values.
	   */
	  slice: DebuggerClient.requester({
	    type: "slice",
	    start: args(0),
	    count: args(1)
	  }, {}),

	  /**
	   * Get all the property values.
	   *
	   * @param aCallback Function
	   *        The function called when we receive the property values.
	   */
	  all: DebuggerClient.requester({
	    type: "all"
	  }, {})
	};

	/**
	 * A LongStringClient provides a way to access "very long" strings from the
	 * debugger server.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip Object
	 *        A pause-lifetime long string grip returned by the protocol.
	 */
	function LongStringClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	exports.LongStringClient = LongStringClient;

	LongStringClient.prototype = {
	  get actor() {
	    return this._grip.actor;
	  },
	  get length() {
	    return this._grip.length;
	  },
	  get initial() {
	    return this._grip.initial;
	  },
	  get _transport() {
	    return this._client._transport;
	  },

	  valid: true,

	  /**
	   * Get the substring of this LongString from aStart to aEnd.
	   *
	   * @param aStart Number
	   *        The starting index.
	   * @param aEnd Number
	   *        The ending index.
	   * @param aCallback Function
	   *        The function called when we receive the substring.
	   */
	  substring: DebuggerClient.requester({
	    type: "substring",
	    start: args(0),
	    end: args(1)
	  }, {
	    telemetry: "SUBSTRING"
	  })
	};

	/**
	 * A SourceClient provides a way to access the source text of a script.
	 *
	 * @param aClient ThreadClient
	 *        The thread client parent.
	 * @param aForm Object
	 *        The form sent across the remote debugging protocol.
	 */
	function SourceClient(aClient, aForm) {
	  this._form = aForm;
	  this._isBlackBoxed = aForm.isBlackBoxed;
	  this._isPrettyPrinted = aForm.isPrettyPrinted;
	  this._activeThread = aClient;
	  this._client = aClient.client;
	}

	SourceClient.prototype = {
	  get _transport() {
	    return this._client._transport;
	  },
	  get isBlackBoxed() {
	    return this._isBlackBoxed;
	  },
	  get isPrettyPrinted() {
	    return this._isPrettyPrinted;
	  },
	  get actor() {
	    return this._form.actor;
	  },
	  get request() {
	    return this._client.request;
	  },
	  get url() {
	    return this._form.url;
	  },

	  /**
	   * Black box this SourceClient's source.
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  blackBox: DebuggerClient.requester({
	    type: "blackbox"
	  }, {
	    telemetry: "BLACKBOX",
	    after: function (aResponse) {
	      if (!aResponse.error) {
	        this._isBlackBoxed = true;
	        if (this._activeThread) {
	          this._activeThread.emit("blackboxchange", this);
	        }
	      }
	      return aResponse;
	    }
	  }),

	  /**
	   * Un-black box this SourceClient's source.
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  unblackBox: DebuggerClient.requester({
	    type: "unblackbox"
	  }, {
	    telemetry: "UNBLACKBOX",
	    after: function (aResponse) {
	      if (!aResponse.error) {
	        this._isBlackBoxed = false;
	        if (this._activeThread) {
	          this._activeThread.emit("blackboxchange", this);
	        }
	      }
	      return aResponse;
	    }
	  }),

	  /**
	   * Get Executable Lines from a source
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  getExecutableLines: function (cb) {
	    let packet = {
	      to: this._form.actor,
	      type: "getExecutableLines"
	    };

	    this._client.request(packet, function (res) {
	      cb(res.lines);
	    });
	  },

	  /**
	   * Get a long string grip for this SourceClient's source.
	   */
	  source: function (aCallback) {
	    var _this17 = this;

	    let packet = {
	      to: this._form.actor,
	      type: "source"
	    };
	    this._client.request(packet, function (aResponse) {
	      _this17._onSourceResponse(aResponse, aCallback);
	    });
	  },

	  /**
	   * Pretty print this source's text.
	   */
	  prettyPrint: function (aIndent, aCallback) {
	    var _this18 = this;

	    const packet = {
	      to: this._form.actor,
	      type: "prettyPrint",
	      indent: aIndent
	    };
	    this._client.request(packet, function (aResponse) {
	      if (!aResponse.error) {
	        _this18._isPrettyPrinted = true;
	        _this18._activeThread._clearFrames();
	        _this18._activeThread.emit("prettyprintchange", _this18);
	      }
	      _this18._onSourceResponse(aResponse, aCallback);
	    });
	  },

	  /**
	   * Stop pretty printing this source's text.
	   */
	  disablePrettyPrint: function (aCallback) {
	    var _this19 = this;

	    const packet = {
	      to: this._form.actor,
	      type: "disablePrettyPrint"
	    };
	    this._client.request(packet, function (aResponse) {
	      if (!aResponse.error) {
	        _this19._isPrettyPrinted = false;
	        _this19._activeThread._clearFrames();
	        _this19._activeThread.emit("prettyprintchange", _this19);
	      }
	      _this19._onSourceResponse(aResponse, aCallback);
	    });
	  },

	  _onSourceResponse: function (aResponse, aCallback) {
	    if (aResponse.error) {
	      aCallback(aResponse);
	      return;
	    }

	    if (typeof aResponse.source === "string") {
	      aCallback(aResponse);
	      return;
	    }

	    let contentType = aResponse.contentType;
	    let source = aResponse.source;

	    let longString = this._activeThread.threadLongString(source);
	    longString.substring(0, longString.length, function (aResponse) {
	      if (aResponse.error) {
	        aCallback(aResponse);
	        return;
	      }

	      aCallback({
	        source: aResponse.substring,
	        contentType: contentType
	      });
	    });
	  },

	  /**
	   * Request to set a breakpoint in the specified location.
	   *
	   * @param object aLocation
	   *        The location and condition of the breakpoint in
	   *        the form of { line[, column, condition] }.
	   * @param function aOnResponse
	   *        Called with the thread's response.
	   */
	  setBreakpoint: function ({ line, column, condition }, aOnResponse = noop) {
	    var _this20 = this;

	    // A helper function that sets the breakpoint.
	    let doSetBreakpoint = function (aCallback) {
	      let root = _this20._client.mainRoot;
	      let location = {
	        line: line,
	        column: column
	      };

	      let packet = {
	        to: _this20.actor,
	        type: "setBreakpoint",
	        location: location,
	        condition: condition
	      };

	      // Backwards compatibility: send the breakpoint request to the
	      // thread if the server doesn't support Debugger.Source actors.
	      if (!root.traits.debuggerSourceActors) {
	        packet.to = _this20._activeThread.actor;
	        packet.location.url = _this20.url;
	      }

	      _this20._client.request(packet, function (aResponse) {
	        // Ignoring errors, since the user may be setting a breakpoint in a
	        // dead script that will reappear on a page reload.
	        let bpClient;
	        if (aResponse.actor) {
	          bpClient = new BreakpointClient(_this20._client, _this20, aResponse.actor, location, root.traits.conditionalBreakpoints ? condition : undefined);
	        }
	        aOnResponse(aResponse, bpClient);
	        if (aCallback) {
	          aCallback();
	        }
	      });
	    };

	    // If the debuggee is paused, just set the breakpoint.
	    if (this._activeThread.paused) {
	      doSetBreakpoint();
	      return;
	    }
	    // Otherwise, force a pause in order to set the breakpoint.
	    this._activeThread.interrupt(function (aResponse) {
	      if (aResponse.error) {
	        // Can't set the breakpoint if pausing failed.
	        aOnResponse(aResponse);
	        return;
	      }

	      const type = aResponse.type;
	      const why = aResponse.why;

	      const cleanUp = type == "paused" && why.type == "interrupted" ? function () {
	        return _this20._activeThread.resume();
	      } : noop;

	      doSetBreakpoint(cleanUp);
	    });
	  }
	};

	/**
	 * Breakpoint clients are used to remove breakpoints that are no longer used.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aSourceClient SourceClient
	 *        The source where this breakpoint exists
	 * @param aActor string
	 *        The actor ID for this breakpoint.
	 * @param aLocation object
	 *        The location of the breakpoint. This is an object with two properties:
	 *        url and line.
	 * @param aCondition string
	 *        The conditional expression of the breakpoint
	 */
	function BreakpointClient(aClient, aSourceClient, aActor, aLocation, aCondition) {
	  this._client = aClient;
	  this._actor = aActor;
	  this.location = aLocation;
	  this.location.actor = aSourceClient.actor;
	  this.location.url = aSourceClient.url;
	  this.source = aSourceClient;
	  this.request = this._client.request;

	  // The condition property should only exist if it's a truthy value
	  if (aCondition) {
	    this.condition = aCondition;
	  }
	}

	BreakpointClient.prototype = {

	  _actor: null,
	  get actor() {
	    return this._actor;
	  },
	  get _transport() {
	    return this._client._transport;
	  },

	  /**
	   * Remove the breakpoint from the server.
	   */
	  remove: DebuggerClient.requester({
	    type: "delete"
	  }, {
	    telemetry: "DELETE"
	  }),

	  /**
	   * Determines if this breakpoint has a condition
	   */
	  hasCondition: function () {
	    let root = this._client.mainRoot;
	    // XXX bug 990137: We will remove support for client-side handling of
	    // conditional breakpoints
	    if (root.traits.conditionalBreakpoints) {
	      return "condition" in this;
	    } else {
	      return "conditionalExpression" in this;
	    }
	  },

	  /**
	   * Get the condition of this breakpoint. Currently we have to
	   * support locally emulated conditional breakpoints until the
	   * debugger servers are updated (see bug 990137). We used a
	   * different property when moving it server-side to ensure that we
	   * are testing the right code.
	   */
	  getCondition: function () {
	    let root = this._client.mainRoot;
	    if (root.traits.conditionalBreakpoints) {
	      return this.condition;
	    } else {
	      return this.conditionalExpression;
	    }
	  },

	  /**
	   * Set the condition of this breakpoint
	   */
	  setCondition: function (gThreadClient, aCondition) {
	    var _this21 = this;

	    let root = this._client.mainRoot;
	    let deferred = promise.defer();

	    if (root.traits.conditionalBreakpoints) {
	      let info = {
	        line: this.location.line,
	        column: this.location.column,
	        condition: aCondition
	      };

	      // Remove the current breakpoint and add a new one with the
	      // condition.
	      this.remove(function (aResponse) {
	        if (aResponse && aResponse.error) {
	          deferred.reject(aResponse);
	          return;
	        }

	        _this21.source.setBreakpoint(info, function (aResponse, aNewBreakpoint) {
	          if (aResponse && aResponse.error) {
	            deferred.reject(aResponse);
	          } else {
	            deferred.resolve(aNewBreakpoint);
	          }
	        });
	      });
	    } else {
	      // The property shouldn't even exist if the condition is blank
	      if (aCondition === "") {
	        delete this.conditionalExpression;
	      } else {
	        this.conditionalExpression = aCondition;
	      }
	      deferred.resolve(this);
	    }

	    return deferred.promise;
	  }
	};

	eventSource(BreakpointClient.prototype);

	/**
	 * Environment clients are used to manipulate the lexical environment actors.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aForm Object
	 *        The form sent across the remote debugging protocol.
	 */
	function EnvironmentClient(aClient, aForm) {
	  this._client = aClient;
	  this._form = aForm;
	  this.request = this._client.request;
	}
	exports.EnvironmentClient = EnvironmentClient;

	EnvironmentClient.prototype = {

	  get actor() {
	    return this._form.actor;
	  },
	  get _transport() {
	    return this._client._transport;
	  },

	  /**
	   * Fetches the bindings introduced by this lexical environment.
	   */
	  getBindings: DebuggerClient.requester({
	    type: "bindings"
	  }, {
	    telemetry: "BINDINGS"
	  }),

	  /**
	   * Changes the value of the identifier whose name is name (a string) to that
	   * represented by value (a grip).
	   */
	  assign: DebuggerClient.requester({
	    type: "assign",
	    name: args(0),
	    value: args(1)
	  }, {
	    telemetry: "ASSIGN"
	  })
	};

	eventSource(EnvironmentClient.prototype);

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict"

	/* General utilities used throughout devtools. */

	;

	var _this = this;

	var _require = __webpack_require__(1);

	var Ci = _require.Ci;
	var Cu = _require.Cu;
	var Cc = _require.Cc;
	var components = _require.components;

	var Services = __webpack_require__(9);
	var promise = __webpack_require__(6);

	var _require2 = __webpack_require__(20);

	const FileUtils = _require2.FileUtils;

	/**
	 * Turn the error |aError| into a string, without fail.
	 */

	exports.safeErrorString = function safeErrorString(aError) {
	  try {
	    let errorString = aError.toString();
	    if (typeof errorString == "string") {
	      // Attempt to attach a stack to |errorString|. If it throws an error, or
	      // isn't a string, don't use it.
	      try {
	        if (aError.stack) {
	          let stack = aError.stack.toString();
	          if (typeof stack == "string") {
	            errorString += "\nStack: " + stack;
	          }
	        }
	      } catch (ee) {}

	      // Append additional line and column number information to the output,
	      // since it might not be part of the stringified error.
	      if (typeof aError.lineNumber == "number" && typeof aError.columnNumber == "number") {
	        errorString += "Line: " + aError.lineNumber + ", column: " + aError.columnNumber;
	      }

	      return errorString;
	    }
	  } catch (ee) {}

	  // We failed to find a good error description, so do the next best thing.
	  return Object.prototype.toString.call(aError);
	};

	/**
	 * Report that |aWho| threw an exception, |aException|.
	 */
	exports.reportException = function reportException(aWho, aException) {
	  let msg = aWho + " threw an exception: " + exports.safeErrorString(aException);

	  dump(msg + "\n");

	  if (Cu && Cu.reportError) {
	    /*
	     * Note that the xpcshell test harness registers an observer for
	     * console messages, so when we're running tests, this will cause
	     * the test to quit.
	     */
	    Cu.reportError(msg);
	  }
	};

	/**
	 * Given a handler function that may throw, return an infallible handler
	 * function that calls the fallible handler, and logs any exceptions it
	 * throws.
	 *
	 * @param aHandler function
	 *      A handler function, which may throw.
	 * @param aName string
	 *      A name for aHandler, for use in error messages. If omitted, we use
	 *      aHandler.name.
	 *
	 * (SpiderMonkey does generate good names for anonymous functions, but we
	 * don't have a way to get at them from JavaScript at the moment.)
	 */
	exports.makeInfallible = function makeInfallible(aHandler, aName) {
	  if (!aName) aName = aHandler.name;

	  return function () /* arguments */{
	    try {
	      return aHandler.apply(this, arguments);
	    } catch (ex) {
	      let who = "Handler function";
	      if (aName) {
	        who += " " + aName;
	      }
	      return exports.reportException(who, ex);
	    }
	  };
	};
	/**
	 * Interleaves two arrays element by element, returning the combined array, like
	 * a zip. In the case of arrays with different sizes, undefined values will be
	 * interleaved at the end along with the extra values of the larger array.
	 *
	 * @param Array a
	 * @param Array b
	 * @returns Array
	 *          The combined array, in the form [a1, b1, a2, b2, ...]
	 */
	exports.zip = function zip(a, b) {
	  if (!b) {
	    return a;
	  }
	  if (!a) {
	    return b;
	  }
	  const pairs = [];
	  for (let i = 0, aLength = a.length, bLength = b.length; i < aLength || i < bLength; i++) {
	    pairs.push([a[i], b[i]]);
	  }
	  return pairs;
	};

	/**
	 * Converts an object into an array with 2-element arrays as key/value
	 * pairs of the object. `{ foo: 1, bar: 2}` would become
	 * `[[foo, 1], [bar 2]]` (order not guaranteed);
	 *
	 * @param object obj
	 * @returns array
	 */
	exports.entries = function entries(obj) {
	  return Object.keys(obj).map(function (k) {
	    return [k, obj[k]];
	  });
	};

	/**
	 * Takes an array of 2-element arrays as key/values pairs and
	 * constructs an object using them.
	 */
	exports.toObject = function (arr) {
	  const obj = {};
	  for (let pair of arr) {
	    obj[pair[0]] = pair[1];
	  }
	  return obj;
	};

	/**
	 * Composes the given functions into a single function, which will
	 * apply the results of each function right-to-left, starting with
	 * applying the given arguments to the right-most function.
	 * `compose(foo, bar, baz)` === `args => foo(bar(baz(args)`
	 *
	 * @param ...function funcs
	 * @returns function
	 */
	exports.compose = function compose(...funcs) {
	  return function (...args) {
	    const initialValue = funcs[funcs.length - 1].apply(null, args);
	    const leftFuncs = funcs.slice(0, -1);
	    return leftFuncs.reduceRight(function (composed, f) {
	      return f(composed);
	    }, initialValue);
	  };
	};

	/**
	 * Waits for the next tick in the event loop to execute a callback.
	 */
	exports.executeSoon = function executeSoon(aFn) {
	  setTimeout(aFn, 0);
	};

	/**
	 * Waits for the next tick in the event loop.
	 *
	 * @return Promise
	 *         A promise that is resolved after the next tick in the event loop.
	 */
	exports.waitForTick = function waitForTick() {
	  let deferred = promise.defer();
	  exports.executeSoon(deferred.resolve);
	  return deferred.promise;
	};

	/**
	 * Waits for the specified amount of time to pass.
	 *
	 * @param number aDelay
	 *        The amount of time to wait, in milliseconds.
	 * @return Promise
	 *         A promise that is resolved after the specified amount of time passes.
	 */
	exports.waitForTime = function waitForTime(aDelay) {
	  let deferred = promise.defer();
	  setTimeout(deferred.resolve, aDelay);
	  return deferred.promise;
	};

	/**
	 * Like Array.prototype.forEach, but doesn't cause jankiness when iterating over
	 * very large arrays by yielding to the browser and continuing execution on the
	 * next tick.
	 *
	 * @param Array aArray
	 *        The array being iterated over.
	 * @param Function aFn
	 *        The function called on each item in the array. If a promise is
	 *        returned by this function, iterating over the array will be paused
	 *        until the respective promise is resolved.
	 * @returns Promise
	 *          A promise that is resolved once the whole array has been iterated
	 *          over, and all promises returned by the aFn callback are resolved.
	 */
	exports.yieldingEach = function yieldingEach(aArray, aFn) {
	  const deferred = promise.defer();

	  let i = 0;
	  let len = aArray.length;
	  let outstanding = [deferred.promise];

	  (function loop() {
	    const start = Date.now();

	    while (i < len) {
	      // Don't block the main thread for longer than 16 ms at a time. To
	      // maintain 60fps, you have to render every frame in at least 16ms; we
	      // aren't including time spent in non-JS here, but this is Good
	      // Enough(tm).
	      if (Date.now() - start > 16) {
	        exports.executeSoon(loop);
	        return;
	      }

	      try {
	        outstanding.push(aFn(aArray[i], i++));
	      } catch (e) {
	        deferred.reject(e);
	        return;
	      }
	    }

	    deferred.resolve();
	  })();

	  return promise.all(outstanding);
	};

	/**
	 * Like XPCOMUtils.defineLazyGetter, but with a |this| sensitive getter that
	 * allows the lazy getter to be defined on a prototype and work correctly with
	 * instances.
	 *
	 * @param Object aObject
	 *        The prototype object to define the lazy getter on.
	 * @param String aKey
	 *        The key to define the lazy getter on.
	 * @param Function aCallback
	 *        The callback that will be called to determine the value. Will be
	 *        called with the |this| value of the current instance.
	 */
	exports.defineLazyPrototypeGetter = function defineLazyPrototypeGetter(aObject, aKey, aCallback) {
	  Object.defineProperty(aObject, aKey, {
	    configurable: true,
	    get: function () {
	      const value = aCallback.call(this);

	      Object.defineProperty(this, aKey, {
	        configurable: true,
	        writable: true,
	        value: value
	      });

	      return value;
	    }
	  });
	};

	/**
	 * Safely get the property value from a Debugger.Object for a given key. Walks
	 * the prototype chain until the property is found.
	 *
	 * @param Debugger.Object aObject
	 *        The Debugger.Object to get the value from.
	 * @param String aKey
	 *        The key to look for.
	 * @return Any
	 */
	exports.getProperty = function getProperty(aObj, aKey) {
	  let root = aObj;
	  try {
	    do {
	      const desc = aObj.getOwnPropertyDescriptor(aKey);
	      if (desc) {
	        if ("value" in desc) {
	          return desc.value;
	        }
	        // Call the getter if it's safe.
	        return exports.hasSafeGetter(desc) ? desc.get.call(root).return : undefined;
	      }
	      aObj = aObj.proto;
	    } while (aObj);
	  } catch (e) {
	    // If anything goes wrong report the error and return undefined.
	    exports.reportException("getProperty", e);
	  }
	  return undefined;
	};

	/**
	 * Determines if a descriptor has a getter which doesn't call into JavaScript.
	 *
	 * @param Object aDesc
	 *        The descriptor to check for a safe getter.
	 * @return Boolean
	 *         Whether a safe getter was found.
	 */
	exports.hasSafeGetter = function hasSafeGetter(aDesc) {
	  // Scripted functions that are CCWs will not appear scripted until after
	  // unwrapping.
	  try {
	    let fn = aDesc.get.unwrap();
	    return fn && fn.callable && fn.class == "Function" && fn.script === undefined;
	  } catch (e) {
	    // Avoid exception 'Object in compartment marked as invisible to Debugger'
	    return false;
	  }
	};

	/**
	 * Check if it is safe to read properties and execute methods from the given JS
	 * object. Safety is defined as being protected from unintended code execution
	 * from content scripts (or cross-compartment code).
	 *
	 * See bugs 945920 and 946752 for discussion.
	 *
	 * @type Object aObj
	 *       The object to check.
	 * @return Boolean
	 *         True if it is safe to read properties from aObj, or false otherwise.
	 */
	exports.isSafeJSObject = function isSafeJSObject(aObj) {
	  // If we are running on a worker thread, Cu is not available. In this case,
	  // we always return false, just to be on the safe side.
	  if (isWorker) {
	    return false;
	  }

	  if (Cu.getGlobalForObject(aObj) == Cu.getGlobalForObject(exports.isSafeJSObject)) {
	    return true; // aObj is not a cross-compartment wrapper.
	  }

	  let principal = Cu.getObjectPrincipal(aObj);
	  if (Services.scriptSecurityManager.isSystemPrincipal(principal)) {
	    return true; // allow chrome objects
	  }

	  return Cu.isXrayWrapper(aObj);
	};

	exports.dumpn = function dumpn(str) {
	  if (exports.dumpn.wantLogging) {
	    console.log("DBG-SERVER: " + str + "\n");
	  }
	};

	// We want wantLogging to be writable. The exports object is frozen by the
	// loader, so define it on dumpn instead.
	exports.dumpn.wantLogging = false;

	/**
	 * A verbose logger for low-level tracing.
	 */
	exports.dumpv = function (msg) {
	  if (exports.dumpv.wantVerbose) {
	    exports.dumpn(msg);
	  }
	};

	// We want wantLogging to be writable. The exports object is frozen by the
	// loader, so define it on dumpn instead.
	exports.dumpv.wantVerbose = false;

	/**
	 * Utility function for updating an object with the properties of
	 * other objects.
	 *
	 * @param aTarget Object
	 *        The object being updated.
	 * @param aNewAttrs Object
	 *        The rest params are objects to update aTarget with. You
	 *        can pass as many as you like.
	 */
	exports.update = function update(aTarget, ...aArgs) {
	  for (let attrs of aArgs) {
	    for (let key in attrs) {
	      let desc = Object.getOwnPropertyDescriptor(attrs, key);

	      if (desc) {
	        Object.defineProperty(aTarget, key, desc);
	      }
	    }
	  }

	  return aTarget;
	};

	/**
	 * Utility function for getting the values from an object as an array
	 *
	 * @param aObject Object
	 *        The object to iterate over
	 */
	exports.values = function values(aObject) {
	  return Object.keys(aObject).map(function (k) {
	    return aObject[k];
	  });
	};

	/**
	 * Defines a getter on a specified object that will be created upon first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject.
	 * @param aLambda
	 *        A function that returns what the getter should return.  This will
	 *        only ever be called once.
	 */
	exports.defineLazyGetter = function defineLazyGetter(aObject, aName, aLambda) {
	  Object.defineProperty(aObject, aName, {
	    get: function () {
	      delete aObject[aName];
	      return aObject[aName] = aLambda.apply(aObject);
	    },
	    configurable: true,
	    enumerable: true
	  });
	};

	// DEPRECATED: use DevToolsUtils.assert(condition, message) instead!
	let haveLoggedDeprecationMessage = false;
	exports.dbg_assert = function dbg_assert(cond, e) {
	  if (!haveLoggedDeprecationMessage) {
	    haveLoggedDeprecationMessage = true;
	    const deprecationMessage = "DevToolsUtils.dbg_assert is deprecated! Use DevToolsUtils.assert instead!\n" + Error().stack;
	    dump(deprecationMessage);
	    if (typeof console === "object" && console && console.warn) {
	      console.warn(deprecationMessage);
	    }
	  }

	  if (!cond) {
	    return e;
	  }
	};

	var _require3 = __webpack_require__(21);

	const AppConstants = _require3.AppConstants;

	/**
	 * No operation. The empty function.
	 */

	exports.noop = function () {};

	function reallyAssert(condition, message) {
	  if (!condition) {
	    const err = new Error("Assertion failure: " + message);
	    exports.reportException("DevToolsUtils.assert", err);
	    throw err;
	  }
	}

	/**
	 * DevToolsUtils.assert(condition, message)
	 *
	 * @param Boolean condition
	 * @param String message
	 *
	 * Assertions are enabled when any of the following are true:
	 *   - This is a DEBUG_JS_MODULES build
	 *   - This is a DEBUG build
	 *   - DevToolsUtils.testing is set to true
	 *
	 * If assertions are enabled, then `condition` is checked and if false-y, the
	 * assertion failure is logged and then an error is thrown.
	 *
	 * If assertions are not enabled, then this function is a no-op.
	 *
	 * This is an improvement over `dbg_assert`, which doesn't actually cause any
	 * fatal behavior, and is therefore much easier to accidentally ignore.
	 */
	Object.defineProperty(exports, "assert", {
	  get: function () {
	    return AppConstants.DEBUG || AppConstants.DEBUG_JS_MODULES || _this.testing ? reallyAssert : exports.noop;
	  }
	});

	/**
	 * Defines a getter on a specified object for a module.  The module will not
	 * be imported until first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject for the module.
	 * @param aResource
	 *        The URL used to obtain the module.
	 * @param aSymbol
	 *        The name of the symbol exported by the module.
	 *        This parameter is optional and defaults to aName.
	 */
	exports.defineLazyModuleGetter = function defineLazyModuleGetter(aObject, aName, aResource, aSymbol) {
	  this.defineLazyGetter(aObject, aName, function XPCU_moduleLambda() {
	    var temp = {};
	    Cu.import(aResource, temp);
	    return temp[aSymbol || aName];
	  });
	};

	var _require4 = __webpack_require__(22);

	const NetUtil = _require4.NetUtil;

	var _require5 = __webpack_require__(23);

	const TextDecoder = _require5.TextDecoder;
	const OS = _require5.OS;

	exports.defineLazyGetter(this, "NetworkHelper", function () {
	  return __webpack_require__(24);
	});

	/**
	 * Performs a request to load the desired URL and returns a promise.
	 *
	 * @param aURL String
	 *        The URL we will request.
	 * @param aOptions Object
	 *        An object with the following optional properties:
	 *        - loadFromCache: if false, will bypass the cache and
	 *          always load fresh from the network (default: true)
	 *        - policy: the nsIContentPolicy type to apply when fetching the URL
	 *        - window: the window to get the loadGroup from
	 *        - charset: the charset to use if the channel doesn't provide one
	 * @returns Promise that resolves with an object with the following members on
	 *          success:
	 *           - content: the document at that URL, as a string,
	 *           - contentType: the content type of the document
	 *
	 *          If an error occurs, the promise is rejected with that error.
	 *
	 * XXX: It may be better to use nsITraceableChannel to get to the sources
	 * without relying on caching when we can (not for eval, etc.):
	 * http://www.softwareishard.com/blog/firebug/nsitraceablechannel-intercept-http-traffic/
	 */
	function mainThreadFetch(aURL, aOptions = { loadFromCache: true,
	  policy: Ci.nsIContentPolicy.TYPE_OTHER,
	  window: null,
	  charset: null }) {
	  // Create a channel.
	  let url = aURL.split(" -> ").pop();
	  let channel;
	  try {
	    channel = newChannelForURL(url, aOptions);
	  } catch (ex) {
	    return promise.reject(ex);
	  }

	  // Set the channel options.
	  channel.loadFlags = aOptions.loadFromCache ? channel.LOAD_FROM_CACHE : channel.LOAD_BYPASS_CACHE;

	  if (aOptions.window) {
	    // Respect private browsing.
	    channel.loadGroup = aOptions.window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocumentLoader).loadGroup;
	  }

	  let deferred = promise.defer();
	  let onResponse = function (stream, status, request) {
	    if (!components.isSuccessCode(status)) {
	      deferred.reject(new Error(`Failed to fetch ${ url }. Code ${ status }.`));
	      return;
	    }

	    try {
	      // We cannot use NetUtil to do the charset conversion as if charset
	      // information is not available and our default guess is wrong the method
	      // might fail and we lose the stream data. This means we can't fall back
	      // to using the locale default encoding (bug 1181345).

	      // Read and decode the data according to the locale default encoding.
	      let available = stream.available();
	      let source = NetUtil.readInputStreamToString(stream, available);
	      stream.close();

	      // If the channel or the caller has correct charset information, the
	      // content will be decoded correctly. If we have to fall back to UTF-8 and
	      // the guess is wrong, the conversion fails and convertToUnicode returns
	      // the input unmodified. Essentially we try to decode the data as UTF-8
	      // and if that fails, we use the locale specific default encoding. This is
	      // the best we can do if the source does not provide charset info.
	      let charset = channel.contentCharset || aOptions.charset || "UTF-8";
	      let unicodeSource = NetworkHelper.convertToUnicode(source, charset);

	      deferred.resolve({
	        content: unicodeSource,
	        contentType: request.contentType
	      });
	    } catch (ex) {
	      let uri = request.originalURI;
	      if (ex.name === "NS_BASE_STREAM_CLOSED" && uri instanceof Ci.nsIFileURL) {
	        // Empty files cause NS_BASE_STREAM_CLOSED exception. Use OS.File to
	        // differentiate between empty files and other errors (bug 1170864).
	        // This can be removed when bug 982654 is fixed.

	        uri.QueryInterface(Ci.nsIFileURL);
	        let result = OS.File.read(uri.file.path).then(function (bytes) {
	          // Convert the bytearray to a String.
	          let decoder = new TextDecoder();
	          let content = decoder.decode(bytes);

	          // We can't detect the contentType without opening a channel
	          // and that failed already. This is the best we can do here.
	          return {
	            content,
	            contentType: "text/plain"
	          };
	        });

	        deferred.resolve(result);
	      } else {
	        deferred.reject(ex);
	      }
	    }
	  };

	  // Open the channel
	  try {
	    NetUtil.asyncFetch(channel, onResponse);
	  } catch (ex) {
	    return promise.reject(ex);
	  }

	  return deferred.promise;
	}

	/**
	 * Opens a channel for given URL. Tries a bit harder than NetUtil.newChannel.
	 *
	 * @param {String} url - The URL to open a channel for.
	 * @param {Object} options - The options object passed to @method fetch.
	 * @return {nsIChannel} - The newly created channel. Throws on failure.
	 */
	function newChannelForURL(url, { policy }) {
	  let channelOptions = {
	    contentPolicyType: policy,
	    loadUsingSystemPrincipal: true,
	    uri: url
	  };

	  try {
	    return NetUtil.newChannel(channelOptions);
	  } catch (e) {
	    // In the xpcshell tests, the script url is the absolute path of the test
	    // file, which will make a malformed URI error be thrown. Add the file
	    // scheme to see if it helps.
	    channelOptions.uri = "file://" + url;

	    return NetUtil.newChannel(channelOptions);
	  }
	}

	// Fetch is defined differently depending on whether we are on the main thread
	// or a worker thread.
	if (!this.isWorker) {
	  exports.fetch = mainThreadFetch;
	} else {
	  // Services is not available in worker threads, nor is there any other way
	  // to fetch a URL. We need to enlist the help from the main thread here, by
	  // issuing an rpc request, to fetch the URL on our behalf.
	  exports.fetch = function (url, options) {
	    return rpc("fetch", url, options);
	  };
	}

	/**
	 * Returns a promise that is resolved or rejected when all promises have settled
	 * (resolved or rejected).
	 *
	 * This differs from Promise.all, which will reject immediately after the first
	 * rejection, instead of waiting for the remaining promises to settle.
	 *
	 * @param values
	 *        Iterable of promises that may be pending, resolved, or rejected. When
	 *        when all promises have settled (resolved or rejected), the returned
	 *        promise will be resolved or rejected as well.
	 *
	 * @return A new promise that is fulfilled when all values have settled
	 *         (resolved or rejected). Its resolution value will be an array of all
	 *         resolved values in the given order, or undefined if values is an
	 *         empty array. The reject reason will be forwarded from the first
	 *         promise in the list of given promises to be rejected.
	 */
	exports.settleAll = function (values) {
	  if (values === null || typeof values[Symbol.iterator] != "function") {
	    throw new Error("settleAll() expects an iterable.");
	  }

	  let deferred = promise.defer();

	  values = Array.isArray(values) ? values : [...values];
	  let countdown = values.length;
	  let resolutionValues = new Array(countdown);
	  let rejectionValue;
	  let rejectionOccurred = false;

	  if (!countdown) {
	    deferred.resolve(resolutionValues);
	    return deferred.promise;
	  }

	  function checkForCompletion() {
	    if (--countdown > 0) {
	      return;
	    }
	    if (!rejectionOccurred) {
	      deferred.resolve(resolutionValues);
	    } else {
	      deferred.reject(rejectionValue);
	    }
	  }

	  for (let i = 0; i < values.length; i++) {
	    let index = i;
	    let value = values[i];
	    let resolver = function (result) {
	      resolutionValues[index] = result;
	      checkForCompletion();
	    };
	    let rejecter = function (error) {
	      if (!rejectionOccurred) {
	        rejectionValue = error;
	        rejectionOccurred = true;
	      }
	      checkForCompletion();
	    };

	    if (value && typeof value.then == "function") {
	      value.then(resolver, rejecter);
	    } else {
	      // Given value is not a promise, forward it as a resolution value.
	      resolver(value);
	    }
	  }

	  return deferred.promise;
	};

	/**
	 * When the testing flag is set, various behaviors may be altered from
	 * production mode, typically to enable easier testing or enhanced debugging.
	 */
	var testing = false;
	Object.defineProperty(exports, "testing", {
	  get: function () {
	    return testing;
	  },
	  set: function (state) {
	    testing = state;
	  }
	});

	/**
	 * Open the file at the given path for reading.
	 *
	 * @param {String} filePath
	 *
	 * @returns Promise<nsIInputStream>
	 */
	exports.openFileStream = function (filePath) {
	  return new Promise(function (resolve, reject) {
	    const uri = NetUtil.newURI(new FileUtils.File(filePath));
	    NetUtil.asyncFetch({ uri, loadUsingSystemPrincipal: true }, function (stream, result) {
	      if (!components.isSuccessCode(result)) {
	        reject(new Error(`Could not open "${ filePath }": result = ${ result }`));
	        return;
	      }

	      resolve(stream);
	    });
	  });
	};

	exports.isGenerator = function (fn) {
	  if (typeof fn !== "function") {
	    return false;
	  }
	  let proto = Object.getPrototypeOf(fn);
	  if (!proto) {
	    return false;
	  }
	  let ctor = proto.constructor;
	  if (!ctor) {
	    return false;
	  }
	  return ctor.name == "GeneratorFunction";
	};

	exports.isPromise = function (p) {
	  return p && typeof p.then === "function";
	};

	/**
	 * Return true if `thing` is a SavedFrame, false otherwise.
	 */
	exports.isSavedFrame = function (thing) {
	  return Object.prototype.toString.call(thing) === "[object SavedFrame]";
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/FileUtils.jsm
	 */
	"use strict";

/***/ },
/* 21 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/AppConstants.jsm
	 */
	"use strict";

/***/ },
/* 22 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/netwerk/base/NetUtil.jsm
	 */
	"use strict";

/***/ },
/* 23 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/components/osfile/osfile.jsm
	 */
	"use strict";

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* vim:set ts=2 sw=2 sts=2 et: */
	/*
	 * Software License Agreement (BSD License)
	 *
	 * Copyright (c) 2007, Parakey Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use of this software in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer.
	 *
	 * * Redistributions in binary form must reproduce the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer in the documentation and/or other
	 *   materials provided with the distribution.
	 *
	 * * Neither the name of Parakey Inc. nor the names of its
	 *   contributors may be used to endorse or promote products
	 *   derived from this software without specific prior
	 *   written permission of Parakey Inc.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
	 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
	 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
	 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
	 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	/*
	 * Creator:
	 *  Joe Hewitt
	 * Contributors
	 *  John J. Barton (IBM Almaden)
	 *  Jan Odvarko (Mozilla Corp.)
	 *  Max Stepanov (Aptana Inc.)
	 *  Rob Campbell (Mozilla Corp.)
	 *  Hans Hillen (Paciello Group, Mozilla)
	 *  Curtis Bartley (Mozilla Corp.)
	 *  Mike Collins (IBM Almaden)
	 *  Kevin Decker
	 *  Mike Ratcliffe (Comartis AG)
	 *  Hernan Rodríguez Colmeiro
	 *  Austin Andrews
	 *  Christoph Dorn
	 *  Steven Roussey (AppCenter Inc, Network54)
	 *  Mihai Sucan (Mozilla Corp.)
	 */

	"use strict";

	var _require = __webpack_require__(1);

	const components = _require.components;
	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	var _require2 = __webpack_require__(22);

	const NetUtil = _require2.NetUtil;

	const DevToolsUtils = __webpack_require__(19);

	// The cache used in the `nsIURL` function.
	const gNSURLStore = new Map();

	/**
	 * Helper object for networking stuff.
	 *
	 * Most of the following functions have been taken from the Firebug source. They
	 * have been modified to match the Firefox coding rules.
	 */
	var NetworkHelper = {
	  /**
	   * Converts aText with a given aCharset to unicode.
	   *
	   * @param string aText
	   *        Text to convert.
	   * @param string aCharset
	   *        Charset to convert the text to.
	   * @returns string
	   *          Converted text.
	   */
	  convertToUnicode: function NH_convertToUnicode(aText, aCharset) {
	    let conv = Cc("@mozilla.org/intl/scriptableunicodeconverter").createInstance(Ci.nsIScriptableUnicodeConverter);
	    try {
	      conv.charset = aCharset || "UTF-8";
	      return conv.ConvertToUnicode(aText);
	    } catch (ex) {
	      return aText;
	    }
	  },

	  /**
	   * Reads all available bytes from aStream and converts them to aCharset.
	   *
	   * @param nsIInputStream aStream
	   * @param string aCharset
	   * @returns string
	   *          UTF-16 encoded string based on the content of aStream and aCharset.
	   */
	  readAndConvertFromStream: function NH_readAndConvertFromStream(aStream, aCharset) {
	    let text = null;
	    try {
	      text = NetUtil.readInputStreamToString(aStream, aStream.available());
	      return this.convertToUnicode(text, aCharset);
	    } catch (err) {
	      return text;
	    }
	  },

	  /**
	  * Reads the posted text from aRequest.
	  *
	  * @param nsIHttpChannel aRequest
	  * @param string aCharset
	  *        The content document charset, used when reading the POSTed data.
	  * @returns string or null
	  *          Returns the posted string if it was possible to read from aRequest
	  *          otherwise null.
	  */
	  readPostTextFromRequest: function NH_readPostTextFromRequest(aRequest, aCharset) {
	    if (aRequest instanceof Ci.nsIUploadChannel) {
	      let iStream = aRequest.uploadStream;

	      let isSeekableStream = false;
	      if (iStream instanceof Ci.nsISeekableStream) {
	        isSeekableStream = true;
	      }

	      let prevOffset;
	      if (isSeekableStream) {
	        prevOffset = iStream.tell();
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }

	      // Read data from the stream.
	      let text = this.readAndConvertFromStream(iStream, aCharset);

	      // Seek locks the file, so seek to the beginning only if necko hasn't
	      // read it yet, since necko doesn't seek to 0 before reading (at lest
	      // not till 459384 is fixed).
	      if (isSeekableStream && prevOffset == 0) {
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }
	      return text;
	    }
	    return null;
	  },

	  /**
	   * Reads the posted text from the page's cache.
	   *
	   * @param nsIDocShell aDocShell
	   * @param string aCharset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          aDocShell otherwise null.
	   */
	  readPostTextFromPage: function NH_readPostTextFromPage(aDocShell, aCharset) {
	    let webNav = aDocShell.QueryInterface(Ci.nsIWebNavigation);
	    return this.readPostTextFromPageViaWebNav(webNav, aCharset);
	  },

	  /**
	   * Reads the posted text from the page's cache, given an nsIWebNavigation
	   * object.
	   *
	   * @param nsIWebNavigation aWebNav
	   * @param string aCharset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          aWebNav, otherwise null.
	   */
	  readPostTextFromPageViaWebNav: function NH_readPostTextFromPageViaWebNav(aWebNav, aCharset) {
	    if (aWebNav instanceof Ci.nsIWebPageDescriptor) {
	      let descriptor = aWebNav.currentDescriptor;

	      if (descriptor instanceof Ci.nsISHEntry && descriptor.postData && descriptor instanceof Ci.nsISeekableStream) {
	        descriptor.seek(NS_SEEK_SET, 0);

	        return this.readAndConvertFromStream(descriptor, aCharset);
	      }
	    }
	    return null;
	  },

	  /**
	   * Gets the web appId that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns number|null
	   *          The appId for the given request, if available.
	   */
	  getAppIdForRequest: function NH_getAppIdForRequest(aRequest) {
	    try {
	      return this.getRequestLoadContext(aRequest).appId;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },

	  /**
	   * Gets the topFrameElement that is associated with aRequest. This
	   * works in single-process and multiprocess contexts. It may cross
	   * the content/chrome boundary.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsIDOMElement|null
	   *          The top frame element for the given request.
	   */
	  getTopFrameForRequest: function NH_getTopFrameForRequest(aRequest) {
	    try {
	      return this.getRequestLoadContext(aRequest).topFrameElement;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },

	  /**
	   * Gets the nsIDOMWindow that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsIDOMWindow or null
	   */
	  getWindowForRequest: function NH_getWindowForRequest(aRequest) {
	    try {
	      return this.getRequestLoadContext(aRequest).associatedWindow;
	    } catch (ex) {
	      // TODO: bug 802246 - getWindowForRequest() throws on b2g: there is no
	      // associatedWindow property.
	    }
	    return null;
	  },

	  /**
	   * Gets the nsILoadContext that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsILoadContext or null
	   */
	  getRequestLoadContext: function NH_getRequestLoadContext(aRequest) {
	    try {
	      return aRequest.notificationCallbacks.getInterface(Ci.nsILoadContext);
	    } catch (ex) {}

	    try {
	      return aRequest.loadGroup.notificationCallbacks.getInterface(Ci.nsILoadContext);
	    } catch (ex) {}

	    return null;
	  },

	  /**
	   * Determines whether the request has been made for the top level document.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns Boolean True if the request represents the top level document.
	   */
	  isTopLevelLoad: function (aRequest) {
	    if (aRequest instanceof Ci.nsIChannel) {
	      let loadInfo = aRequest.loadInfo;
	      if (loadInfo && loadInfo.parentOuterWindowID == loadInfo.outerWindowID) {
	        return aRequest.loadFlags & Ci.nsIChannel.LOAD_DOCUMENT_URI;
	      }
	    }

	    return false;
	  },

	  /**
	   * Loads the content of aUrl from the cache.
	   *
	   * @param string aUrl
	   *        URL to load the cached content for.
	   * @param string aCharset
	   *        Assumed charset of the cached content. Used if there is no charset
	   *        on the channel directly.
	   * @param function aCallback
	   *        Callback that is called with the loaded cached content if available
	   *        or null if something failed while getting the cached content.
	   */
	  loadFromCache: function NH_loadFromCache(aUrl, aCharset, aCallback) {
	    var _this = this;

	    let channel = NetUtil.newChannel({ uri: aUrl, loadUsingSystemPrincipal: true });

	    // Ensure that we only read from the cache and not the server.
	    channel.loadFlags = Ci.nsIRequest.LOAD_FROM_CACHE | Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE | Ci.nsICachingChannel.LOAD_BYPASS_LOCAL_CACHE_IF_BUSY;

	    NetUtil.asyncFetch(channel, function (aInputStream, aStatusCode, aRequest) {
	      if (!components.isSuccessCode(aStatusCode)) {
	        aCallback(null);
	        return;
	      }

	      // Try to get the encoding from the channel. If there is none, then use
	      // the passed assumed aCharset.
	      let aChannel = aRequest.QueryInterface(Ci.nsIChannel);
	      let contentCharset = aChannel.contentCharset || aCharset;

	      // Read the content of the stream using contentCharset as encoding.
	      aCallback(_this.readAndConvertFromStream(aInputStream, contentCharset));
	    });
	  },

	  /**
	   * Parse a raw Cookie header value.
	   *
	   * @param string aHeader
	   *        The raw Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name and value.
	   */
	  parseCookieHeader: function NH_parseCookieHeader(aHeader) {
	    let cookies = aHeader.split(";");
	    let result = [];

	    cookies.forEach(function (aCookie) {
	      let equal = aCookie.indexOf("=");
	      let name = aCookie.substr(0, equal);
	      let value = aCookie.substr(equal + 1);
	      result.push({ name: unescape(name.trim()),
	        value: unescape(value.trim()) });
	    });

	    return result;
	  },

	  /**
	   * Parse a raw Set-Cookie header value.
	   *
	   * @param string aHeader
	   *        The raw Set-Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name, value, secure (boolean), httpOnly
	   *         (boolean), path, domain and expires (ISO date string).
	   */
	  parseSetCookieHeader: function NH_parseSetCookieHeader(aHeader) {
	    let rawCookies = aHeader.split(/\r\n|\n|\r/);
	    let cookies = [];

	    rawCookies.forEach(function (aCookie) {
	      let equal = aCookie.indexOf("=");
	      let name = unescape(aCookie.substr(0, equal).trim());
	      let parts = aCookie.substr(equal + 1).split(";");
	      let value = unescape(parts.shift().trim());

	      let cookie = { name: name, value: value };

	      parts.forEach(function (aPart) {
	        let part = aPart.trim();
	        if (part.toLowerCase() == "secure") {
	          cookie.secure = true;
	        } else if (part.toLowerCase() == "httponly") {
	          cookie.httpOnly = true;
	        } else if (part.indexOf("=") > -1) {
	          let pair = part.split("=");
	          pair[0] = pair[0].toLowerCase();
	          if (pair[0] == "path" || pair[0] == "domain") {
	            cookie[pair[0]] = pair[1];
	          } else if (pair[0] == "expires") {
	            try {
	              pair[1] = pair[1].replace(/-/g, ' ');
	              cookie.expires = new Date(pair[1]).toISOString();
	            } catch (ex) {}
	          }
	        }
	      });

	      cookies.push(cookie);
	    });

	    return cookies;
	  },

	  // This is a list of all the mime category maps jviereck could find in the
	  // firebug code base.
	  mimeCategoryMap: {
	    "text/plain": "txt",
	    "text/html": "html",
	    "text/xml": "xml",
	    "text/xsl": "txt",
	    "text/xul": "txt",
	    "text/css": "css",
	    "text/sgml": "txt",
	    "text/rtf": "txt",
	    "text/x-setext": "txt",
	    "text/richtext": "txt",
	    "text/javascript": "js",
	    "text/jscript": "txt",
	    "text/tab-separated-values": "txt",
	    "text/rdf": "txt",
	    "text/xif": "txt",
	    "text/ecmascript": "js",
	    "text/vnd.curl": "txt",
	    "text/x-json": "json",
	    "text/x-js": "txt",
	    "text/js": "txt",
	    "text/vbscript": "txt",
	    "view-source": "txt",
	    "view-fragment": "txt",
	    "application/xml": "xml",
	    "application/xhtml+xml": "xml",
	    "application/atom+xml": "xml",
	    "application/rss+xml": "xml",
	    "application/vnd.mozilla.maybe.feed": "xml",
	    "application/vnd.mozilla.xul+xml": "xml",
	    "application/javascript": "js",
	    "application/x-javascript": "js",
	    "application/x-httpd-php": "txt",
	    "application/rdf+xml": "xml",
	    "application/ecmascript": "js",
	    "application/http-index-format": "txt",
	    "application/json": "json",
	    "application/x-js": "txt",
	    "multipart/mixed": "txt",
	    "multipart/x-mixed-replace": "txt",
	    "image/svg+xml": "svg",
	    "application/octet-stream": "bin",
	    "image/jpeg": "image",
	    "image/jpg": "image",
	    "image/gif": "image",
	    "image/png": "image",
	    "image/bmp": "image",
	    "application/x-shockwave-flash": "flash",
	    "video/x-flv": "flash",
	    "audio/mpeg3": "media",
	    "audio/x-mpeg-3": "media",
	    "video/mpeg": "media",
	    "video/x-mpeg": "media",
	    "audio/ogg": "media",
	    "application/ogg": "media",
	    "application/x-ogg": "media",
	    "application/x-midi": "media",
	    "audio/midi": "media",
	    "audio/x-mid": "media",
	    "audio/x-midi": "media",
	    "music/crescendo": "media",
	    "audio/wav": "media",
	    "audio/x-wav": "media",
	    "text/json": "json",
	    "application/x-json": "json",
	    "application/json-rpc": "json",
	    "application/x-web-app-manifest+json": "json",
	    "application/manifest+json": "json"
	  },

	  /**
	   * Check if the given MIME type is a text-only MIME type.
	   *
	   * @param string aMimeType
	   * @return boolean
	   */
	  isTextMimeType: function NH_isTextMimeType(aMimeType) {
	    if (aMimeType.indexOf("text/") == 0) {
	      return true;
	    }

	    // XML and JSON often come with custom MIME types, so in addition to the
	    // standard "application/xml" and "application/json", we also look for
	    // variants like "application/x-bigcorp+xml". For JSON we allow "+json" and
	    // "-json" as suffixes.
	    if (/^application\/\w+(?:[\.-]\w+)*(?:\+xml|[-+]json)$/.test(aMimeType)) {
	      return true;
	    }

	    let category = this.mimeCategoryMap[aMimeType] || null;
	    switch (category) {
	      case "txt":
	      case "js":
	      case "json":
	      case "css":
	      case "html":
	      case "svg":
	      case "xml":
	        return true;

	      default:
	        return false;
	    }
	  },

	  /**
	   * Takes a securityInfo object of nsIRequest, the nsIRequest itself and
	   * extracts security information from them.
	   *
	   * @param object securityInfo
	   *        The securityInfo object of a request. If null channel is assumed
	   *        to be insecure.
	   * @param object httpActivity
	   *        The httpActivity object for the request with at least members
	   *        { private, hostname }.
	   *
	   * @return object
	   *         Returns an object containing following members:
	   *          - state: The security of the connection used to fetch this
	   *                   request. Has one of following string values:
	   *                    * "insecure": the connection was not secure (only http)
	   *                    * "weak": the connection has minor security issues
	   *                    * "broken": secure connection failed (e.g. expired cert)
	   *                    * "secure": the connection was properly secured.
	   *          If state == broken:
	   *            - errorMessage: full error message from nsITransportSecurityInfo.
	   *          If state == secure:
	   *            - protocolVersion: one of TLSv1, TLSv1.1, TLSv1.2.
	   *            - cipherSuite: the cipher suite used in this connection.
	   *            - cert: information about certificate used in this connection.
	   *                    See parseCertificateInfo for the contents.
	   *            - hsts: true if host uses Strict Transport Security, false otherwise
	   *            - hpkp: true if host uses Public Key Pinning, false otherwise
	   *          If state == weak: Same as state == secure and
	   *            - weaknessReasons: list of reasons that cause the request to be
	   *                               considered weak. See getReasonsForWeakness.
	   */
	  parseSecurityInfo: function NH_parseSecurityInfo(securityInfo, httpActivity) {
	    const info = {
	      state: "insecure"
	    };

	    // The request did not contain any security info.
	    if (!securityInfo) {
	      return info;
	    }

	    /**
	     * Different scenarios to consider here and how they are handled:
	     * - request is HTTP, the connection is not secure
	     *   => securityInfo is null
	     *      => state === "insecure"
	     *
	     * - request is HTTPS, the connection is secure
	     *   => .securityState has STATE_IS_SECURE flag
	     *      => state === "secure"
	     *
	     * - request is HTTPS, the connection has security issues
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is an NSS error code.
	     *      => state === "broken"
	     *
	     * - request is HTTPS, the connection was terminated before the security
	     *   could be validated
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is NOT an NSS error code.
	     *   => .errorMessage is not available.
	     *      => state === "insecure"
	     *
	     * - request is HTTPS but it uses a weak cipher or old protocol, see
	     *   http://hg.mozilla.org/mozilla-central/annotate/def6ed9d1c1a/
	     *   security/manager/ssl/nsNSSCallbacks.cpp#l1233
	     * - request is mixed content (which makes no sense whatsoever)
	     *   => .securityState has STATE_IS_BROKEN flag
	     *   => .errorCode is NOT an NSS error code
	     *   => .errorMessage is not available
	     *      => state === "weak"
	     */

	    securityInfo.QueryInterface(Ci.nsITransportSecurityInfo);
	    securityInfo.QueryInterface(Ci.nsISSLStatusProvider);

	    const wpl = Ci.nsIWebProgressListener;
	    const NSSErrorsService = Cc['@mozilla.org/nss_errors_service;1'].getService(Ci.nsINSSErrorsService);
	    const SSLStatus = securityInfo.SSLStatus;
	    if (!NSSErrorsService.isNSSErrorCode(securityInfo.errorCode)) {
	      const state = securityInfo.securityState;

	      let uri = null;
	      if (httpActivity.channel && httpActivity.channel.URI) {
	        uri = httpActivity.channel.URI;
	      }
	      if (uri && !uri.schemeIs("https") && !uri.schemeIs("wss")) {
	        // it is not enough to look at the transport security info - schemes other than
	        // https and wss are subject to downgrade/etc at the scheme level and should
	        // always be considered insecure
	        info.state = "insecure";
	      } else if (state & wpl.STATE_IS_SECURE) {
	        // The connection is secure if the scheme is sufficient
	        info.state = "secure";
	      } else if (state & wpl.STATE_IS_BROKEN) {
	        // The connection is not secure, there was no error but there's some
	        // minor security issues.
	        info.state = "weak";
	        info.weaknessReasons = this.getReasonsForWeakness(state);
	      } else if (state & wpl.STATE_IS_INSECURE) {
	        // This was most likely an https request that was aborted before
	        // validation. Return info as info.state = insecure.
	        return info;
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo", "Security state " + state + " has no known STATE_IS_* flags.");
	        return info;
	      }

	      // Cipher suite.
	      info.cipherSuite = SSLStatus.cipherName;

	      // Protocol version.
	      info.protocolVersion = this.formatSecurityProtocol(SSLStatus.protocolVersion);

	      // Certificate.
	      info.cert = this.parseCertificateInfo(SSLStatus.serverCert);

	      // HSTS and HPKP if available.
	      if (httpActivity.hostname) {
	        const sss = Cc("@mozilla.org/ssservice;1").getService(Ci.nsISiteSecurityService);

	        // SiteSecurityService uses different storage if the channel is
	        // private. Thus we must give isSecureHost correct flags or we
	        // might get incorrect results.
	        let flags = httpActivity.private ? Ci.nsISocketProvider.NO_PERMANENT_STORAGE : 0;

	        let host = httpActivity.hostname;

	        info.hsts = sss.isSecureHost(sss.HEADER_HSTS, host, flags);
	        info.hpkp = sss.isSecureHost(sss.HEADER_HPKP, host, flags);
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo", "Could not get HSTS/HPKP status as hostname is not available.");
	        info.hsts = false;
	        info.hpkp = false;
	      }
	    } else {
	      // The connection failed.
	      info.state = "broken";
	      info.errorMessage = securityInfo.errorMessage;
	    }

	    return info;
	  },

	  /**
	   * Takes an nsIX509Cert and returns an object with certificate information.
	   *
	   * @param nsIX509Cert cert
	   *        The certificate to extract the information from.
	   * @return object
	   *         An object with following format:
	   *           {
	   *             subject: { commonName, organization, organizationalUnit },
	   *             issuer: { commonName, organization, organizationUnit },
	   *             validity: { start, end },
	   *             fingerprint: { sha1, sha256 }
	   *           }
	   */
	  parseCertificateInfo: function NH_parseCertifificateInfo(cert) {
	    let info = {};
	    if (cert) {
	      info.subject = {
	        commonName: cert.commonName,
	        organization: cert.organization,
	        organizationalUnit: cert.organizationalUnit
	      };

	      info.issuer = {
	        commonName: cert.issuerCommonName,
	        organization: cert.issuerOrganization,
	        organizationUnit: cert.issuerOrganizationUnit
	      };

	      info.validity = {
	        start: cert.validity.notBeforeLocalDay,
	        end: cert.validity.notAfterLocalDay
	      };

	      info.fingerprint = {
	        sha1: cert.sha1Fingerprint,
	        sha256: cert.sha256Fingerprint
	      };
	    } else {
	      DevToolsUtils.reportException("NetworkHelper.parseCertificateInfo", "Secure connection established without certificate.");
	    }

	    return info;
	  },

	  /**
	   * Takes protocolVersion of SSLStatus object and returns human readable
	   * description.
	   *
	   * @param Number version
	   *        One of nsISSLStatus version constants.
	   * @return string
	   *         One of TLSv1, TLSv1.1, TLSv1.2 if @param version is valid,
	   *         Unknown otherwise.
	   */
	  formatSecurityProtocol: function NH_formatSecurityProtocol(version) {
	    switch (version) {
	      case Ci.nsISSLStatus.TLS_VERSION_1:
	        return "TLSv1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_1:
	        return "TLSv1.1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_2:
	        return "TLSv1.2";
	      default:
	        DevToolsUtils.reportException("NetworkHelper.formatSecurityProtocol", "protocolVersion " + version + " is unknown.");
	        return "Unknown";
	    }
	  },

	  /**
	   * Takes the securityState bitfield and returns reasons for weak connection
	   * as an array of strings.
	   *
	   * @param Number state
	   *        nsITransportSecurityInfo.securityState.
	   *
	   * @return Array[String]
	   *         List of weakness reasons. A subset of { cipher } where
	   *         * cipher: The cipher suite is consireded to be weak (RC4).
	   */
	  getReasonsForWeakness: function NH_getReasonsForWeakness(state) {
	    const wpl = Ci.nsIWebProgressListener;

	    // If there's non-fatal security issues the request has STATE_IS_BROKEN
	    // flag set. See http://hg.mozilla.org/mozilla-central/file/44344099d119
	    // /security/manager/ssl/nsNSSCallbacks.cpp#l1233
	    let reasons = [];

	    if (state & wpl.STATE_IS_BROKEN) {
	      let isCipher = state & wpl.STATE_USES_WEAK_CRYPTO;

	      if (isCipher) {
	        reasons.push("cipher");
	      }

	      if (!isCipher) {
	        DevToolsUtils.reportException("NetworkHelper.getReasonsForWeakness", "STATE_IS_BROKEN without a known reason. Full state was: " + state);
	      }
	    }

	    return reasons;
	  },

	  /**
	   * Parse a url's query string into its components
	   *
	   * @param string aQueryString
	   *        The query part of a url
	   * @return array
	   *         Array of query params {name, value}
	   */
	  parseQueryString: function (aQueryString) {
	    // Make sure there's at least one param available.
	    // Be careful here, params don't necessarily need to have values, so
	    // no need to verify the existence of a "=".
	    if (!aQueryString) {
	      return;
	    }

	    // Turn the params string into an array containing { name: value } tuples.
	    let paramsArray = aQueryString.replace(/^[?&]/, "").split("&").map(function (e) {
	      let param = e.split("=");
	      return {
	        name: param[0] ? NetworkHelper.convertToUnicode(unescape(param[0])) : "",
	        value: param[1] ? NetworkHelper.convertToUnicode(unescape(param[1])) : ""
	      };
	    });

	    return paramsArray;
	  },

	  /**
	   * Helper for getting an nsIURL instance out of a string.
	   */
	  nsIURL: function (aUrl, aStore = gNSURLStore) {
	    if (aStore.has(aUrl)) {
	      return aStore.get(aUrl);
	    }

	    let uri = Services.io.newURI(aUrl, null, null).QueryInterface(Ci.nsIURL);
	    aStore.set(aUrl, uri);
	    return uri;
	  }
	};

	for (let prop of Object.getOwnPropertyNames(NetworkHelper)) {
	  exports[prop] = NetworkHelper[prop];
	}

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const UNCAUGHT_ERROR = 'An error event was emitted for which there was no listener.';
	const BAD_LISTENER = 'The event listener must be a function.';

	var _require = __webpack_require__(27);

	const ns = _require.ns;

	const event = ns();

	const EVENT_TYPE_PATTERN = /^on([A-Z]\w+$)/;
	exports.EVENT_TYPE_PATTERN = EVENT_TYPE_PATTERN;

	// Utility function to access given event `target` object's event listeners for
	// the specific event `type`. If listeners for this type does not exists they
	// will be created.
	const observers = function observers(target, type) {
	  if (!target) throw TypeError("Event target must be an object");
	  let listeners = event(target);
	  return type in listeners ? listeners[type] : listeners[type] = [];
	};

	/**
	 * Registers an event `listener` that is called every time events of
	 * specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function on(target, type, listener) {
	  if (typeof listener !== 'function') throw new Error(BAD_LISTENER);

	  let listeners = observers(target, type);
	  if (! ~listeners.indexOf(listener)) listeners.push(listener);
	}
	exports.on = on;

	var onceWeakMap = new WeakMap();

	/**
	 * Registers an event `listener` that is called only the next time an event
	 * of the specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of the event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function once(target, type, listener) {
	  let replacement = function observer(...args) {
	    off(target, type, observer);
	    onceWeakMap.delete(listener);
	    listener.apply(target, args);
	  };
	  onceWeakMap.set(listener, replacement);
	  on(target, type, replacement);
	}
	exports.once = once;

	/**
	 * Execute each of the listeners in order with the supplied arguments.
	 * All the exceptions that are thrown by listeners during the emit
	 * are caught and can be handled by listeners of 'error' event. Thrown
	 * exceptions are passed as an argument to an 'error' event listener.
	 * If no 'error' listener is registered exception will be logged into an
	 * error console.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @params {Object|Number|String|Boolean} args
	 *    Arguments that will be passed to listeners.
	 */
	function emit(target, type, ...args) {
	  emitOnObject(target, type, target, ...args);
	}
	exports.emit = emit;

	/**
	 * A variant of emit that allows setting the this property for event listeners
	 */
	function emitOnObject(target, type, thisArg, ...args) {
	  let all = observers(target, '*').length;
	  let state = observers(target, type);
	  let listeners = state.slice();
	  let count = listeners.length;
	  let index = 0;

	  // If error event and there are no handlers (explicit or catch-all)
	  // then print error message to the console.
	  if (count === 0 && type === 'error' && all === 0) console.exception(args[0]);
	  while (index < count) {
	    try {
	      let listener = listeners[index];
	      // Dispatch only if listener is still registered.
	      if (~state.indexOf(listener)) listener.apply(thisArg, args);
	    } catch (error) {
	      // If exception is not thrown by a error listener and error listener is
	      // registered emit `error` event. Otherwise dump exception to the console.
	      if (type !== 'error') emit(target, 'error', error);else console.exception(error);
	    }
	    index++;
	  }
	  // Also emit on `"*"` so that one could listen for all events.
	  if (type !== '*') emit(target, '*', type, ...args);
	}
	exports.emitOnObject = emitOnObject;

	/**
	 * Removes an event `listener` for the given event `type` on the given event
	 * `target`. If no `listener` is passed removes all listeners of the given
	 * `type`. If `type` is not passed removes all the listeners of the given
	 * event `target`.
	 * @param {Object} target
	 *    The event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function off(target, type, listener) {
	  let length = arguments.length;
	  if (length === 3) {
	    if (onceWeakMap.has(listener)) {
	      listener = onceWeakMap.get(listener);
	      onceWeakMap.delete(listener);
	    }

	    let listeners = observers(target, type);
	    let index = listeners.indexOf(listener);
	    if (~index) listeners.splice(index, 1);
	  } else if (length === 2) {
	    observers(target, type).splice(0);
	  } else if (length === 1) {
	    let listeners = event(target);
	    Object.keys(listeners).forEach(function (type) {
	      return delete listeners[type];
	    });
	  }
	}
	exports.off = off;

	/**
	 * Returns a number of event listeners registered for the given event `type`
	 * on the given event `target`.
	 */
	function count(target, type) {
	  return observers(target, type).length;
	}
	exports.count = count;

	/**
	 * Registers listeners on the given event `target` from the given `listeners`
	 * dictionary. Iterates over the listeners and if property name matches name
	 * pattern `onEventType` and property is a function, then registers it as
	 * an `eventType` listener on `target`.
	 *
	 * @param {Object} target
	 *    The type of event.
	 * @param {Object} listeners
	 *    Dictionary of listeners.
	 */
	function setListeners(target, listeners) {
	  Object.keys(listeners || {}).forEach(function (key) {
	    let match = EVENT_TYPE_PATTERN.exec(key);
	    let type = match && match[1].toLowerCase();
	    if (!type) return;

	    let listener = listeners[key];
	    if (typeof listener === 'function') on(target, type, listener);
	  });
	}
	exports.setListeners = setListeners;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module)))

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const create = Object.create;
	const prototypeOf = Object.getPrototypeOf;

	/**
	 * Returns a new namespace, function that may can be used to access an
	 * namespaced object of the argument argument. Namespaced object are associated
	 * with owner objects via weak references. Namespaced objects inherit from the
	 * owners ancestor namespaced object. If owner's ancestor is `null` then
	 * namespaced object inherits from given `prototype`. Namespaces can be used
	 * to define internal APIs that can be shared via enclosing `namespace`
	 * function.
	 * @examples
	 *    const internals = ns();
	 *    internals(object).secret = secret;
	 */
	function ns() {
	  const map = new WeakMap();
	  return function namespace(target) {
	    if (!target) // If `target` is not an object return `target` itself.
	      return target;
	    // If target has no namespaced object yet, create one that inherits from
	    // the target prototype's namespaced object.
	    if (!map.has(target)) map.set(target, create(namespace(prototypeOf(target) || null)));

	    return map.get(target);
	  };
	};

	// `Namespace` is a e4x function in the scope, so we export the function also as
	// `ns` as alias to avoid clashing.
	exports.ns = ns;
	exports.Namespace = ns;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module)))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- js-indent-level: 2; indent-tabs-mode: nil -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	const DevToolsUtils = __webpack_require__(19);
	const EventEmitter = __webpack_require__(7);
	const promise = __webpack_require__(6);

	var _require2 = __webpack_require__(18);

	const LongStringClient = _require2.LongStringClient;

	/**
	 * A WebConsoleClient is used as a front end for the WebConsoleActor that is
	 * created on the server, hiding implementation details.
	 *
	 * @param object aDebuggerClient
	 *        The DebuggerClient instance we live for.
	 * @param object aResponse
	 *        The response packet received from the "startListeners" request sent to
	 *        the WebConsoleActor.
	 */

	function WebConsoleClient(aDebuggerClient, aResponse) {
	  this._actor = aResponse.from;
	  this._client = aDebuggerClient;
	  this._longStrings = {};
	  this.traits = aResponse.traits || {};
	  this.events = [];
	  this._networkRequests = new Map();

	  this.pendingEvaluationResults = new Map();
	  this.onEvaluationResult = this.onEvaluationResult.bind(this);
	  this.onNetworkEvent = this._onNetworkEvent.bind(this);
	  this.onNetworkEventUpdate = this._onNetworkEventUpdate.bind(this);

	  this._client.addListener("evaluationResult", this.onEvaluationResult);
	  this._client.addListener("networkEvent", this.onNetworkEvent);
	  this._client.addListener("networkEventUpdate", this.onNetworkEventUpdate);
	  EventEmitter.decorate(this);
	}

	exports.WebConsoleClient = WebConsoleClient;

	WebConsoleClient.prototype = {
	  _longStrings: null,
	  traits: null,

	  /**
	   * Holds the network requests currently displayed by the Web Console. Each key
	   * represents the connection ID and the value is network request information.
	   * @private
	   * @type object
	   */
	  _networkRequests: null,

	  getNetworkRequest(actorId) {
	    return this._networkRequests.get(actorId);
	  },

	  hasNetworkRequest(actorId) {
	    return this._networkRequests.has(actorId);
	  },

	  removeNetworkRequest(actorId) {
	    this._networkRequests.delete(actorId);
	  },

	  getNetworkEvents() {
	    return this._networkRequests.values();
	  },

	  get actor() {
	    return this._actor;
	  },

	  /**
	   * The "networkEvent" message type handler. We redirect any message to
	   * the UI for displaying.
	   *
	   * @private
	   * @param string type
	   *        Message type.
	   * @param object packet
	   *        The message received from the server.
	   */
	  _onNetworkEvent: function (type, packet) {
	    if (packet.from == this._actor) {
	      let actor = packet.eventActor;
	      let networkInfo = {
	        _type: "NetworkEvent",
	        timeStamp: actor.timeStamp,
	        node: null,
	        actor: actor.actor,
	        discardRequestBody: true,
	        discardResponseBody: true,
	        startedDateTime: actor.startedDateTime,
	        request: {
	          url: actor.url,
	          method: actor.method
	        },
	        isXHR: actor.isXHR,
	        response: {},
	        timings: {},
	        updates: [], // track the list of network event updates
	        private: actor.private,
	        fromCache: actor.fromCache
	      };
	      this._networkRequests.set(actor.actor, networkInfo);

	      this.emit("networkEvent", networkInfo);
	    }
	  },

	  /**
	   * The "networkEventUpdate" message type handler. We redirect any message to
	   * the UI for displaying.
	   *
	   * @private
	   * @param string type
	   *        Message type.
	   * @param object packet
	   *        The message received from the server.
	   */
	  _onNetworkEventUpdate: function (type, packet) {
	    let networkInfo = this.getNetworkRequest(packet.from);
	    if (!networkInfo) {
	      return;
	    }

	    networkInfo.updates.push(packet.updateType);

	    switch (packet.updateType) {
	      case "requestHeaders":
	        networkInfo.request.headersSize = packet.headersSize;
	        break;
	      case "requestPostData":
	        networkInfo.discardRequestBody = packet.discardRequestBody;
	        networkInfo.request.bodySize = packet.dataSize;
	        break;
	      case "responseStart":
	        networkInfo.response.httpVersion = packet.response.httpVersion;
	        networkInfo.response.status = packet.response.status;
	        networkInfo.response.statusText = packet.response.statusText;
	        networkInfo.response.headersSize = packet.response.headersSize;
	        networkInfo.response.remoteAddress = packet.response.remoteAddress;
	        networkInfo.response.remotePort = packet.response.remotePort;
	        networkInfo.discardResponseBody = packet.response.discardResponseBody;
	        break;
	      case "responseContent":
	        networkInfo.response.content = {
	          mimeType: packet.mimeType
	        };
	        networkInfo.response.bodySize = packet.contentSize;
	        networkInfo.response.transferredSize = packet.transferredSize;
	        networkInfo.discardResponseBody = packet.discardResponseBody;
	        break;
	      case "eventTimings":
	        networkInfo.totalTime = packet.totalTime;
	        break;
	      case "securityInfo":
	        networkInfo.securityInfo = packet.state;
	        break;
	    }

	    this.emit("networkEventUpdate", {
	      packet: packet,
	      networkInfo
	    });
	  },

	  /**
	   * Retrieve the cached messages from the server.
	   *
	   * @see this.CACHED_MESSAGES
	   * @param array types
	   *        The array of message types you want from the server. See
	   *        this.CACHED_MESSAGES for known types.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getCachedMessages: function WCC_getCachedMessages(types, aOnResponse) {
	    let packet = {
	      to: this._actor,
	      type: "getCachedMessages",
	      messageTypes: types
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Inspect the properties of an object.
	   *
	   * @param string aActor
	   *        The WebConsoleObjectActor ID to send the request to.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  inspectObjectProperties: function WCC_inspectObjectProperties(aActor, aOnResponse) {
	    let packet = {
	      to: aActor,
	      type: "inspectProperties"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Evaluate a JavaScript expression.
	   *
	   * @param string aString
	   *        The code you want to evaluate.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   * @param object [aOptions={}]
	   *        Options for evaluation:
	   *
	   *        - bindObjectActor: an ObjectActor ID. The OA holds a reference to
	   *        a Debugger.Object that wraps a content object. This option allows
	   *        you to bind |_self| to the D.O of the given OA, during string
	   *        evaluation.
	   *
	   *        See: Debugger.Object.executeInGlobalWithBindings() for information
	   *        about bindings.
	   *
	   *        Use case: the variable view needs to update objects and it does so
	   *        by knowing the ObjectActor it inspects and binding |_self| to the
	   *        D.O of the OA. As such, variable view sends strings like these for
	   *        eval:
	   *          _self["prop"] = value;
	   *
	   *        - frameActor: a FrameActor ID. The FA holds a reference to
	   *        a Debugger.Frame. This option allows you to evaluate the string in
	   *        the frame of the given FA.
	   *
	   *        - url: the url to evaluate the script as. Defaults to
	   *        "debugger eval code".
	   *
	   *        - selectedNodeActor: the NodeActor ID of the current selection in the
	   *        Inspector, if such a selection exists. This is used by helper functions
	   *        that can reference the currently selected node in the Inspector, like
	   *        $0.
	   */
	  evaluateJS: function WCC_evaluateJS(aString, aOnResponse, aOptions = {}) {
	    let packet = {
	      to: this._actor,
	      type: "evaluateJS",
	      text: aString,
	      bindObjectActor: aOptions.bindObjectActor,
	      frameActor: aOptions.frameActor,
	      url: aOptions.url,
	      selectedNodeActor: aOptions.selectedNodeActor,
	      selectedObjectActor: aOptions.selectedObjectActor
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Evaluate a JavaScript expression asynchronously.
	   * See evaluateJS for parameter and response information.
	   */
	  evaluateJSAsync: function (aString, aOnResponse, aOptions = {}) {
	    var _this = this;

	    // Pre-37 servers don't support async evaluation.
	    if (!this.traits.evaluateJSAsync) {
	      this.evaluateJS(aString, aOnResponse, aOptions);
	      return;
	    }

	    let packet = {
	      to: this._actor,
	      type: "evaluateJSAsync",
	      text: aString,
	      bindObjectActor: aOptions.bindObjectActor,
	      frameActor: aOptions.frameActor,
	      url: aOptions.url,
	      selectedNodeActor: aOptions.selectedNodeActor,
	      selectedObjectActor: aOptions.selectedObjectActor
	    };

	    this._client.request(packet, function (response) {
	      // Null check this in case the client has been detached while waiting
	      // for a response.
	      if (_this.pendingEvaluationResults) {
	        _this.pendingEvaluationResults.set(response.resultID, aOnResponse);
	      }
	    });
	  },

	  /**
	   * Handler for the actors's unsolicited evaluationResult packet.
	   */
	  onEvaluationResult: function (aNotification, aPacket) {
	    // The client on the main thread can receive notification packets from
	    // multiple webconsole actors: the one on the main thread and the ones
	    // on worker threads.  So make sure we should be handling this request.
	    if (aPacket.from !== this._actor) {
	      return;
	    }

	    // Find the associated callback based on this ID, and fire it.
	    // In a sync evaluation, this would have already been called in
	    // direct response to the client.request function.
	    let onResponse = this.pendingEvaluationResults.get(aPacket.resultID);
	    if (onResponse) {
	      onResponse(aPacket);
	      this.pendingEvaluationResults.delete(aPacket.resultID);
	    } else {
	      DevToolsUtils.reportException("onEvaluationResult", "No response handler for an evaluateJSAsync result (resultID: " + aPacket.resultID + ")");
	    }
	  },

	  /**
	   * Autocomplete a JavaScript expression.
	   *
	   * @param string aString
	   *        The code you want to autocomplete.
	   * @param number aCursor
	   *        Cursor location inside the string. Index starts from 0.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   * @param string aFrameActor
	   *        The id of the frame actor that made the call.
	   */
	  autocomplete: function WCC_autocomplete(aString, aCursor, aOnResponse, aFrameActor) {
	    let packet = {
	      to: this._actor,
	      type: "autocomplete",
	      text: aString,
	      cursor: aCursor,
	      frameActor: aFrameActor
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Clear the cache of messages (page errors and console API calls).
	   */
	  clearMessagesCache: function WCC_clearMessagesCache() {
	    let packet = {
	      to: this._actor,
	      type: "clearMessagesCache"
	    };
	    this._client.request(packet);
	  },

	  /**
	   * Get Web Console-related preferences on the server.
	   *
	   * @param array aPreferences
	   *        An array with the preferences you want to retrieve.
	   * @param function [aOnResponse]
	   *        Optional function to invoke when the response is received.
	   */
	  getPreferences: function WCC_getPreferences(aPreferences, aOnResponse) {
	    let packet = {
	      to: this._actor,
	      type: "getPreferences",
	      preferences: aPreferences
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Set Web Console-related preferences on the server.
	   *
	   * @param object aPreferences
	   *        An object with the preferences you want to change.
	   * @param function [aOnResponse]
	   *        Optional function to invoke when the response is received.
	   */
	  setPreferences: function WCC_setPreferences(aPreferences, aOnResponse) {
	    let packet = {
	      to: this._actor,
	      type: "setPreferences",
	      preferences: aPreferences
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the request headers from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestHeaders: function WCC_getRequestHeaders(aActor, aOnResponse) {
	    let packet = {
	      to: aActor,
	      type: "getRequestHeaders"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the request cookies from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestCookies: function WCC_getRequestCookies(aActor, aOnResponse) {
	    let packet = {
	      to: aActor,
	      type: "getRequestCookies"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the request post data from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestPostData: function WCC_getRequestPostData(aActor, aOnResponse) {
	    let packet = {
	      to: aActor,
	      type: "getRequestPostData"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the response headers from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseHeaders: function WCC_getResponseHeaders(aActor, aOnResponse) {
	    let packet = {
	      to: aActor,
	      type: "getResponseHeaders"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the response cookies from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseCookies: function WCC_getResponseCookies(aActor, aOnResponse) {
	    let packet = {
	      to: aActor,
	      type: "getResponseCookies"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the response content from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseContent: function WCC_getResponseContent(aActor, aOnResponse) {
	    let packet = {
	      to: aActor,
	      type: "getResponseContent"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the timing information for the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getEventTimings: function WCC_getEventTimings(aActor, aOnResponse) {
	    let packet = {
	      to: aActor,
	      type: "getEventTimings"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the security information for the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getSecurityInfo: function WCC_getSecurityInfo(aActor, aOnResponse) {
	    let packet = {
	      to: aActor,
	      type: "getSecurityInfo"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Send a HTTP request with the given data.
	   *
	   * @param string aData
	   *        The details of the HTTP request.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  sendHTTPRequest: function WCC_sendHTTPRequest(aData, aOnResponse) {
	    let packet = {
	      to: this._actor,
	      type: "sendHTTPRequest",
	      request: aData
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Start the given Web Console listeners.
	   *
	   * @see this.LISTENERS
	   * @param array aListeners
	   *        Array of listeners you want to start. See this.LISTENERS for
	   *        known listeners.
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  startListeners: function WCC_startListeners(aListeners, aOnResponse) {
	    let packet = {
	      to: this._actor,
	      type: "startListeners",
	      listeners: aListeners
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Stop the given Web Console listeners.
	   *
	   * @see this.LISTENERS
	   * @param array aListeners
	   *        Array of listeners you want to stop. See this.LISTENERS for
	   *        known listeners.
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  stopListeners: function WCC_stopListeners(aListeners, aOnResponse) {
	    let packet = {
	      to: this._actor,
	      type: "stopListeners",
	      listeners: aListeners
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Return an instance of LongStringClient for the given long string grip.
	   *
	   * @param object aGrip
	   *        The long string grip returned by the protocol.
	   * @return object
	   *         The LongStringClient for the given long string grip.
	   */
	  longString: function WCC_longString(aGrip) {
	    if (aGrip.actor in this._longStrings) {
	      return this._longStrings[aGrip.actor];
	    }

	    let client = new LongStringClient(this._client, aGrip);
	    this._longStrings[aGrip.actor] = client;
	    return client;
	  },

	  /**
	   * Close the WebConsoleClient. This stops all the listeners on the server and
	   * detaches from the console actor.
	   *
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  detach: function WCC_detach(aOnResponse) {
	    this._client.removeListener("evaluationResult", this.onEvaluationResult);
	    this._client.removeListener("networkEvent", this.onNetworkEvent);
	    this._client.removeListener("networkEventUpdate", this.onNetworkEventUpdate);
	    this.stopListeners(null, aOnResponse);
	    this._longStrings = null;
	    this._client = null;
	    this.pendingEvaluationResults.clear();
	    this.pendingEvaluationResults = null;
	    this.clearNetworkRequests();
	    this._networkRequests = null;
	  },

	  clearNetworkRequests: function () {
	    this._networkRequests.clear();
	  },

	  /**
	   * Fetches the full text of a LongString.
	   *
	   * @param object | string stringGrip
	   *        The long string grip containing the corresponding actor.
	   *        If you pass in a plain string (by accident or because you're lazy),
	   *        then a promise of the same string is simply returned.
	   * @return object Promise
	   *         A promise that is resolved when the full string contents
	   *         are available, or rejected if something goes wrong.
	   */
	  getString: function (stringGrip) {
	    // Make sure this is a long string.
	    if (typeof stringGrip != "object" || stringGrip.type != "longString") {
	      return promise.resolve(stringGrip); // Go home string, you're drunk.
	    }

	    // Fetch the long string only once.
	    if (stringGrip._fullText) {
	      return stringGrip._fullText.promise;
	    }

	    let deferred = stringGrip._fullText = promise.defer();
	    let actor = stringGrip.actor;
	    let initial = stringGrip.initial;
	    let length = stringGrip.length;

	    let longStringClient = this.longString(stringGrip);

	    longStringClient.substring(initial.length, length, function (aResponse) {
	      if (aResponse.error) {
	        DevToolsUtils.reportException("getString", aResponse.error + ": " + aResponse.message);

	        deferred.reject(aResponse);
	        return;
	      }
	      deferred.resolve(initial + aResponse.substring);
	    });

	    return deferred.promise;
	  }
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	var osString = "Darwin";
	var InspectorPanel = __webpack_require__(30).InspectorPanel;
	var DebuggerPanel = __webpack_require__(93).DebuggerPanel;
	// loader.lazyGetter(this, "OptionsPanel", () => require("devtools/client/framework/toolbox-options").OptionsPanel);
	// loader.lazyGetter(this, "WebConsolePanel", () => require("devtools/client/webconsole/panel").WebConsolePanel);

	// Strings
	const L10N = __webpack_require__(12);

	var toolboxStrings = new L10N(__webpack_require__(92));
	var webConsoleStrings = new L10N(__webpack_require__(94));
	var inspectorStrings = new L10N(__webpack_require__(91));
	var debuggerStrings = new L10N(__webpack_require__(84));

	var Tools = {};
	exports.Tools = Tools;

	// Definitions
	Tools.options = {
	  id: "options",
	  ordinal: 0,
	  url: "chrome://devtools/content/framework/toolbox-options.xul",
	  icon: "../themes/images/tool-options.svg",
	  invertIconForLightTheme: true,
	  bgTheme: "theme-body",
	  label: l10n("options.label", toolboxStrings),
	  iconOnly: true,
	  panelLabel: l10n("options.panelLabel", toolboxStrings),
	  tooltip: l10n("optionsButton.tooltip", toolboxStrings),
	  inMenu: false,

	  isTargetSupported: function (target) {
	    return true;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new OptionsPanel(iframeWindow, toolbox);
	  }
	};

	Tools.inspector = {
	  id: "inspector",
	  accesskey: l10n("inspector.accesskey", inspectorStrings),
	  key: l10n("inspector.commandkey", inspectorStrings),
	  ordinal: 1,
	  modifiers: osString == "Darwin" ? "accel,alt" : "accel,shift",
	  icon: "../themes/images/tool-inspector.svg",
	  invertIconForLightTheme: true,
	  url: "../inspector/inspector.xhtml",
	  label: l10n("inspector.label", inspectorStrings),
	  panelLabel: l10n("inspector.panelLabel", inspectorStrings),
	  get tooltip() {
	    return l10n("inspector.tooltip2", inspectorStrings, (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,
	  commands: ["devtools/client/responsivedesign/resize-commands", "devtools/client/inspector/inspector-commands", "devtools/client/eyedropper/commands.js"],

	  preventClosingOnKey: true,
	  onkey: function (panel) {
	    panel.toolbox.highlighterUtils.togglePicker();
	  },

	  isTargetSupported: function (target) {
	    return target.hasActor("inspector");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new InspectorPanel(iframeWindow, toolbox);
	  }
	};

	Tools.webConsole = {
	  id: "webconsole",
	  key: l10n("cmd.commandkey", webConsoleStrings),
	  accesskey: l10n("webConsoleCmd.accesskey", webConsoleStrings),
	  modifiers: Services.appinfo.OS == "Darwin" ? "accel,alt" : "accel,shift",
	  ordinal: 2,
	  icon: "../themes/images/tool-webconsole.svg",
	  invertIconForLightTheme: true,
	  url: "chrome://devtools/content/webconsole/webconsole.xul",
	  label: l10n("ToolboxTabWebconsole.label", webConsoleStrings),
	  menuLabel: l10n("MenuWebconsole.label", webConsoleStrings),
	  panelLabel: l10n("ToolboxWebConsole.panelLabel", webConsoleStrings),
	  get tooltip() {
	    return l10n("ToolboxWebconsole.tooltip2", webConsoleStrings, (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,
	  commands: "devtools/client/webconsole/console-commands",

	  preventClosingOnKey: true,
	  onkey: function (panel, toolbox) {
	    if (toolbox.splitConsole) return toolbox.focusConsoleInput();

	    panel.focusInput();
	  },

	  isTargetSupported: function (target) {
	    return true;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new WebConsolePanel(iframeWindow, toolbox);
	  }
	};

	Tools.jsdebugger = {
	  id: "jsdebugger",
	  key: l10n("debuggerMenu.commandkey", debuggerStrings),
	  accesskey: l10n("debuggerMenu.accesskey", debuggerStrings),
	  modifiers: osString == "Darwin" ? "accel,alt" : "accel,shift",
	  ordinal: 3,
	  icon: "chrome://devtools/skin/images/tool-debugger.svg",
	  invertIconForLightTheme: true,
	  highlightedicon: "chrome://devtools/skin/images/tool-debugger-paused.svg",
	  url: "../debugger/debugger.xhtml",
	  label: l10n("ToolboxDebugger.label", debuggerStrings),
	  panelLabel: l10n("ToolboxDebugger.panelLabel", debuggerStrings),
	  get tooltip() {
	    return l10n("ToolboxDebugger.tooltip2", debuggerStrings, (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,
	  commands: "devtools/client/debugger/debugger-commands",

	  isTargetSupported: function (target) {
	    return true;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new DebuggerPanel(iframeWindow, toolbox);
	  }
	};

	var defaultTools = [Tools.options, Tools.webConsole, Tools.inspector, Tools.jsdebugger];

	exports.defaultTools = defaultTools;

	Tools.darkTheme = {
	  id: "dark",
	  label: l10n("options.darkTheme.label", toolboxStrings),
	  ordinal: 1,
	  stylesheets: ["../themes/dark-theme.css"],
	  classList: ["theme-dark"]
	};

	Tools.lightTheme = {
	  id: "light",
	  label: l10n("options.lightTheme.label", toolboxStrings),
	  ordinal: 2,
	  stylesheets: ["../themes/light-theme.css"],
	  classList: ["theme-light"]
	};

	exports.defaultThemes = [Tools.darkTheme, Tools.lightTheme];

	/**
	 * Lookup l10n string from a string bundle.
	 *
	 * @param {string} name
	 *        The key to lookup.
	 * @param {StringBundle} bundle
	 *        The key to lookup.
	 * @returns A localized version of the given key.
	 */
	function l10n(name, bundle, arg) {
	  try {
	    return arg ? bundle.formatStringFromName(name, [arg], 1) : bundle.GetStringFromName(name);
	  } catch (ex) {
	    // Services.console.logStringMessage("Error reading '" + name + "'");
	    // throw new Error("l10n error with " + name);
	    return "Error reading string";
	  }
	}

	function functionkey(shortkey) {
	  return shortkey.split("_")[1];
	}

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;
	const Cr = _require.Cr;

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	var promise = __webpack_require__(6);
	var EventEmitter = exports.EventEmitter = __webpack_require__(7);
	var clipboardHelper = __webpack_require__(31);
	var L10N = __webpack_require__(12);

	var MarkupView = __webpack_require__(32).MarkupView;
	var HTMLBreadcrumbs = __webpack_require__(88).HTMLBreadcrumbs;
	var ToolSidebar = __webpack_require__(89).ToolSidebar;
	var InspectorSearch = __webpack_require__(90).InspectorSearch;

	var strings = new L10N(__webpack_require__(91));
	var toolboxStrings = new L10N(__webpack_require__(92));

	const LAYOUT_CHANGE_TIMER = 250;

	/**
	 * Represents an open instance of the Inspector for a tab.
	 * The inspector controls the breadcrumbs, the markup view, and the sidebar
	 * (computed view, rule view, font view and layout view).
	 *
	 * Events:
	 * - ready
	 *      Fired when the inspector panel is opened for the first time and ready to
	 *      use
	 * - new-root
	 *      Fired after a new root (navigation to a new page) event was fired by
	 *      the walker, and taken into account by the inspector (after the markup
	 *      view has been reloaded)
	 * - markuploaded
	 *      Fired when the markup-view frame has loaded
	 * - layout-change
	 *      Fired when the layout of the inspector changes
	 * - breadcrumbs-updated
	 *      Fired when the breadcrumb widget updates to a new node
	 * - layoutview-updated
	 *      Fired when the layoutview (box model) updates to a new node
	 * - markupmutation
	 *      Fired after markup mutations have been processed by the markup-view
	 * - computed-view-refreshed
	 *      Fired when the computed rules view updates to a new node
	 * - computed-view-property-expanded
	 *      Fired when a property is expanded in the computed rules view
	 * - computed-view-property-collapsed
	 *      Fired when a property is collapsed in the computed rules view
	 * - computed-view-sourcelinks-updated
	 *      Fired when the stylesheet source links have been updated (when switching
	 *      to source-mapped files)
	 * - rule-view-refreshed
	 *      Fired when the rule view updates to a new node
	 * - rule-view-sourcelinks-updated
	 *      Fired when the stylesheet source links have been updated (when switching
	 *      to source-mapped files)
	 */
	function InspectorPanel(iframeWindow, toolbox) {
	  this._toolbox = toolbox;
	  this._target = toolbox._target;
	  this.panelDoc = iframeWindow.document;
	  this.panelWin = iframeWindow;
	  this.panelWin.inspector = this;

	  this.nodeMenuTriggerInfo = null;

	  this._onBeforeNavigate = this._onBeforeNavigate.bind(this);
	  this.onNewRoot = this.onNewRoot.bind(this);
	  this._setupNodeMenu = this._setupNodeMenu.bind(this);
	  this._resetNodeMenu = this._resetNodeMenu.bind(this);
	  this._updateSearchResultsLabel = this._updateSearchResultsLabel.bind(this);
	  this.onNewSelection = this.onNewSelection.bind(this);
	  this.onBeforeNewSelection = this.onBeforeNewSelection.bind(this);
	  this.onDetached = this.onDetached.bind(this);
	  this.onToolboxHostChanged = this.onToolboxHostChanged.bind(this);
	  this.scheduleLayoutChange = this.scheduleLayoutChange.bind(this);
	  this.onPaneToggleButtonClicked = this.onPaneToggleButtonClicked.bind(this);
	  this._onMarkupFrameLoad = this._onMarkupFrameLoad.bind(this);

	  this._target.on("will-navigate", this._onBeforeNavigate);

	  EventEmitter.decorate(this);
	}

	exports.InspectorPanel = InspectorPanel;

	InspectorPanel.prototype = {
	  /**
	   * open is effectively an asynchronous constructor
	   */
	  open: function () {
	    var _this = this;

	    return this.target.makeRemote().then(function () {
	      return _this._getPageStyle();
	    }).then(function () {
	      return _this._getDefaultNodeForSelection();
	    }).then(function (defaultSelection) {
	      return _this._deferredOpen(defaultSelection);
	    }).then(null, console.error);
	  },

	  get toolbox() {
	    return this._toolbox;
	  },

	  get inspector() {
	    return this._toolbox.inspector;
	  },

	  get walker() {
	    return this._toolbox.walker;
	  },

	  get selection() {
	    return this._toolbox.selection;
	  },

	  get isOuterHTMLEditable() {
	    return this._target.client.traits.editOuterHTML;
	  },

	  get hasUrlToImageDataResolver() {
	    return this._target.client.traits.urlToImageDataResolver;
	  },

	  get canGetUniqueSelector() {
	    return this._target.client.traits.getUniqueSelector;
	  },

	  get canGetUsedFontFaces() {
	    return this._target.client.traits.getUsedFontFaces;
	  },

	  get canPasteInnerOrAdjacentHTML() {
	    return this._target.client.traits.pasteHTML;
	  },

	  _deferredOpen: function (defaultSelection) {
	    var _this2 = this;

	    let deferred = promise.defer();

	    this.walker.on("new-root", this.onNewRoot);

	    this.nodemenu = this.panelDoc.getElementById("inspector-node-popup");
	    this.lastNodemenuItem = this.nodemenu.lastChild;
	    this.nodemenu.addEventListener("popupshowing", this._setupNodeMenu, true);
	    this.nodemenu.addEventListener("popuphiding", this._resetNodeMenu, true);

	    this.selection.on("new-node-front", this.onNewSelection);
	    this.selection.on("before-new-node-front", this.onBeforeNewSelection);
	    this.selection.on("detached-front", this.onDetached);

	    // this.breadcrumbs = new HTMLBreadcrumbs(this);
	    this.breadcrumbs = {
	      destroy: function () {},
	      indexOf: function () {},
	      cutAfter: function () {}
	    };

	    this._toolbox.on("host-changed", this.onToolboxHostChanged);

	    if (this.target.isLocalTab) {
	      this.browser = this.target.tab.linkedBrowser;
	      this.browser.addEventListener("resize", this.scheduleLayoutChange, true);

	      // Show a warning when the debugger is paused.
	      // We show the warning only when the inspector
	      // is selected.
	      this.updateDebuggerPausedWarning = function () {
	        // XXX: Need to replace notificationBox
	        return;
	        let notificationBox = _this2._toolbox.getNotificationBox();
	        let notification = notificationBox.getNotificationWithValue("inspector-script-paused");
	        if (!notification && _this2._toolbox.currentToolId == "inspector" && _this2.target.isThreadPaused) {
	          let message = strings.GetStringFromName("debuggerPausedWarning.message");
	          notificationBox.appendNotification(message, "inspector-script-paused", "", notificationBox.PRIORITY_WARNING_HIGH);
	        }

	        if (notification && _this2._toolbox.currentToolId != "inspector") {
	          notificationBox.removeNotification(notification);
	        }

	        if (notification && !_this2.target.isThreadPaused) {
	          notificationBox.removeNotification(notification);
	        }
	      };
	      this.target.on("thread-paused", this.updateDebuggerPausedWarning);
	      this.target.on("thread-resumed", this.updateDebuggerPausedWarning);
	      this._toolbox.on("select", this.updateDebuggerPausedWarning);
	      this.updateDebuggerPausedWarning();
	    }

	    this._initMarkup();
	    this.isReady = false;

	    this.once("markuploaded", function () {
	      _this2.isReady = true;

	      // All the components are initialized. Let's select a node.
	      _this2.selection.setNodeFront(defaultSelection, "inspector-open");

	      _this2.markup.expandNode(_this2.selection.nodeFront);

	      _this2.emit("ready");
	      deferred.resolve(_this2);
	    });

	    this.setupSearchBox();
	    this.setupSidebar();

	    return deferred.promise;
	  },

	  _onBeforeNavigate: function () {
	    this._defaultNode = null;
	    this.selection.setNodeFront(null);
	    this._destroyMarkup();
	    this.isDirty = false;
	    this._pendingSelection = null;
	  },

	  _getPageStyle: function () {
	    var _this3 = this;

	    return this._toolbox.inspector.getPageStyle().then(function (pageStyle) {
	      _this3.pageStyle = pageStyle;
	    });
	  },

	  /**
	   * Return a promise that will resolve to the default node for selection.
	   */
	  _getDefaultNodeForSelection: function () {
	    var _this4 = this;

	    if (this._defaultNode) {
	      return this._defaultNode;
	    }
	    let walker = this.walker;
	    let rootNode = null;
	    let pendingSelection = this._pendingSelection;

	    // A helper to tell if the target has or is about to navigate.
	    // this._pendingSelection changes on "will-navigate" and "new-root" events.
	    let hasNavigated = function () {
	      return pendingSelection !== _this4._pendingSelection;
	    };

	    // If available, set either the previously selected node or the body
	    // as default selected, else set documentElement
	    return walker.getRootNode().then(function (aRootNode) {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }

	      rootNode = aRootNode;
	      if (_this4.selectionCssSelector) {
	        return walker.querySelector(rootNode, _this4.selectionCssSelector);
	      }
	    }).then(function (front) {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }

	      if (front) {
	        return front;
	      }
	      return walker.querySelector(rootNode, "body");
	    }).then(function (front) {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }

	      if (front) {
	        return front;
	      }
	      return _this4.walker.documentElement();
	    }).then(function (node) {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }
	      _this4._defaultNode = node;
	      return node;
	    });
	  },

	  /**
	   * Target getter.
	   */
	  get target() {
	    return this._target;
	  },

	  /**
	   * Target setter.
	   */
	  set target(value) {
	    this._target = value;
	  },

	  /**
	   * Indicate that a tool has modified the state of the page.  Used to
	   * decide whether to show the "are you sure you want to navigate"
	   * notification.
	   */
	  markDirty: function () {
	    this.isDirty = true;
	  },

	  /**
	   * Hooks the searchbar to show result and auto completion suggestions.
	   */
	  setupSearchBox: function () {
	    this.searchBox = this.panelDoc.getElementById("inspector-searchbox");
	    this.searchResultsLabel = this.panelDoc.getElementById("inspector-searchlabel");

	    this.search = new InspectorSearch(this, this.searchBox);
	    this.search.on("search-cleared", this._updateSearchResultsLabel);
	    this.search.on("search-result", this._updateSearchResultsLabel);
	  },

	  get searchSuggestions() {
	    return this.search.autocompleter;
	  },

	  _updateSearchResultsLabel: function (event, result) {
	    let str = "";
	    if (event !== "search-cleared") {
	      if (result) {
	        str = strings.formatStringFromName("inspector.searchResultsCount2", [result.resultsIndex + 1, result.resultsLength], 2);
	      } else {
	        str = strings.GetStringFromName("inspector.searchResultsNone");
	      }
	    }

	    this.searchResultsLabel.textContent = str;
	  },

	  /**
	   * Build the sidebar.
	   */
	  setupSidebar: function () {
	    let tabbox = this.panelDoc.querySelector("#inspector-sidebar");
	    this.sidebar = new ToolSidebar(tabbox, this, "inspector", {
	      showAllTabsMenu: true
	    });

	    let defaultTab = Services.prefs.getCharPref("devtools.inspector.activeSidebar");

	    this._setDefaultSidebar = function (event, toolId) {
	      Services.prefs.setCharPref("devtools.inspector.activeSidebar", toolId);
	    };

	    this.sidebar.on("select", this._setDefaultSidebar);

	    this.sidebar.addTab("ruleview", "../styleinspector/cssruleview.xhtml", "ruleview" == defaultTab);

	    this.sidebar.addTab("computedview", "../styleinspector/computedview.xhtml", "computedview" == defaultTab);

	    if (Services.prefs.getBoolPref("devtools.fontinspector.enabled") && this.canGetUsedFontFaces) {
	      this.sidebar.addTab("fontinspector", "../fontinspector/font-inspector.xhtml", "fontinspector" == defaultTab);
	    }

	    // XXX: Need to get this running with webpack
	    // this.sidebar.addTab("layoutview",
	    //                     "../layoutview/view.xhtml",
	    //                     "layoutview" == defaultTab);

	    // XXX: Need to get this running with webpack
	    // if (this.target.form.animationsActor) {
	    //   this.sidebar.addTab("animationinspector",
	    //                       "../animationinspector/animation-inspector.xhtml",
	    //                       "animationinspector" == defaultTab);
	    // }

	    this.sidebar.show();

	    this.setupSidebarToggle();
	  },

	  /**
	   * Add the expand/collapse behavior for the sidebar panel.
	   */
	  setupSidebarToggle: function () {
	    this._paneToggleButton = this.panelDoc.getElementById("inspector-pane-toggle");
	    this._paneToggleButton.addEventListener("mousedown", this.onPaneToggleButtonClicked);
	    this.updatePaneToggleButton();
	  },

	  /**
	   * Reset the inspector on new root mutation.
	   */
	  onNewRoot: function () {
	    var _this5 = this;

	    this._defaultNode = null;
	    this.selection.setNodeFront(null);
	    this._destroyMarkup();
	    this.isDirty = false;

	    let onNodeSelected = function (defaultNode) {
	      // Cancel this promise resolution as a new one had
	      // been queued up.
	      if (_this5._pendingSelection != onNodeSelected) {
	        return;
	      }
	      _this5._pendingSelection = null;
	      _this5.selection.setNodeFront(defaultNode, "navigateaway");

	      _this5._initMarkup();
	      _this5.once("markuploaded", function () {
	        if (!_this5.markup) {
	          return;
	        }
	        _this5.markup.expandNode(_this5.selection.nodeFront);
	        _this5.emit("new-root");
	      });
	    };
	    this._pendingSelection = onNodeSelected;
	    this._getDefaultNodeForSelection().then(onNodeSelected, console.error);
	  },

	  _selectionCssSelector: null,

	  /**
	   * Set the currently selected node unique css selector.
	   * Will store the current target url along with it to allow pre-selection at
	   * reload
	   */
	  set selectionCssSelector(cssSelector = null) {
	    if (this._panelDestroyer) {
	      return;
	    }

	    this._selectionCssSelector = {
	      selector: cssSelector,
	      url: this._target.url
	    };
	  },

	  /**
	   * Get the current selection unique css selector if any, that is, if a node
	   * is actually selected and that node has been selected while on the same url
	   */
	  get selectionCssSelector() {
	    if (this._selectionCssSelector && this._selectionCssSelector.url === this._target.url) {
	      return this._selectionCssSelector.selector;
	    } else {
	      return null;
	    }
	  },

	  /**
	   * When a new node is selected.
	   */
	  onNewSelection: function (event, value, reason) {
	    var _this6 = this;

	    if (reason === "selection-destroy") {
	      return;
	    }

	    this.cancelLayoutChange();

	    // Wait for all the known tools to finish updating and then let the
	    // client know.
	    let selection = this.selection.nodeFront;

	    // On any new selection made by the user, store the unique css selector
	    // of the selected node so it can be restored after reload of the same page
	    if (this.canGetUniqueSelector && this.selection.isElementNode()) {
	      selection.getUniqueSelector().then(function (selector) {
	        _this6.selectionCssSelector = selector;
	      }).then(null, function (e) {
	        // Only log this as an error if the panel hasn't been destroyed in the
	        // meantime.
	        if (!_this6._panelDestroyer) {
	          console.error(e);
	        } else {
	          console.warn("Could not set the unique selector for the newly " + "selected node, the inspector was destroyed.");
	        }
	      });
	    }

	    let selfUpdate = this.updating("inspector-panel");
	    Services.tm.mainThread.dispatch(function () {
	      try {
	        selfUpdate(selection);
	      } catch (ex) {
	        console.error(ex);
	      }
	    }, Ci.nsIThread.DISPATCH_NORMAL);
	  },

	  /**
	   * Delay the "inspector-updated" notification while a tool
	   * is updating itself.  Returns a function that must be
	   * invoked when the tool is done updating with the node
	   * that the tool is viewing.
	   */
	  updating: function (name) {
	    if (this._updateProgress && this._updateProgress.node != this.selection.nodeFront) {
	      this.cancelUpdate();
	    }

	    if (!this._updateProgress) {
	      // Start an update in progress.
	      var self = this;
	      this._updateProgress = {
	        node: this.selection.nodeFront,
	        outstanding: new Set(),
	        checkDone: function () {
	          if (this !== self._updateProgress) {
	            return;
	          }
	          if (this.node !== self.selection.nodeFront) {
	            self.cancelUpdate();
	            return;
	          }
	          if (this.outstanding.size !== 0) {
	            return;
	          }

	          self._updateProgress = null;
	          self.emit("inspector-updated", name);
	        }
	      };
	    }

	    let progress = this._updateProgress;
	    let done = function () {
	      progress.outstanding.delete(done);
	      progress.checkDone();
	    };
	    progress.outstanding.add(done);
	    return done;
	  },

	  /**
	   * Cancel notification of inspector updates.
	   */
	  cancelUpdate: function () {
	    this._updateProgress = null;
	  },

	  /**
	   * When a new node is selected, before the selection has changed.
	   */
	  onBeforeNewSelection: function (event, node) {
	    if (this.breadcrumbs.indexOf(node) == -1) {
	      // only clear locks if we'd have to update breadcrumbs
	      this.clearPseudoClasses();
	    }
	  },

	  /**
	   * When a node is deleted, select its parent node or the defaultNode if no
	   * parent is found (may happen when deleting an iframe inside which the
	   * node was selected).
	   */
	  onDetached: function (event, parentNode) {
	    this.cancelLayoutChange();
	    this.breadcrumbs.cutAfter(this.breadcrumbs.indexOf(parentNode));
	    this.selection.setNodeFront(parentNode ? parentNode : this._defaultNode, "detached");
	  },

	  /**
	   * Destroy the inspector.
	   */
	  destroy: function () {
	    if (this._panelDestroyer) {
	      return this._panelDestroyer;
	    }

	    if (this.walker) {
	      this.walker.off("new-root", this.onNewRoot);
	      this.pageStyle = null;
	    }

	    this.cancelUpdate();
	    this.cancelLayoutChange();

	    if (this.browser) {
	      this.browser.removeEventListener("resize", this.scheduleLayoutChange, true);
	      this.browser = null;
	    }

	    this.target.off("will-navigate", this._onBeforeNavigate);

	    this.target.off("thread-paused", this.updateDebuggerPausedWarning);
	    this.target.off("thread-resumed", this.updateDebuggerPausedWarning);
	    this._toolbox.off("select", this.updateDebuggerPausedWarning);
	    this._toolbox.off("host-changed", this.onToolboxHostChanged);

	    this.sidebar.off("select", this._setDefaultSidebar);
	    let sidebarDestroyer = this.sidebar.destroy();
	    this.sidebar = null;

	    this.nodemenu.removeEventListener("popupshowing", this._setupNodeMenu, true);
	    this.nodemenu.removeEventListener("popuphiding", this._resetNodeMenu, true);
	    this.breadcrumbs.destroy();
	    this._paneToggleButton.removeEventListener("mousedown", this.onPaneToggleButtonClicked);
	    this._paneToggleButton = null;
	    this.selection.off("new-node-front", this.onNewSelection);
	    this.selection.off("before-new-node", this.onBeforeNewSelection);
	    this.selection.off("before-new-node-front", this.onBeforeNewSelection);
	    this.selection.off("detached-front", this.onDetached);
	    let markupDestroyer = this._destroyMarkup();
	    this.panelWin.inspector = null;
	    this.target = null;
	    this.panelDoc = null;
	    this.panelWin = null;
	    this.breadcrumbs = null;
	    this.lastNodemenuItem = null;
	    this.nodemenu = null;
	    this._toolbox = null;
	    this.search.destroy();
	    this.search = null;
	    this.searchBox = null;

	    this._panelDestroyer = promise.all([sidebarDestroyer, markupDestroyer]);

	    return this._panelDestroyer;
	  },

	  /**
	   * Show the node menu.
	   */
	  showNodeMenu: function (aButton, aPosition, aExtraItems) {
	    if (aExtraItems) {
	      for (let item of aExtraItems) {
	        this.nodemenu.appendChild(item);
	      }
	    }
	    this.nodemenu.openPopup(aButton, aPosition, 0, 0, true, false);
	  },

	  hideNodeMenu: function () {
	    this.nodemenu.hidePopup();
	  },

	  /**
	   * Returns the clipboard content if it is appropriate for pasting
	   * into the current node's outer HTML, otherwise returns null.
	   */
	  _getClipboardContentForPaste: function () {
	    let flavors = clipboard.currentFlavors;
	    if (flavors.indexOf("text") != -1 || flavors.indexOf("html") != -1 && flavors.indexOf("image") == -1) {
	      let content = clipboard.get();
	      if (content && content.trim().length > 0) {
	        return content;
	      }
	    }
	    return null;
	  },

	  /**
	   * Update, enable, disable, hide, show any menu item depending on the current
	   * element.
	   */
	  _setupNodeMenu: function (event) {
	    let markupContainer = this.markup.getContainer(this.selection.nodeFront);
	    this.nodeMenuTriggerInfo = markupContainer.editor.getInfoAtNode(event.target.triggerNode);

	    let isSelectionElement = this.selection.isElementNode() && !this.selection.isPseudoElementNode();
	    let isEditableElement = isSelectionElement && !this.selection.isAnonymousNode();
	    let isDuplicatableElement = isSelectionElement && !this.selection.isAnonymousNode() && !this.selection.isRoot();
	    let isScreenshotable = isSelectionElement && this.canGetUniqueSelector && this.selection.nodeFront.isTreeDisplayed;

	    // Set the pseudo classes
	    for (let name of ["hover", "active", "focus"]) {
	      let menu = this.panelDoc.getElementById("node-menu-pseudo-" + name);

	      if (isSelectionElement) {
	        let checked = this.selection.nodeFront.hasPseudoClassLock(":" + name);
	        menu.setAttribute("checked", checked);
	        menu.removeAttribute("disabled");
	      } else {
	        menu.setAttribute("disabled", "true");
	      }
	    }

	    // Disable delete item if needed
	    let deleteNode = this.panelDoc.getElementById("node-menu-delete");
	    if (isEditableElement) {
	      deleteNode.removeAttribute("disabled");
	    } else {
	      deleteNode.setAttribute("disabled", "true");
	    }

	    // Disable / enable "Copy Unique Selector", "Copy inner HTML",
	    // "Copy outer HTML", "Scroll Into View" & "Screenshot Node" as appropriate
	    let unique = this.panelDoc.getElementById("node-menu-copyuniqueselector");
	    let screenshot = this.panelDoc.getElementById("node-menu-screenshotnode");
	    let duplicateNode = this.panelDoc.getElementById("node-menu-duplicatenode");
	    let copyInnerHTML = this.panelDoc.getElementById("node-menu-copyinner");
	    let copyOuterHTML = this.panelDoc.getElementById("node-menu-copyouter");
	    let scrollIntoView = this.panelDoc.getElementById("node-menu-scrollnodeintoview");
	    let expandAll = this.panelDoc.getElementById("node-menu-expand");
	    let collapse = this.panelDoc.getElementById("node-menu-collapse");

	    expandAll.setAttribute("disabled", "true");
	    collapse.setAttribute("disabled", "true");

	    if (this.selection.isNode() && markupContainer.hasChildren) {
	      if (markupContainer.expanded) {
	        collapse.removeAttribute("disabled");
	      }
	      expandAll.removeAttribute("disabled");
	    }

	    this._target.actorHasMethod("domwalker", "duplicateNode").then(function (value) {
	      duplicateNode.hidden = !value;
	    });
	    this._target.actorHasMethod("domnode", "scrollIntoView").then(function (value) {
	      scrollIntoView.hidden = !value;
	    });

	    if (isDuplicatableElement) {
	      duplicateNode.removeAttribute("disabled");
	    } else {
	      duplicateNode.setAttribute("disabled", "true");
	    }

	    if (isSelectionElement) {
	      unique.removeAttribute("disabled");
	      copyInnerHTML.removeAttribute("disabled");
	      copyOuterHTML.removeAttribute("disabled");
	      scrollIntoView.removeAttribute("disabled");
	    } else {
	      unique.setAttribute("disabled", "true");
	      copyInnerHTML.setAttribute("disabled", "true");
	      copyOuterHTML.setAttribute("disabled", "true");
	      scrollIntoView.setAttribute("disabled", "true");
	    }
	    if (!this.canGetUniqueSelector) {
	      unique.hidden = true;
	    }

	    if (isScreenshotable) {
	      screenshot.removeAttribute("disabled");
	    } else {
	      screenshot.setAttribute("disabled", "true");
	    }

	    // Enable/Disable the link open/copy items.
	    this._setupNodeLinkMenu();

	    // Enable the "edit HTML" item if the selection is an element and the root
	    // actor has the appropriate trait (isOuterHTMLEditable)
	    let editHTML = this.panelDoc.getElementById("node-menu-edithtml");
	    if (isEditableElement && this.isOuterHTMLEditable) {
	      editHTML.removeAttribute("disabled");
	    } else {
	      editHTML.setAttribute("disabled", "true");
	    }

	    let pasteOuterHTML = this.panelDoc.getElementById("node-menu-pasteouterhtml");
	    let pasteInnerHTML = this.panelDoc.getElementById("node-menu-pasteinnerhtml");
	    let pasteBefore = this.panelDoc.getElementById("node-menu-pastebefore");
	    let pasteAfter = this.panelDoc.getElementById("node-menu-pasteafter");
	    let pasteFirstChild = this.panelDoc.getElementById("node-menu-pastefirstchild");
	    let pasteLastChild = this.panelDoc.getElementById("node-menu-pastelastchild");

	    // Is the clipboard content appropriate? Is the element editable?
	    if (isEditableElement && this._getClipboardContentForPaste()) {
	      pasteInnerHTML.disabled = !this.canPasteInnerOrAdjacentHTML;
	      // Enable the "paste outer HTML" item if the selection is an element and
	      // the root actor has the appropriate trait (isOuterHTMLEditable).
	      pasteOuterHTML.disabled = !this.isOuterHTMLEditable;
	      // Don't paste before / after a root or a BODY or a HEAD element.
	      pasteBefore.disabled = pasteAfter.disabled = !this.canPasteInnerOrAdjacentHTML || this.selection.isRoot() || this.selection.isBodyNode() || this.selection.isHeadNode();
	      // Don't paste as a first / last child of a HTML document element.
	      pasteFirstChild.disabled = pasteLastChild.disabled = !this.canPasteInnerOrAdjacentHTML || this.selection.isHTMLNode() && this.selection.isRoot();
	    } else {
	      pasteOuterHTML.disabled = true;
	      pasteInnerHTML.disabled = true;
	      pasteBefore.disabled = true;
	      pasteAfter.disabled = true;
	      pasteFirstChild.disabled = true;
	      pasteLastChild.disabled = true;
	    }

	    // Enable the "copy image data-uri" item if the selection is previewable
	    // which essentially checks if it's an image or canvas tag
	    let copyImageData = this.panelDoc.getElementById("node-menu-copyimagedatauri");
	    if (isSelectionElement && markupContainer && markupContainer.isPreviewable()) {
	      copyImageData.removeAttribute("disabled");
	    } else {
	      copyImageData.setAttribute("disabled", "true");
	    }

	    // Enable / disable "Add Attribute", "Edit Attribute"
	    // and "Remove Attribute" items
	    this._setupAttributeMenu(isEditableElement);
	  },

	  _setupAttributeMenu: function (isEditableElement) {
	    let addAttribute = this.panelDoc.getElementById("node-menu-add-attribute");
	    let editAttribute = this.panelDoc.getElementById("node-menu-edit-attribute");
	    let removeAttribute = this.panelDoc.getElementById("node-menu-remove-attribute");
	    let nodeInfo = this.nodeMenuTriggerInfo;

	    // Enable "Add Attribute" for all editable elements
	    if (isEditableElement) {
	      addAttribute.removeAttribute("disabled");
	    } else {
	      addAttribute.setAttribute("disabled", "true");
	    }

	    // Enable "Edit Attribute" and "Remove Attribute" only on attribute click
	    if (isEditableElement && nodeInfo && nodeInfo.type === "attribute") {
	      editAttribute.removeAttribute("disabled");
	      editAttribute.setAttribute("label", strings.formatStringFromName("inspector.menu.editAttribute.label", [`"${ nodeInfo.name }"`], 1));

	      removeAttribute.removeAttribute("disabled");
	      removeAttribute.setAttribute("label", strings.formatStringFromName("inspector.menu.removeAttribute.label", [`"${ nodeInfo.name }"`], 1));
	    } else {
	      editAttribute.setAttribute("disabled", "true");
	      editAttribute.setAttribute("label", strings.formatStringFromName("inspector.menu.editAttribute.label", [''], 1));

	      removeAttribute.setAttribute("disabled", "true");
	      removeAttribute.setAttribute("label", strings.formatStringFromName("inspector.menu.removeAttribute.label", [''], 1));
	    }
	  },

	  _resetNodeMenu: function () {
	    // Remove any extra items
	    while (this.lastNodemenuItem.nextSibling) {
	      let toDelete = this.lastNodemenuItem.nextSibling;
	      toDelete.parentNode.removeChild(toDelete);
	    }
	  },

	  /**
	   * Link menu items can be shown or hidden depending on the context and
	   * selected node, and their labels can vary.
	   */
	  _setupNodeLinkMenu: function () {
	    var _this7 = this;

	    let linkSeparator = this.panelDoc.getElementById("node-menu-link-separator");
	    let linkFollow = this.panelDoc.getElementById("node-menu-link-follow");
	    let linkCopy = this.panelDoc.getElementById("node-menu-link-copy");

	    // Hide all by default.
	    linkSeparator.setAttribute("hidden", "true");
	    linkFollow.setAttribute("hidden", "true");
	    linkCopy.setAttribute("hidden", "true");

	    // Get information about the right-clicked node.
	    let popupNode = this.panelDoc.popupNode;
	    if (!popupNode || !popupNode.classList.contains("link")) {
	      return;
	    }

	    let type = popupNode.dataset.type;
	    if (type === "uri" || type === "cssresource" || type === "jsresource") {
	      // First make sure the target can resolve relative URLs.
	      this.target.actorHasMethod("inspector", "resolveRelativeURL").then(function (canResolve) {
	        if (!canResolve) {
	          return;
	        }

	        linkSeparator.removeAttribute("hidden");

	        // Links can't be opened in new tabs in the browser toolbox.
	        if (type === "uri" && !_this7.target.chrome) {
	          linkFollow.removeAttribute("hidden");
	          linkFollow.setAttribute("label", strings.GetStringFromName("inspector.menu.openUrlInNewTab.label"));
	        } else if (type === "cssresource") {
	          linkFollow.removeAttribute("hidden");
	          linkFollow.setAttribute("label", toolboxStrings.GetStringFromName("toolbox.viewCssSourceInStyleEditor.label"));
	        } else if (type === "jsresource") {
	          linkFollow.removeAttribute("hidden");
	          linkFollow.setAttribute("label", toolboxStrings.GetStringFromName("toolbox.viewJsSourceInDebugger.label"));
	        }

	        linkCopy.removeAttribute("hidden");
	        linkCopy.setAttribute("label", strings.GetStringFromName("inspector.menu.copyUrlToClipboard.label"));
	      }, console.error);
	    } else if (type === "idref") {
	      linkSeparator.removeAttribute("hidden");
	      linkFollow.removeAttribute("hidden");
	      linkFollow.setAttribute("label", strings.formatStringFromName("inspector.menu.selectElement.label", [popupNode.dataset.link], 1));
	    }
	  },

	  _initMarkup: function () {
	    let doc = this.panelDoc;

	    this._markupBox = doc.getElementById("markup-box");

	    // create tool iframe
	    this._markupFrame = doc.createElement("iframe");
	    this._markupFrame.setAttribute("flex", "1");
	    this._markupFrame.setAttribute("tooltip", "aHTMLTooltip");
	    this._markupFrame.setAttribute("context", "inspector-node-popup");

	    // This is needed to enable tooltips inside the iframe document.
	    this._markupFrame.addEventListener("load", this._onMarkupFrameLoad, true);

	    this._markupBox.setAttribute("collapsed", true);
	    this._markupBox.appendChild(this._markupFrame);
	    this._markupFrame.setAttribute("src", "../markupview/markup-view.xhtml");
	    this._markupFrame.setAttribute("aria-label", strings.GetStringFromName("inspector.panelLabel.markupView"));
	  },

	  _onMarkupFrameLoad: function () {
	    this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);

	    this._markupFrame.contentWindow.focus();

	    this._markupBox.removeAttribute("collapsed");

	    let controllerWindow = this._toolbox.doc.defaultView;
	    this.markup = new MarkupView(this, this._markupFrame, controllerWindow);

	    this.emit("markuploaded");
	  },

	  _destroyMarkup: function () {
	    let destroyPromise;

	    if (this._markupFrame) {
	      this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);
	    }

	    if (this.markup) {
	      destroyPromise = this.markup.destroy();
	      this.markup = null;
	    } else {
	      destroyPromise = promise.resolve();
	    }

	    if (this._markupFrame) {
	      this._markupFrame.parentNode.removeChild(this._markupFrame);
	      this._markupFrame = null;
	    }

	    this._markupBox = null;

	    return destroyPromise;
	  },

	  /**
	   * When the type of toolbox host changes.
	   */
	  onToolboxHostChanged: function () {
	    this.updatePaneToggleButton();
	  },

	  /**
	   * When the pane toggle button is clicked, toggle the pane, change the button
	   * state and tooltip.
	   */
	  onPaneToggleButtonClicked: function (e) {
	    let sidePane = this.panelDoc.querySelector("#inspector-sidebar");
	    let button = this._paneToggleButton;
	    let isVisible = !button.hasAttribute("pane-collapsed");

	    // Make sure the sidebar has a width attribute before collapsing because
	    // ViewHelpers needs it.
	    if (isVisible && !sidePane.hasAttribute("width")) {
	      sidePane.setAttribute("width", sidePane.getBoundingClientRect().width);
	    }

	    ViewHelpers.togglePane({
	      visible: !isVisible,
	      animated: true,
	      delayed: true
	    }, sidePane);

	    if (isVisible) {
	      button.setAttribute("pane-collapsed", "");
	      button.setAttribute("tooltiptext", strings.GetStringFromName("inspector.expandPane"));
	    } else {
	      button.removeAttribute("pane-collapsed");
	      button.setAttribute("tooltiptext", strings.GetStringFromName("inspector.collapsePane"));
	    }
	  },

	  /**
	   * Update the pane toggle button visibility depending on the toolbox host type.
	   */
	  updatePaneToggleButton: function () {
	    this._paneToggleButton.setAttribute("hidden", this._toolbox.hostType === HostType.SIDE);
	  },

	  /**
	   * Toggle a pseudo class.
	   */
	  togglePseudoClass: function (aPseudo) {
	    if (this.selection.isElementNode()) {
	      let node = this.selection.nodeFront;
	      if (node.hasPseudoClassLock(aPseudo)) {
	        return this.walker.removePseudoClassLock(node, aPseudo, { parents: true });
	      }

	      let hierarchical = aPseudo == ":hover" || aPseudo == ":active";
	      return this.walker.addPseudoClassLock(node, aPseudo, { parents: hierarchical });
	    }
	  },

	  /**
	   * Show DOM properties
	   */
	  showDOMProperties: function () {
	    var _this8 = this;

	    this._toolbox.openSplitConsole().then(function () {
	      let panel = _this8._toolbox.getPanel("webconsole");
	      let jsterm = panel.hud.jsterm;

	      jsterm.execute("inspect($0)");
	      jsterm.inputNode.focus();
	    });
	  },

	  /**
	   * Use in Console.
	   *
	   * Takes the currently selected node in the inspector and assigns it to a
	   * temp variable on the content window.  Also opens the split console and
	   * autofills it with the temp variable.
	   */
	  useInConsole: function () {
	    var _this9 = this;

	    this._toolbox.openSplitConsole().then(function () {
	      let panel = _this9._toolbox.getPanel("webconsole");
	      let jsterm = panel.hud.jsterm;

	      let evalString = `{ let i = 0;
	        while (window.hasOwnProperty("temp" + i) && i < 1000) {
	          i++;
	        }
	        window["temp" + i] = $0;
	        "temp" + i;
	      }`;

	      let options = {
	        selectedNodeActor: _this9.selection.nodeFront.actorID
	      };
	      jsterm.requestEvaluation(evalString, options).then(function (res) {
	        jsterm.setInputValue(res.result);
	        _this9.emit("console-var-ready");
	      });
	    });
	  },

	  /**
	   * Clear any pseudo-class locks applied to the current hierarchy.
	   */
	  clearPseudoClasses: function () {
	    if (!this.walker) {
	      return;
	    }
	    return this.walker.clearPseudoClassLocks().then(null, console.error);
	  },

	  /**
	   * Edit the outerHTML of the selected Node.
	   */
	  editHTML: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }
	    if (this.markup) {
	      this.markup.beginEditingOuterHTML(this.selection.nodeFront);
	    }
	  },

	  /**
	   * Paste the contents of the clipboard into the selected Node's outer HTML.
	   */
	  pasteOuterHTML: function () {
	    var _this10 = this;

	    let content = this._getClipboardContentForPaste();
	    if (!content) return promise.reject("No clipboard content for paste");

	    let node = this.selection.nodeFront;
	    return this.markup.getNodeOuterHTML(node).then(function (oldContent) {
	      _this10.markup.updateNodeOuterHTML(node, content, oldContent);
	    });
	  },

	  /**
	   * Paste the contents of the clipboard into the selected Node's inner HTML.
	   */
	  pasteInnerHTML: function () {
	    var _this11 = this;

	    let content = this._getClipboardContentForPaste();
	    if (!content) return promise.reject("No clipboard content for paste");

	    let node = this.selection.nodeFront;
	    return this.markup.getNodeInnerHTML(node).then(function (oldContent) {
	      _this11.markup.updateNodeInnerHTML(node, content, oldContent);
	    });
	  },

	  /**
	   * Paste the contents of the clipboard as adjacent HTML to the selected Node.
	   * @param position The position as specified for Element.insertAdjacentHTML
	   *        (i.e. "beforeBegin", "afterBegin", "beforeEnd", "afterEnd").
	   */
	  pasteAdjacentHTML: function (position) {
	    let content = this._getClipboardContentForPaste();
	    if (!content) return promise.reject("No clipboard content for paste");

	    let node = this.selection.nodeFront;
	    return this.markup.insertAdjacentHTMLToNode(node, position, content);
	  },

	  /**
	   * Copy the innerHTML of the selected Node to the clipboard.
	   */
	  copyInnerHTML: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }
	    this._copyLongString(this.walker.innerHTML(this.selection.nodeFront));
	  },

	  /**
	   * Copy the outerHTML of the selected Node to the clipboard.
	   */
	  copyOuterHTML: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }
	    let node = this.selection.nodeFront;

	    switch (node.nodeType) {
	      case Ci.nsIDOMNode.ELEMENT_NODE:
	        this._copyLongString(this.walker.outerHTML(node));
	        break;
	      case Ci.nsIDOMNode.COMMENT_NODE:
	        this._getLongString(node.getNodeValue()).then(function (comment) {
	          clipboardHelper.copy("<!--" + comment + "-->");
	        });
	        break;
	      case Ci.nsIDOMNode.DOCUMENT_TYPE_NODE:
	        clipboardHelper.copy(node.doctypeString);
	        break;
	    }
	  },

	  /**
	   * Copy the data-uri for the currently selected image in the clipboard.
	   */
	  copyImageDataUri: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    if (container && container.isPreviewable()) {
	      container.copyImageDataUri();
	    }
	  },

	  /**
	   * Copy the content of a longString (via a promise resolving a LongStringActor) to the clipboard
	   * @param  {Promise} longStringActorPromise promise expected to resolve a LongStringActor instance
	   * @return {Promise} promise resolving (with no argument) when the string is sent to the clipboard
	   */
	  _copyLongString: function (longStringActorPromise) {
	    return this._getLongString(longStringActorPromise).then(function (string) {
	      clipboardHelper.copy(string);
	    }).catch(Cu.reportError);
	  },

	  /**
	   * Retrieve the content of a longString (via a promise resolving a LongStringActor)
	   * @param  {Promise} longStringActorPromise promise expected to resolve a LongStringActor instance
	   * @return {Promise} promise resolving with the retrieved string as argument
	   */
	  _getLongString: function (longStringActorPromise) {
	    return longStringActorPromise.then(function (longStringActor) {
	      return longStringActor.string().then(function (string) {
	        longStringActor.release().catch(Cu.reportError);
	        return string;
	      });
	    }).catch(Cu.reportError);
	  },

	  /**
	   * Copy a unique selector of the selected Node to the clipboard.
	   */
	  copyUniqueSelector: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }

	    this.selection.nodeFront.getUniqueSelector().then(function (selector) {
	      clipboardHelper.copy(selector);
	    }).then(null, console.error);
	  },

	  /**
	   * Initiate gcli screenshot command on selected node
	   */
	  screenshotNode: function () {
	    var _this12 = this;

	    CommandUtils.createRequisition(this._target, {
	      environment: CommandUtils.createEnvironment(this, '_target')
	    }).then(function (requisition) {
	      // Bug 1180314 -  CssSelector might contain white space so need to make sure it is
	      // passed to screenshot as a single parameter.  More work *might* be needed if
	      // CssSelector could contain escaped single- or double-quotes, backslashes, etc.
	      requisition.updateExec("screenshot --selector '" + _this12.selectionCssSelector + "'");
	    });
	  },

	  /**
	   * Scroll the node into view.
	   */
	  scrollNodeIntoView: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }

	    this.selection.nodeFront.scrollIntoView();
	  },

	  /**
	   * Duplicate the selected node
	   */
	  duplicateNode: function () {
	    let selection = this.selection;
	    if (!selection.isElementNode() || selection.isRoot() || selection.isAnonymousNode() || selection.isPseudoElementNode()) {
	      return;
	    }
	    this.walker.duplicateNode(selection.nodeFront).catch(function (e) {
	      return console.error(e);
	    });
	  },

	  /**
	   * Delete the selected node.
	   */
	  deleteNode: function () {
	    if (!this.selection.isNode() || this.selection.isRoot()) {
	      return;
	    }

	    // If the markup panel is active, use the markup panel to delete
	    // the node, making this an undoable action.
	    if (this.markup) {
	      this.markup.deleteNode(this.selection.nodeFront);
	    } else {
	      // remove the node from content
	      this.walker.removeNode(this.selection.nodeFront);
	    }
	  },

	  /**
	   * Add attribute to node.
	   * Used for node context menu and shouldn't be called directly.
	   */
	  onAddAttribute: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    container.addAttribute();
	  },

	  /**
	   * Edit attribute for node.
	   * Used for node context menu and shouldn't be called directly.
	   */
	  onEditAttribute: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    container.editAttribute(this.nodeMenuTriggerInfo.name);
	  },

	  /**
	   * Remove attribute from node.
	   * Used for node context menu and shouldn't be called directly.
	   */
	  onRemoveAttribute: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    container.removeAttribute(this.nodeMenuTriggerInfo.name);
	  },

	  expandNode: function () {
	    this.markup.expandAll(this.selection.nodeFront);
	  },

	  collapseNode: function () {
	    this.markup.collapseNode(this.selection.nodeFront);
	  },

	  /**
	   * This method is here for the benefit of the node-menu-link-follow menu item
	   * in the inspector contextual-menu.
	   */
	  onFollowLink: function () {
	    let type = this.panelDoc.popupNode.dataset.type;
	    let link = this.panelDoc.popupNode.dataset.link;

	    this.followAttributeLink(type, link);
	  },

	  /**
	   * Given a type and link found in a node's attribute in the markup-view,
	   * attempt to follow that link (which may result in opening a new tab, the
	   * style editor or debugger).
	   */
	  followAttributeLink: function (type, link) {
	    var _this13 = this;

	    if (!type || !link) {
	      return;
	    }

	    if (type === "uri" || type === "cssresource" || type === "jsresource") {
	      // Open link in a new tab.
	      // When the inspector menu was setup on click (see _setupNodeLinkMenu), we
	      // already checked that resolveRelativeURL existed.
	      this.inspector.resolveRelativeURL(link, this.selection.nodeFront).then(function (url) {
	        if (type === "uri") {
	          let browserWin = _this13.target.tab.ownerDocument.defaultView;
	          browserWin.openUILinkIn(url, "tab");
	        } else if (type === "cssresource") {
	          return _this13.toolbox.viewSourceInStyleEditor(url);
	        } else if (type === "jsresource") {
	          return _this13.toolbox.viewSourceInDebugger(url);
	        }
	      }).catch(function (e) {
	        return console.error(e);
	      });
	    } else if (type == "idref") {
	      // Select the node in the same document.
	      this.walker.document(this.selection.nodeFront).then(function (doc) {
	        return _this13.walker.querySelector(doc, "#" + CSS.escape(link)).then(function (node) {
	          if (!node) {
	            _this13.emit("idref-attribute-link-failed");
	            return;
	          }
	          _this13.selection.setNodeFront(node);
	        });
	      }).catch(function (e) {
	        return console.error(e);
	      });
	    }
	  },

	  /**
	   * This method is here for the benefit of the node-menu-link-copy menu item
	   * in the inspector contextual-menu.
	   */
	  onCopyLink: function () {
	    let link = this.panelDoc.popupNode.dataset.link;

	    this.copyAttributeLink(link);
	  },

	  /**
	   * This method is here for the benefit of copying links.
	   */
	  copyAttributeLink: function (link) {
	    // When the inspector menu was setup on click (see _setupNodeLinkMenu), we
	    // already checked that resolveRelativeURL existed.
	    this.inspector.resolveRelativeURL(link, this.selection.nodeFront).then(function (url) {
	      clipboardHelper.copy(url);
	    }, console.error);
	  },

	  /**
	   * Trigger a high-priority layout change for things that need to be
	   * updated immediately
	   */
	  immediateLayoutChange: function () {
	    this.emit("layout-change");
	  },

	  /**
	   * Schedule a low-priority change event for things like paint
	   * and resize.
	   */
	  scheduleLayoutChange: function (event) {
	    var _this14 = this;

	    // Filter out non browser window resize events (i.e. triggered by iframes)
	    if (this.browser.contentWindow === event.target) {
	      if (this._timer) {
	        return null;
	      }
	      this._timer = this.panelWin.setTimeout(function () {
	        _this14.emit("layout-change");
	        _this14._timer = null;
	      }, LAYOUT_CHANGE_TIMER);
	    }
	  },

	  /**
	   * Cancel a pending low-priority change event if any is
	   * scheduled.
	   */
	  cancelLayoutChange: function () {
	    if (this._timer) {
	      this.panelWin.clearTimeout(this._timer);
	      delete this._timer;
	    }
	  }
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	"use strict";

	/*
	 * A sham for features of `sdk/clipboard` and `nsIClipboardHelper`
	 */

	// Store it as a var for now
	var clipboard = "";

	module.exports = {
	  get: function () {
	    return clipboard;
	  },
	  copy: function (str) {
	    return clipboard = str;
	  },
	  currentFlavors: ["text/html"]
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Cu = _require.Cu;
	const Ci = _require.Ci;

	// Page size for pageup/pagedown

	const PAGE_SIZE = 10;
	const DEFAULT_MAX_CHILDREN = 100;
	const COLLAPSE_ATTRIBUTE_LENGTH = 120;
	const COLLAPSE_DATA_URL_REGEX = /^data.+base64/;
	const COLLAPSE_DATA_URL_LENGTH = 60;
	const NEW_SELECTION_HIGHLIGHTER_TIMER = 1000;
	const DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE = 50;
	const DRAG_DROP_MIN_AUTOSCROLL_SPEED = 5;
	const DRAG_DROP_MAX_AUTOSCROLL_SPEED = 15;
	const DRAG_DROP_MIN_INITIAL_DISTANCE = 10;
	const AUTOCOMPLETE_POPUP_PANEL_ID = "markupview_autoCompletePopup";

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	var _require3 = __webpack_require__(33);

	const UndoStack = _require3.UndoStack;

	var _require4 = __webpack_require__(34);

	const editableField = _require4.editableField;
	const InplaceEditor = _require4.InplaceEditor;

	var _require5 = __webpack_require__(35);

	const HTMLEditor = _require5.HTMLEditor;

	const promise = __webpack_require__(6);

	var _require6 = __webpack_require__(54);

	const Tooltip = _require6.Tooltip;

	const EventEmitter = __webpack_require__(7);
	const Heritage = __webpack_require__(64);

	var _require7 = __webpack_require__(86);

	const parseAttribute = _require7.parseAttribute;

	const ELLIPSIS = "…"; // Should be l10n'd

	var _require8 = __webpack_require__(38);

	const Task = _require8.Task;

	var _require9 = __webpack_require__(73);

	const scrollIntoViewIfNeeded = _require9.scrollIntoViewIfNeeded;

	const clipboardHelper = __webpack_require__(31);

	// Removed this already, will need to bring it back if this is called

	var _require10 = __webpack_require__(87);

	const template = _require10.template;

	var _require11 = __webpack_require__(15);

	const XPCOMUtils = _require11.XPCOMUtils;

	loader.lazyGetter(this, "DOMParser", function () {
	  return Cc("@mozilla.org/xmlextras/domparser;1").createInstance(Ci.nsIDOMParser);
	});

	var _require12 = __webpack_require__(44);

	const AutocompletePopup = _require12.AutocompletePopup;

	/**
	 * Vocabulary for the purposes of this file:
	 *
	 * MarkupContainer - the structure that holds an editor and its
	 *  immediate children in the markup panel.
	 *  - MarkupElementContainer: markup container for element nodes
	 *  - MarkupTextContainer: markup container for text / comment nodes
	 *  - MarkupReadonlyContainer: markup container for other nodes
	 * Node - A content node.
	 * object.elt - A UI element in the markup panel.
	 */

	/**
	 * The markup tree.  Manages the mapping of nodes to MarkupContainers,
	 * updating based on mutations, and the undo/redo bindings.
	 *
	 * @param Inspector aInspector
	 *        The inspector we're watching.
	 * @param iframe aFrame
	 *        An iframe in which the caller has kindly loaded markup-view.xhtml.
	 */

	function MarkupView(aInspector, aFrame, aControllerWindow) {
	  this._inspector = aInspector;
	  this.walker = this._inspector.walker;
	  this._frame = aFrame;
	  this.win = this._frame.contentWindow;
	  this.doc = this._frame.contentDocument;
	  this._elt = this.doc.querySelector("#root");
	  // XXX: source editor doesn't work yet
	  // this.htmlEditor = { hide: () => {}, refresh: () => {}, show: () => {}, destroy: () => {}, once: () => {}}
	  this.htmlEditor = new HTMLEditor(this.doc);

	  try {
	    this.maxChildren = Services.prefs.getIntPref("devtools.markup.pagesize");
	  } catch (ex) {
	    this.maxChildren = DEFAULT_MAX_CHILDREN;
	  }

	  // Creating the popup to be used to show CSS suggestions.
	  let options = {
	    autoSelect: true,
	    theme: "auto",
	    // panelId option prevents the markupView autocomplete popup from
	    // sharing XUL elements with other views, such as ruleView (see Bug 1191093)
	    panelId: AUTOCOMPLETE_POPUP_PANEL_ID
	  };
	  this.popup = new AutocompletePopup(this.doc.defaultView.parent.document, options);

	  this.undo = new UndoStack();
	  this.undo.installController(aControllerWindow);

	  this._containers = new Map();

	  // Binding functions that need to be called in scope.
	  this._mutationObserver = this._mutationObserver.bind(this);
	  this._onDisplayChange = this._onDisplayChange.bind(this);
	  this._onMouseClick = this._onMouseClick.bind(this);
	  this._onMouseUp = this._onMouseUp.bind(this);
	  this._onNewSelection = this._onNewSelection.bind(this);
	  this._onKeyDown = this._onKeyDown.bind(this);
	  this._onCopy = this._onCopy.bind(this);
	  this._onFocus = this._onFocus.bind(this);
	  this._onMouseMove = this._onMouseMove.bind(this);
	  this._onMouseLeave = this._onMouseLeave.bind(this);
	  this._onToolboxPickerHover = this._onToolboxPickerHover.bind(this);

	  // Listening to various events.
	  this._elt.addEventListener("click", this._onMouseClick, false);
	  this._elt.addEventListener("mousemove", this._onMouseMove, false);
	  this._elt.addEventListener("mouseleave", this._onMouseLeave, false);
	  this.doc.body.addEventListener("mouseup", this._onMouseUp);
	  this.win.addEventListener("keydown", this._onKeyDown, false);
	  this.win.addEventListener("copy", this._onCopy);
	  this._frame.addEventListener("focus", this._onFocus, false);
	  this.walker.on("mutations", this._mutationObserver);
	  this.walker.on("display-change", this._onDisplayChange);
	  this._inspector.selection.on("new-node-front", this._onNewSelection);
	  this._inspector.toolbox.on("picker-node-hovered", this._onToolboxPickerHover);

	  this._onNewSelection();
	  this._initTooltips();

	  EventEmitter.decorate(this);
	}

	exports.MarkupView = MarkupView;

	MarkupView.prototype = {
	  /**
	   * How long does a node flash when it mutates (in ms).
	   */
	  CONTAINER_FLASHING_DURATION: 500,

	  _selectedContainer: null,

	  _initTooltips: function () {
	    this.tooltip = new Tooltip(this._inspector.panelDoc);
	    this._makeTooltipPersistent(false);
	  },

	  _makeTooltipPersistent: function (state) {
	    if (state) {
	      this.tooltip.stopTogglingOnHover();
	    } else {
	      this.tooltip.startTogglingOnHover(this._elt, this._isImagePreviewTarget.bind(this));
	    }
	  },

	  _onToolboxPickerHover: function (event, nodeFront) {
	    var _this = this;

	    this.showNode(nodeFront).then(function () {
	      _this._showContainerAsHovered(nodeFront);
	    }, function (e) {
	      return console.error(e);
	    });
	  },

	  isDragging: false,

	  _onMouseMove: function (event) {
	    let target = event.target;

	    // Auto-scroll if we're dragging.
	    if (this.isDragging) {
	      event.preventDefault();
	      this._autoScroll(event);
	      return;
	    }

	    // Show the current container as hovered and highlight it.
	    // This requires finding the current MarkupContainer (walking up the DOM).
	    while (!target.container) {
	      if (target.tagName.toLowerCase() === "body") {
	        return;
	      }
	      target = target.parentNode;
	    }

	    let container = target.container;
	    if (this._hoveredNode !== container.node) {
	      if (container.node.nodeType !== Ci.nsIDOMNode.TEXT_NODE) {
	        this._showBoxModel(container.node);
	      } else {
	        this._hideBoxModel();
	      }
	    }
	    this._showContainerAsHovered(container.node);
	  },

	  /**
	   * Executed on each mouse-move while a node is being dragged in the view.
	   * Auto-scrolls the view to reveal nodes below the fold to drop the dragged
	   * node in.
	   */
	  _autoScroll: function (event) {
	    let docEl = this.doc.documentElement;

	    if (this._autoScrollInterval) {
	      clearInterval(this._autoScrollInterval);
	    }

	    // Auto-scroll when the mouse approaches top/bottom edge.
	    let fromBottom = docEl.clientHeight - event.pageY + this.win.scrollY;
	    let fromTop = event.pageY - this.win.scrollY;

	    if (fromBottom <= DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE) {
	      // Map our distance from 0-50 to 5-15 range so the speed is kept in a
	      // range not too fast, not too slow.
	      let speed = map(fromBottom, 0, DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE, DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);

	      this._autoScrollInterval = setInterval(function () {
	        docEl.scrollTop -= speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED;
	      }, 0);
	    }

	    if (fromTop <= DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE) {
	      let speed = map(fromTop, 0, DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE, DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);

	      this._autoScrollInterval = setInterval(function () {
	        docEl.scrollTop += speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED;
	      }, 0);
	    }
	  },

	  _onMouseClick: function (event) {
	    // From the target passed here, let's find the parent MarkupContainer
	    // and ask it if the tooltip should be shown
	    let parentNode = event.target;
	    let container;
	    while (parentNode !== this.doc.body) {
	      if (parentNode.container) {
	        container = parentNode.container;
	        break;
	      }
	      parentNode = parentNode.parentNode;
	    }

	    if (container instanceof MarkupElementContainer) {
	      // With the newly found container, delegate the tooltip content creation
	      // and decision to show or not the tooltip
	      container._buildEventTooltipContent(event.target, this.tooltip);
	    }
	  },

	  _onMouseUp: function () {
	    this.indicateDropTarget(null);
	    this.indicateDragTarget(null);
	    if (this._autoScrollInterval) {
	      clearInterval(this._autoScrollInterval);
	    }
	  },

	  cancelDragging: function () {
	    if (!this.isDragging) {
	      return;
	    }

	    for (let _ref of this._containers) {
	      var _ref2 = _slicedToArray(_ref, 2);

	      let container = _ref2[1];

	      if (container.isDragging) {
	        container.cancelDragging();
	        break;
	      }
	    }

	    this.indicateDropTarget(null);
	    this.indicateDragTarget(null);
	    if (this._autoScrollInterval) {
	      clearInterval(this._autoScrollInterval);
	    }
	  },

	  _hoveredNode: null,

	  /**
	   * Show a NodeFront's container as being hovered
	   * @param {NodeFront} nodeFront The node to show as hovered
	   */
	  _showContainerAsHovered: function (nodeFront) {
	    if (this._hoveredNode === nodeFront) {
	      return;
	    }

	    if (this._hoveredNode) {
	      this.getContainer(this._hoveredNode).hovered = false;
	    }

	    this.getContainer(nodeFront).hovered = true;
	    this._hoveredNode = nodeFront;
	  },

	  _onMouseLeave: function () {
	    if (this._autoScrollInterval) {
	      clearInterval(this._autoScrollInterval);
	    }
	    if (this.isDragging) {
	      return;
	    }

	    this._hideBoxModel(true);
	    if (this._hoveredNode) {
	      this.getContainer(this._hoveredNode).hovered = false;
	    }
	    this._hoveredNode = null;
	  },

	  /**
	   * Show the box model highlighter on a given node front
	   * @param {NodeFront} nodeFront The node to show the highlighter for
	   * @return a promise that resolves when the highlighter for this nodeFront is
	   * shown, taking into account that there could already be highlighter requests
	   * queued up
	   */
	  _showBoxModel: function (nodeFront) {
	    return this._inspector.toolbox.highlighterUtils.highlightNodeFront(nodeFront);
	  },

	  /**
	   * Hide the box model highlighter on a given node front
	   * @param {NodeFront} nodeFront The node to hide the highlighter for
	   * @param {Boolean} forceHide See toolbox-highlighter-utils/unhighlight
	   * @return a promise that resolves when the highlighter for this nodeFront is
	   * hidden, taking into account that there could already be highlighter requests
	   * queued up
	   */
	  _hideBoxModel: function (forceHide) {
	    return this._inspector.toolbox.highlighterUtils.unhighlight(forceHide);
	  },

	  _briefBoxModelTimer: null,

	  _clearBriefBoxModelTimer: function () {
	    if (this._briefBoxModelTimer) {
	      clearTimeout(this._briefBoxModelTimer);
	      this._briefBoxModelPromise.resolve();
	      this._briefBoxModelPromise = null;
	      this._briefBoxModelTimer = null;
	    }
	  },

	  _brieflyShowBoxModel: function (nodeFront) {
	    var _this2 = this;

	    this._clearBriefBoxModelTimer();
	    let onShown = this._showBoxModel(nodeFront);
	    this._briefBoxModelPromise = promise.defer();

	    this._briefBoxModelTimer = setTimeout(function () {
	      _this2._hideBoxModel().then(_this2._briefBoxModelPromise.resolve, _this2._briefBoxModelPromise.resolve);
	    }, NEW_SELECTION_HIGHLIGHTER_TIMER);

	    return promise.all([onShown, this._briefBoxModelPromise.promise]);
	  },

	  template: function (aName, aDest, aOptions = { stack: "markup-view.xhtml" }) {
	    let node = this.doc.getElementById("template-" + aName).cloneNode(true);
	    node.removeAttribute("id");
	    // See above: removed already, will need to bring it back if this is called
	    template(node, aDest, aOptions);
	    return node;
	  },

	  /**
	   * Get the MarkupContainer object for a given node, or undefined if
	   * none exists.
	   */
	  getContainer: function (aNode) {
	    return this._containers.get(aNode);
	  },

	  update: function () {
	    var _this3 = this;

	    let updateChildren = function (node) {
	      _this3.getContainer(node).update();
	      for (let child of node.treeChildren()) {
	        updateChildren(child);
	      }
	    };

	    // Start with the documentElement
	    let documentElement;
	    for (let node of this._rootNode.treeChildren()) {
	      if (node.isDocumentElement === true) {
	        documentElement = node;
	        break;
	      }
	    }

	    // Recursively update each node starting with documentElement.
	    updateChildren(documentElement);
	  },

	  /**
	   * Executed when the mouse hovers over a target in the markup-view and is used
	   * to decide whether this target should be used to display an image preview
	   * tooltip.
	   * Delegates the actual decision to the corresponding MarkupContainer instance
	   * if one is found.
	   * @return the promise returned by MarkupElementContainer._isImagePreviewTarget
	   */
	  _isImagePreviewTarget: function (target) {
	    // From the target passed here, let's find the parent MarkupContainer
	    // and ask it if the tooltip should be shown
	    if (this.isDragging) {
	      return promise.reject(false);
	    }

	    let parent = target,
	        container;
	    while (parent !== this.doc.body) {
	      if (parent.container) {
	        container = parent.container;
	        break;
	      }
	      parent = parent.parentNode;
	    }

	    if (container instanceof MarkupElementContainer) {
	      // With the newly found container, delegate the tooltip content creation
	      // and decision to show or not the tooltip
	      return container.isImagePreviewTarget(target, this.tooltip);
	    }
	  },

	  /**
	   * Given the known reason, should the current selection be briefly highlighted
	   * In a few cases, we don't want to highlight the node:
	   * - If the reason is null (used to reset the selection),
	   * - if it's "inspector-open" (when the inspector opens up, let's not highlight
	   * the default node)
	   * - if it's "navigateaway" (since the page is being navigated away from)
	   * - if it's "test" (this is a special case for mochitest. In tests, we often
	   * need to select elements but don't necessarily want the highlighter to come
	   * and go after a delay as this might break test scenarios)
	   * We also do not want to start a brief highlight timeout if the node is already
	   * being hovered over, since in that case it will already be highlighted.
	   */
	  _shouldNewSelectionBeHighlighted: function () {
	    let reason = this._inspector.selection.reason;
	    let unwantedReasons = ["inspector-open", "navigateaway", "nodeselected", "test"];
	    let isHighlitNode = this._hoveredNode === this._inspector.selection.nodeFront;
	    return !isHighlitNode && reason && unwantedReasons.indexOf(reason) === -1;
	  },

	  /**
	   * React to new-node-front selection events.
	   * Highlights the node if needed, and make sure it is shown and selected in
	   * the view.
	   */
	  _onNewSelection: function () {
	    var _this4 = this;

	    let selection = this._inspector.selection;

	    this.htmlEditor.hide();
	    if (this._hoveredNode && this._hoveredNode !== selection.nodeFront) {
	      this.getContainer(this._hoveredNode).hovered = false;
	      this._hoveredNode = null;
	    }

	    if (!selection.isNode()) {
	      this.unmarkSelectedNode();
	      return;
	    }

	    let done = this._inspector.updating("markup-view");
	    let onShowBoxModel, onShow;

	    // Highlight the element briefly if needed.
	    if (this._shouldNewSelectionBeHighlighted()) {
	      onShowBoxModel = this._brieflyShowBoxModel(selection.nodeFront);
	    }

	    onShow = this.showNode(selection.nodeFront).then(function () {
	      // We could be destroyed by now.
	      if (_this4._destroyer) {
	        return promise.reject("markupview destroyed");
	      }

	      // Mark the node as selected.
	      _this4.markNodeAsSelected(selection.nodeFront);

	      // Make sure the new selection receives focus so the keyboard can be used.
	      _this4.maybeFocusNewSelection();
	    }).catch(function (e) {
	      if (!_this4._destroyer) {
	        console.error(e);
	      } else {
	        console.warn("Could not mark node as selected, the markup-view was " + "destroyed while showing the node.");
	      }
	    });

	    promise.all([onShowBoxModel, onShow]).then(done);
	  },

	  /**
	   * Focus the current node selection's MarkupContainer if the selection
	   * happened because the user picked an element using the element picker or
	   * browser context menu.
	   */
	  maybeFocusNewSelection: function () {
	    var _inspector$selection = this._inspector.selection;
	    let reason = _inspector$selection.reason;
	    let nodeFront = _inspector$selection.nodeFront;

	    if (reason !== "browser-context-menu" && reason !== "picker-node-picked") {
	      return;
	    }

	    this.getContainer(nodeFront).focus();
	  },

	  /**
	   * Create a TreeWalker to find the next/previous
	   * node for selection.
	   */
	  _selectionWalker: function (aStart) {
	    let walker = this.doc.createTreeWalker(aStart || this._elt, Ci.nsIDOMNodeFilter.SHOW_ELEMENT, function (aElement) {
	      if (aElement.container && aElement.container.elt === aElement && aElement.container.visible) {
	        return Ci.nsIDOMNodeFilter.FILTER_ACCEPT;
	      }
	      return Ci.nsIDOMNodeFilter.FILTER_SKIP;
	    });
	    walker.currentNode = this._selectedContainer.elt;
	    return walker;
	  },

	  _onCopy: function (evt) {
	    // Ignore copy events from editors
	    if (this._isInputOrTextarea(evt.target)) {
	      return;
	    }

	    let selection = this._inspector.selection;
	    if (selection.isNode()) {
	      this._inspector.copyOuterHTML();
	    }
	    evt.stopPropagation();
	    evt.preventDefault();
	  },

	  /**
	   * Key handling.
	   */
	  _onKeyDown: function (aEvent) {
	    let handled = true;

	    // Ignore keystrokes that originated in editors.
	    if (this._isInputOrTextarea(aEvent.target)) {
	      return;
	    }

	    switch (aEvent.keyCode) {
	      case Ci.nsIDOMKeyEvent.DOM_VK_H:
	        if (aEvent.metaKey || aEvent.shiftKey) {
	          handled = false;
	        } else {
	          let node = this._selectedContainer.node;
	          if (node.hidden) {
	            this.walker.unhideNode(node);
	          } else {
	            this.walker.hideNode(node);
	          }
	        }
	        break;
	      case Ci.nsIDOMKeyEvent.DOM_VK_DELETE:
	        this.deleteNodeOrAttribute();
	        break;
	      case Ci.nsIDOMKeyEvent.DOM_VK_BACK_SPACE:
	        this.deleteNodeOrAttribute(true);
	        break;
	      case Ci.nsIDOMKeyEvent.DOM_VK_HOME:
	        let rootContainer = this.getContainer(this._rootNode);
	        this.navigate(rootContainer.children.firstChild.container);
	        break;
	      case Ci.nsIDOMKeyEvent.DOM_VK_LEFT:
	        if (this._selectedContainer.expanded) {
	          this.collapseNode(this._selectedContainer.node);
	        } else {
	          let parent = this._selectionWalker().parentNode();
	          if (parent) {
	            this.navigate(parent.container);
	          }
	        }
	        break;
	      case Ci.nsIDOMKeyEvent.DOM_VK_RIGHT:
	        if (!this._selectedContainer.expanded && this._selectedContainer.hasChildren) {
	          this._expandContainer(this._selectedContainer);
	        } else {
	          let next = this._selectionWalker().nextNode();
	          if (next) {
	            this.navigate(next.container);
	          }
	        }
	        break;
	      case Ci.nsIDOMKeyEvent.DOM_VK_UP:
	        let prev = this._selectionWalker().previousNode();
	        if (prev) {
	          this.navigate(prev.container);
	        }
	        break;
	      case Ci.nsIDOMKeyEvent.DOM_VK_DOWN:
	        let next = this._selectionWalker().nextNode();
	        if (next) {
	          this.navigate(next.container);
	        }
	        break;
	      case Ci.nsIDOMKeyEvent.DOM_VK_PAGE_UP:
	        {
	          let walker = this._selectionWalker();
	          let selection = this._selectedContainer;
	          for (let i = 0; i < PAGE_SIZE; i++) {
	            let prev = walker.previousNode();
	            if (!prev) {
	              break;
	            }
	            selection = prev.container;
	          }
	          this.navigate(selection);
	          break;
	        }
	      case Ci.nsIDOMKeyEvent.DOM_VK_PAGE_DOWN:
	        {
	          let walker = this._selectionWalker();
	          let selection = this._selectedContainer;
	          for (let i = 0; i < PAGE_SIZE; i++) {
	            let next = walker.nextNode();
	            if (!next) {
	              break;
	            }
	            selection = next.container;
	          }
	          this.navigate(selection);
	          break;
	        }
	      case Ci.nsIDOMKeyEvent.DOM_VK_F2:
	        {
	          this.beginEditingOuterHTML(this._selectedContainer.node);
	          break;
	        }
	      case Ci.nsIDOMKeyEvent.DOM_VK_S:
	        {
	          let selection = this._selectedContainer.node;
	          this._inspector.scrollNodeIntoView(selection);
	          break;
	        }
	      case Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE:
	        {
	          if (this.isDragging) {
	            this.cancelDragging();
	            break;
	          }
	        }
	      default:
	        handled = false;
	    }
	    if (handled) {
	      aEvent.stopPropagation();
	      aEvent.preventDefault();
	    }
	  },

	  /**
	   * Check if a node is an input or textarea
	   */
	  _isInputOrTextarea: function (element) {
	    let name = element.tagName.toLowerCase();
	    return name === "input" || name === "textarea";
	  },

	  /**
	   * If there's an attribute on the current node that's currently focused, then
	   * delete this attribute, otherwise delete the node itself.
	   * @param {boolean} moveBackward If set to true and if we're deleting the
	   * node, focus the previous sibling after deletion, otherwise the next one.
	   */
	  deleteNodeOrAttribute: function (moveBackward) {
	    let focusedAttribute = this.doc.activeElement ? this.doc.activeElement.closest(".attreditor") : null;
	    if (focusedAttribute) {
	      // The focused attribute might not be in the current selected container.
	      let container = focusedAttribute.closest("li.child").container;
	      container.removeAttribute(focusedAttribute.dataset.attr);
	    } else {
	      this.deleteNode(this._selectedContainer.node, moveBackward);
	    }
	  },

	  /**
	   * Delete a node from the DOM.
	   * This is an undoable action.
	   *
	   * @param {NodeFront} aNode The node to remove.
	   * @param {boolean} moveBackward If set to true, focus the previous sibling,
	   * otherwise the next one.
	   */
	  deleteNode: function (aNode, moveBackward) {
	    var _this5 = this;

	    if (aNode.isDocumentElement || aNode.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE || aNode.isAnonymous) {
	      return;
	    }

	    let container = this.getContainer(aNode);

	    // Retain the node so we can undo this...
	    this.walker.retainNode(aNode).then(function () {
	      let parent = aNode.parentNode();
	      let nextSibling = null;
	      _this5.undo.do(function () {
	        _this5.walker.removeNode(aNode).then(function (siblings) {
	          nextSibling = siblings.nextSibling;
	          let focusNode = moveBackward ? siblings.previousSibling : nextSibling;

	          // If we can't move as the user wants, we move to the other direction.
	          // If there is no sibling elements anymore, move to the parent node.
	          if (!focusNode) {
	            focusNode = nextSibling || siblings.previousSibling || parent;
	          }

	          if (container.selected) {
	            _this5.navigate(_this5.getContainer(focusNode));
	          }
	        });
	      }, function () {
	        _this5.walker.insertBefore(aNode, parent, nextSibling);
	      });
	    }).then(null, console.error);
	  },

	  /**
	   * If an editable item is focused, select its container.
	   */
	  _onFocus: function (aEvent) {
	    let parent = aEvent.target;
	    while (!parent.container) {
	      parent = parent.parentNode;
	    }
	    if (parent) {
	      this.navigate(parent.container, true);
	    }
	  },

	  /**
	   * Handle a user-requested navigation to a given MarkupContainer,
	   * updating the inspector's currently-selected node.
	   *
	   * @param MarkupContainer aContainer
	   *        The container we're navigating to.
	   * @param aIgnoreFocus aIgnoreFocus
	   *        If falsy, keyboard focus will be moved to the container too.
	   */
	  navigate: function (aContainer, aIgnoreFocus) {
	    if (!aContainer) {
	      return;
	    }

	    let node = aContainer.node;
	    this.markNodeAsSelected(node, "treepanel");

	    if (!aIgnoreFocus) {
	      aContainer.focus();
	    }
	  },

	  /**
	   * Make sure a node is included in the markup tool.
	   *
	   * @param NodeFront aNode
	   *        The node in the content document.
	   * @param boolean aFlashNode
	   *        Whether the newly imported node should be flashed
	   * @returns MarkupContainer The MarkupContainer object for this element.
	   */
	  importNode: function (aNode, aFlashNode) {
	    if (!aNode) {
	      return null;
	    }

	    if (this._containers.has(aNode)) {
	      return this.getContainer(aNode);
	    }

	    let container;
	    let nodeType = aNode.nodeType;
	    let isPseudoElement = aNode.isPseudoElement;

	    if (aNode === this.walker.rootNode) {
	      container = new RootContainer(this, aNode);
	      this._elt.appendChild(container.elt);
	      this._rootNode = aNode;
	    } else if (nodeType == Ci.nsIDOMNode.ELEMENT_NODE && !isPseudoElement) {
	      container = new MarkupElementContainer(this, aNode, this._inspector);
	    } else if (nodeType == Ci.nsIDOMNode.COMMENT_NODE || nodeType == Ci.nsIDOMNode.TEXT_NODE) {
	      container = new MarkupTextContainer(this, aNode, this._inspector);
	    } else {
	      container = new MarkupReadOnlyContainer(this, aNode, this._inspector);
	    }

	    if (aFlashNode) {
	      container.flashMutation();
	    }

	    this._containers.set(aNode, container);
	    container.childrenDirty = true;

	    this._updateChildren(container);

	    this._inspector.emit("container-created", container);

	    return container;
	  },

	  /**
	   * Mutation observer used for included nodes.
	   */
	  _mutationObserver: function (aMutations) {
	    var _this6 = this;

	    let requiresLayoutChange = false;

	    for (let mutation of aMutations) {
	      let type = mutation.type;
	      let target = mutation.target;

	      if (mutation.type === "documentUnload") {
	        // Treat this as a childList change of the child (maybe the protocol
	        // should do this).
	        type = "childList";
	        target = mutation.targetParent;
	        if (!target) {
	          continue;
	        }
	      }

	      let container = this.getContainer(target);
	      if (!container) {
	        // Container might not exist if this came from a load event for a node
	        // we're not viewing.
	        continue;
	      }
	      if (type === "attributes" || type === "characterData") {
	        container.update();

	        // Auto refresh style properties on selected node when they change.
	        if (type === "attributes" && container.selected) {
	          requiresLayoutChange = true;
	        }
	      } else if (type === "childList" || type === "nativeAnonymousChildList") {
	        container.childrenDirty = true;
	        // Update the children to take care of changes in the markup view DOM.
	        this._updateChildren(container, { flash: true });
	      } else if (type === "pseudoClassLock") {
	        container.update();
	      }
	    }

	    if (requiresLayoutChange) {
	      this._inspector.immediateLayoutChange();
	    }
	    this._waitForChildren().then(function (nodes) {
	      if (_this6._destroyer) {
	        console.warn("Could not fully update after markup mutations, " + "the markup-view was destroyed while waiting for children.");
	        return;
	      }
	      _this6._flashMutatedNodes(aMutations);
	      _this6._inspector.emit("markupmutation", aMutations);

	      // Since the htmlEditor is absolutely positioned, a mutation may change
	      // the location in which it should be shown.
	      _this6.htmlEditor.refresh();
	    });
	  },

	  /**
	   * React to display-change events from the walker
	   * @param {Array} nodes An array of nodeFronts
	   */
	  _onDisplayChange: function (nodes) {
	    for (let node of nodes) {
	      let container = this.getContainer(node);
	      if (container) {
	        container.isDisplayed = node.isDisplayed;
	      }
	    }
	  },

	  /**
	   * Given a list of mutations returned by the mutation observer, flash the
	   * corresponding containers to attract attention.
	   */
	  _flashMutatedNodes: function (aMutations) {
	    var _this7 = this;

	    let addedOrEditedContainers = new Set();
	    let removedContainers = new Set();

	    for (let _ref3 of aMutations) {
	      let type = _ref3.type;
	      let target = _ref3.target;
	      let added = _ref3.added;
	      let removed = _ref3.removed;
	      let newValue = _ref3.newValue;

	      let container = this.getContainer(target);

	      if (container) {
	        if (type === "characterData") {
	          addedOrEditedContainers.add(container);
	        } else if (type === "attributes" && newValue === null) {
	          // Removed attributes should flash the entire node.
	          // New or changed attributes will flash the attribute itself
	          // in ElementEditor.flashAttribute.
	          addedOrEditedContainers.add(container);
	        } else if (type === "childList") {
	          // If there has been removals, flash the parent
	          if (removed.length) {
	            removedContainers.add(container);
	          }

	          // If there has been additions, flash the nodes if their associated
	          // container exist (so if their parent is expanded in the inspector).
	          added.forEach(function (added) {
	            let addedContainer = _this7.getContainer(added);
	            if (addedContainer) {
	              addedOrEditedContainers.add(addedContainer);

	              // The node may be added as a result of an append, in which case
	              // it will have been removed from another container first, but in
	              // these cases we don't want to flash both the removal and the
	              // addition
	              removedContainers.delete(container);
	            }
	          });
	        }
	      }
	    }

	    for (let container of removedContainers) {
	      container.flashMutation();
	    }
	    for (let container of addedOrEditedContainers) {
	      container.flashMutation();
	    }
	  },

	  /**
	   * Make sure the given node's parents are expanded and the
	   * node is scrolled on to screen.
	   */
	  showNode: function (aNode, centered = true) {
	    var _this8 = this;

	    let parent = aNode;

	    this.importNode(aNode);

	    while (parent = parent.parentNode()) {
	      this.importNode(parent);
	      this.expandNode(parent);
	    }

	    return this._waitForChildren().then(function () {
	      if (_this8._destroyer) {
	        return promise.reject("markupview destroyed");
	      }
	      return _this8._ensureVisible(aNode);
	    }).then(function () {
	      scrollIntoViewIfNeeded(_this8.getContainer(aNode).editor.elt, centered);
	    }, function (e) {
	      // Only report this rejection as an error if the panel hasn't been
	      // destroyed in the meantime.
	      if (!_this8._destroyer) {
	        console.error(e);
	      } else {
	        console.warn("Could not show the node, the markup-view was destroyed " + "while waiting for children");
	      }
	    });
	  },

	  /**
	   * Expand the container's children.
	   */
	  _expandContainer: function (aContainer) {
	    var _this9 = this;

	    return this._updateChildren(aContainer, { expand: true }).then(function () {
	      if (_this9._destroyer) {
	        console.warn("Could not expand the node, the markup-view was destroyed");
	        return;
	      }
	      aContainer.setExpanded(true);
	    });
	  },

	  /**
	   * Expand the node's children.
	   */
	  expandNode: function (aNode) {
	    let container = this.getContainer(aNode);
	    this._expandContainer(container);
	  },

	  /**
	   * Expand the entire tree beneath a container.
	   *
	   * @param aContainer The container to expand.
	   */
	  _expandAll: function (aContainer) {
	    var _this10 = this;

	    return this._expandContainer(aContainer).then(function () {
	      let child = aContainer.children.firstChild;
	      let promises = [];
	      while (child) {
	        promises.push(_this10._expandAll(child.container));
	        child = child.nextSibling;
	      }
	      return promise.all(promises);
	    }).then(null, console.error);
	  },

	  /**
	   * Expand the entire tree beneath a node.
	   *
	   * @param aContainer The node to expand, or null
	   *        to start from the top.
	   */
	  expandAll: function (aNode) {
	    aNode = aNode || this._rootNode;
	    return this._expandAll(this.getContainer(aNode));
	  },

	  /**
	   * Collapse the node's children.
	   */
	  collapseNode: function (aNode) {
	    let container = this.getContainer(aNode);
	    container.setExpanded(false);
	  },

	  /**
	   * Returns either the innerHTML or the outerHTML for a remote node.
	   * @param aNode The NodeFront to get the outerHTML / innerHTML for.
	   * @param isOuter A boolean that, if true, makes the function return the
	   *                outerHTML, otherwise the innerHTML.
	   * @returns A promise that will be resolved with the outerHTML / innerHTML.
	   */
	  _getNodeHTML: function (aNode, isOuter) {
	    let walkerPromise = null;

	    if (isOuter) {
	      walkerPromise = this.walker.outerHTML(aNode);
	    } else {
	      walkerPromise = this.walker.innerHTML(aNode);
	    }

	    return walkerPromise.then(function (longstr) {
	      return longstr.string().then(function (html) {
	        longstr.release().then(null, console.error);
	        return html;
	      });
	    });
	  },

	  /**
	   * Retrieve the outerHTML for a remote node.
	   * @param aNode The NodeFront to get the outerHTML for.
	   * @returns A promise that will be resolved with the outerHTML.
	   */
	  getNodeOuterHTML: function (aNode) {
	    return this._getNodeHTML(aNode, true);
	  },

	  /**
	   * Retrieve the innerHTML for a remote node.
	   * @param aNode The NodeFront to get the innerHTML for.
	   * @returns A promise that will be resolved with the innerHTML.
	   */
	  getNodeInnerHTML: function (aNode) {
	    return this._getNodeHTML(aNode);
	  },

	  /**
	   * Listen to mutations, expect a given node to be removed and try and select
	   * the node that sits at the same place instead.
	   * This is useful when changing the outerHTML or the tag name so that the
	   * newly inserted node gets selected instead of the one that just got removed.
	   */
	  reselectOnRemoved: function (removedNode, reason) {
	    var _this11 = this;

	    // Only allow one removed node reselection at a time, so that when there are
	    // more than 1 request in parallel, the last one wins.
	    this.cancelReselectOnRemoved();

	    // Get the removedNode index in its parent node to reselect the right node.
	    let isHTMLTag = removedNode.tagName.toLowerCase() === "html";
	    let oldContainer = this.getContainer(removedNode);
	    let parentContainer = this.getContainer(removedNode.parentNode());
	    let childIndex = parentContainer.getChildContainers().indexOf(oldContainer);

	    let onMutations = this._removedNodeObserver = function (e, mutations) {
	      let isNodeRemovalMutation = false;
	      for (let mutation of mutations) {
	        let containsRemovedNode = mutation.removed && mutation.removed.some(function (n) {
	          return n === removedNode;
	        });
	        if (mutation.type === "childList" && (containsRemovedNode || isHTMLTag)) {
	          isNodeRemovalMutation = true;
	          break;
	        }
	      }
	      if (!isNodeRemovalMutation) {
	        return;
	      }

	      _this11._inspector.off("markupmutation", onMutations);
	      _this11._removedNodeObserver = null;

	      // Don't select the new node if the user has already changed the current
	      // selection.
	      if (_this11._inspector.selection.nodeFront === parentContainer.node || _this11._inspector.selection.nodeFront === removedNode && isHTMLTag) {
	        let childContainers = parentContainer.getChildContainers();
	        if (childContainers && childContainers[childIndex]) {
	          _this11.markNodeAsSelected(childContainers[childIndex].node, reason);
	          if (childContainers[childIndex].hasChildren) {
	            _this11.expandNode(childContainers[childIndex].node);
	          }
	          _this11.emit("reselectedonremoved");
	        }
	      }
	    };

	    // Start listening for mutations until we find a childList change that has
	    // removedNode removed.
	    this._inspector.on("markupmutation", onMutations);
	  },

	  /**
	   * Make sure to stop listening for node removal markupmutations and not
	   * reselect the corresponding node when that happens.
	   * Useful when the outerHTML/tagname edition failed.
	   */
	  cancelReselectOnRemoved: function () {
	    if (this._removedNodeObserver) {
	      this._inspector.off("markupmutation", this._removedNodeObserver);
	      this._removedNodeObserver = null;
	      this.emit("canceledreselectonremoved");
	    }
	  },

	  /**
	   * Replace the outerHTML of any node displayed in the inspector with
	   * some other HTML code
	   * @param {NodeFront} node node which outerHTML will be replaced.
	   * @param {string} newValue The new outerHTML to set on the node.
	   * @param {string} oldValue The old outerHTML that will be used if the
	   *                          user undoes the update.
	   * @returns A promise that will resolve when the outer HTML has been updated.
	   */
	  updateNodeOuterHTML: function (node, newValue, oldValue) {
	    var _this12 = this;

	    let container = this.getContainer(node);
	    if (!container) {
	      return promise.reject();
	    }

	    // Changing the outerHTML removes the node which outerHTML was changed.
	    // Listen to this removal to reselect the right node afterwards.
	    this.reselectOnRemoved(node, "outerhtml");
	    return this.walker.setOuterHTML(node, newValue).then(null, function () {
	      _this12.cancelReselectOnRemoved();
	    });
	  },

	  /**
	   * Replace the innerHTML of any node displayed in the inspector with
	   * some other HTML code
	   * @param {Node} node node which innerHTML will be replaced.
	   * @param {string} newValue The new innerHTML to set on the node.
	   * @param {string} oldValue The old innerHTML that will be used if the user
	   *                 undoes the update.
	   * @returns A promise that will resolve when the inner HTML has been updated.
	   */
	  updateNodeInnerHTML: function (node, newValue, oldValue) {
	    var _this13 = this;

	    let container = this.getContainer(node);
	    if (!container) {
	      return promise.reject();
	    }

	    let def = promise.defer();

	    container.undo.do(function () {
	      _this13.walker.setInnerHTML(node, newValue).then(def.resolve, def.reject);
	    }, function () {
	      _this13.walker.setInnerHTML(node, oldValue);
	    });

	    return def.promise;
	  },

	  /**
	   * Insert adjacent HTML to any node displayed in the inspector.
	   *
	   * @param {NodeFront} node The reference node.
	   * @param {string} position The position as specified for Element.insertAdjacentHTML
	   *        (i.e. "beforeBegin", "afterBegin", "beforeEnd", "afterEnd").
	   * @param {string} newValue The adjacent HTML.
	   * @returns A promise that will resolve when the adjacent HTML has
	   *          been inserted.
	   */
	  insertAdjacentHTMLToNode: function (node, position, value) {
	    var _this14 = this;

	    let container = this.getContainer(node);
	    if (!container) {
	      return promise.reject();
	    }

	    let def = promise.defer();

	    let injectedNodes = [];
	    container.undo.do(function () {
	      _this14.walker.insertAdjacentHTML(node, position, value).then(function (nodeArray) {
	        injectedNodes = nodeArray.nodes;
	        return nodeArray;
	      }).then(def.resolve, def.reject);
	    }, function () {
	      _this14.walker.removeNodes(injectedNodes);
	    });

	    return def.promise;
	  },

	  /**
	   * Open an editor in the UI to allow editing of a node's outerHTML.
	   * @param aNode The NodeFront to edit.
	   */
	  beginEditingOuterHTML: function (aNode) {
	    var _this15 = this;

	    this.getNodeOuterHTML(aNode).then(function (oldValue) {
	      let container = _this15.getContainer(aNode);
	      if (!container) {
	        return;
	      }
	      _this15.htmlEditor.show(container.tagLine, oldValue);
	      _this15.htmlEditor.once("popuphidden", function (e, aCommit, aValue) {
	        // Need to focus the <html> element instead of the frame / window
	        // in order to give keyboard focus back to doc (from editor).
	        _this15.doc.documentElement.focus();

	        if (aCommit) {
	          _this15.updateNodeOuterHTML(aNode, aValue, oldValue);
	        }
	      });
	    });
	  },

	  /**
	   * Mark the given node expanded.
	   * @param {NodeFront} aNode The NodeFront to mark as expanded.
	   * @param {Boolean} aExpanded Whether the expand or collapse.
	   * @param {Boolean} aExpandDescendants Whether to expand all descendants too
	   */
	  setNodeExpanded: function (aNode, aExpanded, aExpandDescendants) {
	    if (aExpanded) {
	      if (aExpandDescendants) {
	        this.expandAll(aNode);
	      } else {
	        this.expandNode(aNode);
	      }
	    } else {
	      this.collapseNode(aNode);
	    }
	  },

	  /**
	   * Mark the given node selected, and update the inspector.selection
	   * object's NodeFront to keep consistent state between UI and selection.
	   * @param {NodeFront} aNode The NodeFront to mark as selected.
	   * @param {String} reason The reason for marking the node as selected.
	   * @return {Boolean} False if the node is already marked as selected, true
	   * otherwise.
	   */
	  markNodeAsSelected: function (node, reason) {
	    let container = this.getContainer(node);
	    if (this._selectedContainer === container) {
	      return false;
	    }

	    // Un-select the previous container.
	    if (this._selectedContainer) {
	      this._selectedContainer.selected = false;
	    }

	    // Select the new container.
	    this._selectedContainer = container;
	    if (node) {
	      this._selectedContainer.selected = true;
	    }

	    // Change the current selection if needed.
	    if (this._inspector.selection.nodeFront !== node) {
	      this._inspector.selection.setNodeFront(node, reason || "nodeselected");
	    }

	    return true;
	  },

	  /**
	   * Make sure that every ancestor of the selection are updated
	   * and included in the list of visible children.
	   */
	  _ensureVisible: function (node) {
	    while (node) {
	      let container = this.getContainer(node);
	      let parent = node.parentNode();
	      if (!container.elt.parentNode) {
	        let parentContainer = this.getContainer(parent);
	        if (parentContainer) {
	          parentContainer.childrenDirty = true;
	          this._updateChildren(parentContainer, { expand: true });
	        }
	      }

	      node = parent;
	    }
	    return this._waitForChildren();
	  },

	  /**
	   * Unmark selected node (no node selected).
	   */
	  unmarkSelectedNode: function () {
	    if (this._selectedContainer) {
	      this._selectedContainer.selected = false;
	      this._selectedContainer = null;
	    }
	  },

	  /**
	   * Check if the current selection is a descendent of the container.
	   * if so, make sure it's among the visible set for the container,
	   * and set the dirty flag if needed.
	   * @returns The node that should be made visible, if any.
	   */
	  _checkSelectionVisible: function (aContainer) {
	    let centered = null;
	    let node = this._inspector.selection.nodeFront;
	    while (node) {
	      if (node.parentNode() === aContainer.node) {
	        centered = node;
	        break;
	      }
	      node = node.parentNode();
	    }

	    return centered;
	  },

	  /**
	   * Make sure all children of the given container's node are
	   * imported and attached to the container in the right order.
	   *
	   * Children need to be updated only in the following circumstances:
	   * a) We just imported this node and have never seen its children.
	   *    container.childrenDirty will be set by importNode in this case.
	   * b) We received a childList mutation on the node.
	   *    container.childrenDirty will be set in that case too.
	   * c) We have changed the selection, and the path to that selection
	   *    wasn't loaded in a previous children request (because we only
	   *    grab a subset).
	   *    container.childrenDirty should be set in that case too!
	   *
	   * @param MarkupContainer aContainer
	   *        The markup container whose children need updating
	   * @param Object options
	   *        Options are {expand:boolean,flash:boolean}
	   * @return a promise that will be resolved when the children are ready
	   * (which may be immediately).
	   */
	  _updateChildren: function (aContainer, options) {
	    var _this16 = this;

	    let expand = options && options.expand;
	    let flash = options && options.flash;

	    aContainer.hasChildren = aContainer.node.hasChildren;

	    if (!this._queuedChildUpdates) {
	      this._queuedChildUpdates = new Map();
	    }

	    if (this._queuedChildUpdates.has(aContainer)) {
	      return this._queuedChildUpdates.get(aContainer);
	    }

	    if (!aContainer.childrenDirty) {
	      return promise.resolve(aContainer);
	    }

	    if (aContainer.singleTextChild && aContainer.singleTextChild != aContainer.node.singleTextChild) {

	      // This container was doing double duty as a container for a single
	      // text child, back that out.
	      this._containers.delete(aContainer.singleTextChild);
	      aContainer.clearSingleTextChild();

	      if (aContainer.hasChildren && aContainer.selected) {
	        aContainer.setExpanded(true);
	      }
	    }

	    if (aContainer.node.singleTextChild) {
	      aContainer.setExpanded(false);
	      // this container will do double duty as the container for the single
	      // text child.
	      while (aContainer.children.firstChild) {
	        aContainer.children.removeChild(aContainer.children.firstChild);
	      }

	      aContainer.setSingleTextChild(aContainer.node.singleTextChild);

	      this._containers.set(aContainer.node.singleTextChild, aContainer);
	      aContainer.childrenDirty = false;
	      return promise.resolve(aContainer);
	    }

	    if (!aContainer.hasChildren) {
	      while (aContainer.children.firstChild) {
	        aContainer.children.removeChild(aContainer.children.firstChild);
	      }
	      aContainer.childrenDirty = false;
	      aContainer.setExpanded(false);
	      return promise.resolve(aContainer);
	    }

	    // If we're not expanded (or asked to update anyway), we're done for
	    // now.  Note that this will leave the childrenDirty flag set, so when
	    // expanded we'll refresh the child list.
	    if (!(aContainer.expanded || expand)) {
	      return promise.resolve(aContainer);
	    }

	    // We're going to issue a children request, make sure it includes the
	    // centered node.
	    let centered = this._checkSelectionVisible(aContainer);

	    // Children aren't updated yet, but clear the childrenDirty flag anyway.
	    // If the dirty flag is re-set while we're fetching we'll need to fetch
	    // again.
	    aContainer.childrenDirty = false;
	    let updatePromise = this._getVisibleChildren(aContainer, centered).then(function (children) {
	      if (!_this16._containers) {
	        return promise.reject("markup view destroyed");
	      }
	      _this16._queuedChildUpdates.delete(aContainer);

	      // If children are dirty, we got a change notification for this node
	      // while the request was in progress, we need to do it again.
	      if (aContainer.childrenDirty) {
	        return _this16._updateChildren(aContainer, { expand: centered });
	      }

	      let fragment = _this16.doc.createDocumentFragment();

	      for (let child of children.nodes) {
	        let container = _this16.importNode(child, flash);
	        fragment.appendChild(container.elt);
	      }

	      while (aContainer.children.firstChild) {
	        aContainer.children.removeChild(aContainer.children.firstChild);
	      }

	      if (!(children.hasFirst && children.hasLast)) {
	        let data = {
	          showing: _this16.strings.GetStringFromName("markupView.more.showing"),
	          showAll: _this16.strings.formatStringFromName("markupView.more.showAll", [aContainer.node.numChildren.toString()], 1),
	          allButtonClick: function () {
	            aContainer.maxChildren = -1;
	            aContainer.childrenDirty = true;
	            _this16._updateChildren(aContainer);
	          }
	        };

	        if (!children.hasFirst) {
	          let span = _this16.template("more-nodes", data);
	          fragment.insertBefore(span, fragment.firstChild);
	        }
	        if (!children.hasLast) {
	          let span = _this16.template("more-nodes", data);
	          fragment.appendChild(span);
	        }
	      }

	      aContainer.children.appendChild(fragment);
	      return aContainer;
	    }).then(null, console.error);
	    this._queuedChildUpdates.set(aContainer, updatePromise);
	    return updatePromise;
	  },

	  _waitForChildren: function () {
	    if (!this._queuedChildUpdates) {
	      return promise.resolve(undefined);
	    }

	    return promise.all([...this._queuedChildUpdates.values()]);
	  },

	  /**
	   * Return a list of the children to display for this container.
	   */
	  _getVisibleChildren: function (aContainer, aCentered) {
	    let maxChildren = aContainer.maxChildren || this.maxChildren;
	    if (maxChildren == -1) {
	      maxChildren = undefined;
	    }

	    return this.walker.children(aContainer.node, {
	      maxNodes: maxChildren,
	      center: aCentered
	    });
	  },

	  /**
	   * Tear down the markup panel.
	   */
	  destroy: function () {
	    if (this._destroyer) {
	      return this._destroyer;
	    }

	    this._destroyer = promise.resolve();

	    this._clearBriefBoxModelTimer();

	    this._hoveredNode = null;

	    this.htmlEditor.destroy();
	    this.htmlEditor = null;

	    this.undo.destroy();
	    this.undo = null;

	    this.popup.destroy();
	    this.popup = null;

	    this._elt.removeEventListener("click", this._onMouseClick, false);
	    this._elt.removeEventListener("mousemove", this._onMouseMove, false);
	    this._elt.removeEventListener("mouseleave", this._onMouseLeave, false);
	    this.doc.body.removeEventListener("mouseup", this._onMouseUp);
	    this.win.removeEventListener("keydown", this._onKeyDown, false);
	    this.win.removeEventListener("copy", this._onCopy);
	    this._frame.removeEventListener("focus", this._onFocus, false);
	    this.walker.off("mutations", this._mutationObserver);
	    this.walker.off("display-change", this._onDisplayChange);
	    this._inspector.selection.off("new-node-front", this._onNewSelection);
	    this._inspector.toolbox.off("picker-node-hovered", this._onToolboxPickerHover);

	    this._elt = null;

	    for (let _ref4 of this._containers) {
	      var _ref5 = _slicedToArray(_ref4, 2);

	      let container = _ref5[1];

	      container.destroy();
	    }
	    this._containers = null;

	    this.tooltip.destroy();
	    this.tooltip = null;

	    this.win = null;
	    this.doc = null;

	    this._lastDropTarget = null;
	    this._lastDragTarget = null;

	    return this._destroyer;
	  },

	  /**
	   * Find the closest element with class tag-line. These are used to indicate
	   * drag and drop targets.
	   * @param {DOMNode} el
	   * @return {DOMNode}
	   */
	  findClosestDragDropTarget: function (el) {
	    return el.classList.contains("tag-line") ? el : el.querySelector(".tag-line") || el.closest(".tag-line");
	  },

	  /**
	   * Takes an element as it's only argument and marks the element
	   * as the drop target
	   */
	  indicateDropTarget: function (el) {
	    if (this._lastDropTarget) {
	      this._lastDropTarget.classList.remove("drop-target");
	    }

	    if (!el) {
	      return;
	    }

	    let target = this.findClosestDragDropTarget(el);
	    if (target) {
	      target.classList.add("drop-target");
	      this._lastDropTarget = target;
	    }
	  },

	  /**
	   * Takes an element to mark it as indicator of dragging target's initial place
	   */
	  indicateDragTarget: function (el) {
	    if (this._lastDragTarget) {
	      this._lastDragTarget.classList.remove("drag-target");
	    }

	    if (!el) {
	      return;
	    }

	    let target = this.findClosestDragDropTarget(el);
	    if (target) {
	      target.classList.add("drag-target");
	      this._lastDragTarget = target;
	    }
	  },

	  /**
	   * Used to get the nodes required to modify the markup after dragging the
	   * element (parent/nextSibling).
	   */
	  get dropTargetNodes() {
	    let target = this._lastDropTarget;

	    if (!target) {
	      return null;
	    }

	    let parent, nextSibling;

	    if (this._lastDropTarget.previousElementSibling && this._lastDropTarget.previousElementSibling.nodeName.toLowerCase() === "ul") {
	      parent = target.parentNode.container.node;
	      nextSibling = null;
	    } else {
	      parent = target.parentNode.container.node.parentNode();
	      nextSibling = target.parentNode.container.node;
	    }

	    if (nextSibling && nextSibling.isBeforePseudoElement) {
	      nextSibling = target.parentNode.parentNode.children[1].container.node;
	    }
	    if (nextSibling && nextSibling.isAfterPseudoElement) {
	      parent = target.parentNode.container.node.parentNode();
	      nextSibling = null;
	    }

	    if (parent.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE) {
	      return null;
	    }

	    return { parent, nextSibling };
	  }
	};

	/**
	 * The main structure for storing a document node in the markup
	 * tree.  Manages creation of the editor for the node and
	 * a <ul> for placing child elements, and expansion/collapsing
	 * of the element.
	 *
	 * This should not be instantiated directly, instead use one of:
	 *    MarkupReadOnlyContainer
	 *    MarkupTextContainer
	 *    MarkupElementContainer
	 */
	function MarkupContainer() {}

	MarkupContainer.prototype = {
	  /*
	   * Initialize the MarkupContainer.  Should be called while one
	   * of the other contain classes is instantiated.
	   *
	   * @param MarkupView markupView
	   *        The markup view that owns this container.
	   * @param NodeFront node
	   *        The node to display.
	   * @param string templateID
	   *        Which template to render for this container
	   */
	  initialize: function (markupView, node, templateID) {
	    this.markup = markupView;
	    this.node = node;
	    this.undo = this.markup.undo;
	    this.win = this.markup._frame.contentWindow;

	    // The template will fill the following properties
	    this.elt = null;
	    this.expander = null;
	    this.tagState = null;
	    this.tagLine = null;
	    this.children = null;
	    this.markup.template(templateID, this);
	    this.elt.container = this;

	    this._onMouseDown = this._onMouseDown.bind(this);
	    this._onToggle = this._onToggle.bind(this);
	    this._onMouseUp = this._onMouseUp.bind(this);
	    this._onMouseMove = this._onMouseMove.bind(this);

	    // Binding event listeners
	    this.elt.addEventListener("mousedown", this._onMouseDown, false);
	    this.markup.doc.body.addEventListener("mouseup", this._onMouseUp, true);
	    this.markup.doc.body.addEventListener("mousemove", this._onMouseMove, true);
	    this.elt.addEventListener("dblclick", this._onToggle, false);
	    if (this.expander) {
	      this.expander.addEventListener("click", this._onToggle, false);
	    }

	    // Marking the node as shown or hidden
	    this.isDisplayed = this.node.isDisplayed;
	  },

	  toString: function () {
	    return "[MarkupContainer for " + this.node + "]";
	  },

	  isPreviewable: function () {
	    if (this.node.tagName && !this.node.isPseudoElement) {
	      let tagName = this.node.tagName.toLowerCase();
	      let srcAttr = this.editor.getAttributeElement("src");
	      let isImage = tagName === "img" && srcAttr;
	      let isCanvas = tagName === "canvas";

	      return isImage || isCanvas;
	    }

	    return false;
	  },

	  /**
	   * Show the element has displayed or not
	   */
	  set isDisplayed(isDisplayed) {
	    this.elt.classList.remove("not-displayed");
	    if (!isDisplayed) {
	      this.elt.classList.add("not-displayed");
	    }
	  },

	  /**
	   * True if the current node has children.  The MarkupView
	   * will set this attribute for the MarkupContainer.
	   */
	  _hasChildren: false,

	  get hasChildren() {
	    return this._hasChildren;
	  },

	  set hasChildren(aValue) {
	    this._hasChildren = aValue;
	    this.updateExpander();
	  },

	  /**
	   * True if the current node can be expanded.
	   */
	  get canExpand() {
	    return this._hasChildren && !this.node.singleTextChild;
	  },

	  /**
	   * True if this is the root <html> element and can't be collapsed
	   */
	  get mustExpand() {
	    return this.node._parent === this.markup.walker.rootNode;
	  },

	  updateExpander: function () {
	    if (!this.expander) {
	      return;
	    }

	    if (this.canExpand && !this.mustExpand) {
	      this.expander.style.visibility = "visible";
	    } else {
	      this.expander.style.visibility = "hidden";
	    }
	  },

	  /**
	   * If the node has children, return the list of containers for all these
	   * children.
	   */
	  getChildContainers: function () {
	    if (!this.hasChildren) {
	      return null;
	    }

	    return [...this.children.children].map(function (node) {
	      return node.container;
	    });
	  },

	  /**
	   * True if the node has been visually expanded in the tree.
	   */
	  get expanded() {
	    return !this.elt.classList.contains("collapsed");
	  },

	  setExpanded: function (aValue) {
	    if (!this.expander) {
	      return;
	    }

	    if (!this.canExpand) {
	      aValue = false;
	    }
	    if (this.mustExpand) {
	      aValue = true;
	    }

	    if (aValue && this.elt.classList.contains("collapsed")) {
	      // Expanding a node means cloning its "inline" closing tag into a new
	      // tag-line that the user can interact with and showing the children.
	      let closingTag = this.elt.querySelector(".close");
	      if (closingTag) {
	        if (!this.closeTagLine) {
	          let line = this.markup.doc.createElement("div");
	          line.classList.add("tag-line");

	          let tagState = this.markup.doc.createElement("div");
	          tagState.classList.add("tag-state");
	          line.appendChild(tagState);

	          line.appendChild(closingTag.cloneNode(true));

	          flashElementOff(line);
	          this.closeTagLine = line;
	        }
	        this.elt.appendChild(this.closeTagLine);
	      }

	      this.elt.classList.remove("collapsed");
	      this.expander.setAttribute("open", "");
	      this.hovered = false;
	    } else if (!aValue) {
	      if (this.closeTagLine) {
	        this.elt.removeChild(this.closeTagLine);
	        this.closeTagLine = undefined;
	      }
	      this.elt.classList.add("collapsed");
	      this.expander.removeAttribute("open");
	    }
	  },

	  parentContainer: function () {
	    return this.elt.parentNode ? this.elt.parentNode.container : null;
	  },

	  _isDragging: false,
	  _dragStartY: 0,

	  set isDragging(isDragging) {
	    this._isDragging = isDragging;
	    this.markup.isDragging = isDragging;

	    if (isDragging) {
	      this.elt.classList.add("dragging");
	      this.markup.doc.body.classList.add("dragging");
	    } else {
	      this.elt.classList.remove("dragging");
	      this.markup.doc.body.classList.remove("dragging");
	    }
	  },

	  get isDragging() {
	    return this._isDragging;
	  },

	  /**
	   * Check if element is draggable
	   */
	  isDraggable: function () {
	    let tagName = this.node.tagName.toLowerCase();

	    return !this.node.isPseudoElement && !this.node.isAnonymous && !this.node.isDocumentElement && tagName !== "body" && tagName !== "head" && this.win.getSelection().isCollapsed && this.node.parentNode().tagName !== null;
	  },

	  _onMouseDown: function (event) {
	    let target = event.target;
	    let button = event.button;
	    let metaKey = event.metaKey;
	    let ctrlKey = event.ctrlKey;

	    let isLeftClick = button === 0;
	    let isMiddleClick = button === 1;
	    let isMetaClick = isLeftClick && (metaKey || ctrlKey);

	    // The "show more nodes" button already has its onclick, so early return.
	    if (target.nodeName === "button") {
	      return;
	    }

	    // target is the MarkupContainer itself.
	    this.hovered = false;
	    this.markup.navigate(this);
	    event.stopPropagation();

	    // Preventing the default behavior will avoid the body to gain focus on
	    // mouseup (through bubbling) when clicking on a non focusable node in the
	    // line. So, if the click happened outside of a focusable element, do
	    // prevent the default behavior, so that the tagname or textcontent gains
	    // focus.
	    if (!target.closest(".editor [tabindex]")) {
	      event.preventDefault();
	    }

	    // Follow attribute links if middle or meta click.
	    if (isMiddleClick || isMetaClick) {
	      let link = target.dataset.link;
	      let type = target.dataset.type;
	      this.markup._inspector.followAttributeLink(type, link);
	      return;
	    }

	    // Start node drag & drop (if the mouse moved, see _onMouseMove).
	    if (isLeftClick && this.isDraggable()) {
	      this._isPreDragging = true;
	      this._dragStartY = event.pageY;
	    }
	  },

	  /**
	   * On mouse up, stop dragging.
	   */
	  _onMouseUp: Task.async(function* () {
	    this._isPreDragging = false;

	    if (this.isDragging) {
	      this.cancelDragging();

	      let dropTargetNodes = this.markup.dropTargetNodes;

	      if (!dropTargetNodes) {
	        return;
	      }

	      yield this.markup.walker.insertBefore(this.node, dropTargetNodes.parent, dropTargetNodes.nextSibling);
	      this.markup.emit("drop-completed");
	    }
	  }),

	  /**
	   * On mouse move, move the dragged element and indicate the drop target.
	   */
	  _onMouseMove: function (event) {
	    // If this is the first move after mousedown, only start dragging after the
	    // mouse has travelled a few pixels and then indicate the start position.
	    let initialDiff = Math.abs(event.pageY - this._dragStartY);
	    if (this._isPreDragging && initialDiff >= DRAG_DROP_MIN_INITIAL_DISTANCE) {
	      this._isPreDragging = false;
	      this.isDragging = true;

	      // If this is the last child, use the closing <div.tag-line> of parent as
	      // indicator.
	      let position = this.elt.nextElementSibling || this.markup.getContainer(this.node.parentNode()).closeTagLine;
	      this.markup.indicateDragTarget(position);
	    }

	    if (this.isDragging) {
	      let diff = event.pageY - this._dragStartY;
	      this.elt.style.top = diff + "px";

	      let el = this.markup.doc.elementFromPoint(event.pageX - this.win.scrollX, event.pageY - this.win.scrollY);
	      this.markup.indicateDropTarget(el);
	    }
	  },

	  cancelDragging: function () {
	    if (!this.isDragging) {
	      return;
	    }

	    this._isPreDragging = false;
	    this.isDragging = false;
	    this.elt.style.removeProperty("top");
	  },

	  /**
	   * Temporarily flash the container to attract attention.
	   * Used for markup mutations.
	   */
	  flashMutation: function () {
	    var _this17 = this;

	    if (!this.selected) {
	      let contentWin = this.win;
	      flashElementOn(this.tagState, this.editor.elt);
	      if (this._flashMutationTimer) {
	        clearTimeout(this._flashMutationTimer);
	        this._flashMutationTimer = null;
	      }
	      this._flashMutationTimer = setTimeout(function () {
	        flashElementOff(_this17.tagState, _this17.editor.elt);
	      }, this.markup.CONTAINER_FLASHING_DURATION);
	    }
	  },

	  _hovered: false,

	  /**
	   * Highlight the currently hovered tag + its closing tag if necessary
	   * (that is if the tag is expanded)
	   */
	  set hovered(aValue) {
	    this.tagState.classList.remove("flash-out");
	    this._hovered = aValue;
	    if (aValue) {
	      if (!this.selected) {
	        this.tagState.classList.add("theme-bg-darker");
	      }
	      if (this.closeTagLine) {
	        this.closeTagLine.querySelector(".tag-state").classList.add("theme-bg-darker");
	      }
	    } else {
	      this.tagState.classList.remove("theme-bg-darker");
	      if (this.closeTagLine) {
	        this.closeTagLine.querySelector(".tag-state").classList.remove("theme-bg-darker");
	      }
	    }
	  },

	  /**
	   * True if the container is visible in the markup tree.
	   */
	  get visible() {
	    return this.elt.getBoundingClientRect().height > 0;
	  },

	  /**
	   * True if the container is currently selected.
	   */
	  _selected: false,

	  get selected() {
	    return this._selected;
	  },

	  set selected(aValue) {
	    this.tagState.classList.remove("flash-out");
	    this._selected = aValue;
	    this.editor.selected = aValue;
	    if (this._selected) {
	      this.tagLine.setAttribute("selected", "");
	      this.tagState.classList.add("theme-selected");
	    } else {
	      this.tagLine.removeAttribute("selected");
	      this.tagState.classList.remove("theme-selected");
	    }
	  },

	  /**
	   * Update the container's editor to the current state of the
	   * viewed node.
	   */
	  update: function () {
	    if (this.node.pseudoClassLocks.length) {
	      this.elt.classList.add("pseudoclass-locked");
	    } else {
	      this.elt.classList.remove("pseudoclass-locked");
	    }

	    if (this.editor.update) {
	      this.editor.update();
	    }
	  },

	  /**
	   * Try to put keyboard focus on the current editor.
	   */
	  focus: function () {
	    let focusable = this.editor.elt.querySelector("[tabindex]");
	    if (focusable) {
	      focusable.focus();
	    }
	  },

	  _onToggle: function (event) {
	    this.markup.navigate(this);
	    if (this.hasChildren) {
	      this.markup.setNodeExpanded(this.node, !this.expanded, event.altKey);
	    }
	    event.stopPropagation();
	  },

	  /**
	   * Get rid of event listeners and references, when the container is no longer
	   * needed
	   */
	  destroy: function () {
	    // Remove event listeners
	    this.elt.removeEventListener("mousedown", this._onMouseDown, false);
	    this.elt.removeEventListener("dblclick", this._onToggle, false);
	    this.markup.doc.body.removeEventListener("mouseup", this._onMouseUp, true);
	    this.markup.doc.body.removeEventListener("mousemove", this._onMouseMove, true);

	    this.win = null;

	    if (this.expander) {
	      this.expander.removeEventListener("click", this._onToggle, false);
	    }

	    // Recursively destroy children containers
	    let firstChild;
	    while (firstChild = this.children.firstChild) {
	      // Not all children of a container are containers themselves
	      // ("show more nodes" button is one example)
	      if (firstChild.container) {
	        firstChild.container.destroy();
	      }
	      this.children.removeChild(firstChild);
	    }

	    this.editor.destroy();
	  }
	};

	/**
	 * An implementation of MarkupContainer for Pseudo Elements,
	 * Doctype nodes, or any other type generic node that doesn't
	 * fit for other editors.
	 * Does not allow any editing, just viewing / selecting.
	 *
	 * @param MarkupView markupView
	 *        The markup view that owns this container.
	 * @param NodeFront node
	 *        The node to display.
	 */
	function MarkupReadOnlyContainer(markupView, node) {
	  MarkupContainer.prototype.initialize.call(this, markupView, node, "readonlycontainer");

	  this.editor = new GenericEditor(this, node);
	  this.tagLine.appendChild(this.editor.elt);
	}

	MarkupReadOnlyContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});

	/**
	 * An implementation of MarkupContainer for text node and comment nodes.
	 * Allows basic text editing in a textarea.
	 *
	 * @param MarkupView aMarkupView
	 *        The markup view that owns this container.
	 * @param NodeFront aNode
	 *        The node to display.
	 * @param Inspector aInspector
	 *        The inspector tool container the markup-view
	 */
	function MarkupTextContainer(markupView, node) {
	  MarkupContainer.prototype.initialize.call(this, markupView, node, "textcontainer");

	  if (node.nodeType == Ci.nsIDOMNode.TEXT_NODE) {
	    this.editor = new TextEditor(this, node, "text");
	  } else if (node.nodeType == Ci.nsIDOMNode.COMMENT_NODE) {
	    this.editor = new TextEditor(this, node, "comment");
	  } else {
	    throw "Invalid node for MarkupTextContainer";
	  }

	  this.tagLine.appendChild(this.editor.elt);
	}

	MarkupTextContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});

	/**
	 * An implementation of MarkupContainer for Elements that can contain
	 * child nodes.
	 * Allows editing of tag name, attributes, expanding / collapsing.
	 *
	 * @param MarkupView markupView
	 *        The markup view that owns this container.
	 * @param NodeFront node
	 *        The node to display.
	 */
	function MarkupElementContainer(markupView, node) {
	  MarkupContainer.prototype.initialize.call(this, markupView, node, "elementcontainer");

	  if (node.nodeType === Ci.nsIDOMNode.ELEMENT_NODE) {
	    this.editor = new ElementEditor(this, node);
	  } else {
	    throw "Invalid node for MarkupElementContainer";
	  }

	  this.tagLine.appendChild(this.editor.elt);
	}

	MarkupElementContainer.prototype = Heritage.extend(MarkupContainer.prototype, {

	  _buildEventTooltipContent: function (target, tooltip) {
	    var _this18 = this;

	    if (target.hasAttribute("data-event")) {
	      tooltip.hide(target);

	      this.node.getEventListenerInfo().then(function (listenerInfo) {
	        tooltip.setEventContent({
	          eventListenerInfos: listenerInfo,
	          toolbox: _this18.markup._inspector.toolbox
	        });

	        _this18.markup._makeTooltipPersistent(true);
	        tooltip.once("hidden", function () {
	          _this18.markup._makeTooltipPersistent(false);
	        });
	        tooltip.show(target);
	      });
	      return true;
	    }
	  },

	  /**
	   * Generates the an image preview for this Element. The element must be an
	   * image or canvas (@see isPreviewable).
	   *
	   * @return A Promise that is resolved with an object of form
	   * { data, size: { naturalWidth, naturalHeight, resizeRatio } } where
	   *   - data is the data-uri for the image preview.
	   *   - size contains information about the original image size and if the
	   *     preview has been resized.
	   *
	   * If this element is not previewable or the preview cannot be generated for
	   * some reason, the Promise is rejected.
	   */
	  _getPreview: function () {
	    if (!this.isPreviewable()) {
	      return promise.reject("_getPreview called on a non-previewable element.");
	    }

	    if (this.tooltipDataPromise) {
	      // A preview request is already pending. Re-use that request.
	      return this.tooltipDataPromise;
	    }

	    let maxDim = Services.prefs.getIntPref("devtools.inspector.imagePreviewTooltipSize");

	    // Fetch the preview from the server.
	    this.tooltipDataPromise = Task.spawn((function* () {
	      let preview = yield this.node.getImageData(maxDim);
	      let data = yield preview.data.string();

	      // Clear the pending preview request. We can't reuse the results later as
	      // the preview contents might have changed.
	      this.tooltipDataPromise = null;

	      return { data, size: preview.size };
	    }).bind(this));

	    return this.tooltipDataPromise;
	  },

	  /**
	   * Executed by MarkupView._isImagePreviewTarget which is itself called when the
	   * mouse hovers over a target in the markup-view.
	   * Checks if the target is indeed something we want to have an image tooltip
	   * preview over and, if so, inserts content into the tooltip.
	   * @return a promise that resolves when the content has been inserted or
	   * rejects if no preview is required. This promise is then used by Tooltip.js
	   * to decide if/when to show the tooltip
	   */
	  isImagePreviewTarget: function (target, tooltip) {
	    // Is this Element previewable.
	    if (!this.isPreviewable()) {
	      return promise.reject(false);
	    }

	    // If the Element has an src attribute, the tooltip is shown when hovering
	    // over the src url. If not, the tooltip is shown when hovering over the tag
	    // name.
	    let src = this.editor.getAttributeElement("src");
	    let expectedTarget = src ? src.querySelector(".link") : this.editor.tag;
	    if (target !== expectedTarget) {
	      return promise.reject(false);
	    }

	    return this._getPreview().then(function ({ data, size }) {
	      // The preview is ready.
	      tooltip.setImageContent(data, size);
	    }, function () {
	      // Indicate the failure but show the tooltip anyway.
	      tooltip.setBrokenImageContent();
	    });
	  },

	  copyImageDataUri: function () {
	    // We need to send again a request to gettooltipData even if one was sent for
	    // the tooltip, because we want the full-size image
	    this.node.getImageData().then(function (data) {
	      data.data.string().then(function (str) {
	        clipboardHelper.copyString(str);
	      });
	    });
	  },

	  setSingleTextChild: function (singleTextChild) {
	    this.singleTextChild = singleTextChild;
	    this.editor.updateTextEditor();
	  },

	  clearSingleTextChild: function () {
	    this.singleTextChild = undefined;
	    this.editor.updateTextEditor();
	  },

	  /**
	   * Trigger new attribute field for input.
	   */
	  addAttribute: function () {
	    this.editor.newAttr.editMode();
	  },

	  /**
	   * Trigger attribute field for editing.
	   */
	  editAttribute: function (attrName) {
	    this.editor.attrElements.get(attrName).editMode();
	  },

	  /**
	   * Remove attribute from container.
	   * This is an undoable action.
	   */
	  removeAttribute: function (attrName) {
	    let doMods = this.editor._startModifyingAttributes();
	    let undoMods = this.editor._startModifyingAttributes();
	    this.editor._saveAttribute(attrName, undoMods);
	    doMods.removeAttribute(attrName);
	    this.undo.do(function () {
	      doMods.apply();
	    }, function () {
	      undoMods.apply();
	    });
	  }
	});

	/**
	 * Dummy container node used for the root document element.
	 */
	function RootContainer(aMarkupView, aNode) {
	  this.doc = aMarkupView.doc;
	  this.elt = this.doc.createElement("ul");
	  this.elt.container = this;
	  this.children = this.elt;
	  this.node = aNode;
	  this.toString = function () {
	    return "[root container]";
	  };
	}

	RootContainer.prototype = {
	  hasChildren: true,
	  expanded: true,
	  update: function () {},
	  destroy: function () {},

	  /**
	   * If the node has children, return the list of containers for all these
	   * children.
	   */
	  getChildContainers: function () {
	    return [...this.children.children].map(function (node) {
	      return node.container;
	    });
	  },

	  setExpanded: function (aValue) {}
	};

	/**
	 * Creates an editor for non-editable nodes.
	 */
	function GenericEditor(aContainer, aNode) {
	  this.container = aContainer;
	  this.markup = this.container.markup;
	  this.template = this.markup.template.bind(this.markup);
	  this.elt = null;
	  this.template("generic", this);

	  if (aNode.isPseudoElement) {
	    this.tag.classList.add("theme-fg-color5");
	    this.tag.textContent = aNode.isBeforePseudoElement ? "::before" : "::after";
	  } else if (aNode.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE) {
	    this.elt.classList.add("comment");
	    this.tag.textContent = aNode.doctypeString;
	  } else {
	    this.tag.textContent = aNode.nodeName;
	  }
	}

	GenericEditor.prototype = {
	  destroy: function () {
	    this.elt.remove();
	  },

	  /**
	   * Stub method for consistency with ElementEditor.
	   */
	  getInfoAtNode: function () {
	    return null;
	  }
	};

	/**
	 * Creates a simple text editor node, used for TEXT and COMMENT
	 * nodes.
	 *
	 * @param MarkupContainer aContainer The container owning this editor.
	 * @param DOMNode aNode The node being edited.
	 * @param string aTemplate The template id to use to build the editor.
	 */
	function TextEditor(aContainer, aNode, aTemplate) {
	  var _this19 = this;

	  this.container = aContainer;
	  this.markup = this.container.markup;
	  this.node = aNode;
	  this.template = this.markup.template.bind(aTemplate);
	  this._selected = false;

	  this.markup.template(aTemplate, this);

	  editableField({
	    element: this.value,
	    stopOnReturn: true,
	    trigger: "dblclick",
	    multiline: true,
	    trimOutput: false,
	    done: function (aVal, aCommit) {
	      if (!aCommit) {
	        return;
	      }
	      _this19.node.getNodeValue().then(function (longstr) {
	        longstr.string().then(function (oldValue) {
	          longstr.release().then(null, console.error);

	          _this19.container.undo.do(function () {
	            _this19.node.setNodeValue(aVal);
	          }, function () {
	            _this19.node.setNodeValue(oldValue);
	          });
	        });
	      });
	    }
	  });

	  this.update();
	}

	TextEditor.prototype = {
	  get selected() {
	    return this._selected;
	  },

	  set selected(aValue) {
	    if (aValue === this._selected) {
	      return;
	    }
	    this._selected = aValue;
	    this.update();
	  },

	  update: function () {
	    var _this20 = this;

	    if (!this.selected || !this.node.incompleteValue) {
	      let text = this.node.shortValue;
	      if (this.node.incompleteValue) {
	        text += ELLIPSIS;
	      }
	      this.value.textContent = text;
	    } else {
	      let longstr = null;
	      this.node.getNodeValue().then(function (ret) {
	        longstr = ret;
	        return longstr.string();
	      }).then(function (str) {
	        longstr.release().then(null, console.error);
	        if (_this20.selected) {
	          _this20.value.textContent = str;
	          _this20.markup.emit("text-expand");
	        }
	      }).then(null, console.error);
	    }
	  },

	  destroy: function () {},

	  /**
	   * Stub method for consistency with ElementEditor.
	   */
	  getInfoAtNode: function () {
	    return null;
	  }
	};

	/**
	 * Creates an editor for an Element node.
	 *
	 * @param MarkupContainer aContainer The container owning this editor.
	 * @param Element aNode The node being edited.
	 */
	function ElementEditor(aContainer, aNode) {
	  var _this21 = this;

	  this.container = aContainer;
	  this.node = aNode;
	  this.markup = this.container.markup;
	  this.template = this.markup.template.bind(this.markup);
	  this.doc = this.markup.doc;

	  this.attrElements = new Map();
	  this.animationTimers = {};

	  // The templates will fill the following properties
	  this.elt = null;
	  this.tag = null;
	  this.closeTag = null;
	  this.attrList = null;
	  this.newAttr = null;
	  this.closeElt = null;

	  // Create the main editor
	  this.template("element", this);

	  // Make the tag name editable (unless this is a remote node or
	  // a document element)
	  if (!aNode.isDocumentElement) {
	    this.tag.setAttribute("tabindex", "0");
	    editableField({
	      element: this.tag,
	      trigger: "dblclick",
	      stopOnReturn: true,
	      done: this.onTagEdit.bind(this)
	    });
	  }

	  // Make the new attribute space editable.
	  this.newAttr.editMode = editableField({
	    element: this.newAttr,
	    trigger: "dblclick",
	    stopOnReturn: true,
	    contentType: InplaceEditor.CONTENT_TYPES.CSS_MIXED,
	    popup: this.markup.popup,
	    done: function (aVal, aCommit) {
	      if (!aCommit) {
	        return;
	      }

	      let doMods = _this21._startModifyingAttributes();
	      let undoMods = _this21._startModifyingAttributes();
	      _this21._applyAttributes(aVal, null, doMods, undoMods);
	      _this21.container.undo.do(function () {
	        doMods.apply();
	      }, function () {
	        undoMods.apply();
	      });
	    }
	  });

	  let tagName = this.node.nodeName.toLowerCase();
	  this.tag.textContent = tagName;
	  this.closeTag.textContent = tagName;
	  this.eventNode.style.display = this.node.hasEventListeners ? "inline-block" : "none";

	  this.update();
	  this.initialized = true;
	}

	ElementEditor.prototype = {

	  set selected(aValue) {
	    if (this.textEditor) {
	      this.textEditor.selected = aValue;
	    }
	  },

	  flashAttribute: function (attrName) {
	    var _this22 = this;

	    if (this.animationTimers[attrName]) {
	      clearTimeout(this.animationTimers[attrName]);
	    }

	    flashElementOn(this.getAttributeElement(attrName));

	    this.animationTimers[attrName] = setTimeout(function () {
	      flashElementOff(_this22.getAttributeElement(attrName));
	    }, this.markup.CONTAINER_FLASHING_DURATION);
	  },
	  /**
	   * Returns information about node in the editor.
	   *
	   * @param {DOMNode} node
	   *        The node to get information from.
	   *
	   * @return {Object}
	   *         An object literal with the following information:
	   *         {type: "attribute", name: "rel", value: "index", el: node}
	   */
	  getInfoAtNode: function (node) {
	    if (!node) {
	      return null;
	    }

	    let type = null;
	    let name = null;
	    let value = null;

	    // Attribute
	    let attribute = node.closest('.attreditor');
	    if (attribute) {
	      type = "attribute";
	      name = attribute.querySelector('.attr-name').textContent;
	      value = attribute.querySelector('.attr-value').textContent;
	    }

	    return { type, name, value, el: node };
	  },

	  /**
	   * Update the state of the editor from the node.
	   */
	  update: function () {
	    let nodeAttributes = this.node.attributes || [];

	    // Keep the data model in sync with attributes on the node.
	    let currentAttributes = new Set(nodeAttributes.map(function (a) {
	      return a.name;
	    }));
	    for (let name of this.attrElements.keys()) {
	      if (!currentAttributes.has(name)) {
	        this.removeAttribute(name);
	      }
	    }

	    // Only loop through the current attributes on the node.  Missing
	    // attributes have already been removed at this point.
	    for (let attr of nodeAttributes) {
	      let el = this.attrElements.get(attr.name);
	      let valueChanged = el && el.querySelector(".attr-value").textContent !== attr.value;
	      let isEditing = el && el.querySelector(".editable").inplaceEditor;
	      let canSimplyShowEditor = el && (!valueChanged || isEditing);

	      if (canSimplyShowEditor) {
	        // Element already exists and doesn't need to be recreated.
	        // Just show it (it's hidden by default due to the template).
	        el.style.removeProperty("display");
	      } else {
	        // Create a new editor, because the value of an existing attribute
	        // has changed.
	        let attribute = this._createAttribute(attr);
	        attribute.style.removeProperty("display");

	        // Temporarily flash the attribute to highlight the change.
	        // But not if this is the first time the editor instance has
	        // been created.
	        if (this.initialized) {
	          this.flashAttribute(attr.name);
	        }
	      }
	    }

	    this.updateTextEditor();
	  },

	  /**
	   * Update the inline text editor in case of a single text child node.
	   */
	  updateTextEditor: function () {
	    let node = this.node.singleTextChild;

	    if (this.textEditor && this.textEditor.node != node) {
	      this.elt.removeChild(this.textEditor.elt);
	      this.textEditor = null;
	    }

	    if (node && !this.textEditor) {
	      // Create a text editor added to this editor.
	      // This editor won't receive an update automatically, so we rely on
	      // child text editors to let us know that we need updating.
	      this.textEditor = new TextEditor(this.container, node, "text");
	      this.elt.insertBefore(this.textEditor.elt, this.elt.firstChild.nextSibling.nextSibling);
	    }

	    if (this.textEditor) {
	      this.textEditor.update();
	    }
	  },

	  _startModifyingAttributes: function () {
	    return this.node.startModifyingAttributes();
	  },

	  /**
	   * Get the element used for one of the attributes of this element
	   * @param string attrName The name of the attribute to get the element for
	   * @return DOMElement
	   */
	  getAttributeElement: function (attrName) {
	    return this.attrList.querySelector(".attreditor[data-attr=" + attrName + "] .attr-value");
	  },

	  /**
	   * Remove an attribute from the attrElements object and the DOM
	   * @param string attrName The name of the attribute to remove
	   */
	  removeAttribute: function (attrName) {
	    let attr = this.attrElements.get(attrName);
	    if (attr) {
	      this.attrElements.delete(attrName);
	      attr.remove();
	    }
	  },

	  _createAttribute: function (aAttr, aBefore = null) {
	    var _this23 = this;

	    // Create the template editor, which will save some variables here.
	    let data = {
	      attrName: aAttr.name
	    };
	    this.template("attribute", data);
	    let attr = data.attr;
	    let inner = data.inner;
	    let name = data.name;
	    let val = data.val;

	    // Double quotes need to be handled specially to prevent DOMParser failing.
	    // name="v"a"l"u"e" when editing -> name='v"a"l"u"e"'
	    // name="v'a"l'u"e" when editing -> name="v'a&quot;l'u&quot;e"

	    let editValueDisplayed = aAttr.value || "";
	    let hasDoubleQuote = editValueDisplayed.includes('"');
	    let hasSingleQuote = editValueDisplayed.includes("'");
	    let initial = aAttr.name + '="' + editValueDisplayed + '"';

	    // Can't just wrap value with ' since the value contains both " and '.
	    if (hasDoubleQuote && hasSingleQuote) {
	      editValueDisplayed = editValueDisplayed.replace(/\"/g, "&quot;");
	      initial = aAttr.name + '="' + editValueDisplayed + '"';
	    }

	    // Wrap with ' since there are no single quotes in the attribute value.
	    if (hasDoubleQuote && !hasSingleQuote) {
	      initial = aAttr.name + "='" + editValueDisplayed + "'";
	    }

	    // Make the attribute editable.
	    attr.editMode = editableField({
	      element: inner,
	      trigger: "dblclick",
	      stopOnReturn: true,
	      selectAll: false,
	      initial: initial,
	      contentType: InplaceEditor.CONTENT_TYPES.CSS_MIXED,
	      popup: this.markup.popup,
	      start: function (aEditor, aEvent) {
	        // If the editing was started inside the name or value areas,
	        // select accordingly.
	        if (aEvent && aEvent.target === name) {
	          aEditor.input.setSelectionRange(0, name.textContent.length);
	        } else if (aEvent && aEvent.target.closest(".attr-value") === val) {
	          let length = editValueDisplayed.length;
	          let editorLength = aEditor.input.value.length;
	          let start = editorLength - (length + 1);
	          aEditor.input.setSelectionRange(start, start + length);
	        } else {
	          aEditor.input.select();
	        }
	      },
	      done: function (aVal, aCommit, direction) {
	        if (!aCommit || aVal === initial) {
	          return;
	        }

	        let doMods = _this23._startModifyingAttributes();
	        let undoMods = _this23._startModifyingAttributes();

	        // Remove the attribute stored in this editor and re-add any attributes
	        // parsed out of the input element. Restore original attribute if
	        // parsing fails.
	        _this23.refocusOnEdit(aAttr.name, attr, direction);
	        _this23._saveAttribute(aAttr.name, undoMods);
	        doMods.removeAttribute(aAttr.name);
	        _this23._applyAttributes(aVal, attr, doMods, undoMods);
	        _this23.container.undo.do(function () {
	          doMods.apply();
	        }, function () {
	          undoMods.apply();
	        });
	      }
	    });

	    // Figure out where we should place the attribute.
	    let before = aBefore;
	    if (aAttr.name == "id") {
	      before = this.attrList.firstChild;
	    } else if (aAttr.name == "class") {
	      let idNode = this.attrElements.get("id");
	      before = idNode ? idNode.nextSibling : this.attrList.firstChild;
	    }
	    this.attrList.insertBefore(attr, before);

	    this.removeAttribute(aAttr.name);
	    this.attrElements.set(aAttr.name, attr);

	    // Parse the attribute value to detect whether there are linkable parts in
	    // it (make sure to pass a complete list of existing attributes to the
	    // parseAttribute function, by concatenating aAttr, because this could be a
	    // newly added attribute not yet on this.node).
	    let attributes = this.node.attributes.filter(function ({ name }) {
	      return name !== aAttr.name;
	    });
	    attributes.push(aAttr);
	    let parsedLinksData = parseAttribute(this.node.namespaceURI, this.node.tagName, attributes, aAttr.name);

	    // Create links in the attribute value, and collapse long attributes if
	    // needed.
	    let collapse = function (value) {
	      if (value && value.match(COLLAPSE_DATA_URL_REGEX)) {
	        return truncateString(value, COLLAPSE_DATA_URL_LENGTH);
	      }
	      return truncateString(value, COLLAPSE_ATTRIBUTE_LENGTH);
	    };

	    val.innerHTML = "";
	    for (let token of parsedLinksData) {
	      if (token.type === "string") {
	        val.appendChild(this.doc.createTextNode(collapse(token.value)));
	      } else {
	        let link = this.doc.createElement("span");
	        link.classList.add("link");
	        link.setAttribute("data-type", token.type);
	        link.setAttribute("data-link", token.value);
	        link.textContent = collapse(token.value);
	        val.appendChild(link);
	      }
	    }

	    name.textContent = aAttr.name;

	    return attr;
	  },

	  /**
	   * Parse a user-entered attribute string and apply the resulting
	   * attributes to the node.  This operation is undoable.
	   *
	   * @param string aValue the user-entered value.
	   * @param Element aAttrNode the attribute editor that created this
	   *        set of attributes, used to place new attributes where the
	   *        user put them.
	   */
	  _applyAttributes: function (aValue, aAttrNode, aDoMods, aUndoMods) {
	    let attrs = parseAttributeValues(aValue, this.doc);
	    for (let attr of attrs) {
	      // Create an attribute editor next to the current attribute if needed.
	      this._createAttribute(attr, aAttrNode ? aAttrNode.nextSibling : null);
	      this._saveAttribute(attr.name, aUndoMods);
	      aDoMods.setAttribute(attr.name, attr.value);
	    }
	  },

	  /**
	   * Saves the current state of the given attribute into an attribute
	   * modification list.
	   */
	  _saveAttribute: function (aName, aUndoMods) {
	    let node = this.node;
	    if (node.hasAttribute(aName)) {
	      let oldValue = node.getAttribute(aName);
	      aUndoMods.setAttribute(aName, oldValue);
	    } else {
	      aUndoMods.removeAttribute(aName);
	    }
	  },

	  /**
	   * Listen to mutations, and when the attribute list is regenerated
	   * try to focus on the attribute after the one that's being edited now.
	   * If the attribute order changes, go to the beginning of the attribute list.
	   */
	  refocusOnEdit: function (attrName, attrNode, direction) {
	    var _this24 = this;

	    // Only allow one refocus on attribute change at a time, so when there's
	    // more than 1 request in parallel, the last one wins.
	    if (this._editedAttributeObserver) {
	      this.markup._inspector.off("markupmutation", this._editedAttributeObserver);
	      this._editedAttributeObserver = null;
	    }

	    let container = this.markup.getContainer(this.node);

	    let activeAttrs = [...this.attrList.childNodes].filter(function (el) {
	      return el.style.display != "none";
	    });
	    let attributeIndex = activeAttrs.indexOf(attrNode);

	    let onMutations = this._editedAttributeObserver = function (e, mutations) {
	      let isDeletedAttribute = false;
	      let isNewAttribute = false;
	      for (let mutation of mutations) {
	        let inContainer = _this24.markup.getContainer(mutation.target) === container;
	        if (!inContainer) {
	          continue;
	        }

	        let isOriginalAttribute = mutation.attributeName === attrName;

	        isDeletedAttribute = isDeletedAttribute || isOriginalAttribute && mutation.newValue === null;
	        isNewAttribute = isNewAttribute || mutation.attributeName !== attrName;
	      }
	      let isModifiedOrder = isDeletedAttribute && isNewAttribute;
	      _this24._editedAttributeObserver = null;

	      // "Deleted" attributes are merely hidden, so filter them out.
	      let visibleAttrs = [..._this24.attrList.childNodes].filter(function (el) {
	        return el.style.display != "none";
	      });
	      let activeEditor;
	      if (visibleAttrs.length > 0) {
	        if (!direction) {
	          // No direction was given; stay on current attribute.
	          activeEditor = visibleAttrs[attributeIndex];
	        } else if (isModifiedOrder) {
	          // The attribute was renamed, reordering the existing attributes.
	          // So let's go to the beginning of the attribute list for consistency.
	          activeEditor = visibleAttrs[0];
	        } else {
	          let newAttributeIndex;
	          if (isDeletedAttribute) {
	            newAttributeIndex = attributeIndex;
	          } else {
	            if (direction == Ci.nsIFocusManager.MOVEFOCUS_FORWARD) {
	              newAttributeIndex = attributeIndex + 1;
	            } else if (direction == Ci.nsIFocusManager.MOVEFOCUS_BACKWARD) {
	              newAttributeIndex = attributeIndex - 1;
	            }
	          }

	          // The number of attributes changed (deleted), or we moved through the array
	          // so check we're still within bounds.
	          if (newAttributeIndex >= 0 && newAttributeIndex <= visibleAttrs.length - 1) {
	            activeEditor = visibleAttrs[newAttributeIndex];
	          }
	        }
	      }

	      // Either we have no attributes left,
	      // or we just edited the last attribute and want to move on.
	      if (!activeEditor) {
	        activeEditor = _this24.newAttr;
	      }

	      // Refocus was triggered by tab or shift-tab.
	      // Continue in edit mode.
	      if (direction) {
	        activeEditor.editMode();
	      } else {
	        // Refocus was triggered by enter.
	        // Exit edit mode (but restore focus).
	        let editable = activeEditor === _this24.newAttr ? activeEditor : activeEditor.querySelector(".editable");
	        editable.focus();
	      }

	      _this24.markup.emit("refocusedonedit");
	    };

	    // Start listening for mutations until we find an attributes change
	    // that modifies this attribute.
	    this.markup._inspector.once("markupmutation", onMutations);
	  },

	  /**
	   * Called when the tag name editor has is done editing.
	   */
	  onTagEdit: function (newTagName, isCommit) {
	    var _this25 = this;

	    if (!isCommit || newTagName.toLowerCase() === this.node.tagName.toLowerCase() || !("editTagName" in this.markup.walker)) {
	      return;
	    }

	    // Changing the tagName removes the node. Make sure the replacing node gets
	    // selected afterwards.
	    this.markup.reselectOnRemoved(this.node, "edittagname");
	    this.markup.walker.editTagName(this.node, newTagName).then(null, function () {
	      // Failed to edit the tag name, cancel the reselection.
	      _this25.markup.cancelReselectOnRemoved();
	    });
	  },

	  destroy: function () {
	    for (let key in this.animationTimers) {
	      clearTimeout(this.animationTimers[key]);
	    }
	    this.animationTimers = null;
	  }
	};

	function nodeDocument(node) {
	  return node.ownerDocument || (node.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE ? node : null);
	}

	function truncateString(str, maxLength) {
	  if (!str || str.length <= maxLength) {
	    return str;
	  }

	  return str.substring(0, Math.ceil(maxLength / 2)) + "…" + str.substring(str.length - Math.floor(maxLength / 2));
	}

	/**
	 * Parse attribute names and values from a string.
	 *
	 * @param  {String} attr
	 *         The input string for which names/values are to be parsed.
	 * @param  {HTMLDocument} doc
	 *         A document that can be used to test valid attributes.
	 * @return {Array}
	 *         An array of attribute names and their values.
	 */
	function parseAttributeValues(attr, doc) {
	  attr = attr.trim();

	  // Handle bad user inputs by appending a " or ' if it fails to parse without
	  // them. Also note that a SVG tag is used to make sure the HTML parser
	  // preserves mixed-case attributes
	  let el = DOMParser.parseFromString("<svg " + attr + "></svg>", "text/html").body.childNodes[0] || DOMParser.parseFromString("<svg " + attr + "\"></svg>", "text/html").body.childNodes[0] || DOMParser.parseFromString("<svg " + attr + "'></svg>", "text/html").body.childNodes[0];

	  let div = doc.createElement("div");
	  let attributes = [];
	  for (let _ref6 of el.attributes) {
	    let name = _ref6.name;
	    let value = _ref6.value;

	    // Try to set on an element in the document, throws exception on bad input.
	    // Prevents InvalidCharacterError - "String contains an invalid character".
	    try {
	      div.setAttribute(name, value);
	      attributes.push({ name, value });
	    } catch (e) {}
	  }

	  // Attributes return from DOMParser in reverse order from how they are entered.
	  return attributes.reverse();
	}

	/**
	 * Apply a 'flashed' background and foreground color to elements.  Intended
	 * to be used with flashElementOff as a way of drawing attention to an element.
	 *
	 * @param  {Node} backgroundElt
	 *         The element to set the highlighted background color on.
	 * @param  {Node} foregroundElt
	 *         The element to set the matching foreground color on.
	 *         Optional.  This will equal backgroundElt if not set.
	 */
	function flashElementOn(backgroundElt, foregroundElt = backgroundElt) {
	  if (!backgroundElt || !foregroundElt) {
	    return;
	  }

	  // Make sure the animation class is not here
	  backgroundElt.classList.remove("flash-out");

	  // Change the background
	  backgroundElt.classList.add("theme-bg-contrast");

	  foregroundElt.classList.add("theme-fg-contrast");
	  [].forEach.call(foregroundElt.querySelectorAll("[class*=theme-fg-color]"), function (span) {
	    return span.classList.add("theme-fg-contrast");
	  });
	}

	/**
	 * Remove a 'flashed' background and foreground color to elements.
	 * See flashElementOn.
	 *
	 * @param  {Node} backgroundElt
	 *         The element to reomve the highlighted background color on.
	 * @param  {Node} foregroundElt
	 *         The element to remove the matching foreground color on.
	 *         Optional.  This will equal backgroundElt if not set.
	 */
	function flashElementOff(backgroundElt, foregroundElt = backgroundElt) {
	  if (!backgroundElt || !foregroundElt) {
	    return;
	  }

	  // Add the animation class to smoothly remove the background
	  backgroundElt.classList.add("flash-out");

	  // Remove the background
	  backgroundElt.classList.remove("theme-bg-contrast");

	  foregroundElt.classList.remove("theme-fg-contrast");
	  [].forEach.call(foregroundElt.querySelectorAll("[class*=theme-fg-color]"), function (span) {
	    return span.classList.remove("theme-fg-contrast");
	  });
	}

	/**
	 * Map a number from one range to another.
	 */
	function map(value, oldMin, oldMax, newMin, newMax) {
	  let ratio = oldMax - oldMin;
	  if (ratio == 0) {
	    return value;
	  }
	  return newMin + (newMax - newMin) * ((value - oldMin) / ratio);
	}

	loader.lazyGetter(MarkupView.prototype, "strings", function () {
	  return Services.strings.createBundle("chrome://devtools/locale/inspector.properties");
	});

/***/ },
/* 33 */
/***/ function(module, exports) {

	"use strict";

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * A simple undo stack manager.
	 *
	 * Actions are added along with the necessary code to
	 * reverse the action.
	 *
	 * @param function aChange Called whenever the size or position
	 *   of the undo stack changes, to use for updating undo-related
	 *   UI.
	 * @param integer aMaxUndo Maximum number of undo steps.
	 *   defaults to 50.
	 */
	function UndoStack(aMaxUndo) {
	  this.maxUndo = aMaxUndo || 50;
	  this._stack = [];
	}

	exports.UndoStack = UndoStack;

	UndoStack.prototype = {
	  // Current index into the undo stack.  Is positioned after the last
	  // currently-applied change.
	  _index: 0,

	  // The current batch depth (see startBatch() for details)
	  _batchDepth: 0,

	  destroy: function Undo_destroy() {
	    this.uninstallController();
	    delete this._stack;
	  },

	  /**
	   * Start a collection of related changes.  Changes will be batched
	   * together into one undo/redo item until endBatch() is called.
	   *
	   * Batches can be nested, in which case the outer batch will contain
	   * all items from the inner batches.  This allows larger user
	   * actions made up of a collection of smaller actions to be
	   * undone as a single action.
	   */
	  startBatch: function Undo_startBatch() {
	    if (this._batchDepth++ === 0) {
	      this._batch = [];
	    }
	  },

	  /**
	   * End a batch of related changes, performing its action and adding
	   * it to the undo stack.
	   */
	  endBatch: function Undo_endBatch() {
	    if (--this._batchDepth > 0) {
	      return;
	    }

	    // Cut off the end of the undo stack at the current index,
	    // and the beginning to prevent a stack larger than maxUndo.
	    let start = Math.max(this._index + 1 - this.maxUndo, 0);
	    this._stack = this._stack.slice(start, this._index);

	    let batch = this._batch;
	    delete this._batch;
	    let entry = {
	      do: function () {
	        for (let item of batch) {
	          item.do();
	        }
	      },
	      undo: function () {
	        for (let i = batch.length - 1; i >= 0; i--) {
	          batch[i].undo();
	        }
	      }
	    };
	    this._stack.push(entry);
	    this._index = this._stack.length;
	    entry.do();
	    this._change();
	  },

	  /**
	   * Perform an action, adding it to the undo stack.
	   *
	   * @param function aDo Called to perform the action.
	   * @param function aUndo Called to reverse the action.
	   */
	  do: function Undo_do(aDo, aUndo) {
	    this.startBatch();
	    this._batch.push({ do: aDo, undo: aUndo });
	    this.endBatch();
	  },

	  /*
	   * Returns true if undo() will do anything.
	   */
	  canUndo: function Undo_canUndo() {
	    return this._index > 0;
	  },

	  /**
	   * Undo the top of the undo stack.
	   *
	   * @return true if an action was undone.
	   */
	  undo: function Undo_canUndo() {
	    if (!this.canUndo()) {
	      return false;
	    }
	    this._stack[--this._index].undo();
	    this._change();
	    return true;
	  },

	  /**
	   * Returns true if redo() will do anything.
	   */
	  canRedo: function Undo_canRedo() {
	    return this._stack.length > this._index;
	  },

	  /**
	   * Redo the most recently undone action.
	   *
	   * @return true if an action was redone.
	   */
	  redo: function Undo_canRedo() {
	    if (!this.canRedo()) {
	      return false;
	    }
	    this._stack[this._index++].do();
	    this._change();
	    return true;
	  },

	  _change: function Undo__change() {
	    if (this._controllerWindow) {
	      this._controllerWindow.goUpdateCommand("cmd_undo");
	      this._controllerWindow.goUpdateCommand("cmd_redo");
	    }
	  },

	  /**
	   * ViewController implementation for undo/redo.
	   */

	  /**
	   * Install this object as a command controller.
	   */
	  installController: function Undo_installController(aControllerWindow) {
	    this._controllerWindow = aControllerWindow;
	    // aControllerWindow.controllers.appendController(this);
	  },

	  /**
	   * Uninstall this object from the command controller.
	   */
	  uninstallController: function Undo_uninstallController() {
	    if (!this._controllerWindow) {
	      return;
	    }
	    // this._controllerWindow.controllers.removeController(this);
	  },

	  supportsCommand: function Undo_supportsCommand(aCommand) {
	    return aCommand == "cmd_undo" || aCommand == "cmd_redo";
	  },

	  isCommandEnabled: function Undo_isCommandEnabled(aCommand) {
	    switch (aCommand) {
	      case "cmd_undo":
	        return this.canUndo();
	      case "cmd_redo":
	        return this.canRedo();
	    };
	    return false;
	  },

	  doCommand: function Undo_doCommand(aCommand) {
	    switch (aCommand) {
	      case "cmd_undo":
	        return this.undo();
	      case "cmd_redo":
	        return this.redo();
	    }
	  },

	  onEvent: function Undo_onEvent(aEvent) {}
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Basic use:
	 * let spanToEdit = document.getElementById("somespan");
	 *
	 * editableField({
	 *   element: spanToEdit,
	 *   done: function(value, commit, direction) {
	 *     if (commit) {
	 *       spanToEdit.textContent = value;
	 *     }
	 *   },
	 *   trigger: "dblclick"
	 * });
	 *
	 * See editableField() for more options.
	 */

	"use strict";

	var _require = __webpack_require__(1);

	const Ci = _require.Ci;
	const Cu = _require.Cu;
	const Cc = _require.Cc;

	const HTML_NS = "http://www.w3.org/1999/xhtml";
	const CONTENT_TYPES = {
	  PLAIN_TEXT: 0,
	  CSS_VALUE: 1,
	  CSS_MIXED: 2,
	  CSS_PROPERTY: 3
	};
	const MAX_POPUP_ENTRIES = 10;

	const FOCUS_FORWARD = Ci.nsIFocusManager.MOVEFOCUS_FORWARD;
	const FOCUS_BACKWARD = Ci.nsIFocusManager.MOVEFOCUS_BACKWARD;

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	var _require3 = __webpack_require__(15);

	const XPCOMUtils = _require3.XPCOMUtils;

	const EventEmitter = __webpack_require__(7);

	/**
	 * Mark a span editable.  |editableField| will listen for the span to
	 * be focused and create an InlineEditor to handle text input.
	 * Changes will be committed when the InlineEditor's input is blurred
	 * or dropped when the user presses escape.
	 *
	 * @param {Object} options
	 *    Options for the editable field, including:
	 *    {Element} element:
	 *      (required) The span to be edited on focus.
	 *    {Function} canEdit:
	 *       Will be called before creating the inplace editor.  Editor
	 *       won't be created if canEdit returns false.
	 *    {Function} start:
	 *       Will be called when the inplace editor is initialized.
	 *    {Function} change:
	 *       Will be called when the text input changes.  Will be called
	 *       with the current value of the text input.
	 *    {Function} done:
	 *       Called when input is committed or blurred.  Called with
	 *       current value, a boolean telling the caller whether to
	 *       commit the change, and the direction of the next element to be
	 *       selected. Direction may be one of nsIFocusManager.MOVEFOCUS_FORWARD,
	 *       nsIFocusManager.MOVEFOCUS_BACKWARD, or null (no movement).
	 *       This function is called before the editor has been torn down.
	 *    {Function} destroy:
	 *       Called when the editor is destroyed and has been torn down.
	 *    {Object} advanceChars:
	 *       This can be either a string or a function.
	 *       If it is a string, then if any characters in it are typed,
	 *       focus will advance to the next element.
	 *       Otherwise, if it is a function, then the function will
	 *       be called with three arguments: a key code, the current text,
	 *       and the insertion point.  If the function returns true,
	 *       then the focus advance takes place.  If it returns false,
	 *       then the character is inserted instead.
	 *    {Boolean} stopOnReturn:
	 *       If true, the return key will not advance the editor to the next
	 *       focusable element.
	 *    {Boolean} stopOnTab:
	 *       If true, the tab key will not advance the editor to the next
	 *       focusable element.
	 *    {Boolean} stopOnShiftTab:
	 *       If true, shift tab will not advance the editor to the previous
	 *       focusable element.
	 *    {String} trigger: The DOM event that should trigger editing,
	 *      defaults to "click"
	 *    {Boolean} multiline: Should the editor be a multiline textarea?
	 *      defaults to false
	 *    {Boolean} trimOutput: Should the returned string be trimmed?
	 *      defaults to true
	 *    {Boolean} preserveTextStyles: If true, do not copy text-related styles
	 *              from `element` to the new input.
	 *      defaults to false
	 */
	function editableField(options) {
	  return editableItem(options, function (element, event) {
	    if (!options.element.inplaceEditor) {
	      new InplaceEditor(options, event);
	    }
	  });
	}

	exports.editableField = editableField;

	/**
	 * Handle events for an element that should respond to
	 * clicks and sit in the editing tab order, and call
	 * a callback when it is activated.
	 *
	 * @param {Object} options
	 *    The options for this editor, including:
	 *    {Element} element: The DOM element.
	 *    {String} trigger: The DOM event that should trigger editing,
	 *      defaults to "click"
	 * @param {Function} callback
	 *        Called when the editor is activated.
	 * @return {Function} function which calls callback
	 */
	function editableItem(options, callback) {
	  let trigger = options.trigger || "click";
	  let element = options.element;
	  element.addEventListener(trigger, function (evt) {
	    if (evt.target.nodeName !== "a") {
	      let win = this.ownerDocument.defaultView;
	      let selection = win.getSelection();
	      if (trigger != "click" || selection.isCollapsed) {
	        callback(element, evt);
	      }
	      evt.stopPropagation();
	    }
	  }, false);

	  // If focused by means other than a click, start editing by
	  // pressing enter or space.
	  element.addEventListener("keypress", function (evt) {
	    if (evt.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_RETURN || evt.charCode === Ci.nsIDOMKeyEvent.DOM_VK_SPACE) {
	      callback(element);
	    }
	  }, true);

	  // Ugly workaround - the element is focused on mousedown but
	  // the editor is activated on click/mouseup.  This leads
	  // to an ugly flash of the focus ring before showing the editor.
	  // So hide the focus ring while the mouse is down.
	  element.addEventListener("mousedown", function (evt) {
	    if (evt.target.nodeName !== "a") {
	      let cleanup = function () {
	        element.style.removeProperty("outline-style");
	        element.removeEventListener("mouseup", cleanup, false);
	        element.removeEventListener("mouseout", cleanup, false);
	      };
	      element.style.setProperty("outline-style", "none");
	      element.addEventListener("mouseup", cleanup, false);
	      element.addEventListener("mouseout", cleanup, false);
	    }
	  }, false);

	  // Mark the element editable field for tab
	  // navigation while editing.
	  element._editable = true;

	  // Save the trigger type so we can dispatch this later
	  element._trigger = trigger;

	  return function turnOnEditMode() {
	    callback(element);
	  };
	}

	exports.editableItem = this.editableItem;

	/*
	 * Various API consumers (especially tests) sometimes want to grab the
	 * inplaceEditor expando off span elements. However, when each global has its
	 * own compartment, those expandos live on Xray wrappers that are only visible
	 * within this JSM. So we provide a little workaround here.
	 */

	function getInplaceEditorForSpan(span) {
	  return span.inplaceEditor;
	}

	exports.getInplaceEditorForSpan = getInplaceEditorForSpan;

	function InplaceEditor(options, event) {
	  this.elt = options.element;
	  let doc = this.elt.ownerDocument;
	  this.doc = doc;
	  this.elt.inplaceEditor = this;

	  this.change = options.change;
	  this.done = options.done;
	  this.destroy = options.destroy;
	  this.initial = options.initial ? options.initial : this.elt.textContent;
	  this.multiline = options.multiline || false;
	  this.trimOutput = options.trimOutput === undefined ? true : !!options.trimOutput;
	  this.stopOnShiftTab = !!options.stopOnShiftTab;
	  this.stopOnTab = !!options.stopOnTab;
	  this.stopOnReturn = !!options.stopOnReturn;
	  this.contentType = options.contentType || CONTENT_TYPES.PLAIN_TEXT;
	  this.property = options.property;
	  this.popup = options.popup;
	  this.preserveTextStyles = options.preserveTextStyles === undefined ? false : !!options.preserveTextStyles;

	  this._onBlur = this._onBlur.bind(this);
	  this._onKeyPress = this._onKeyPress.bind(this);
	  this._onInput = this._onInput.bind(this);
	  this._onKeyup = this._onKeyup.bind(this);

	  this._createInput();
	  this._autosize();
	  this.inputCharWidth = this._getInputCharWidth();

	  // Pull out character codes for advanceChars, listing the
	  // characters that should trigger a blur.
	  if (typeof options.advanceChars === "function") {
	    this._advanceChars = options.advanceChars;
	  } else {
	    let advanceCharcodes = {};
	    let advanceChars = options.advanceChars || "";
	    for (let i = 0; i < advanceChars.length; i++) {
	      advanceCharcodes[advanceChars.charCodeAt(i)] = true;
	    }
	    this._advanceChars = function (aCharCode) {
	      return aCharCode in advanceCharcodes;
	    };
	  }

	  // Hide the provided element and add our editor.
	  this.originalDisplay = this.elt.style.display;
	  this.elt.style.display = "none";
	  this.elt.parentNode.insertBefore(this.input, this.elt);

	  this.input.focus();

	  if (typeof options.selectAll == "undefined" || options.selectAll) {
	    this.input.select();
	  }

	  if (this.contentType == CONTENT_TYPES.CSS_VALUE && this.input.value == "") {
	    this._maybeSuggestCompletion(true);
	  }

	  this.input.addEventListener("blur", this._onBlur, false);
	  this.input.addEventListener("keypress", this._onKeyPress, false);
	  this.input.addEventListener("input", this._onInput, false);

	  this.input.addEventListener("dblclick", function (e) {
	    e.stopPropagation();
	  }, false);
	  this.input.addEventListener("mousedown", function (e) {
	    e.stopPropagation();
	  }, false);

	  this.validate = options.validate;

	  if (this.validate) {
	    this.input.addEventListener("keyup", this._onKeyup, false);
	  }

	  this._updateSize();

	  if (options.start) {
	    options.start(this, event);
	  }

	  EventEmitter.decorate(this);
	}

	exports.InplaceEditor = InplaceEditor;

	InplaceEditor.CONTENT_TYPES = CONTENT_TYPES;

	InplaceEditor.prototype = {

	  get currentInputValue() {
	    let val = this.trimOutput ? this.input.value.trim() : this.input.value;
	    return val;
	  },

	  _createInput: function () {
	    this.input = this.doc.createElementNS(HTML_NS, this.multiline ? "textarea" : "input");
	    this.input.inplaceEditor = this;
	    this.input.classList.add("styleinspector-propertyeditor");
	    this.input.value = this.initial;
	    if (!this.preserveTextStyles) {
	      copyTextStyles(this.elt, this.input);
	    }
	  },

	  /**
	   * Get rid of the editor.
	   */
	  _clear: function () {
	    if (!this.input) {
	      // Already cleared.
	      return;
	    }

	    this.input.removeEventListener("blur", this._onBlur, false);
	    this.input.removeEventListener("keypress", this._onKeyPress, false);
	    this.input.removeEventListener("keyup", this._onKeyup, false);
	    this.input.removeEventListener("oninput", this._onInput, false);
	    this._stopAutosize();

	    this.elt.style.display = this.originalDisplay;

	    if (this.doc.activeElement == this.input) {
	      this.elt.focus();
	    }

	    this.input.remove();
	    this.input = null;

	    delete this.elt.inplaceEditor;
	    delete this.elt;

	    if (this.destroy) {
	      this.destroy();
	    }
	  },

	  /**
	   * Keeps the editor close to the size of its input string.  This is pretty
	   * crappy, suggestions for improvement welcome.
	   */
	  _autosize: function () {
	    // Create a hidden, absolutely-positioned span to measure the text
	    // in the input.  Boo.

	    // We can't just measure the original element because a) we don't
	    // change the underlying element's text ourselves (we leave that
	    // up to the client), and b) without tweaking the style of the
	    // original element, it might wrap differently or something.
	    this._measurement = this.doc.createElementNS(HTML_NS, this.multiline ? "pre" : "span");
	    this._measurement.className = "autosizer";
	    this.elt.parentNode.appendChild(this._measurement);
	    let style = this._measurement.style;
	    style.visibility = "hidden";
	    style.position = "absolute";
	    style.top = "0";
	    style.left = "0";
	    copyTextStyles(this.input, this._measurement);
	    this._updateSize();
	  },

	  /**
	   * Clean up the mess created by _autosize().
	   */
	  _stopAutosize: function () {
	    if (!this._measurement) {
	      return;
	    }
	    this._measurement.remove();
	    delete this._measurement;
	  },

	  /**
	   * Size the editor to fit its current contents.
	   */
	  _updateSize: function () {
	    // Replace spaces with non-breaking spaces.  Otherwise setting
	    // the span's textContent will collapse spaces and the measurement
	    // will be wrong.
	    this._measurement.textContent = this.input.value.replace(/ /g, "\u00a0");

	    // We add a bit of padding to the end.  Should be enough to fit
	    // any letter that could be typed, otherwise we'll scroll before
	    // we get a chance to resize.  Yuck.
	    let width = this._measurement.offsetWidth + 10;

	    if (this.multiline) {
	      // Make sure there's some content in the current line.  This is a hack to
	      // account for the fact that after adding a newline the <pre> doesn't grow
	      // unless there's text content on the line.
	      width += 15;
	      this.input.style.height = this._measurement.offsetHeight + "px";
	    }

	    this.input.style.width = width + "px";
	  },

	  /**
	   * Get the width of a single character in the input to properly position the
	   * autocompletion popup.
	   */
	  _getInputCharWidth: function () {
	    // Just make the text content to be 'x' to get the width of any character in
	    // a monospace font.
	    this._measurement.textContent = "x";
	    return this._measurement.offsetWidth;
	  },

	  /**
	  * Increment property values in rule view.
	  *
	  * @param {Number} increment
	  *        The amount to increase/decrease the property value.
	  * @return {Boolean} true if value has been incremented.
	  */
	  _incrementValue: function (increment) {
	    let value = this.input.value;
	    let selectionStart = this.input.selectionStart;
	    let selectionEnd = this.input.selectionEnd;

	    let newValue = this._incrementCSSValue(value, increment, selectionStart, selectionEnd);

	    if (!newValue) {
	      return false;
	    }

	    this.input.value = newValue.value;
	    this.input.setSelectionRange(newValue.start, newValue.end);
	    this._doValidation();

	    // Call the user's change handler if available.
	    if (this.change) {
	      this.change(this.currentInputValue);
	    }

	    return true;
	  },

	  /**
	   * Increment the property value based on the property type.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} increment
	   *        Amount to increase/decrease the property value.
	   * @param {Number} selStart
	   *        Starting index of the value.
	   * @param {Number} selEnd
	   *        Ending index of the value.
	   * @return {Object} object with properties 'value', 'start', and 'end'.
	   */
	  _incrementCSSValue: function (value, increment, selStart, selEnd) {
	    let range = this._parseCSSValue(value, selStart);
	    let type = range && range.type || "";
	    let rawValue = range ? value.substring(range.start, range.end) : "";
	    let incrementedValue = null,
	        selection;

	    if (type === "num") {
	      let newValue = this._incrementRawValue(rawValue, increment);
	      if (newValue !== null) {
	        incrementedValue = newValue;
	        selection = [0, incrementedValue.length];
	      }
	    } else if (type === "hex") {
	      let exprOffset = selStart - range.start;
	      let exprOffsetEnd = selEnd - range.start;
	      let newValue = this._incHexColor(rawValue, increment, exprOffset, exprOffsetEnd);
	      if (newValue) {
	        incrementedValue = newValue.value;
	        selection = newValue.selection;
	      }
	    } else {
	      let info;
	      if (type === "rgb" || type === "hsl") {
	        info = {};
	        let part = value.substring(range.start, selStart).split(",").length - 1;
	        if (part === 3) {
	          // alpha
	          info.minValue = 0;
	          info.maxValue = 1;
	        } else if (type === "rgb") {
	          info.minValue = 0;
	          info.maxValue = 255;
	        } else if (part !== 0) {
	          // hsl percentage
	          info.minValue = 0;
	          info.maxValue = 100;

	          // select the previous number if the selection is at the end of a
	          // percentage sign.
	          if (value.charAt(selStart - 1) === "%") {
	            --selStart;
	          }
	        }
	      }
	      return this._incrementGenericValue(value, increment, selStart, selEnd, info);
	    }

	    if (incrementedValue === null) {
	      return null;
	    }

	    let preRawValue = value.substr(0, range.start);
	    let postRawValue = value.substr(range.end);

	    return {
	      value: preRawValue + incrementedValue + postRawValue,
	      start: range.start + selection[0],
	      end: range.start + selection[1]
	    };
	  },

	  /**
	   * Parses the property value and type.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} offset
	   *        Starting index of value.
	   * @return {Object} object with properties 'value', 'start', 'end', and
	   *         'type'.
	   */
	  _parseCSSValue: function (value, offset) {
	    const reSplitCSS = /(url\("?[^"\)]+"?\)?)|(rgba?\([^)]*\)?)|(hsla?\([^)]*\)?)|(#[\dA-Fa-f]+)|(-?\d*\.?\d+(%|[a-z]{1,4})?)|"([^"]*)"?|'([^']*)'?|([^,\s\/!\(\)]+)|(!(.*)?)/;
	    let start = 0;
	    let m;

	    // retreive values from left to right until we find the one at our offset
	    while ((m = reSplitCSS.exec(value)) && m.index + m[0].length < offset) {
	      value = value.substr(m.index + m[0].length);
	      start += m.index + m[0].length;
	      offset -= m.index + m[0].length;
	    }

	    if (!m) {
	      return null;
	    }

	    let type;
	    if (m[1]) {
	      type = "url";
	    } else if (m[2]) {
	      type = "rgb";
	    } else if (m[3]) {
	      type = "hsl";
	    } else if (m[4]) {
	      type = "hex";
	    } else if (m[5]) {
	      type = "num";
	    }

	    return {
	      value: m[0],
	      start: start + m.index,
	      end: start + m.index + m[0].length,
	      type: type
	    };
	  },

	  /**
	   * Increment the property value for types other than
	   * number or hex, such as rgb, hsl, and file names.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} increment
	   *        Amount to increment/decrement.
	   * @param {Number} offset
	   *        Starting index of the property value.
	   * @param {Number} offsetEnd
	   *        Ending index of the property value.
	   * @param {Object} info
	   *        Object with details about the property value.
	   * @return {Object} object with properties 'value', 'start', and 'end'.
	   */
	  _incrementGenericValue: function (value, increment, offset, offsetEnd, info) {
	    // Try to find a number around the cursor to increment.
	    let start, end;
	    // Check if we are incrementing in a non-number context (such as a URL)
	    if (/^-?[0-9.]/.test(value.substring(offset, offsetEnd)) && !/\d/.test(value.charAt(offset - 1) + value.charAt(offsetEnd))) {
	      // We have a number selected, possibly with a suffix, and we are not in
	      // the disallowed case of just part of a known number being selected.
	      // Use that number.
	      start = offset;
	      end = offsetEnd;
	    } else {
	      // Parse periods as belonging to the number only if we are in a known
	      // number context. (This makes incrementing the 1 in 'image1.gif' work.)
	      let pattern = "[" + (info ? "0-9." : "0-9") + "]*";
	      let before = new RegExp(pattern + "$").exec(value.substr(0, offset))[0].length;
	      let after = new RegExp("^" + pattern).exec(value.substr(offset))[0].length;

	      start = offset - before;
	      end = offset + after;

	      // Expand the number to contain an initial minus sign if it seems
	      // free-standing.
	      if (value.charAt(start - 1) === "-" && (start - 1 === 0 || /[ (:,='"]/.test(value.charAt(start - 2)))) {
	        --start;
	      }
	    }

	    if (start !== end) {
	      // Include percentages as part of the incremented number (they are
	      // common enough).
	      if (value.charAt(end) === "%") {
	        ++end;
	      }

	      let first = value.substr(0, start);
	      let mid = value.substring(start, end);
	      let last = value.substr(end);

	      mid = this._incrementRawValue(mid, increment, info);

	      if (mid !== null) {
	        return {
	          value: first + mid + last,
	          start: start,
	          end: start + mid.length
	        };
	      }
	    }
	  },

	  /**
	   * Increment the property value for numbers.
	   *
	   * @param {String} rawValue
	   *        Raw value to increment.
	   * @param {Number} increment
	   *        Amount to increase/decrease the raw value.
	   * @param {Object} info
	   *        Object with info about the property value.
	   * @return {String} the incremented value.
	   */
	  _incrementRawValue: function (rawValue, increment, info) {
	    let num = parseFloat(rawValue);

	    if (isNaN(num)) {
	      return null;
	    }

	    let number = /\d+(\.\d+)?/.exec(rawValue);
	    let units = rawValue.substr(number.index + number[0].length);

	    // avoid rounding errors
	    let newValue = Math.round((num + increment) * 1000) / 1000;

	    if (info && "minValue" in info) {
	      newValue = Math.max(newValue, info.minValue);
	    }
	    if (info && "maxValue" in info) {
	      newValue = Math.min(newValue, info.maxValue);
	    }

	    newValue = newValue.toString();

	    return newValue + units;
	  },

	  /**
	   * Increment the property value for hex.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} increment
	   *        Amount to increase/decrease the property value.
	   * @param {Number} offset
	   *        Starting index of the property value.
	   * @param {Number} offsetEnd
	   *        Ending index of the property value.
	   * @return {Object} object with properties 'value' and 'selection'.
	   */
	  _incHexColor: function (rawValue, increment, offset, offsetEnd) {
	    // Return early if no part of the rawValue is selected.
	    if (offsetEnd > rawValue.length && offset >= rawValue.length) {
	      return null;
	    }
	    if (offset < 1 && offsetEnd <= 1) {
	      return null;
	    }
	    // Ignore the leading #.
	    rawValue = rawValue.substr(1);
	    --offset;
	    --offsetEnd;

	    // Clamp the selection to within the actual value.
	    offset = Math.max(offset, 0);
	    offsetEnd = Math.min(offsetEnd, rawValue.length);
	    offsetEnd = Math.max(offsetEnd, offset);

	    // Normalize #ABC -> #AABBCC.
	    if (rawValue.length === 3) {
	      rawValue = rawValue.charAt(0) + rawValue.charAt(0) + rawValue.charAt(1) + rawValue.charAt(1) + rawValue.charAt(2) + rawValue.charAt(2);
	      offset *= 2;
	      offsetEnd *= 2;
	    }

	    if (rawValue.length !== 6) {
	      return null;
	    }

	    // If no selection, increment an adjacent color, preferably one to the left.
	    if (offset === offsetEnd) {
	      if (offset === 0) {
	        offsetEnd = 1;
	      } else {
	        offset = offsetEnd - 1;
	      }
	    }

	    // Make the selection cover entire parts.
	    offset -= offset % 2;
	    offsetEnd += offsetEnd % 2;

	    // Remap the increments from [0.1, 1, 10] to [1, 1, 16].
	    if (increment > -1 && increment < 1) {
	      increment = increment < 0 ? -1 : 1;
	    }
	    if (Math.abs(increment) === 10) {
	      increment = increment < 0 ? -16 : 16;
	    }

	    let isUpper = rawValue.toUpperCase() === rawValue;

	    for (let pos = offset; pos < offsetEnd; pos += 2) {
	      // Increment the part in [pos, pos+2).
	      let mid = rawValue.substr(pos, 2);
	      let value = parseInt(mid, 16);

	      if (isNaN(value)) {
	        return null;
	      }

	      mid = Math.min(Math.max(value + increment, 0), 255).toString(16);

	      while (mid.length < 2) {
	        mid = "0" + mid;
	      }
	      if (isUpper) {
	        mid = mid.toUpperCase();
	      }

	      rawValue = rawValue.substr(0, pos) + mid + rawValue.substr(pos + 2);
	    }

	    return {
	      value: "#" + rawValue,
	      selection: [offset + 1, offsetEnd + 1]
	    };
	  },

	  /**
	   * Cycle through the autocompletion suggestions in the popup.
	   *
	   * @param {Boolean} reverse
	   *        true to select previous item from the popup.
	   * @param {Boolean} noSelect
	   *        true to not select the text after selecting the newly selectedItem
	   *        from the popup.
	   */
	  _cycleCSSSuggestion: function (reverse, noSelect) {
	    // selectedItem can be null when nothing is selected in an empty editor.

	    var _ref = this.popup.selectedItem || { label: "", preLabel: "" };

	    let label = _ref.label;
	    let preLabel = _ref.preLabel;

	    if (reverse) {
	      this.popup.selectPreviousItem();
	    } else {
	      this.popup.selectNextItem();
	    }

	    this._selectedIndex = this.popup.selectedIndex;
	    let input = this.input;
	    let pre = "";

	    if (input.selectionStart < input.selectionEnd) {
	      pre = input.value.slice(0, input.selectionStart);
	    } else {
	      pre = input.value.slice(0, input.selectionStart - label.length + preLabel.length);
	    }

	    let post = input.value.slice(input.selectionEnd, input.value.length);
	    let item = this.popup.selectedItem;
	    let toComplete = item.label.slice(item.preLabel.length);
	    input.value = pre + toComplete + post;

	    if (!noSelect) {
	      input.setSelectionRange(pre.length, pre.length + toComplete.length);
	    } else {
	      input.setSelectionRange(pre.length + toComplete.length, pre.length + toComplete.length);
	    }

	    this._updateSize();
	    // This emit is mainly for the purpose of making the test flow simpler.
	    this.emit("after-suggest");
	  },

	  /**
	   * Call the client's done handler and clear out.
	   */
	  _apply: function (event, direction) {
	    if (this._applied) {
	      return null;
	    }

	    this._applied = true;

	    if (this.done) {
	      let val = this.cancelled ? this.initial : this.currentInputValue;
	      return this.done(val, !this.cancelled, direction);
	    }

	    return null;
	  },

	  /**
	   * Handle loss of focus by calling done if it hasn't been called yet.
	   */
	  _onBlur: function (event, doNotClear) {
	    var _this = this;

	    if (event && this.popup && this.popup.isOpen && this.popup.selectedIndex >= 0) {
	      let label, preLabel;

	      if (this._selectedIndex === undefined) {
	        var _popup$getItemAtIndex = this.popup.getItemAtIndex(this.popup.selectedIndex);

	        label = _popup$getItemAtIndex.label;
	        preLabel = _popup$getItemAtIndex.preLabel;
	      } else {
	        var _popup$getItemAtIndex2 = this.popup.getItemAtIndex(this._selectedIndex);

	        label = _popup$getItemAtIndex2.label;
	        preLabel = _popup$getItemAtIndex2.preLabel;
	      }

	      let input = this.input;
	      let pre = "";

	      // CSS_MIXED needs special treatment here to make it so that
	      // multiple presses of tab will cycle through completions, but
	      // without selecting the completed text.  However, this same
	      // special treatment will do the wrong thing for other editing
	      // styles.
	      if (input.selectionStart < input.selectionEnd || this.contentType !== CONTENT_TYPES.CSS_MIXED) {
	        pre = input.value.slice(0, input.selectionStart);
	      } else {
	        pre = input.value.slice(0, input.selectionStart - label.length + preLabel.length);
	      }
	      let post = input.value.slice(input.selectionEnd, input.value.length);
	      let item = this.popup.selectedItem;
	      this._selectedIndex = this.popup.selectedIndex;
	      let toComplete = item.label.slice(item.preLabel.length);
	      input.value = pre + toComplete + post;
	      input.setSelectionRange(pre.length + toComplete.length, pre.length + toComplete.length);
	      this._updateSize();
	      // Wait for the popup to hide and then focus input async otherwise it does
	      // not work.
	      let onPopupHidden = function () {
	        _this.popup._panel.removeEventListener("popuphidden", onPopupHidden);
	        _this.doc.defaultView.setTimeout(function () {
	          input.focus();
	          _this.emit("after-suggest");
	        }, 0);
	      };
	      this.popup._panel.addEventListener("popuphidden", onPopupHidden);
	      this.popup.hidePopup();
	      // Content type other than CSS_MIXED is used in rule-view where the values
	      // are live previewed. So we apply the value before returning.
	      if (this.contentType != CONTENT_TYPES.CSS_MIXED) {
	        this._apply();
	      }
	      return;
	    }

	    this._apply();

	    if (!doNotClear) {
	      this._clear();
	    }
	  },

	  /**
	   * Handle the input field's keypress event.
	   */
	  _onKeyPress: function (event) {
	    let prevent = false;

	    const largeIncrement = 100;
	    const mediumIncrement = 10;
	    const smallIncrement = 0.1;

	    let increment = 0;

	    if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_UP || event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_PAGE_UP) {
	      increment = 1;
	    } else if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_DOWN || event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_PAGE_DOWN) {
	      increment = -1;
	    }

	    if (event.shiftKey && !event.altKey) {
	      if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_PAGE_UP || event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_PAGE_DOWN) {
	        increment *= largeIncrement;
	      } else {
	        increment *= mediumIncrement;
	      }
	    } else if (event.altKey && !event.shiftKey) {
	      increment *= smallIncrement;
	    }

	    // Use default cursor movement rather than providing auto-suggestions.
	    if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_HOME || event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_END || event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_PAGE_UP || event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_PAGE_DOWN) {
	      this._preventSuggestions = true;
	    }

	    let cycling = false;
	    if (increment && this._incrementValue(increment)) {
	      this._updateSize();
	      prevent = true;
	      cycling = true;
	    } else if (increment && this.popup && this.popup.isOpen) {
	      cycling = true;
	      prevent = true;
	      this._cycleCSSSuggestion(increment > 0);
	      this._doValidation();
	    }

	    if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_BACK_SPACE || event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_DELETE || event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_LEFT || event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_RIGHT) {
	      if (this.popup && this.popup.isOpen) {
	        this.popup.hidePopup();
	      }
	    } else if (!cycling && !event.metaKey && !event.altKey && !event.ctrlKey) {
	      this._maybeSuggestCompletion();
	    }

	    if (this.multiline && event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_RETURN && event.shiftKey) {
	      prevent = false;
	    } else if (this._advanceChars(event.charCode, this.input.value, this.input.selectionStart) || event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_RETURN || event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_TAB) {
	      prevent = true;

	      let direction = FOCUS_FORWARD;
	      if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_TAB && event.shiftKey) {
	        if (this.stopOnShiftTab) {
	          direction = null;
	        } else {
	          direction = FOCUS_BACKWARD;
	        }
	      }
	      if (this.stopOnReturn && event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_RETURN || this.stopOnTab && event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_TAB && !event.shiftKey) {
	        direction = null;
	      }

	      // Now we don't want to suggest anything as we are moving out.
	      this._preventSuggestions = true;
	      // But we still want to show suggestions for css values. i.e. moving out
	      // of css property input box in forward direction
	      if (this.contentType == CONTENT_TYPES.CSS_PROPERTY && direction == FOCUS_FORWARD) {
	        this._preventSuggestions = false;
	      }

	      let input = this.input;

	      if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_TAB && this.contentType == CONTENT_TYPES.CSS_MIXED) {
	        if (this.popup && input.selectionStart < input.selectionEnd) {
	          event.preventDefault();
	          input.setSelectionRange(input.selectionEnd, input.selectionEnd);
	          this.emit("after-suggest");
	          return;
	        } else if (this.popup && this.popup.isOpen) {
	          event.preventDefault();
	          this._cycleCSSSuggestion(event.shiftKey, true);
	          return;
	        }
	      }

	      this._apply(event, direction);

	      // Close the popup if open
	      if (this.popup && this.popup.isOpen) {
	        this.popup.hidePopup();
	      }

	      if (direction !== null && focusManager.focusedElement === input) {
	        // If the focused element wasn't changed by the done callback,
	        // move the focus as requested.
	        let next = moveFocus(this.doc.defaultView, direction);

	        // If the next node to be focused has been tagged as an editable
	        // node, trigger editing using the configured event
	        if (next && next.ownerDocument === this.doc && next._editable) {
	          let e = this.doc.createEvent("Event");
	          e.initEvent(next._trigger, true, true);
	          next.dispatchEvent(e);
	        }
	      }

	      this._clear();
	    } else if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE) {
	      // Cancel and blur ourselves.
	      // Now we don't want to suggest anything as we are moving out.
	      this._preventSuggestions = true;
	      // Close the popup if open
	      if (this.popup && this.popup.isOpen) {
	        this.popup.hidePopup();
	      }
	      prevent = true;
	      this.cancelled = true;
	      this._apply();
	      this._clear();
	      event.stopPropagation();
	    } else if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_SPACE) {
	      // No need for leading spaces here.  This is particularly
	      // noticable when adding a property: it's very natural to type
	      // <name>: (which advances to the next property) then spacebar.
	      prevent = !this.input.value;
	    }

	    if (prevent) {
	      event.preventDefault();
	    }
	  },

	  /**
	   * Handle the input field's keyup event.
	   */
	  _onKeyup: function () {
	    this._applied = false;
	  },

	  /**
	   * Handle changes to the input text.
	   */
	  _onInput: function () {
	    // Validate the entered value.
	    this._doValidation();

	    // Update size if we're autosizing.
	    if (this._measurement) {
	      this._updateSize();
	    }

	    // Call the user's change handler if available.
	    if (this.change) {
	      this.change(this.currentInputValue);
	    }
	  },

	  /**
	   * Fire validation callback with current input
	   */
	  _doValidation: function () {
	    if (this.validate && this.input) {
	      this.validate(this.input.value);
	    }
	  },

	  /**
	   * Handles displaying suggestions based on the current input.
	   *
	   * @param {Boolean} noAutoInsert
	   *        true if you don't want to automatically insert the first suggestion
	   */
	  _maybeSuggestCompletion: function (noAutoInsert) {
	    var _this2 = this;

	    // Input can be null in cases when you intantaneously switch out of it.
	    if (!this.input) {
	      return;
	    }
	    let preTimeoutQuery = this.input.value;
	    // Since we are calling this method from a keypress event handler, the
	    // |input.value| does not include currently typed character. Thus we perform
	    // this method async.
	    this.doc.defaultView.setTimeout(function () {
	      if (_this2._preventSuggestions) {
	        _this2._preventSuggestions = false;
	        return;
	      }
	      if (_this2.contentType == CONTENT_TYPES.PLAIN_TEXT) {
	        return;
	      }
	      if (!_this2.input) {
	        return;
	      }
	      let input = _this2.input;
	      // The length of input.value should be increased by 1
	      if (input.value.length - preTimeoutQuery.length > 1) {
	        return;
	      }
	      let query = input.value.slice(0, input.selectionStart);
	      let startCheckQuery = query;
	      if (query == null) {
	        return;
	      }
	      // If nothing is selected and there is a non-space character after the
	      // cursor, do not autocomplete.
	      if (input.selectionStart == input.selectionEnd && input.selectionStart < input.value.length && input.value.slice(input.selectionStart)[0] != " ") {
	        // This emit is mainly to make the test flow simpler.
	        _this2.emit("after-suggest", "nothing to autocomplete");
	        return;
	      }
	      let list = [];
	      if (_this2.contentType == CONTENT_TYPES.CSS_PROPERTY) {
	        list = CSSPropertyList;
	      } else if (_this2.contentType == CONTENT_TYPES.CSS_VALUE) {
	        // Get the last query to be completed before the caret.
	        let match = /([^\s,.\/]+$)/.exec(query);
	        if (match) {
	          startCheckQuery = match[0];
	        } else {
	          startCheckQuery = "";
	        }

	        list = ["!important", ...domUtils.getCSSValuesForProperty(_this2.property.name)];

	        if (query == "") {
	          // Do not suggest '!important' without any manually typed character.
	          list.splice(0, 1);
	        }
	      } else if (_this2.contentType == CONTENT_TYPES.CSS_MIXED && /^\s*style\s*=/.test(query)) {
	        // Detecting if cursor is at property or value;
	        let match = query.match(/([:;"'=]?)\s*([^"';:=]+)?$/);
	        if (match && match.length >= 2) {
	          if (match[1] == ":") {
	            // We are in CSS value completion
	            let propertyName = query.match(/[;"'=]\s*([^"';:= ]+)\s*:\s*[^"';:=]*$/)[1];
	            list = ["!important;", ...domUtils.getCSSValuesForProperty(propertyName)];
	            let matchLastQuery = /([^\s,.\/]+$)/.exec(match[2] || "");
	            if (matchLastQuery) {
	              startCheckQuery = matchLastQuery[0];
	            } else {
	              startCheckQuery = "";
	            }
	            if (!match[2]) {
	              // Don't suggest '!important' without any manually typed character
	              list.splice(0, 1);
	            }
	          } else if (match[1]) {
	            // We are in CSS property name completion
	            list = CSSPropertyList;
	            startCheckQuery = match[2];
	          }
	          if (startCheckQuery == null) {
	            // This emit is mainly to make the test flow simpler.
	            _this2.emit("after-suggest", "nothing to autocomplete");
	            return;
	          }
	        }
	      }
	      if (!noAutoInsert) {
	        list.some(function (item) {
	          if (startCheckQuery != null && item.startsWith(startCheckQuery)) {
	            input.value = query + item.slice(startCheckQuery.length) + input.value.slice(query.length);
	            input.setSelectionRange(query.length, query.length + item.length - startCheckQuery.length);
	            _this2._updateSize();
	            return true;
	          }
	        });
	      }

	      if (!_this2.popup) {
	        // This emit is mainly to make the test flow simpler.
	        _this2.emit("after-suggest", "no popup");
	        return;
	      }
	      let finalList = [];
	      let length = list.length;
	      for (let i = 0, count = 0; i < length && count < MAX_POPUP_ENTRIES; i++) {
	        if (startCheckQuery != null && list[i].startsWith(startCheckQuery)) {
	          count++;
	          finalList.push({
	            preLabel: startCheckQuery,
	            label: list[i]
	          });
	        } else if (count > 0) {
	          // Since count was incremented, we had already crossed the entries
	          // which would have started with query, assuming that list is sorted.
	          break;
	        } else if (startCheckQuery != null && list[i][0] > startCheckQuery[0]) {
	          // We have crossed all possible matches alphabetically.
	          break;
	        }
	      }

	      if (finalList.length > 1) {
	        // Calculate the offset for the popup to be opened.
	        let x = (_this2.input.selectionStart - startCheckQuery.length) * _this2.inputCharWidth;
	        _this2.popup.setItems(finalList);
	        _this2.popup.openPopup(_this2.input, x);
	        if (noAutoInsert) {
	          _this2.popup.selectedIndex = -1;
	        }
	      } else {
	        _this2.popup.hidePopup();
	      }
	      // This emit is mainly for the purpose of making the test flow simpler.
	      _this2.emit("after-suggest");
	      _this2._doValidation();
	    }, 0);
	  }
	};

	/**
	 * Copy text-related styles from one element to another.
	 */
	function copyTextStyles(from, to) {
	  let win = from.ownerDocument.defaultView;
	  let style = win.getComputedStyle(from);
	  to.style.fontFamily = style.getPropertyCSSValue("font-family").cssText;
	  to.style.fontSize = style.getPropertyCSSValue("font-size").cssText;
	  to.style.fontWeight = style.getPropertyCSSValue("font-weight").cssText;
	  to.style.fontStyle = style.getPropertyCSSValue("font-style").cssText;
	}

	/**
	 * Trigger a focus change similar to pressing tab/shift-tab.
	 */
	function moveFocus(win, direction) {
	  return focusManager.moveFocus(win, null, direction, 0);
	}

	XPCOMUtils.defineLazyGetter(this, "focusManager", function () {
	  return Services.focus;
	});

	XPCOMUtils.defineLazyGetter(this, "CSSPropertyList", function () {
	  return domUtils.getCSSPropertyNames(domUtils.INCLUDE_ALIASES).sort();
	});

	// XPCOMUtils.defineLazyGetter(this, "domUtils", function() {
	//   return Cc("@mozilla.org/inspector/dom-utils;1").getService(Ci.inIDOMUtils);
	// });

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;

	const Editor = __webpack_require__(36);

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	const EventEmitter = __webpack_require__(7);

	exports.HTMLEditor = HTMLEditor;

	function ctrl(k) {
	  return (Services.appinfo.OS == "Darwin" ? "Cmd-" : "Ctrl-") + k;
	}
	function stopPropagation(e) {
	  e.stopPropagation();
	}
	/**
	 * A wrapper around the Editor component, that allows editing of HTML.
	 *
	 * The main functionality this provides around the Editor is the ability
	 * to show/hide/position an editor inplace. It only appends once to the
	 * body, and uses CSS to position the editor.  The reason it is done this
	 * way is that the editor is loaded in an iframe, and calling appendChild
	 * causes it to reload.
	 *
	 * Meant to be embedded inside of an HTML page, as in markup-view.xhtml.
	 *
	 * @param HTMLDocument htmlDocument
	 *        The document to attach the editor to.  Will also use this
	 *        document as a basis for listening resize events.
	 */
	function HTMLEditor(htmlDocument) {
	  var _this = this;

	  this.doc = htmlDocument;
	  this.container = this.doc.createElement("div");
	  this.container.className = "html-editor theme-body";
	  this.container.style.display = "none";
	  this.editorInner = this.doc.createElement("div");
	  this.editorInner.className = "html-editor-inner";
	  this.container.appendChild(this.editorInner);

	  this.doc.body.appendChild(this.container);
	  this.hide = this.hide.bind(this);
	  this.refresh = this.refresh.bind(this);

	  EventEmitter.decorate(this);

	  this.doc.defaultView.addEventListener("resize", this.refresh, true);

	  let config = {
	    mode: Editor.modes.html,
	    lineWrapping: true,
	    styleActiveLine: false,
	    extraKeys: {},
	    theme: "mozilla markup-view"
	  };

	  config.extraKeys[ctrl("Enter")] = this.hide;
	  config.extraKeys["F2"] = this.hide;
	  config.extraKeys["Esc"] = this.hide.bind(this, false);

	  this.container.addEventListener("click", this.hide, false);
	  this.editorInner.addEventListener("click", stopPropagation, false);
	  this.editor = new Editor(config);

	  let iframe = this.editorInner.ownerDocument.createElement("iframe");
	  this.editor.appendTo(this.editorInner, iframe).then(function () {
	    _this.hide(false);
	  }).then(null, function (err) {
	    return console.log(err.message);
	  });
	}

	HTMLEditor.prototype = {

	  /**
	   * Need to refresh position by manually setting CSS values, so this will
	   * need to be called on resizes and other sizing changes.
	   */
	  refresh: function () {
	    let element = this._attachedElement;

	    if (element) {
	      this.container.style.top = element.offsetTop + "px";
	      this.container.style.left = element.offsetLeft + "px";
	      this.container.style.width = element.offsetWidth + "px";
	      this.container.style.height = element.parentNode.offsetHeight + "px";
	      this.editor.refresh();
	    }
	  },

	  /**
	   * Anchor the editor to a particular element.
	   *
	   * @param DOMNode element
	   *        The element that the editor will be anchored to.
	   *        Should belong to the HTMLDocument passed into the constructor.
	   */
	  _attach: function (element) {
	    this._detach();
	    this._attachedElement = element;
	    element.classList.add("html-editor-container");
	    this.refresh();
	  },

	  /**
	   * Unanchor the editor from an element.
	   */
	  _detach: function () {
	    if (this._attachedElement) {
	      this._attachedElement.classList.remove("html-editor-container");
	      this._attachedElement = undefined;
	    }
	  },

	  /**
	   * Anchor the editor to a particular element, and show the editor.
	   *
	   * @param DOMNode element
	   *        The element that the editor will be anchored to.
	   *        Should belong to the HTMLDocument passed into the constructor.
	   * @param string text
	   *        Value to set the contents of the editor to
	   * @param function cb
	   *        The function to call when hiding
	   */
	  show: function (element, text) {
	    if (this._visible) {
	      return;
	    }

	    this._originalValue = text;
	    this.editor.setText(text);
	    this._attach(element);
	    this.container.style.display = "flex";
	    this._visible = true;

	    this.editor.refresh();
	    this.editor.focus();

	    this.emit("popupshown");
	  },

	  /**
	   * Hide the editor, optionally committing the changes
	   *
	   * @param bool shouldCommit
	   *             A change will be committed by default.  If this param
	   *             strictly equals false, no change will occur.
	   */
	  hide: function (shouldCommit) {
	    if (!this._visible) {
	      return;
	    }

	    this.container.style.display = "none";
	    this._detach();

	    let newValue = this.editor.getText();
	    let valueHasChanged = this._originalValue !== newValue;
	    let preventCommit = shouldCommit === false || !valueHasChanged;
	    this._originalValue = undefined;
	    this._visible = undefined;
	    this.emit("popuphidden", !preventCommit, newValue);
	  },

	  /**
	   * Destroy this object and unbind all event handlers
	   */
	  destroy: function () {
	    this.doc.defaultView.removeEventListener("resize", this.refresh, true);
	    this.container.removeEventListener("click", this.hide, false);
	    this.editorInner.removeEventListener("click", stopPropagation, false);

	    this.hide(false);
	    this.container.remove();
	    this.editor.destroy();
	  }
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2; fill-column: 80 -*- */
	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;
	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const components = _require.components;

	var _require2 = __webpack_require__(37);

	const EXPAND_TAB = _require2.EXPAND_TAB;
	const TAB_SIZE = _require2.TAB_SIZE;
	const DETECT_INDENT = _require2.DETECT_INDENT;
	const getIndentationFromIteration = _require2.getIndentationFromIteration;

	const ENABLE_CODE_FOLDING = "devtools.editor.enableCodeFolding";
	const KEYMAP = "devtools.editor.keymap";
	const AUTO_CLOSE = "devtools.editor.autoclosebrackets";
	const AUTOCOMPLETE = "devtools.editor.autocomplete";
	const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
	const VALID_KEYMAPS = new Set(["emacs", "vim", "sublime"]);

	var _require3 = __webpack_require__(38);

	const Task = _require3.Task;

	// Maximum allowed margin (in number of lines) from top or bottom of the editor
	// while shifting to a line which was initially out of view.

	const MAX_VERTICAL_OFFSET = 3;

	// Match @Scratchpad/N:LINE[:COLUMN] or (LINE[:COLUMN]) anywhere at an end of
	// line in text selection.
	const RE_SCRATCHPAD_ERROR = /(?:@Scratchpad\/\d+:|\()(\d+):?(\d+)?(?:\)|\n)/;
	const RE_JUMP_TO_LINE = /^(\d+):?(\d+)?/;

	const promise = __webpack_require__(6);
	const events = __webpack_require__(7);

	var _require4 = __webpack_require__(39);

	const PrefObserver = _require4.PrefObserver;

	var _require5 = __webpack_require__(9);

	const Services = _require5.Services;

	const L10N = Services.strings.createBundle(__webpack_require__(40));

	const OS = Services.appinfo.OS;

	// CM_STYLES, CM_SCRIPTS and CM_IFRAME represent the HTML,
	// JavaScript and CSS that is injected into an iframe in
	// order to initialize a CodeMirror instance.

	const CM_STYLES = [];

	const CM_SCRIPTS = ["shared/theme-switching.js", "sourceeditor/codemirror/lib/codemirror.js", "sourceeditor/codemirror/addon/dialog/dialog.js", "sourceeditor/codemirror/addon/search/searchcursor.js", "sourceeditor/codemirror/addon/search/search.js", "sourceeditor/codemirror/addon/edit/matchbrackets.js", "sourceeditor/codemirror/addon/edit/closebrackets.js", "sourceeditor/codemirror/addon/comment/comment.js", "sourceeditor/codemirror/mode/javascript.js", "sourceeditor/codemirror/mode/xml.js", "sourceeditor/codemirror/mode/css.js", "sourceeditor/codemirror/mode/htmlmixed.js", "sourceeditor/codemirror/mode/clike.js", "sourceeditor/codemirror/addon/selection/active-line.js", "sourceeditor/codemirror/addon/edit/trailingspace.js", "sourceeditor/codemirror/keymap/emacs.js", "sourceeditor/codemirror/keymap/vim.js", "sourceeditor/codemirror/keymap/sublime.js", "sourceeditor/codemirror/addon/fold/foldcode.js", "sourceeditor/codemirror/addon/fold/brace-fold.js", "sourceeditor/codemirror/addon/fold/comment-fold.js", "sourceeditor/codemirror/addon/fold/xml-fold.js", "sourceeditor/codemirror/addon/fold/foldgutter.js"];

	const CM_IFRAME = "/client/sourceeditor/codemirror.html";

	const CM_MAPPING = ["focus", "hasFocus", "lineCount", "somethingSelected", "getCursor", "setSelection", "getSelection", "replaceSelection", "extendSelection", "undo", "redo", "clearHistory", "openDialog", "refresh", "getScrollInfo", "getViewport"];

	var _getCSSKeywords = getCSSKeywords();

	const cssProperties = _getCSSKeywords.cssProperties;
	const cssValues = _getCSSKeywords.cssValues;
	const cssColors = _getCSSKeywords.cssColors;

	const editors = new WeakMap();

	Editor.modes = {
	  text: { name: "text" },
	  html: { name: "htmlmixed" },
	  css: { name: "css" },
	  js: { name: "javascript" },
	  vs: { name: "x-shader/x-vertex" },
	  fs: { name: "x-shader/x-fragment" }
	};

	/**
	 * A very thin wrapper around CodeMirror. Provides a number
	 * of helper methods to make our use of CodeMirror easier and
	 * another method, appendTo, to actually create and append
	 * the CodeMirror instance.
	 *
	 * Note that Editor doesn't expose CodeMirror instance to the
	 * outside world.
	 *
	 * Constructor accepts one argument, config. It is very
	 * similar to the CodeMirror configuration object so for most
	 * properties go to CodeMirror's documentation (see below).
	 *
	 * Other than that, it accepts one additional and optional
	 * property contextMenu. This property should be an element, or
	 * an ID of an element that we can use as a context menu.
	 *
	 * This object is also an event emitter.
	 *
	 * CodeMirror docs: http://codemirror.net/doc/manual.html
	 */
	function Editor(config) {
	  var _this = this;

	  const tabSize = Services.prefs.getIntPref(TAB_SIZE);
	  const useTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
	  const useAutoClose = Services.prefs.getBoolPref(AUTO_CLOSE);

	  this.version = null;
	  this.config = {
	    value: "",
	    mode: Editor.modes.text,
	    indentUnit: tabSize,
	    tabSize: tabSize,
	    contextMenu: null,
	    matchBrackets: true,
	    extraKeys: {},
	    indentWithTabs: useTabs,
	    styleActiveLine: true,
	    autoCloseBrackets: "()[]{}''\"\"``",
	    autoCloseEnabled: useAutoClose,
	    theme: "mozilla",
	    themeSwitching: true,
	    autocomplete: false,
	    autocompleteOpts: {}
	  };

	  // Additional shortcuts.
	  this.config.extraKeys[Editor.keyFor("jumpToLine")] = function () {
	    return _this.jumpToLine();
	  };
	  this.config.extraKeys[Editor.keyFor("moveLineUp", { noaccel: true })] = function () {
	    return _this.moveLineUp();
	  };
	  this.config.extraKeys[Editor.keyFor("moveLineDown", { noaccel: true })] = function () {
	    return _this.moveLineDown();
	  };
	  this.config.extraKeys[Editor.keyFor("toggleComment")] = "toggleComment";

	  // Disable ctrl-[ and ctrl-] because toolbox uses those shortcuts.
	  this.config.extraKeys[Editor.keyFor("indentLess")] = false;
	  this.config.extraKeys[Editor.keyFor("indentMore")] = false;

	  // Overwrite default config with user-provided, if needed.
	  Object.keys(config).forEach(function (k) {
	    if (k != "extraKeys") {
	      _this.config[k] = config[k];
	      return;
	    }

	    if (!config.extraKeys) return;

	    Object.keys(config.extraKeys).forEach(function (key) {
	      _this.config.extraKeys[key] = config.extraKeys[key];
	    });
	  });

	  if (!this.config.gutters) {
	    this.config.gutters = [];
	  }
	  if (this.config.lineNumbers && this.config.gutters.indexOf("CodeMirror-linenumbers") === -1) {
	    this.config.gutters.push("CodeMirror-linenumbers");
	  }

	  // Remember the initial value of autoCloseBrackets.
	  this.config.autoCloseBracketsSaved = this.config.autoCloseBrackets;

	  // Overwrite default tab behavior. If something is selected,
	  // indent those lines. If nothing is selected and we're
	  // indenting with tabs, insert one tab. Otherwise insert N
	  // whitespaces where N == indentUnit option.
	  this.config.extraKeys.Tab = function (cm) {
	    if (cm.somethingSelected()) {
	      cm.indentSelection("add");
	      return;
	    }

	    if (_this.config.indentWithTabs) {
	      cm.replaceSelection("\t", "end", "+input");
	      return;
	    }

	    var num = cm.getOption("indentUnit");
	    if (cm.getCursor().ch !== 0) num -= 1;
	    cm.replaceSelection(" ".repeat(num), "end", "+input");
	  };

	  // Allow add-ons to inject scripts for their editor instances
	  if (!this.config.externalScripts) {
	    this.config.externalScripts = [];
	  }

	  events.decorate(this);
	}

	Editor.prototype = {
	  container: null,
	  version: null,
	  config: null,

	  /**
	   * Appends the current Editor instance to the element specified by
	   * 'el'. You can also provide your won iframe to host the editor as
	   * an optional second parameter. This method actually creates and
	   * loads CodeMirror and all its dependencies.
	   *
	   * This method is asynchronous and returns a promise.
	   */
	  appendTo: function (el, env) {
	    let def = promise.defer();
	    let cm = editors.get(this);

	    var parser = document.createElement('a');
	    var baseUri = window.location.href;

	    // Yuck.. since the CM iframe is a data URI we need an absolute path
	    // for our resources and we are making some pretty bad assumptions about
	    // where it will be.
	    baseUri = baseUri.split("/").slice(0, -2).join("/") + "/";

	    if (!env) env = document.createElement("iframe");

	    env.flex = 1;

	    if (cm) throw new Error("You can append an editor only once.");

	    let onLoad = Task.async((function* () {
	      var _this2 = this;

	      // Once the iframe is loaded, we can inject CodeMirror
	      // and its dependencies into its DOM.

	      env.removeEventListener("load", onLoad, true);
	      // let win = env.contentWindow.wrappedJSObject;
	      let win = env.contentWindow;

	      if (!this.config.themeSwitching) win.document.documentElement.setAttribute("force-theme", "light");

	      let scriptsToInject = CM_SCRIPTS.concat(this.config.externalScripts);
	      for (let script of scriptsToInject) {
	        yield Services.scriptloader.loadSubScript(baseUri + script, win, "utf8");
	      }

	      // Replace the propertyKeywords, colorKeywords and valueKeywords
	      // properties of the CSS MIME type with the values provided by Gecko.
	      let cssSpec = win.CodeMirror.resolveMode("text/css");
	      cssSpec.propertyKeywords = cssProperties;
	      cssSpec.colorKeywords = cssColors;
	      cssSpec.valueKeywords = cssValues;
	      win.CodeMirror.defineMIME("text/css", cssSpec);

	      let scssSpec = win.CodeMirror.resolveMode("text/x-scss");
	      scssSpec.propertyKeywords = cssProperties;
	      scssSpec.colorKeywords = cssColors;
	      scssSpec.valueKeywords = cssValues;
	      win.CodeMirror.defineMIME("text/x-scss", scssSpec);

	      win.CodeMirror.commands.save = function () {
	        return _this2.emit("saveRequested");
	      };

	      // Create a CodeMirror instance add support for context menus,
	      // overwrite the default controller (otherwise items in the top and
	      // context menus won't work).

	      cm = win.CodeMirror(win.document.body, this.config);
	      cm.getWrapperElement().addEventListener("contextmenu", function (ev) {
	        ev.preventDefault();
	        if (!_this2.config.contextMenu) return;
	        let popup = _this2.config.contextMenu;
	        if (typeof popup == "string") popup = el.ownerDocument.getElementById(_this2.config.contextMenu);
	        popup.openPopupAtScreen(ev.screenX, ev.screenY, true);
	      }, false);

	      // Intercept the find and find again keystroke on CodeMirror, to avoid
	      // the browser's search

	      let findKey = L10N.GetStringFromName("find.commandkey");
	      let findAgainKey = L10N.GetStringFromName("findAgain.commandkey");

	      var _ref = OS === "Darwin" ? ["metaKey", "altKey"] : ["ctrlKey", "shiftKey"];

	      var _ref2 = _slicedToArray(_ref, 2);

	      let accel = _ref2[0];
	      let modifier = _ref2[1];

	      cm.getWrapperElement().addEventListener("keydown", function (ev) {
	        let key = ev.key.toUpperCase();
	        let node = ev.originalTarget;
	        let isInput = node.tagName === "INPUT";
	        let isSearchInput = isInput && node.type === "search";

	        // replace box is a different input instance than search, and it is
	        // located in a code mirror dialog
	        let isDialogInput = isInput && node.parentNode && node.parentNode.classList.contains("CodeMirror-dialog");

	        if (!ev[accel] || !(isSearchInput || isDialogInput)) return;

	        if (key === findKey) {
	          ev.preventDefault();

	          if (isSearchInput || ev[modifier]) {
	            node.select();
	          }
	        } else if (key === findAgainKey) {
	          ev.preventDefault();

	          if (!isSearchInput) return;

	          let query = node.value;

	          // If there isn't a search state, or the text in the input does not
	          // match with the current search state, we need to create a new one
	          if (!cm.state.search || cm.state.search.query !== query) {
	            cm.state.search = {
	              posFrom: null,
	              posTo: null,
	              overlay: null,
	              query
	            };
	          }

	          if (ev.shiftKey) {
	            cm.execCommand("findPrev");
	          } else {
	            cm.execCommand("findNext");
	          }
	        }
	      });

	      cm.on("focus", function () {
	        return _this2.emit("focus");
	      });
	      cm.on("scroll", function () {
	        return _this2.emit("scroll");
	      });
	      cm.on("change", function () {
	        _this2.emit("change");
	        if (!_this2._lastDirty) {
	          _this2._lastDirty = true;
	          _this2.emit("dirty-change");
	        }
	      });
	      cm.on("cursorActivity", function (cm) {
	        return _this2.emit("cursorActivity");
	      });

	      cm.on("gutterClick", function (cm, line, gutter, ev) {
	        let head = { line: line, ch: 0 };
	        let tail = { line: line, ch: _this2.getText(line).length };

	        // Shift-click on a gutter selects the whole line.
	        if (ev.shiftKey) {
	          cm.setSelection(head, tail);
	          return;
	        }

	        _this2.emit("gutterClick", line, ev.button);
	      });

	      win.CodeMirror.defineExtension("l10n", function (name) {
	        return L10N.GetStringFromName(name);
	      });

	      // XXX: No controllers
	      // cm.getInputField().controllers.insertControllerAt(0, controller(this));

	      this.container = env;
	      editors.set(this, cm);

	      this.reloadPreferences = this.reloadPreferences.bind(this);
	      this._prefObserver = new PrefObserver("devtools.editor.");
	      this._prefObserver.on(TAB_SIZE, this.reloadPreferences);
	      this._prefObserver.on(EXPAND_TAB, this.reloadPreferences);
	      this._prefObserver.on(KEYMAP, this.reloadPreferences);
	      this._prefObserver.on(AUTO_CLOSE, this.reloadPreferences);
	      this._prefObserver.on(AUTOCOMPLETE, this.reloadPreferences);
	      this._prefObserver.on(DETECT_INDENT, this.reloadPreferences);
	      this._prefObserver.on(ENABLE_CODE_FOLDING, this.reloadPreferences);

	      this.reloadPreferences();

	      win.editor = this;
	      let editorReadyEvent = new win.CustomEvent("editorReady");
	      win.dispatchEvent(editorReadyEvent);

	      def.resolve();
	    }).bind(this));

	    env.addEventListener("load", onLoad, true);
	    env.setAttribute("src", CM_IFRAME);
	    el.appendChild(env);

	    this.once("destroy", function () {
	      return el.removeChild(env);
	    });
	    return def.promise;
	  },

	  /**
	   * Returns a boolean indicating whether the editor is ready to
	   * use.  Use appendTo(el).then(() => {}) for most cases
	   */
	  isAppended: function () {
	    return editors.has(this);
	  },

	  /**
	   * Returns the currently active highlighting mode.
	   * See Editor.modes for the list of all suppoert modes.
	   */
	  getMode: function () {
	    return this.getOption("mode");
	  },

	  /**
	   * Load a script into editor's containing window.
	   */
	  loadScript: function (url) {
	    if (!this.container) {
	      throw new Error("Can't load a script until the editor is loaded.");
	    }
	    let win = this.container.contentWindow.wrappedJSObject;
	    Services.scriptloader.loadSubScript(url, win, "utf8");
	  },

	  /**
	   * Changes the value of a currently used highlighting mode.
	   * See Editor.modes for the list of all supported modes.
	   */
	  setMode: function (value) {
	    this.setOption("mode", value);

	    // If autocomplete was set up and the mode is changing, then
	    // turn it off and back on again so the proper mode can be used.
	    if (this.config.autocomplete) {
	      this.setOption("autocomplete", false);
	      this.setOption("autocomplete", true);
	    }
	  },

	  /**
	   * Returns text from the text area. If line argument is provided
	   * the method returns only that line.
	   */
	  getText: function (line) {
	    let cm = editors.get(this);

	    if (line == null) return cm.getValue();

	    let info = cm.lineInfo(line);
	    return info ? cm.lineInfo(line).text : "";
	  },

	  /**
	   * Replaces whatever is in the text area with the contents of
	   * the 'value' argument.
	   */
	  setText: function (value) {
	    let cm = editors.get(this);
	    cm.setValue(value);

	    this.resetIndentUnit();
	  },

	  /**
	   * Reload the state of the editor based on all current preferences.
	   * This is called automatically when any of the relevant preferences
	   * change.
	   */
	  reloadPreferences: function () {
	    // Restore the saved autoCloseBrackets value if it is preffed on.
	    let useAutoClose = Services.prefs.getBoolPref(AUTO_CLOSE);
	    this.setOption("autoCloseBrackets", useAutoClose ? this.config.autoCloseBracketsSaved : false);

	    // If alternative keymap is provided, use it.
	    const keyMap = Services.prefs.getCharPref(KEYMAP);
	    if (VALID_KEYMAPS.has(keyMap)) this.setOption("keyMap", keyMap);else this.setOption("keyMap", "default");
	    this.updateCodeFoldingGutter();

	    this.resetIndentUnit();
	    this.setupAutoCompletion();
	  },

	  /**
	   * Set the editor's indentation based on the current prefs and
	   * re-detect indentation if we should.
	   */
	  resetIndentUnit: function () {
	    let cm = editors.get(this);

	    let iterFn = function (start, end, callback) {
	      cm.eachLine(start, end, function (line) {
	        return callback(line.text);
	      });
	    };

	    var _getIndentationFromIt = getIndentationFromIteration(iterFn);

	    let indentUnit = _getIndentationFromIt.indentUnit;
	    let indentWithTabs = _getIndentationFromIt.indentWithTabs;

	    cm.setOption("tabSize", indentUnit);
	    cm.setOption("indentUnit", indentUnit);
	    cm.setOption("indentWithTabs", indentWithTabs);
	  },

	  /**
	   * Replaces contents of a text area within the from/to {line, ch}
	   * range. If neither `from` nor `to` arguments are provided works
	   * exactly like setText. If only `from` object is provided, inserts
	   * text at that point, *overwriting* as many characters as needed.
	   */
	  replaceText: function (value, from, to) {
	    let cm = editors.get(this);

	    if (!from) {
	      this.setText(value);
	      return;
	    }

	    if (!to) {
	      let text = cm.getRange({ line: 0, ch: 0 }, from);
	      this.setText(text + value);
	      return;
	    }

	    cm.replaceRange(value, from, to);
	  },

	  /**
	   * Inserts text at the specified {line, ch} position, shifting existing
	   * contents as necessary.
	   */
	  insertText: function (value, at) {
	    let cm = editors.get(this);
	    cm.replaceRange(value, at, at);
	  },

	  /**
	   * Deselects contents of the text area.
	   */
	  dropSelection: function () {
	    if (!this.somethingSelected()) return;

	    this.setCursor(this.getCursor());
	  },

	  /**
	   * Returns true if there is more than one selection in the editor.
	   */
	  hasMultipleSelections: function () {
	    let cm = editors.get(this);
	    return cm.listSelections().length > 1;
	  },

	  /**
	   * Gets the first visible line number in the editor.
	   */
	  getFirstVisibleLine: function () {
	    let cm = editors.get(this);
	    return cm.lineAtHeight(0, "local");
	  },

	  /**
	   * Scrolls the view such that the given line number is the first visible line.
	   */
	  setFirstVisibleLine: function (line) {
	    let cm = editors.get(this);

	    var _cm$charCoords = cm.charCoords({ line: line, ch: 0 }, "local");

	    let top = _cm$charCoords.top;

	    cm.scrollTo(0, top);
	  },

	  /**
	   * Sets the cursor to the specified {line, ch} position with an additional
	   * option to align the line at the "top", "center" or "bottom" of the editor
	   * with "top" being default value.
	   */
	  setCursor: function ({ line, ch }, align) {
	    let cm = editors.get(this);
	    this.alignLine(line, align);
	    cm.setCursor({ line: line, ch: ch });
	    this.emit("cursorActivity");
	  },

	  /**
	   * Aligns the provided line to either "top", "center" or "bottom" of the
	   * editor view with a maximum margin of MAX_VERTICAL_OFFSET lines from top or
	   * bottom.
	   */
	  alignLine: function (line, align) {
	    let cm = editors.get(this);
	    let from = cm.lineAtHeight(0, "page");
	    let to = cm.lineAtHeight(cm.getWrapperElement().clientHeight, "page");
	    let linesVisible = to - from;
	    let halfVisible = Math.round(linesVisible / 2);

	    // If the target line is in view, skip the vertical alignment part.
	    if (line <= to && line >= from) {
	      return;
	    }

	    // Setting the offset so that the line always falls in the upper half
	    // of visible lines (lower half for bottom aligned).
	    // MAX_VERTICAL_OFFSET is the maximum allowed value.
	    let offset = Math.min(halfVisible, MAX_VERTICAL_OFFSET);

	    let topLine = ({
	      "center": Math.max(line - halfVisible, 0),
	      "bottom": Math.max(line - linesVisible + offset, 0),
	      "top": Math.max(line - offset, 0)
	    })[align || "top"] || offset;

	    // Bringing down the topLine to total lines in the editor if exceeding.
	    topLine = Math.min(topLine, this.lineCount());
	    this.setFirstVisibleLine(topLine);
	  },

	  /**
	   * Returns whether a marker of a specified class exists in a line's gutter.
	   */
	  hasMarker: function (line, gutterName, markerClass) {
	    let marker = this.getMarker(line, gutterName);
	    if (!marker) return false;

	    return marker.classList.contains(markerClass);
	  },

	  /**
	   * Adds a marker with a specified class to a line's gutter. If another marker
	   * exists on that line, the new marker class is added to its class list.
	   */
	  addMarker: function (line, gutterName, markerClass) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);
	    if (!info) return;

	    let gutterMarkers = info.gutterMarkers;
	    if (gutterMarkers) {
	      let marker = gutterMarkers[gutterName];
	      if (marker) {
	        marker.classList.add(markerClass);
	        return;
	      }
	    }

	    let marker = cm.getWrapperElement().ownerDocument.createElement("div");
	    marker.className = markerClass;
	    cm.setGutterMarker(info.line, gutterName, marker);
	  },

	  /**
	   * The reverse of addMarker. Removes a marker of a specified class from a
	   * line's gutter.
	   */
	  removeMarker: function (line, gutterName, markerClass) {
	    if (!this.hasMarker(line, gutterName, markerClass)) return;

	    let cm = editors.get(this);
	    cm.lineInfo(line).gutterMarkers[gutterName].classList.remove(markerClass);
	  },

	  /**
	   * Adds a marker with a specified class and an HTML content to a line's
	   * gutter. If another marker exists on that line, it is overwritten by a new
	   * marker.
	   */
	  addContentMarker: function (line, gutterName, markerClass, content) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);
	    if (!info) return;

	    let marker = cm.getWrapperElement().ownerDocument.createElement("div");
	    marker.className = markerClass;
	    marker.innerHTML = content;
	    cm.setGutterMarker(info.line, gutterName, marker);
	  },

	  /**
	   * The reverse of addContentMarker. Removes any line's markers in the
	   * specified gutter.
	   */
	  removeContentMarker: function (line, gutterName) {
	    let cm = editors.get(this);
	    cm.setGutterMarker(info.line, gutterName, null);
	  },

	  getMarker: function (line, gutterName) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);
	    if (!info) return null;

	    let gutterMarkers = info.gutterMarkers;
	    if (!gutterMarkers) return null;

	    return gutterMarkers[gutterName];
	  },

	  /**
	   * Remove all gutter markers in the gutter with the given name.
	   */
	  removeAllMarkers: function (gutterName) {
	    let cm = editors.get(this);
	    cm.clearGutter(gutterName);
	  },

	  /**
	   * Handles attaching a set of events listeners on a marker. They should
	   * be passed as an object literal with keys as event names and values as
	   * function listeners. The line number, marker node and optional data
	   * will be passed as arguments to the function listener.
	   *
	   * You don't need to worry about removing these event listeners.
	   * They're automatically orphaned when clearing markers.
	   */
	  setMarkerListeners: function (line, gutterName, markerClass, events, data) {
	    if (!this.hasMarker(line, gutterName, markerClass)) return;

	    let cm = editors.get(this);
	    let marker = cm.lineInfo(line).gutterMarkers[gutterName];

	    for (let name in events) {
	      let listener = events[name].bind(this, line, marker, data);
	      marker.addEventListener(name, listener);
	    }
	  },

	  /**
	   * Returns whether a line is decorated using the specified class name.
	   */
	  hasLineClass: function (line, className) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);

	    if (!info || !info.wrapClass) return false;

	    return info.wrapClass.split(" ").indexOf(className) != -1;
	  },

	  /**
	   * Set a CSS class name for the given line, including the text and gutter.
	   */
	  addLineClass: function (line, className) {
	    let cm = editors.get(this);
	    cm.addLineClass(line, "wrap", className);
	  },

	  /**
	   * The reverse of addLineClass.
	   */
	  removeLineClass: function (line, className) {
	    let cm = editors.get(this);
	    cm.removeLineClass(line, "wrap", className);
	  },

	  /**
	   * Mark a range of text inside the two {line, ch} bounds. Since the range may
	   * be modified, for example, when typing text, this method returns a function
	   * that can be used to remove the mark.
	   */
	  markText: function (from, to, className = "marked-text") {
	    let cm = editors.get(this);
	    let text = cm.getRange(from, to);
	    let span = cm.getWrapperElement().ownerDocument.createElement("span");
	    span.className = className;
	    span.textContent = text;

	    let mark = cm.markText(from, to, { replacedWith: span });
	    return {
	      anchor: span,
	      clear: function () {
	        return mark.clear();
	      }
	    };
	  },

	  /**
	   * Calculates and returns one or more {line, ch} objects for
	   * a zero-based index who's value is relative to the start of
	   * the editor's text.
	   *
	   * If only one argument is given, this method returns a single
	   * {line,ch} object. Otherwise it returns an array.
	   */
	  getPosition: function (...args) {
	    let cm = editors.get(this);
	    let res = args.map(function (ind) {
	      return cm.posFromIndex(ind);
	    });
	    return args.length === 1 ? res[0] : res;
	  },

	  /**
	   * The reverse of getPosition. Similarly to getPosition this
	   * method returns a single value if only one argument was given
	   * and an array otherwise.
	   */
	  getOffset: function (...args) {
	    let cm = editors.get(this);
	    let res = args.map(function (pos) {
	      return cm.indexFromPos(pos);
	    });
	    return args.length > 1 ? res : res[0];
	  },

	  /**
	   * Returns a {line, ch} object that corresponds to the
	   * left, top coordinates.
	   */
	  getPositionFromCoords: function ({ left, top }) {
	    let cm = editors.get(this);
	    return cm.coordsChar({ left: left, top: top });
	  },

	  /**
	   * The reverse of getPositionFromCoords. Similarly, returns a {left, top}
	   * object that corresponds to the specified line and character number.
	   */
	  getCoordsFromPosition: function ({ line, ch }) {
	    let cm = editors.get(this);
	    return cm.charCoords({ line: ~ ~line, ch: ~ ~ch });
	  },

	  /**
	   * Returns true if there's something to undo and false otherwise.
	   */
	  canUndo: function () {
	    let cm = editors.get(this);
	    return cm.historySize().undo > 0;
	  },

	  /**
	   * Returns true if there's something to redo and false otherwise.
	   */
	  canRedo: function () {
	    let cm = editors.get(this);
	    return cm.historySize().redo > 0;
	  },

	  /**
	   * Marks the contents as clean and returns the current
	   * version number.
	   */
	  setClean: function () {
	    let cm = editors.get(this);
	    this.version = cm.changeGeneration();
	    this._lastDirty = false;
	    this.emit("dirty-change");
	    return this.version;
	  },

	  /**
	   * Returns true if contents of the text area are
	   * clean i.e. no changes were made since the last version.
	   */
	  isClean: function () {
	    let cm = editors.get(this);
	    return cm.isClean(this.version);
	  },

	  /**
	   * This method opens an in-editor dialog asking for a line to
	   * jump to. Once given, it changes cursor to that line.
	   */
	  jumpToLine: function () {
	    var _this3 = this;

	    let doc = editors.get(this).getWrapperElement().ownerDocument;
	    let div = doc.createElement("div");
	    let inp = doc.createElement("input");
	    let txt = doc.createTextNode(L10N.GetStringFromName("gotoLineCmd.promptTitle"));

	    inp.type = "text";
	    inp.style.width = "10em";
	    inp.style.MozMarginStart = "1em";

	    div.appendChild(txt);
	    div.appendChild(inp);

	    if (!this.hasMultipleSelections()) {
	      let cm = editors.get(this);
	      let sel = cm.getSelection();
	      // Scratchpad inserts and selects a comment after an error happens:
	      // "@Scratchpad/1:10:2". Parse this to get the line and column.
	      // In the string above this is line 10, column 2.
	      let match = sel.match(RE_SCRATCHPAD_ERROR);
	      if (match) {
	        var _match = _slicedToArray(match, 3);

	        let line = _match[1];
	        let column = _match[2];

	        inp.value = column ? line + ":" + column : line;
	        inp.selectionStart = inp.selectionEnd = inp.value.length;
	      }
	    }

	    this.openDialog(div, function (line) {
	      // Handle LINE:COLUMN as well as LINE
	      let match = line.toString().match(RE_JUMP_TO_LINE);
	      if (match) {
	        var _match2 = _slicedToArray(match, 3);

	        let line = _match2[1];
	        let column = _match2[2];

	        _this3.setCursor({ line: line - 1, ch: column ? column - 1 : 0 });
	      }
	    });
	  },

	  /**
	   * Moves the content of the current line or the lines selected up a line.
	   */
	  moveLineUp: function () {
	    let cm = editors.get(this);
	    let start = cm.getCursor("start");
	    let end = cm.getCursor("end");

	    if (start.line === 0) return;

	    // Get the text in the lines selected or the current line of the cursor
	    // and append the text of the previous line.
	    let value;
	    if (start.line !== end.line) {
	      value = cm.getRange({ line: start.line, ch: 0 }, { line: end.line, ch: cm.getLine(end.line).length }) + "\n";
	    } else {
	      value = cm.getLine(start.line) + "\n";
	    }
	    value += cm.getLine(start.line - 1);

	    // Replace the previous line and the currently selected lines with the new
	    // value and maintain the selection of the text.
	    cm.replaceRange(value, { line: start.line - 1, ch: 0 }, { line: end.line, ch: cm.getLine(end.line).length });
	    cm.setSelection({ line: start.line - 1, ch: start.ch }, { line: end.line - 1, ch: end.ch });
	  },

	  /**
	   * Moves the content of the current line or the lines selected down a line.
	   */
	  moveLineDown: function () {
	    let cm = editors.get(this);
	    let start = cm.getCursor("start");
	    let end = cm.getCursor("end");

	    if (end.line + 1 === cm.lineCount()) return;

	    // Get the text of next line and append the text in the lines selected
	    // or the current line of the cursor.
	    let value = cm.getLine(end.line + 1) + "\n";
	    if (start.line !== end.line) {
	      value += cm.getRange({ line: start.line, ch: 0 }, { line: end.line, ch: cm.getLine(end.line).length });
	    } else {
	      value += cm.getLine(start.line);
	    }

	    // Replace the currently selected lines and the next line with the new
	    // value and maintain the selection of the text.
	    cm.replaceRange(value, { line: start.line, ch: 0 }, { line: end.line + 1, ch: cm.getLine(end.line + 1).length });
	    cm.setSelection({ line: start.line + 1, ch: start.ch }, { line: end.line + 1, ch: end.ch });
	  },

	  /**
	   * Returns current font size for the editor area, in pixels.
	   */
	  getFontSize: function () {
	    let cm = editors.get(this);
	    let el = cm.getWrapperElement();
	    let win = el.ownerDocument.defaultView;

	    return parseInt(win.getComputedStyle(el).getPropertyValue("font-size"), 10);
	  },

	  /**
	   * Sets font size for the editor area.
	   */
	  setFontSize: function (size) {
	    let cm = editors.get(this);
	    cm.getWrapperElement().style.fontSize = parseInt(size, 10) + "px";
	    cm.refresh();
	  },

	  /**
	   * Sets an option for the editor.  For most options it just defers to
	   * CodeMirror.setOption, but certain ones are maintained within the editor
	   * instance.
	   */
	  setOption: function (o, v) {
	    let cm = editors.get(this);

	    // Save the state of a valid autoCloseBrackets string, so we can reset
	    // it if it gets preffed off and back on.
	    if (o === "autoCloseBrackets" && v) {
	      this.config.autoCloseBracketsSaved = v;
	    }

	    if (o === "autocomplete") {
	      this.config.autocomplete = v;
	      this.setupAutoCompletion();
	    } else {
	      cm.setOption(o, v);
	      this.config[o] = v;
	    }

	    if (o === "enableCodeFolding") {
	      // The new value maybe explicitly force foldGUtter on or off, ignoring
	      // the prefs service.
	      this.updateCodeFoldingGutter();
	    }
	  },

	  /**
	   * Gets an option for the editor.  For most options it just defers to
	   * CodeMirror.getOption, but certain ones are maintained within the editor
	   * instance.
	   */
	  getOption: function (o) {
	    let cm = editors.get(this);
	    if (o === "autocomplete") {
	      return this.config.autocomplete;
	    } else {
	      return cm.getOption(o);
	    }
	  },

	  /**
	   * Sets up autocompletion for the editor. Lazily imports the required
	   * dependencies because they vary by editor mode.
	   *
	   * Autocompletion is special, because we don't want to automatically use
	   * it just because it is preffed on (it still needs to be requested by the
	   * editor), but we do want to always disable it if it is preffed off.
	   */
	  setupAutoCompletion: function () {
	    // The autocomplete module will overwrite this.initializeAutoCompletion
	    // with a mode specific autocompletion handler.
	    if (!this.initializeAutoCompletion) {
	      this.extend(__webpack_require__(41));
	    }

	    if (this.config.autocomplete && Services.prefs.getBoolPref(AUTOCOMPLETE)) {
	      this.initializeAutoCompletion(this.config.autocompleteOpts);
	    } else {
	      this.destroyAutoCompletion();
	    }
	  },

	  /**
	   * Extends an instance of the Editor object with additional
	   * functions. Each function will be called with context as
	   * the first argument. Context is a {ed, cm} object where
	   * 'ed' is an instance of the Editor object and 'cm' is an
	   * instance of the CodeMirror object. Example:
	   *
	   * function hello(ctx, name) {
	   *   let { cm, ed } = ctx;
	   *   cm;   // CodeMirror instance
	   *   ed;   // Editor instance
	   *   name; // 'Mozilla'
	   * }
	   *
	   * editor.extend({ hello: hello });
	   * editor.hello('Mozilla');
	   */
	  extend: function (funcs) {
	    var _this4 = this;

	    Object.keys(funcs).forEach(function (name) {
	      let cm = editors.get(_this4);
	      let ctx = { ed: _this4, cm: cm, Editor: Editor };

	      if (name === "initialize") {
	        funcs[name](ctx);
	        return;
	      }

	      _this4[name] = funcs[name].bind(null, ctx);
	    });
	  },

	  destroy: function () {
	    this.container = null;
	    this.config = null;
	    this.version = null;

	    if (this._prefObserver) {
	      this._prefObserver.off(TAB_SIZE, this.reloadPreferences);
	      this._prefObserver.off(EXPAND_TAB, this.reloadPreferences);
	      this._prefObserver.off(KEYMAP, this.reloadPreferences);
	      this._prefObserver.off(AUTO_CLOSE, this.reloadPreferences);
	      this._prefObserver.off(AUTOCOMPLETE, this.reloadPreferences);
	      this._prefObserver.off(DETECT_INDENT, this.reloadPreferences);
	      this._prefObserver.off(ENABLE_CODE_FOLDING, this.reloadPreferences);
	      this._prefObserver.destroy();
	    }

	    this.emit("destroy");
	  },

	  updateCodeFoldingGutter: function () {
	    let shouldFoldGutter = this.config.enableCodeFolding,
	        foldGutterIndex = this.config.gutters.indexOf("CodeMirror-foldgutter"),
	        cm = editors.get(this);

	    if (shouldFoldGutter === undefined) {
	      shouldFoldGutter = Services.prefs.getBoolPref(ENABLE_CODE_FOLDING);
	    }

	    if (shouldFoldGutter) {
	      // Add the gutter before enabling foldGutter
	      if (foldGutterIndex === -1) {
	        let gutters = this.config.gutters.slice();
	        gutters.push("CodeMirror-foldgutter");
	        this.setOption("gutters", gutters);
	      }

	      this.setOption("foldGutter", true);
	    } else {
	      // No code should remain folded when folding is off.
	      if (cm) {
	        cm.execCommand("unfoldAll");
	      }

	      // Remove the gutter so it doesn't take up space
	      if (foldGutterIndex !== -1) {
	        let gutters = this.config.gutters.slice();
	        gutters.splice(foldGutterIndex, 1);
	        this.setOption("gutters", gutters);
	      }

	      this.setOption("foldGutter", false);
	    }
	  }
	};

	// Since Editor is a thin layer over CodeMirror some methods
	// are mapped directly—without any changes.

	CM_MAPPING.forEach(function (name) {
	  Editor.prototype[name] = function (...args) {
	    let cm = editors.get(this);
	    return cm[name].apply(cm, args);
	  };
	});

	// Static methods on the Editor object itself.

	/**
	 * Returns a string representation of a shortcut 'key' with
	 * a OS specific modifier. Cmd- for Macs, Ctrl- for other
	 * platforms. Useful with extraKeys configuration option.
	 *
	 * CodeMirror defines all keys with modifiers in the following
	 * order: Shift - Ctrl/Cmd - Alt - Key
	 */
	Editor.accel = function (key, modifiers = {}) {
	  return (modifiers.shift ? "Shift-" : "") + (Services.appinfo.OS == "Darwin" ? "Cmd-" : "Ctrl-") + (modifiers.alt ? "Alt-" : "") + key;
	};

	/**
	 * Returns a string representation of a shortcut for a
	 * specified command 'cmd'. Append Cmd- for macs, Ctrl- for other
	 * platforms unless noaccel is specified in the options. Useful when overwriting
	 * or disabling default shortcuts.
	 */
	Editor.keyFor = function (cmd, opts = { noaccel: false }) {
	  let key = L10N.GetStringFromName(cmd + ".commandkey");
	  return opts.noaccel ? key : Editor.accel(key);
	};

	// Since Gecko already provide complete and up to date list of CSS property
	// names, values and color names, we compute them so that they can replace
	// the ones used in CodeMirror while initiating an editor object. This is done
	// here instead of the file codemirror/css.js so as to leave that file untouched
	// and easily upgradable.
	function getCSSKeywords() {
	  return {
	    cssProperties: {},
	    cssValues: {},
	    cssColors: {}
	  };
	  function keySet(array) {
	    var keys = {};
	    for (var i = 0; i < array.length; ++i) {
	      keys[array[i]] = true;
	    }
	    return keys;
	  }

	  let domUtils = Cc("@mozilla.org/inspector/dom-utils;1").getService(Ci.inIDOMUtils);
	  let cssProperties = domUtils.getCSSPropertyNames(domUtils.INCLUDE_ALIASES);
	  let cssColors = {};
	  let cssValues = {};
	  cssProperties.forEach(function (property) {
	    if (property.includes("color")) {
	      domUtils.getCSSValuesForProperty(property).forEach(function (value) {
	        cssColors[value] = true;
	      });
	    } else {
	      domUtils.getCSSValuesForProperty(property).forEach(function (value) {
	        cssValues[value] = true;
	      });
	    }
	  });
	  return {
	    cssProperties: keySet(cssProperties),
	    cssValues: cssValues,
	    cssColors: cssColors
	  };
	}

	/**
	 * Returns a controller object that can be used for
	 * editor-specific commands such as find, jump to line,
	 * copy/paste, etc.
	 */
	function controller(ed) {
	  return {
	    supportsCommand: function (cmd) {
	      switch (cmd) {
	        case "cmd_find":
	        case "cmd_findAgain":
	        case "cmd_findPrevious":
	        case "cmd_gotoLine":
	        case "cmd_undo":
	        case "cmd_redo":
	        case "cmd_delete":
	        case "cmd_selectAll":
	          return true;
	      }

	      return false;
	    },

	    isCommandEnabled: function (cmd) {
	      let cm = editors.get(ed);

	      switch (cmd) {
	        case "cmd_find":
	        case "cmd_gotoLine":
	        case "cmd_selectAll":
	          return true;
	        case "cmd_findAgain":
	          return cm.state.search != null && cm.state.search.query != null;
	        case "cmd_undo":
	          return ed.canUndo();
	        case "cmd_redo":
	          return ed.canRedo();
	        case "cmd_delete":
	          return ed.somethingSelected();
	      }

	      return false;
	    },

	    doCommand: function (cmd) {
	      let cm = editors.get(ed);
	      let map = {
	        "cmd_selectAll": "selectAll",
	        "cmd_find": "find",
	        "cmd_undo": "undo",
	        "cmd_redo": "redo",
	        "cmd_delete": "delCharAfter",
	        "cmd_findAgain": "findNext"
	      };

	      if (map[cmd]) {
	        cm.execCommand(map[cmd]);
	        return;
	      }

	      if (cmd == "cmd_gotoLine") ed.jumpToLine();
	    },

	    onEvent: function () {}
	  };
	}

	module.exports = Editor;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2; fill-column: 80 -*- */
	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	const EXPAND_TAB = "devtools.editor.expandtab";
	const TAB_SIZE = "devtools.editor.tabsize";
	const DETECT_INDENT = "devtools.editor.detectindentation";
	const DETECT_INDENT_MAX_LINES = 500;

	/**
	 * Get the indentation to use in an editor, or return false if the user has
	 * asked for the indentation to be guessed from some text.
	 *
	 * @return {false | Object}
	 *        Returns false if the "detect indentation" pref is set.
	 *        an object of the form {indentUnit, indentWithTabs}.
	 *        |indentUnit| is the number of indentation units to use
	 *        to indent a "block".
	 *        |indentWithTabs| is a boolean which is true if indentation
	 *        should be done using tabs.
	 */
	function getIndentationFromPrefs() {
	  let shouldDetect = Services.prefs.getBoolPref(DETECT_INDENT);
	  if (shouldDetect) {
	    return false;
	  }

	  let indentWithTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
	  let indentUnit = Services.prefs.getIntPref(TAB_SIZE);
	  return { indentUnit, indentWithTabs };
	}

	/**
	 * Given a function that can iterate over some text, compute the indentation to
	 * use.  This consults various prefs to arrive at a decision.
	 *
	 * @param {Function} iterFunc A function of three arguments:
	 *        (start, end, callback); where |start| and |end| describe
	 *        the range of text lines to examine, and |callback| is a function
	 *        to be called with the text of each line.
	 *
	 * @return {Object} an object of the form {indentUnit, indentWithTabs}.
	 *        |indentUnit| is the number of indentation units to use
	 *        to indent a "block".
	 *        |indentWithTabs| is a boolean which is true if indentation
	 *        should be done using tabs.
	 */
	function getIndentationFromIteration(iterFunc) {
	  let indentWithTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
	  let indentUnit = Services.prefs.getIntPref(TAB_SIZE);
	  let shouldDetect = Services.prefs.getBoolPref(DETECT_INDENT);

	  if (shouldDetect) {
	    let indent = detectIndentation(iterFunc);
	    if (indent != null) {
	      indentWithTabs = indent.tabs;
	      indentUnit = indent.spaces ? indent.spaces : indentUnit;
	    }
	  }

	  return { indentUnit, indentWithTabs };
	}

	/**
	 * A wrapper for @see getIndentationFromIteration which computes the
	 * indentation of a given string.
	 *
	 * @param {String} string the input text
	 * @return {Object} an object of the same form as returned by
	 *                  getIndentationFromIteration
	 */
	function getIndentationFromString(string) {
	  let iteratorFn = function (start, end, callback) {
	    let split = string.split(/\r\n|\r|\n|\f/);
	    split.slice(start, end).forEach(callback);
	  };
	  return getIndentationFromIteration(iteratorFn);
	}

	/**
	 * Detect the indentation used in an editor. Returns an object
	 * with 'tabs' - whether this is tab-indented and 'spaces' - the
	 * width of one indent in spaces. Or `null` if it's inconclusive.
	 */
	function detectIndentation(textIteratorFn) {
	  // # spaces indent -> # lines with that indent
	  let spaces = {};
	  // indentation width of the last line we saw
	  let last = 0;
	  // # of lines that start with a tab
	  let tabs = 0;
	  // # of indented lines (non-zero indent)
	  let total = 0;

	  textIteratorFn(0, DETECT_INDENT_MAX_LINES, function (text) {
	    if (text.startsWith("\t")) {
	      tabs++;
	      total++;
	      return;
	    }
	    let width = 0;
	    while (text[width] === " ") {
	      width++;
	    }
	    // don't count lines that are all spaces
	    if (width == text.length) {
	      last = 0;
	      return;
	    }
	    if (width > 1) {
	      total++;
	    }

	    // see how much this line is offset from the line above it
	    let indent = Math.abs(width - last);
	    if (indent > 1 && indent <= 8) {
	      spaces[indent] = (spaces[indent] || 0) + 1;
	    }
	    last = width;
	  });

	  // this file is not indented at all
	  if (total == 0) {
	    return null;
	  }

	  // mark as tabs if they start more than half the lines
	  if (tabs >= total / 2) {
	    return { tabs: true };
	  }

	  // find most frequent non-zero width difference between adjacent lines
	  let freqIndent = null,
	      max = 1;
	  for (let width in spaces) {
	    width = parseInt(width, 10);
	    let tally = spaces[width];
	    if (tally > max) {
	      max = tally;
	      freqIndent = width;
	    }
	  }
	  if (!freqIndent) {
	    return null;
	  }

	  return { tabs: false, spaces: freqIndent };
	}

	exports.EXPAND_TAB = EXPAND_TAB;
	exports.TAB_SIZE = TAB_SIZE;
	exports.DETECT_INDENT = DETECT_INDENT;
	exports.getIndentationFromPrefs = getIndentationFromPrefs;
	exports.getIndentationFromIteration = getIndentationFromIteration;
	exports.getIndentationFromString = getIndentationFromString;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var promise = __webpack_require__(6);

	/**
	 * This module implements a subset of "Task.js" <http://taskjs.org/>.
	 *
	 * Paraphrasing from the Task.js site, tasks make sequential, asynchronous
	 * operations simple, using the power of JavaScript's "yield" operator.
	 *
	 * Tasks are built upon generator functions and promises, documented here:
	 *
	 * <https://developer.mozilla.org/en/JavaScript/Guide/Iterators_and_Generators>
	 * <http://wiki.commonjs.org/wiki/Promises/A>
	 *
	 * The "Task.spawn" function takes a generator function and starts running it as
	 * a task.  Every time the task yields a promise, it waits until the promise is
	 * fulfilled.  "Task.spawn" returns a promise that is resolved when the task
	 * completes successfully, or is rejected if an exception occurs.
	 *
	 * -----------------------------------------------------------------------------
	 *
	 * Cu.import("resource://gre/modules/Task.jsm");
	 *
	 * Task.spawn(function* () {
	 *
	 *   // This is our task. Let's create a promise object, wait on it and capture
	 *   // its resolution value.
	 *   let myPromise = getPromiseResolvedOnTimeoutWithValue(1000, "Value");
	 *   let result = yield myPromise;
	 *
	 *   // This part is executed only after the promise above is fulfilled (after
	 *   // one second, in this imaginary example).  We can easily loop while
	 *   // calling asynchronous functions, and wait multiple times.
	 *   for (let i = 0; i < 3; i++) {
	 *     result += yield getPromiseResolvedOnTimeoutWithValue(50, "!");
	 *   }
	 *
	 *   return "Resolution result for the task: " + result;
	 * }).then(function (result) {
	 *
	 *   // result == "Resolution result for the task: Value!!!"
	 *
	 *   // The result is undefined if no value was returned.
	 *
	 * }, function (exception) {
	 *
	 *   // Failure!  We can inspect or report the exception.
	 *
	 * });
	 *
	 * -----------------------------------------------------------------------------
	 *
	 * This module implements only the "Task.js" interfaces described above, with no
	 * additional features to control the task externally, or do custom scheduling.
	 * It also provides the following extensions that simplify task usage in the
	 * most common cases:
	 *
	 * - The "Task.spawn" function also accepts an iterator returned by a generator
	 *   function, in addition to a generator function.  This way, you can call into
	 *   the generator function with the parameters you want, and with "this" bound
	 *   to the correct value.  Also, "this" is never bound to the task object when
	 *   "Task.spawn" calls the generator function.
	 *
	 * - In addition to a promise object, a task can yield the iterator returned by
	 *   a generator function.  The iterator is turned into a task automatically.
	 *   This reduces the syntax overhead of calling "Task.spawn" explicitly when
	 *   you want to recurse into other task functions.
	 *
	 * - The "Task.spawn" function also accepts a primitive value, or a function
	 *   returning a primitive value, and treats the value as the result of the
	 *   task.  This makes it possible to call an externally provided function and
	 *   spawn a task from it, regardless of whether it is an asynchronous generator
	 *   or a synchronous function.  This comes in handy when iterating over
	 *   function lists where some items have been converted to tasks and some not.
	 */

	////////////////////////////////////////////////////////////////////////////////
	//// Globals

	// The following error types are considered programmer errors, which should be
	// reported (possibly redundantly) so as to let programmers fix their code.
	const ERRORS_TO_REPORT = ["EvalError", "RangeError", "ReferenceError", "TypeError"];

	/**
	 * The Task currently being executed
	 */
	var gCurrentTask = null;

	/**
	 * If `true`, capture stacks whenever entering a Task and rewrite the
	 * stack any exception thrown through a Task.
	 */
	var gMaintainStack = false;

	/**
	 * Iterate through the lines of a string.
	 *
	 * @return Iterator<string>
	 */
	function* linesOf(string) {
	  let reLine = /([^\r\n])+/g;
	  let match;
	  while (match = reLine.exec(string)) {
	    yield [match[0], match.index];
	  }
	};

	/**
	 * Detect whether a value is a generator.
	 *
	 * @param aValue
	 *        The value to identify.
	 * @return A boolean indicating whether the value is a generator.
	 */
	function isGenerator(aValue) {
	  return Object.prototype.toString.call(aValue) == "[object Generator]";
	}

	////////////////////////////////////////////////////////////////////////////////
	//// Task

	/**
	 * This object provides the public module functions.
	 */
	let Task = {
	  /**
	   * Creates and starts a new task.
	   *
	   * @param aTask
	   *        - If you specify a generator function, it is called with no
	   *          arguments to retrieve the associated iterator.  The generator
	   *          function is a task, that is can yield promise objects to wait
	   *          upon.
	   *        - If you specify the iterator returned by a generator function you
	   *          called, the generator function is also executed as a task.  This
	   *          allows you to call the function with arguments.
	   *        - If you specify a function that is not a generator, it is called
	   *          with no arguments, and its return value is used to resolve the
	   *          returned promise.
	   *        - If you specify anything else, you get a promise that is already
	   *          resolved with the specified value.
	   *
	   * @return A promise object where you can register completion callbacks to be
	   *         called when the task terminates.
	   */
	  spawn: function Task_spawn(aTask) {
	    return createAsyncFunction(aTask).call(undefined);
	  },

	  /**
	   * Create and return an 'async function' that starts a new task.
	   *
	   * This is similar to 'spawn' except that it doesn't immediately start
	   * the task, it binds the task to the async function's 'this' object and
	   * arguments, and it requires the task to be a function.
	   *
	   * It simplifies the common pattern of implementing a method via a task,
	   * like this simple object with a 'greet' method that has a 'name' parameter
	   * and spawns a task to send a greeting and return its reply:
	   *
	   * let greeter = {
	   *   message: "Hello, NAME!",
	   *   greet: function(name) {
	   *     return Task.spawn((function* () {
	   *       return yield sendGreeting(this.message.replace(/NAME/, name));
	   *     }).bind(this);
	   *   })
	   * };
	   *
	   * With Task.async, the method can be declared succinctly:
	   *
	   * let greeter = {
	   *   message: "Hello, NAME!",
	   *   greet: Task.async(function* (name) {
	   *     return yield sendGreeting(this.message.replace(/NAME/, name));
	   *   })
	   * };
	   *
	   * While maintaining identical semantics:
	   *
	   * greeter.greet("Mitchell").then((reply) => { ... }); // behaves the same
	   *
	   * @param aTask
	   *        The task function to start.
	   *
	   * @return A function that starts the task function and returns its promise.
	   */
	  async: function Task_async(aTask) {
	    if (typeof aTask != "function") {
	      throw new TypeError("aTask argument must be a function");
	    }

	    return createAsyncFunction(aTask);
	  },

	  /**
	   * Constructs a special exception that, when thrown inside a legacy generator
	   * function (non-star generator), allows the associated task to be resolved
	   * with a specific value.
	   *
	   * Example: throw new Task.Result("Value");
	   */
	  Result: function Task_Result(aValue) {
	    this.value = aValue;
	  }
	};

	function createAsyncFunction(aTask) {
	  let asyncFunction = function () {
	    let result = aTask;
	    if (aTask && typeof aTask == "function") {
	      if (aTask.isAsyncFunction) {
	        throw new TypeError("Cannot use an async function in place of a promise. " + "You should either invoke the async function first " + "or use 'Task.spawn' instead of 'Task.async' to start " + "the Task and return its promise.");
	      }

	      try {
	        // Let's call into the function ourselves.
	        result = aTask.apply(this, arguments);
	      } catch (ex) {
	        if (ex instanceof Task.Result) {
	          return promise.resolve(ex.value);
	        }
	        return promise.reject(ex);
	      }
	    }

	    if (isGenerator(result)) {
	      // This is an iterator resulting from calling a generator function.
	      return new TaskImpl(result).deferred.promise;
	    }

	    // Just propagate the given value to the caller as a resolved promise.
	    return promise.resolve(result);
	  };

	  asyncFunction.isAsyncFunction = true;

	  return asyncFunction;
	}

	////////////////////////////////////////////////////////////////////////////////
	//// TaskImpl

	/**
	 * Executes the specified iterator as a task, and gives access to the promise
	 * that is fulfilled when the task terminates.
	 */
	function TaskImpl(iterator) {
	  if (gMaintainStack) {
	    this._stack = new Error().stack;
	  }
	  this.deferred = promise.defer();
	  this._iterator = iterator;
	  this._isStarGenerator = !("send" in iterator);
	  this._run(true);
	}

	TaskImpl.prototype = {
	  /**
	   * Includes the promise object where task completion callbacks are registered,
	   * and methods to resolve or reject the promise at task completion.
	   */
	  deferred: null,

	  /**
	   * The iterator returned by the generator function associated with this task.
	   */
	  _iterator: null,

	  /**
	   * Whether this Task is using a star generator.
	   */
	  _isStarGenerator: false,

	  /**
	   * Main execution routine, that calls into the generator function.
	   *
	   * @param aSendResolved
	   *        If true, indicates that we should continue into the generator
	   *        function regularly (if we were waiting on a promise, it was
	   *        resolved). If true, indicates that we should cause an exception to
	   *        be thrown into the generator function (if we were waiting on a
	   *        promise, it was rejected).
	   * @param aSendValue
	   *        Resolution result or rejection exception, if any.
	   */
	  _run: function TaskImpl_run(aSendResolved, aSendValue) {

	    try {
	      gCurrentTask = this;

	      if (this._isStarGenerator) {
	        try {
	          let result = aSendResolved ? this._iterator.next(aSendValue) : this._iterator.throw(aSendValue);

	          if (result.done) {
	            // The generator function returned.
	            this.deferred.resolve(result.value);
	          } else {
	            // The generator function yielded.
	            this._handleResultValue(result.value);
	          }
	        } catch (ex) {
	          // The generator function failed with an uncaught exception.
	          this._handleException(ex);
	        }
	      } else {
	        try {
	          let yielded = aSendResolved ? this._iterator.send(aSendValue) : this._iterator.throw(aSendValue);
	          this._handleResultValue(yielded);
	        } catch (ex) {
	          if (ex instanceof Task.Result) {
	            // The generator function threw the special exception that allows it to
	            // return a specific value on resolution.
	            return this.deferred.resolve(ex.value);
	          }
	          if (ex instanceof StopIteration) {
	            // The generator function terminated with no specific result.
	            this.deferred.resolve(undefined);
	          }
	          // The generator function failed with an uncaught exception.
	          this._handleException(ex);
	        }
	      }
	    } finally {
	      //
	      // At this stage, the Task may have finished executing, or have
	      // walked through a `yield` or passed control to a sub-Task.
	      // Regardless, if we still own `gCurrentTask`, reset it. If we
	      // have not finished execution of this Task, re-entering `_run`
	      // will set `gCurrentTask` to `this` as needed.
	      //
	      // We just need to be careful here in case we hit the following
	      // pattern:
	      //
	      //   Task.spawn(foo);
	      //   Task.spawn(bar);
	      //
	      // Here, `foo` and `bar` may be interleaved, so when we finish
	      // executing `foo`, `gCurrentTask` may actually either `foo` or
	      // `bar`. If `gCurrentTask` has already been set to `bar`, leave
	      // it be and it will be reset to `null` once `bar` is complete.
	      //
	      if (gCurrentTask == this) {
	        gCurrentTask = null;
	      }
	    }
	  },

	  /**
	   * Handle a value yielded by a generator.
	   *
	   * @param aValue
	   *        The yielded value to handle.
	   */
	  _handleResultValue: function TaskImpl_handleResultValue(aValue) {
	    // If our task yielded an iterator resulting from calling another
	    // generator function, automatically spawn a task from it, effectively
	    // turning it into a promise that is fulfilled on task completion.
	    if (isGenerator(aValue)) {
	      aValue = Task.spawn(aValue);
	    }

	    if (aValue && typeof aValue.then == "function") {
	      // We have a promise object now. When fulfilled, call again into this
	      // function to continue the task, with either a resolution or rejection
	      // condition.
	      aValue.then(this._run.bind(this, true), this._run.bind(this, false));
	    } else {
	      // If our task yielded a value that is not a promise, just continue and
	      // pass it directly as the result of the yield statement.
	      this._run(true, aValue);
	    }
	  },

	  /**
	   * Handle an uncaught exception thrown from a generator.
	   *
	   * @param aException
	   *        The uncaught exception to handle.
	   */
	  _handleException: function TaskImpl_handleException(aException) {

	    gCurrentTask = this;

	    if (aException && typeof aException == "object" && "stack" in aException) {

	      let stack = aException.stack;

	      if (gMaintainStack && aException._capturedTaskStack != this._stack && typeof stack == "string") {

	        // Rewrite the stack for more readability.

	        let bottomStack = this._stack;
	        let topStack = stack;

	        stack = Task.Debugging.generateReadableStack(stack);

	        aException.stack = stack;

	        // If aException is reinjected in the same task and rethrown,
	        // we don't want to perform the rewrite again.
	        aException._capturedTaskStack = bottomStack;
	      } else if (!stack) {
	        stack = "Not available";
	      }

	      if ("name" in aException && ERRORS_TO_REPORT.indexOf(aException.name) != -1) {

	        // We suspect that the exception is a programmer error, so we now
	        // display it using dump().  Note that we do not use Cu.reportError as
	        // we assume that this is a programming error, so we do not want end
	        // users to see it. Also, if the programmer handles errors correctly,
	        // they will either treat the error or log them somewhere.

	        dump("*************************\n");
	        dump("A coding exception was thrown and uncaught in a Task.\n\n");
	        dump("Full message: " + aException + "\n");
	        dump("Full stack: " + aException.stack + "\n");
	        dump("*************************\n");
	      }
	    }

	    this.deferred.reject(aException);
	  },

	  get callerStack() {
	    // Cut `this._stack` at the last line of the first block that
	    // contains Task.jsm, keep the tail.
	    for (let _ref of linesOf(this._stack || "")) {
	      var _ref2 = _slicedToArray(_ref, 2);

	      let line = _ref2[0];
	      let index = _ref2[1];

	      if (line.indexOf("/Task.jsm:") == -1) {
	        return this._stack.substring(index);
	      }
	    }
	    return "";
	  }
	};

	Task.Debugging = {

	  /**
	   * Control stack rewriting.
	   *
	   * If `true`, any exception thrown from a Task will be rewritten to
	   * provide a human-readable stack trace. Otherwise, stack traces will
	   * be left unchanged.
	   *
	   * There is a (small but existing) runtime cost associated to stack
	   * rewriting, so you should probably not activate this in production
	   * code.
	   *
	   * @type {bool}
	   */
	  get maintainStack() {
	    return gMaintainStack;
	  },
	  set maintainStack(x) {
	    if (!x) {
	      gCurrentTask = null;
	    }
	    return gMaintainStack = x;
	  },

	  /**
	   * Generate a human-readable stack for an error raised in
	   * a Task.
	   *
	   * @param {string} topStack The stack provided by the error.
	   * @param {string=} prefix Optionally, a prefix for each line.
	   */
	  generateReadableStack: function (topStack, prefix) {
	    if (!gCurrentTask) {
	      return topStack;
	    }
	    if (prefix === undefined) {
	      prefix = "";
	    }

	    // Cut `topStack` at the first line that contains Task.jsm, keep the head.
	    let lines = [];
	    for (let _ref3 of linesOf(topStack)) {
	      var _ref4 = _slicedToArray(_ref3, 1);

	      let line = _ref4[0];

	      if (line.indexOf("/Task.jsm:") != -1) {
	        break;
	      }
	      lines.push(prefix + line);
	    }
	    if (!prefix) {
	      lines.push(gCurrentTask.callerStack);
	    } else {
	      for (let _ref5 of linesOf(gCurrentTask.callerStack)) {
	        var _ref6 = _slicedToArray(_ref5, 1);

	        let line = _ref6[0];

	        lines.push(prefix + line);
	      }
	    }

	    return lines.join("\n");
	  }
	};

	exports.Task = Task;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;
	const Cr = _require.Cr;

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	const EventEmitter = __webpack_require__(7);

	exports.PREF_ORIG_SOURCES = "devtools.styleeditor.source-maps-enabled";

	/**
	 * A PreferenceObserver observes a pref branch for pref changes.
	 * It emits an event for each preference change.
	 */
	function PrefObserver(branchName) {
	  this.branchName = branchName;
	  this.branch = Services.prefs.getBranch(branchName);
	  this.branch.addObserver("", this, false);

	  EventEmitter.decorate(this);
	}

	exports.PrefObserver = PrefObserver;

	PrefObserver.prototype = {
	  observe: function (subject, topic, data) {
	    if (topic == "nsPref:changed") {
	      this.emit(this.branchName + data);
	    }
	  },

	  destroy: function () {
	    if (this.branch) {
	      this.branch.removeObserver('', this);
	    }
	  }
	};

/***/ },
/* 40 */
/***/ function(module, exports) {

	module.exports = {
	  "findCmd.promptTitle": "Find…",
	  "findCmd.promptMessage": "Search for:",
	  "gotoLineCmd.promptTitle": "Go to line…",
	  "gotoLineCmd.promptMessage": "Jump to line number:",
	  "annotation.breakpoint.title": "Breakpoint: %S",
	  "annotation.currentLine": "Current line",
	  "annotation.debugLocation.title": "Current step: %S",
	  "autocompletion.docsLink": "docs",
	  "autocompletion.notFound": "not found",
	  "jumpToLine.commandkey": "J",
	  "toggleComment.commandkey": "/",
	  "indentLess.commandkey": "[",
	  "indentMore.commandkey": "]",
	  "moveLineUp.commandkey": "Alt-Up",
	  "moveLineDown.commandkey": "Alt-Down",
	  "autocompletion.commandkey": "Space",
	  "showInformation2.commandkey": "Shift-Ctrl-Space",
	  "find.commandkey": "F",
	  "findAgain.commandkey": "G"
	}

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;

	const cssAutoCompleter = __webpack_require__(42);

	var _require2 = __webpack_require__(44);

	const AutocompletePopup = _require2.AutocompletePopup;

	const CM_TERN_SCRIPTS = ["chrome://devtools/content/sourceeditor/codemirror/tern/tern.js", "chrome://devtools/content/sourceeditor/codemirror/hint/show-hint.js"];

	const autocompleteMap = new WeakMap();

	// A simple way to give each popup its own panelId.
	var autocompleteCounter = 0;

	/**
	 * Prepares an editor instance for autocompletion.
	 */
	function initializeAutoCompletion(ctx, options = {}) {
	  let cm = ctx.cm;
	  let ed = ctx.ed;
	  let Editor = ctx.Editor;

	  if (autocompleteMap.has(ed)) {
	    return;
	  }

	  let win = ed.container.contentWindow.wrappedJSObject;
	  let CodeMirror = win.CodeMirror;
	  let document = win.document;

	  let completer = null;
	  let autocompleteKey = "Ctrl-" + Editor.keyFor("autocompletion", { noaccel: true });
	  if (ed.config.mode == Editor.modes.js) {
	    let defs = [__webpack_require__(45), __webpack_require__(46)];

	    CM_TERN_SCRIPTS.forEach(ed.loadScript, ed);
	    win.tern = __webpack_require__(47);
	    cm.tern = new CodeMirror.TernServer({
	      defs: defs,
	      typeTip: function (data) {
	        let tip = document.createElement("span");
	        tip.className = "CodeMirror-Tern-information";
	        let tipType = document.createElement("strong");
	        tipType.appendChild(document.createTextNode(data.type || cm.l10n("autocompletion.notFound")));
	        tip.appendChild(tipType);

	        if (data.doc) {
	          tip.appendChild(document.createTextNode(" — " + data.doc));
	        }

	        if (data.url) {
	          tip.appendChild(document.createTextNode(" "));
	          let docLink = document.createElement("a");
	          docLink.textContent = "[" + cm.l10n("autocompletion.docsLink") + "]";
	          docLink.href = data.url;
	          docLink.className = "theme-link";
	          docLink.setAttribute("target", "_blank");
	          tip.appendChild(docLink);
	        }

	        return tip;
	      }
	    });

	    let keyMap = {};
	    let updateArgHintsCallback = cm.tern.updateArgHints.bind(cm.tern, cm);
	    cm.on("cursorActivity", updateArgHintsCallback);

	    keyMap[autocompleteKey] = function (cm) {
	      cm.tern.getHint(cm, function (data) {
	        CodeMirror.on(data, "shown", function () {
	          return ed.emit("before-suggest");
	        });
	        CodeMirror.on(data, "close", function () {
	          return ed.emit("after-suggest");
	        });
	        CodeMirror.on(data, "select", function () {
	          return ed.emit("suggestion-entered");
	        });
	        CodeMirror.showHint(cm, function (cm, cb) {
	          return cb(data);
	        }, { async: true });
	      });
	    };

	    keyMap[Editor.keyFor("showInformation2", { noaccel: true })] = function (cm) {
	      cm.tern.showType(cm, null, function () {
	        ed.emit("show-information");
	      });
	    };
	    cm.addKeyMap(keyMap);

	    let destroyTern = function () {
	      ed.off("destroy", destroyTern);
	      cm.off("cursorActivity", updateArgHintsCallback);
	      cm.removeKeyMap(keyMap);
	      win.tern = cm.tern = null;
	      autocompleteMap.delete(ed);
	    };

	    ed.on("destroy", destroyTern);

	    autocompleteMap.set(ed, {
	      destroy: destroyTern
	    });

	    // TODO: Integrate tern autocompletion with this autocomplete API.
	    return;
	  } else if (ed.config.mode == Editor.modes.css) {
	    completer = new cssAutoCompleter({ walker: options.walker });
	  }

	  function insertSelectedPopupItem() {
	    let autocompleteState = autocompleteMap.get(ed);
	    if (!popup || !popup.isOpen || !autocompleteState) {
	      return;
	    }

	    if (!autocompleteState.suggestionInsertedOnce && popup.selectedItem) {
	      autocompleteMap.get(ed).insertingSuggestion = true;
	      insertPopupItem(ed, popup.selectedItem);
	    }

	    popup.hidePopup();
	    ed.emit("popup-hidden"); // This event is used in tests.
	    return true;
	  }

	  // Give each popup a new name to avoid sharing the elements.
	  let panelId = "devtools_sourceEditorCompletePopup" + autocompleteCounter;
	  ++autocompleteCounter;

	  let popup = new AutocompletePopup(win.parent.document, {
	    position: "after_start",
	    fixedWidth: true,
	    theme: "auto",
	    autoSelect: true,
	    onClick: insertSelectedPopupItem,
	    panelId: panelId
	  });

	  let cycle = function (reverse) {
	    if (popup && popup.isOpen) {
	      cycleSuggestions(ed, reverse == true);
	      return;
	    }

	    return CodeMirror.Pass;
	  };

	  let keyMap = {
	    "Tab": cycle,
	    "Down": cycle,
	    "Shift-Tab": cycle.bind(null, true),
	    "Up": cycle.bind(null, true),
	    "Enter": function () {
	      let wasHandled = insertSelectedPopupItem();
	      return wasHandled ? true : CodeMirror.Pass;
	    }
	  };
	  let autoCompleteCallback = autoComplete.bind(null, ctx);
	  let keypressCallback = onEditorKeypress.bind(null, ctx);
	  keyMap[autocompleteKey] = autoCompleteCallback;
	  cm.addKeyMap(keyMap);

	  cm.on("keydown", keypressCallback);
	  ed.on("change", autoCompleteCallback);
	  ed.on("destroy", destroy);

	  function destroy() {
	    ed.off("destroy", destroy);
	    cm.off("keydown", keypressCallback);
	    ed.off("change", autoCompleteCallback);
	    cm.removeKeyMap(keyMap);
	    popup.destroy();
	    keyMap = popup = completer = null;
	    autocompleteMap.delete(ed);
	  }

	  autocompleteMap.set(ed, {
	    popup: popup,
	    completer: completer,
	    keyMap: keyMap,
	    destroy: destroy,
	    insertingSuggestion: false,
	    suggestionInsertedOnce: false
	  });
	}

	/**
	 * Destroy autocompletion on an editor instance.
	 */
	function destroyAutoCompletion(ctx) {
	  let ed = ctx.ed;

	  if (!autocompleteMap.has(ed)) {
	    return;
	  }

	  var _autocompleteMap$get = autocompleteMap.get(ed);

	  let destroy = _autocompleteMap$get.destroy;

	  destroy();
	}

	/**
	 * Provides suggestions to autocomplete the current token/word being typed.
	 */
	function autoComplete({ ed, cm }) {
	  let priv = autocompleteMap.get(ed);
	  let completer = priv.completer;
	  let popup = priv.popup;

	  if (!completer || priv.insertingSuggestion || priv.doNotAutocomplete) {
	    priv.insertingSuggestion = false;
	    return;
	  }
	  let cur = ed.getCursor();
	  completer.complete(cm.getRange({ line: 0, ch: 0 }, cur), cur).then(function (suggestions) {
	    if (!suggestions || !suggestions.length || suggestions[0].preLabel == null) {
	      priv.suggestionInsertedOnce = false;
	      popup.hidePopup();
	      ed.emit("after-suggest");
	      return;
	    }
	    // The cursor is at the end of the currently entered part of the token, like
	    // "backgr|" but we need to open the popup at the beginning of the character
	    // "b". Thus we need to calculate the width of the entered part of the token
	    // ("backgr" here). 4 comes from the popup's left padding.

	    let cursorElement = cm.display.cursorDiv.querySelector(".CodeMirror-cursor");
	    let left = suggestions[0].preLabel.length * cm.defaultCharWidth() + 4;
	    popup.hidePopup();
	    popup.setItems(suggestions);
	    popup.openPopup(cursorElement, -1 * left, 0);
	    priv.suggestionInsertedOnce = false;
	    // This event is used in tests.
	    ed.emit("after-suggest");
	  }).then(null, Cu.reportError);
	}

	/**
	 * Inserts a popup item into the current cursor location
	 * in the editor.
	 */
	function insertPopupItem(ed, popupItem) {
	  let label = popupItem.label;
	  let preLabel = popupItem.preLabel;
	  let text = popupItem.text;

	  let cur = ed.getCursor();
	  let textBeforeCursor = ed.getText(cur.line).substring(0, cur.ch);
	  let backwardsTextBeforeCursor = textBeforeCursor.split("").reverse().join("");
	  let backwardsPreLabel = preLabel.split("").reverse().join("");

	  // If there is additional text in the preLabel vs the line, then
	  // just insert the entire autocomplete text.  An example:
	  // if you type 'a' and select '#about' from the autocomplete menu,
	  // then the final text needs to the end up as '#about'.
	  if (backwardsPreLabel.indexOf(backwardsTextBeforeCursor) === 0) {
	    ed.replaceText(text, { line: cur.line, ch: 0 }, cur);
	  } else {
	    ed.replaceText(text.slice(preLabel.length), cur, cur);
	  }
	}

	/**
	 * Cycles through provided suggestions by the popup in a top to bottom manner
	 * when `reverse` is not true. Opposite otherwise.
	 */
	function cycleSuggestions(ed, reverse) {
	  let priv = autocompleteMap.get(ed);
	  let popup = priv.popup;
	  let completer = priv.completer;

	  let cur = ed.getCursor();
	  priv.insertingSuggestion = true;
	  if (!priv.suggestionInsertedOnce) {
	    priv.suggestionInsertedOnce = true;
	    let firstItem;
	    if (reverse) {
	      firstItem = popup.getItemAtIndex(popup.itemCount - 1);
	      popup.selectPreviousItem();
	    } else {
	      firstItem = popup.getItemAtIndex(0);
	      if (firstItem.label == firstItem.preLabel && popup.itemCount > 1) {
	        firstItem = popup.getItemAtIndex(1);
	        popup.selectNextItem();
	      }
	    }
	    if (popup.itemCount == 1) popup.hidePopup();
	    insertPopupItem(ed, firstItem);
	  } else {
	    let fromCur = {
	      line: cur.line,
	      ch: cur.ch - popup.selectedItem.text.length
	    };
	    if (reverse) popup.selectPreviousItem();else popup.selectNextItem();
	    ed.replaceText(popup.selectedItem.text, fromCur, cur);
	  }
	  // This event is used in tests.
	  ed.emit("suggestion-entered");
	}

	/**
	 * onkeydown handler for the editor instance to prevent autocompleting on some
	 * keypresses.
	 */
	function onEditorKeypress({ ed, Editor }, cm, event) {
	  let priv = autocompleteMap.get(ed);

	  // Do not try to autocomplete with multiple selections.
	  if (ed.hasMultipleSelections()) {
	    priv.doNotAutocomplete = true;
	    priv.popup.hidePopup();
	    return;
	  }

	  if ((event.ctrlKey || event.metaKey) && event.keyCode == event.DOM_VK_SPACE) {
	    // When Ctrl/Cmd + Space is pressed, two simultaneous keypresses are emitted
	    // first one for just the Ctrl/Cmd and second one for combo. The first one
	    // leave the priv.doNotAutocomplete as true, so we have to make it false
	    priv.doNotAutocomplete = false;
	    return;
	  }

	  if (event.ctrlKey || event.metaKey || event.altKey) {
	    priv.doNotAutocomplete = true;
	    priv.popup.hidePopup();
	    return;
	  }

	  switch (event.keyCode) {
	    case event.DOM_VK_RETURN:
	      priv.doNotAutocomplete = true;
	      break;

	    case event.DOM_VK_ESCAPE:
	      if (priv.popup.isOpen) event.preventDefault();
	    case event.DOM_VK_LEFT:
	    case event.DOM_VK_RIGHT:
	    case event.DOM_VK_HOME:
	    case event.DOM_VK_END:
	      priv.doNotAutocomplete = true;
	      priv.popup.hidePopup();
	      break;

	    case event.DOM_VK_BACK_SPACE:
	    case event.DOM_VK_DELETE:
	      if (ed.config.mode == Editor.modes.css) priv.completer.invalidateCache(ed.getCursor().line);
	      priv.doNotAutocomplete = true;
	      priv.popup.hidePopup();
	      break;

	    default:
	      priv.doNotAutocomplete = false;
	  }
	}

	/**
	 * Returns the private popup. This method is used by tests to test the feature.
	 */
	function getPopup({ ed }) {
	  if (autocompleteMap.has(ed)) return autocompleteMap.get(ed).popup;

	  return null;
	}

	/**
	 * Returns contextual information about the token covered by the caret if the
	 * implementation of completer supports it.
	 */
	function getInfoAt({ ed }, caret) {
	  let completer = autocompleteMap.get(ed).completer;
	  if (completer && completer.getInfoAt) return completer.getInfoAt(ed.getText(), caret);

	  return null;
	}

	/**
	 * Returns whether autocompletion is enabled for this editor.
	 * Used for testing
	 */
	function isAutocompletionEnabled({ ed }) {
	  return autocompleteMap.has(ed);
	}

	// Export functions

	module.exports.initializeAutoCompletion = initializeAutoCompletion;
	module.exports.destroyAutoCompletion = destroyAutoCompletion;
	module.exports.getAutocompletionPopup = getPopup;
	module.exports.getInfoAt = getInfoAt;
	module.exports.isAutocompletionEnabled = isAutocompletionEnabled;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	var _require2 = __webpack_require__(43);

	const cssTokenizer = _require2.cssTokenizer;
	const cssTokenizerWithLineColumn = _require2.cssTokenizerWithLineColumn;

	/**
	 * Here is what this file (+ css-parsing-utils.js) do.
	 *
	 * The main objective here is to provide as much suggestions to the user editing
	 * a stylesheet in Style Editor. The possible things that can be suggested are:
	 *  - CSS property names
	 *  - CSS property values
	 *  - CSS Selectors
	 *  - Some other known CSS keywords
	 *
	 * Gecko provides a list of both property names and their corresponding values.
	 * We take out a list of matching selectors using the Inspector actor's
	 * `getSuggestionsForQuery` method. Now the only thing is to parse the CSS being
	 * edited by the user, figure out what token or word is being written and last
	 * but the most difficult, what is being edited.
	 *
	 * The file 'css-parsing-utils' helps to convert the CSS into meaningful tokens,
	 * each having a certain type associated with it. These tokens help us to figure
	 * out the currently edited word and to write a CSS state machine to figure out
	 * what the user is currently editing. By that, I mean, whether he is editing a
	 * selector or a property or a value, or even fine grained information like an
	 * id in the selector.
	 *
	 * The `resolveState` method iterated over the tokens spitted out by the
	 * tokenizer, using switch cases, follows a state machine logic and finally
	 * figures out these informations:
	 *  - The state of the CSS at the cursor (one out of CSS_STATES)
	 *  - The current token that is being edited `cmpleting`
	 *  - If the state is "selector", the selector state (one of SELECTOR_STATES)
	 *  - If the state is "selector", the current selector till the cursor
	 *  - If the state is "value", the corresponding property name
	 *
	 * In case of "value" and "property" states, we simply use the information
	 * provided by Gecko to filter out the possible suggestions.
	 * For "selector" state, we request the Inspector actor to query the page DOM
	 * and filter out the possible suggestions.
	 * For "media" and "keyframes" state, the only possible suggestions for now are
	 * "media" and "keyframes" respectively, although "media" can have suggestions
	 * like "max-width", "orientation" etc. Similarly "value" state can also have
	 * much better logical suggestions if we fine grain identify a sub state just
	 * like we do for the "selector" state.
	 */

	// Autocompletion types.

	const CSS_STATES = {
	  "null": "null",
	  property: "property", // foo { bar|: … }
	  value: "value", // foo {bar: baz|}
	  selector: "selector", // f| {bar: baz}
	  media: "media", // @med| , or , @media scr| { }
	  keyframes: "keyframes", // @keyf|
	  frame: "frame" };

	// @keyframs foobar { t|
	const SELECTOR_STATES = {
	  "null": "null",
	  id: "id", // #f|
	  class: "class", // #foo.b|
	  tag: "tag", // fo|
	  pseudo: "pseudo", // foo:|
	  attribute: "attribute", // foo[b|
	  value: "value" };

	// foo[bar=b|

	var _getCSSKeywords = getCSSKeywords();

	const properties = _getCSSKeywords.properties;
	const propertyNames = _getCSSKeywords.propertyNames;

	/**
	 * Constructor for the autocompletion object.
	 *
	 * @param options {Object} An options object containing the following options:
	 *        - walker {Object} The object used for query selecting from the current
	 *                 target's DOM.
	 *        - maxEntries {Number} Maximum selectors suggestions to display.
	 */

	function CSSCompleter(options = {}) {
	  this.walker = options.walker;
	  this.maxEntries = options.maxEntries || 15;

	  // Array containing the [line, ch, scopeStack] for the locations where the
	  // CSS state is "null"
	  this.nullStates = [];
	}

	CSSCompleter.prototype = {

	  /**
	   * Returns a list of suggestions based on the caret position.
	   *
	   * @param source {String} String of the source code.
	   * @param caret {Object} Cursor location with line and ch properties.
	   *
	   * @returns [{object}] A sorted list of objects containing the following
	   *          peroperties:
	   *          - label {String} Full keyword for the suggestion
	   *          - preLabel {String} Already entered part of the label
	   */
	  complete: function (source, caret) {
	    // Getting the context from the caret position.
	    if (!this.resolveState(source, caret)) {
	      // We couldn't resolve the context, we won't be able to complete.
	      return Promise.resolve([]);
	    }

	    // Properly suggest based on the state.
	    switch (this.state) {
	      case CSS_STATES.property:
	        return this.completeProperties(this.completing);

	      case CSS_STATES.value:
	        return this.completeValues(this.propertyName, this.completing);

	      case CSS_STATES.selector:
	        return this.suggestSelectors();

	      case CSS_STATES.media:
	      case CSS_STATES.keyframes:
	        if ("media".startsWith(this.completing)) {
	          return Promise.resolve([{
	            label: "media",
	            preLabel: this.completing,
	            text: "media"
	          }]);
	        } else if ("keyframes".startsWith(this.completing)) {
	          return Promise.resolve([{
	            label: "keyframes",
	            preLabel: this.completing,
	            text: "keyframes"
	          }]);
	        }
	    }
	    return Promise.resolve([]);
	  },

	  /**
	   * Resolves the state of CSS at the cursor location. This method implements a
	   * custom written CSS state machine. The various switch statements provide the
	   * transition rules for the state. It also finds out various informatino about
	   * the nearby CSS like the property name being completed, the complete
	   * selector, etc.
	   *
	   * @param source {String} String of the source code.
	   * @param caret {Object} Cursor location with line and ch properties.
	   *
	   * @returns CSS_STATE
	   *          One of CSS_STATE enum or null if the state cannot be resolved.
	   */
	  resolveState: function (source, { line, ch }) {
	    // Function to return the last element of an array
	    let peek = function (arr) {
	      return arr[arr.length - 1];
	    };
	    // _state can be one of CSS_STATES;
	    let _state = CSS_STATES.null;
	    let selector = "";
	    let selectorState = SELECTOR_STATES.null;
	    let propertyName = null;
	    let scopeStack = [];
	    let selectors = [];

	    // Fetch the closest null state line, ch from cached null state locations
	    let matchedStateIndex = this.findNearestNullState(line);
	    if (matchedStateIndex > -1) {
	      let state = this.nullStates[matchedStateIndex];
	      line -= state[0];
	      if (line == 0) ch -= state[1];
	      source = source.split("\n").slice(state[0]);
	      source[0] = source[0].slice(state[1]);
	      source = source.join("\n");
	      scopeStack = [...state[2]];
	      this.nullStates.length = matchedStateIndex + 1;
	    } else {
	      this.nullStates = [];
	    }
	    let tokens = cssTokenizerWithLineColumn(source);
	    let tokIndex = tokens.length - 1;
	    if (tokIndex >= 0 && (tokens[tokIndex].loc.end.line < line || tokens[tokIndex].loc.end.line === line && tokens[tokIndex].loc.end.column < ch)) {
	      // If the last token ends before the cursor location, we didn't
	      // tokenize it correctly.  This special case can happen if the
	      // final token is a comment.
	      return null;
	    }

	    let cursor = 0;
	    // This will maintain a stack of paired elements like { & }, @m & }, : & ; etc
	    let token = null;
	    let selectorBeforeNot = null;
	    while (cursor <= tokIndex && (token = tokens[cursor++])) {
	      switch (_state) {
	        case CSS_STATES.property:
	          // From CSS_STATES.property, we can either go to CSS_STATES.value state
	          // when we hit the first ':' or CSS_STATES.selector if "}" is reached.
	          if (token.tokenType === "symbol") {
	            switch (token.text) {
	              case ":":
	                scopeStack.push(":");
	                if (tokens[cursor - 2].tokenType != "whitespace") propertyName = tokens[cursor - 2].text;else propertyName = tokens[cursor - 3].text;
	                _state = CSS_STATES.value;
	                break;

	              case "}":
	                if (/[{f]/.test(peek(scopeStack))) {
	                  let popped = scopeStack.pop();
	                  if (popped == "f") {
	                    _state = CSS_STATES.frame;
	                  } else {
	                    selector = "";
	                    selectors = [];
	                    _state = CSS_STATES.null;
	                  }
	                }
	                break;
	            }
	          }
	          break;

	        case CSS_STATES.value:
	          // From CSS_STATES.value, we can go to one of CSS_STATES.property,
	          // CSS_STATES.frame, CSS_STATES.selector and CSS_STATES.null
	          if (token.tokenType === "symbol") {
	            switch (token.text) {
	              case ";":
	                if (/[:]/.test(peek(scopeStack))) {
	                  scopeStack.pop();
	                  _state = CSS_STATES.property;
	                }
	                break;

	              case "}":
	                if (peek(scopeStack) == ":") scopeStack.pop();

	                if (/[{f]/.test(peek(scopeStack))) {
	                  let popped = scopeStack.pop();
	                  if (popped == "f") {
	                    _state = CSS_STATES.frame;
	                  } else {
	                    selector = "";
	                    selectors = [];
	                    _state = CSS_STATES.null;
	                  }
	                }
	                break;
	            }
	          }
	          break;

	        case CSS_STATES.selector:
	          // From CSS_STATES.selector, we can only go to CSS_STATES.property when
	          // we hit "{"
	          if (token.tokenType === "symbol" && token.text == "{") {
	            scopeStack.push("{");
	            _state = CSS_STATES.property;
	            selectors.push(selector);
	            selector = "";
	            break;
	          }
	          switch (selectorState) {
	            case SELECTOR_STATES.id:
	            case SELECTOR_STATES.class:
	            case SELECTOR_STATES.tag:
	              switch (token.tokenType) {
	                case "hash":
	                case "id":
	                  selectorState = SELECTOR_STATES.id;
	                  selector += "#" + token.text;
	                  break;

	                case "symbol":
	                  if (token.text == ".") {
	                    selectorState = SELECTOR_STATES.class;
	                    selector += ".";
	                    if (cursor <= tokIndex && tokens[cursor].tokenType == "ident") {
	                      token = tokens[cursor++];
	                      selector += token.text;
	                    }
	                  } else if (token.text == "#") {
	                    selectorState = SELECTOR_STATES.id;
	                    selector += "#";
	                  } else if (/[>~+]/.test(token.text)) {
	                    selectorState = SELECTOR_STATES.null;
	                    selector += token.text;
	                  } else if (token.text == ",") {
	                    selectorState = SELECTOR_STATES.null;
	                    selectors.push(selector);
	                    selector = "";
	                  } else if (token.text == ":") {
	                    selectorState = SELECTOR_STATES.pseudo;
	                    selector += ":";
	                    if (cursor > tokIndex) break;

	                    token = tokens[cursor++];
	                    switch (token.tokenType) {
	                      case "function":
	                        if (token.text == "not") {
	                          selectorBeforeNot = selector;
	                          selector = "";
	                          scopeStack.push("(");
	                        } else {
	                          selector += token.text + "(";
	                        }
	                        selectorState = SELECTOR_STATES.null;
	                        break;

	                      case "ident":
	                        selector += token.text;
	                        break;
	                    }
	                  } else if (token.text == "[") {
	                    selectorState = SELECTOR_STATES.attribute;
	                    scopeStack.push("[");
	                    selector += "[";
	                  } else if (token.text == ")") {
	                    if (peek(scopeStack) == "(") {
	                      scopeStack.pop();
	                      selector = selectorBeforeNot + "not(" + selector + ")";
	                      selectorBeforeNot = null;
	                    } else {
	                      selector += ")";
	                    }
	                    selectorState = SELECTOR_STATES.null;
	                  }
	                  break;

	                case "whitespace":
	                  selectorState = SELECTOR_STATES.null;
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.null:
	              // From SELECTOR_STATES.null state, we can go to one of
	              // SELECTOR_STATES.id, SELECTOR_STATES.class or SELECTOR_STATES.tag
	              switch (token.tokenType) {
	                case "hash":
	                case "id":
	                  selectorState = SELECTOR_STATES.id;
	                  selector += "#" + token.text;
	                  break;

	                case "ident":
	                  selectorState = SELECTOR_STATES.tag;
	                  selector += token.text;
	                  break;

	                case "symbol":
	                  if (token.text == ".") {
	                    selectorState = SELECTOR_STATES.class;
	                    selector += ".";
	                    if (cursor <= tokIndex && tokens[cursor].tokenType == "ident") {
	                      token = tokens[cursor++];
	                      selector += token.text;
	                    }
	                  } else if (token.text == "#") {
	                    selectorState = SELECTOR_STATES.id;
	                    selector += "#";
	                  } else if (token.text == "*") {
	                    selectorState = SELECTOR_STATES.tag;
	                    selector += "*";
	                  } else if (/[>~+]/.test(token.text)) {
	                    selector += token.text;
	                  } else if (token.text == ",") {
	                    selectorState = SELECTOR_STATES.null;
	                    selectors.push(selector);
	                    selector = "";
	                  } else if (token.text == ":") {
	                    selectorState = SELECTOR_STATES.pseudo;
	                    selector += ":";
	                    if (cursor > tokIndex) break;

	                    token = tokens[cursor++];
	                    switch (token.tokenType) {
	                      case "function":
	                        if (token.text == "not") {
	                          selectorBeforeNot = selector;
	                          selector = "";
	                          scopeStack.push("(");
	                        } else {
	                          selector += token.text + "(";
	                        }
	                        selectorState = SELECTOR_STATES.null;
	                        break;

	                      case "ident":
	                        selector += token.text;
	                        break;
	                    }
	                  } else if (token.text == "[") {
	                    selectorState = SELECTOR_STATES.attribute;
	                    scopeStack.push("[");
	                    selector += "[";
	                  } else if (token.text == ")") {
	                    if (peek(scopeStack) == "(") {
	                      scopeStack.pop();
	                      selector = selectorBeforeNot + "not(" + selector + ")";
	                      selectorBeforeNot = null;
	                    } else {
	                      selector += ")";
	                    }
	                    selectorState = SELECTOR_STATES.null;
	                  }
	                  break;

	                case "whitespace":
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.pseudo:
	              switch (token.tokenType) {
	                case "symbol":
	                  if (/[>~+]/.test(token.text)) {
	                    selectorState = SELECTOR_STATES.null;
	                    selector += token.text;
	                  } else if (token.text == ",") {
	                    selectorState = SELECTOR_STATES.null;
	                    selectors.push(selector);
	                    selector = "";
	                  } else if (token.text == ":") {
	                    selectorState = SELECTOR_STATES.pseudo;
	                    selector += ":";
	                    if (cursor > tokIndex) break;

	                    token = tokens[cursor++];
	                    switch (token.tokenType) {
	                      case "function":
	                        if (token.text == "not") {
	                          selectorBeforeNot = selector;
	                          selector = "";
	                          scopeStack.push("(");
	                        } else {
	                          selector += token.text + "(";
	                        }
	                        selectorState = SELECTOR_STATES.null;
	                        break;

	                      case "ident":
	                        selector += token.text;
	                        break;
	                    }
	                  } else if (token.text == "[") {
	                    selectorState = SELECTOR_STATES.attribute;
	                    scopeStack.push("[");
	                    selector += "[";
	                  }
	                  break;

	                case "whitespace":
	                  selectorState = SELECTOR_STATES.null;
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.attribute:
	              switch (token.tokenType) {
	                case "symbol":
	                  if (/[~|^$*]/.test(token.text)) {
	                    selector += token.text;
	                    token = tokens[cursor++];
	                  } else if (token.text == "=") {
	                    selectorState = SELECTOR_STATES.value;
	                    selector += token.text;
	                  } else if (token.text == "]") {
	                    if (peek(scopeStack) == "[") scopeStack.pop();

	                    selectorState = SELECTOR_STATES.null;
	                    selector += "]";
	                  }
	                  break;

	                case "ident":
	                case "string":
	                  selector += token.text;
	                  break;

	                case "whitespace":
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.value:
	              switch (token.tokenType) {
	                case "string":
	                case "ident":
	                  selector += token.text;
	                  break;

	                case "symbol":
	                  if (token.text == "]") {
	                    if (peek(scopeStack) == "[") scopeStack.pop();

	                    selectorState = SELECTOR_STATES.null;
	                    selector += "]";
	                  }
	                  break;

	                case "whitespace":
	                  selector && (selector += " ");
	                  break;
	              }
	              break;
	          }
	          break;

	        case CSS_STATES.null:
	          // From CSS_STATES.null state, we can go to either CSS_STATES.media or
	          // CSS_STATES.selector.
	          switch (token.tokenType) {
	            case "hash":
	            case "id":
	              selectorState = SELECTOR_STATES.id;
	              selector = "#" + token.text;
	              _state = CSS_STATES.selector;
	              break;

	            case "ident":
	              selectorState = SELECTOR_STATES.tag;
	              selector = token.text;
	              _state = CSS_STATES.selector;
	              break;

	            case "symbol":
	              if (token.text == ".") {
	                selectorState = SELECTOR_STATES.class;
	                selector = ".";
	                _state = CSS_STATES.selector;
	                if (cursor <= tokIndex && tokens[cursor].tokenType == "ident") {
	                  token = tokens[cursor++];
	                  selector += token.text;
	                }
	              } else if (token.text == "#") {
	                selectorState = SELECTOR_STATES.id;
	                selector = "#";
	                _state = CSS_STATES.selector;
	              } else if (token.text == "*") {
	                selectorState = SELECTOR_STATES.tag;
	                selector = "*";
	                _state = CSS_STATES.selector;
	              } else if (token.text == ":") {
	                _state = CSS_STATES.selector;
	                selectorState = SELECTOR_STATES.pseudo;
	                selector += ":";
	                if (cursor > tokIndex) break;

	                token = tokens[cursor++];
	                switch (token.tokenType) {
	                  case "function":
	                    if (token.text == "not") {
	                      selectorBeforeNot = selector;
	                      selector = "";
	                      scopeStack.push("(");
	                    } else {
	                      selector += token.text + "(";
	                    }
	                    selectorState = SELECTOR_STATES.null;
	                    break;

	                  case "ident":
	                    selector += token.text;
	                    break;
	                }
	              } else if (token.text == "[") {
	                _state = CSS_STATES.selector;
	                selectorState = SELECTOR_STATES.attribute;
	                scopeStack.push("[");
	                selector += "[";
	              } else if (token.text == "}") {
	                if (peek(scopeStack) == "@m") scopeStack.pop();
	              }
	              break;

	            case "at":
	              _state = token.text.startsWith("m") ? CSS_STATES.media : CSS_STATES.keyframes;
	              break;
	          }
	          break;

	        case CSS_STATES.media:
	          // From CSS_STATES.media, we can only go to CSS_STATES.null state when
	          // we hit the first '{'
	          if (token.tokenType == "symbol" && token.text == "{") {
	            scopeStack.push("@m");
	            _state = CSS_STATES.null;
	          }
	          break;

	        case CSS_STATES.keyframes:
	          // From CSS_STATES.keyframes, we can only go to CSS_STATES.frame state
	          // when we hit the first '{'
	          if (token.tokenType == "symbol" && token.text == "{") {
	            scopeStack.push("@k");
	            _state = CSS_STATES.frame;
	          }
	          break;

	        case CSS_STATES.frame:
	          // From CSS_STATES.frame, we can either go to CSS_STATES.property state
	          // when we hit the first '{' or to CSS_STATES.selector when we hit '}'
	          if (token.tokenType == "symbol") {
	            if (token.text == "{") {
	              scopeStack.push("f");
	              _state = CSS_STATES.property;
	            } else if (token.text == "}") {
	              if (peek(scopeStack) == "@k") scopeStack.pop();

	              _state = CSS_STATES.null;
	            }
	          }
	          break;
	      }
	      if (_state == CSS_STATES.null) {
	        if (this.nullStates.length == 0) {
	          this.nullStates.push([token.loc.end.line, token.loc.end.column, [...scopeStack]]);
	          continue;
	        }
	        let tokenLine = token.loc.end.line;
	        let tokenCh = token.loc.end.column;
	        if (tokenLine == 0) continue;
	        if (matchedStateIndex > -1) tokenLine += this.nullStates[matchedStateIndex][0];
	        this.nullStates.push([tokenLine, tokenCh, [...scopeStack]]);
	      }
	    }
	    this.state = _state;
	    this.propertyName = _state == CSS_STATES.value ? propertyName : null;
	    this.selectorState = _state == CSS_STATES.selector ? selectorState : null;
	    this.selectorBeforeNot = selectorBeforeNot == null ? null : selectorBeforeNot;
	    if (token) {
	      selector = selector.slice(0, selector.length + token.loc.end.column - ch);
	      this.selector = selector;
	    } else {
	      this.selector = "";
	    }
	    this.selectors = selectors;

	    if (token && token.tokenType != "whitespace") {
	      let text;
	      if (token.tokenType == "dimension" || !token.text) text = source.substring(token.startOffset, token.endOffset);else text = token.text;
	      this.completing = text.slice(0, ch - token.loc.start.column).replace(/^[.#]$/, "");
	    } else {
	      this.completing = "";
	    }
	    // Special case the situation when the user just entered ":" after typing a
	    // property name.
	    if (this.completing == ":" && _state == CSS_STATES.value) this.completing = "";

	    // Special check for !important; case.
	    if (token && tokens[cursor - 2] && tokens[cursor - 2].text == "!" && this.completing == "important".slice(0, this.completing.length)) {
	      this.completing = "!" + this.completing;
	    }
	    return _state;
	  },

	  /**
	   * Queries the DOM Walker actor for suggestions regarding the selector being
	   * completed
	   */
	  suggestSelectors: function () {
	    var _this = this;

	    let walker = this.walker;
	    if (!walker) return Promise.resolve([]);

	    let query = this.selector;
	    // Even though the selector matched atleast one node, there is still
	    // possibility of suggestions.
	    switch (this.selectorState) {
	      case SELECTOR_STATES.null:
	        if (this.completing === ",") {
	          return Promise.resolve([]);
	        }

	        query += "*";
	        break;

	      case SELECTOR_STATES.tag:
	        query = query.slice(0, query.length - this.completing.length);
	        break;

	      case SELECTOR_STATES.id:
	      case SELECTOR_STATES.class:
	      case SELECTOR_STATES.pseudo:
	        if (/^[.:#]$/.test(this.completing)) {
	          query = query.slice(0, query.length - this.completing.length);
	          this.completing = "";
	        } else {
	          query = query.slice(0, query.length - this.completing.length - 1);
	        }
	        break;
	    }

	    if (/[\s+>~]$/.test(query) && this.selectorState != SELECTOR_STATES.attribute && this.selectorState != SELECTOR_STATES.value) {
	      query += "*";
	    }

	    // Set the values that this request was supposed to suggest to.
	    this._currentQuery = query;
	    return walker.getSuggestionsForQuery(query, this.completing, this.selectorState).then(function (result) {
	      return _this.prepareSelectorResults(result);
	    });
	  },

	  /**
	   * Prepares the selector suggestions returned by the walker actor.
	   */
	  prepareSelectorResults: function (result) {
	    if (this._currentQuery != result.query) return [];

	    result = result.suggestions;
	    let query = this.selector;
	    let completion = [];
	    for (let _ref of result) {
	      var _ref2 = _slicedToArray(_ref, 3);

	      let value = _ref2[0];
	      let count = _ref2[1];
	      let state = _ref2[2];

	      switch (this.selectorState) {
	        case SELECTOR_STATES.id:
	        case SELECTOR_STATES.class:
	        case SELECTOR_STATES.pseudo:
	          if (/^[.:#]$/.test(this.completing)) {
	            value = query.slice(0, query.length - this.completing.length) + value;
	          } else {
	            value = query.slice(0, query.length - this.completing.length - 1) + value;
	          }
	          break;

	        case SELECTOR_STATES.tag:
	          value = query.slice(0, query.length - this.completing.length) + value;
	          break;

	        case SELECTOR_STATES.null:
	          value = query + value;
	          break;

	        default:
	          value = query.slice(0, query.length - this.completing.length) + value;
	      }

	      let item = {
	        label: value,
	        preLabel: query,
	        text: value,
	        score: count
	      };

	      // In case the query's state is tag and the item's state is id or class
	      // adjust the preLabel
	      if (this.selectorState === SELECTOR_STATES.tag && state === SELECTOR_STATES.class) {
	        item.preLabel = "." + item.preLabel;
	      }
	      if (this.selectorState === SELECTOR_STATES.tag && state === SELECTOR_STATES.id) {
	        item.preLabel = "#" + item.preLabel;
	      }

	      completion.push(item);

	      if (completion.length > this.maxEntries - 1) break;
	    }
	    return completion;
	  },

	  /**
	   * Returns CSS property name suggestions based on the input.
	   *
	   * @param startProp {String} Initial part of the property being completed.
	   */
	  completeProperties: function (startProp) {
	    let finalList = [];
	    if (!startProp) return Promise.resolve(finalList);

	    let length = propertyNames.length;
	    let i = 0,
	        count = 0;
	    for (; i < length && count < this.maxEntries; i++) {
	      if (propertyNames[i].startsWith(startProp)) {
	        count++;
	        let propName = propertyNames[i];
	        finalList.push({
	          preLabel: startProp,
	          label: propName,
	          text: propName + ": "
	        });
	      } else if (propertyNames[i] > startProp) {
	        // We have crossed all possible matches alphabetically.
	        break;
	      }
	    }
	    return Promise.resolve(finalList);
	  },

	  /**
	   * Returns CSS value suggestions based on the corresponding property.
	   *
	   * @param propName {String} The property to which the value being completed
	   *        belongs.
	   * @param startValue {String} Initial part of the value being completed.
	   */
	  completeValues: function (propName, startValue) {
	    let finalList = [];
	    let list = ["!important;", ...(properties[propName] || [])];
	    // If there is no character being completed, we are showing an initial list
	    // of possible values. Skipping '!important' in this case.
	    if (!startValue) list.splice(0, 1);

	    let length = list.length;
	    let i = 0,
	        count = 0;
	    for (; i < length && count < this.maxEntries; i++) {
	      if (list[i].startsWith(startValue)) {
	        count++;
	        let value = list[i];
	        finalList.push({
	          preLabel: startValue,
	          label: value,
	          text: value
	        });
	      } else if (list[i] > startValue) {
	        // We have crossed all possible matches alphabetically.
	        break;
	      }
	    }
	    return Promise.resolve(finalList);
	  },

	  /**
	   * A biased binary search in a sorted array where the middle element is
	   * calculated based on the values at the lower and the upper index in each
	   * iteration.
	   *
	   * This method returns the index of the closest null state from the passed
	   * `line` argument. Once we have the closest null state, we can start applying
	   * the state machine logic from that location instead of the absolute starting
	   * of the CSS source. This speeds up the tokenizing and the state machine a
	   * lot while using autocompletion at high line numbers in a CSS source.
	   */
	  findNearestNullState: function (line) {
	    let arr = this.nullStates;
	    let high = arr.length - 1;
	    let low = 0;
	    let target = 0;

	    if (high < 0) return -1;
	    if (arr[high][0] <= line) return high;
	    if (arr[low][0] > line) return -1;

	    while (high > low) {
	      if (arr[low][0] <= line && arr[low[0] + 1] > line) return low;
	      if (arr[high][0] > line && arr[high - 1][0] <= line) return high - 1;

	      target = (line - arr[low][0]) / (arr[high][0] - arr[low][0]) * (high - low) | 0;

	      if (arr[target][0] <= line && arr[target + 1][0] > line) {
	        return target;
	      } else if (line > arr[target][0]) {
	        low = target + 1;
	        high--;
	      } else {
	        high = target - 1;
	        low++;
	      }
	    }

	    return -1;
	  },

	  /**
	   * Invalidates the state cache for and above the line.
	   */
	  invalidateCache: function (line) {
	    this.nullStates.length = this.findNearestNullState(line) + 1;
	  },

	  /**
	   * Get the state information about a token surrounding the {line, ch} position
	   *
	   * @param {string} source
	   *        The complete source of the CSS file. Unlike resolve state method,
	   *        this method requires the full source.
	   * @param {object} caret
	   *        The line, ch position of the caret.
	   *
	   * @returns {object}
	   *          An object containing the state of token covered by the caret.
	   *          The object has following properties when the the state is
	   *          "selector", "value" or "property", null otherwise:
	   *           - state {string} one of CSS_STATES - "selector", "value" etc.
	   *           - selector {string} The selector at the caret when `state` is
	   *                      selector. OR
	   *           - selectors {[string]} Array of selector strings in case when
	   *                       `state` is "value" or "property"
	   *           - propertyName {string} The property name at the current caret or
	   *                          the property name corresponding to the value at
	   *                          the caret.
	   *           - value {string} The css value at the current caret.
	   *           - loc {object} An object containing the starting and the ending
	   *                 caret position of the whole selector, value or property.
	   *                  - { start: {line, ch}, end: {line, ch}}
	   */
	  getInfoAt: function (source, caret) {
	    var _this2 = this;

	    // Limits the input source till the {line, ch} caret position
	    function limit(source, { line, ch }) {
	      line++;
	      let list = source.split("\n");
	      if (list.length < line) return source;
	      if (line == 1) return list[0].slice(0, ch);
	      return [...list.slice(0, line - 1), list[line - 1].slice(0, ch)].join("\n");
	    }

	    // Get the state at the given line, ch
	    let state = this.resolveState(limit(source, caret), caret);
	    let propertyName = this.propertyName;
	    let line = caret.line;
	    let ch = caret.ch;

	    let sourceArray = source.split("\n");
	    let limitedSource = limit(source, caret);

	    /**
	     * Method to traverse forwards from the caret location to figure out the
	     * ending point of a selector or css value.
	     *
	     * @param {function} check
	     *        A method which takes the current state as an input and determines
	     *        whether the state changed or not.
	     */
	    let traverseForward = function (check) {
	      let location;
	      // Backward loop to determine the beginning location of the selector.
	      do {
	        let lineText = sourceArray[line];
	        if (line == caret.line) lineText = lineText.substring(caret.ch);

	        let prevToken = undefined;
	        let tokens = cssTokenizer(lineText);
	        let found = false;
	        let ech = line == caret.line ? caret.ch : 0;
	        for (let token of tokens) {
	          // If the line is completely spaces, handle it differently
	          if (lineText.trim() == "") {
	            limitedSource += lineText;
	          } else {
	            limitedSource += sourceArray[line].substring(ech + token.startOffset, ech + token.endOffset);
	          }

	          // Whitespace cannot change state.
	          if (token.tokenType == "whitespace") {
	            prevToken = token;
	            continue;
	          }

	          let state = _this2.resolveState(limitedSource, {
	            line: line,
	            ch: token.endOffset + ech
	          });
	          if (check(state)) {
	            if (prevToken && prevToken.tokenType == "whitespace") token = prevToken;
	            location = {
	              line: line,
	              ch: token.startOffset + ech
	            };
	            found = true;
	            break;
	          }
	          prevToken = token;
	        }
	        limitedSource += "\n";
	        if (found) break;
	      } while (line++ < sourceArray.length);
	      return location;
	    };

	    /**
	     * Method to traverse backwards from the caret location to figure out the
	     * starting point of a selector or css value.
	     *
	     * @param {function} check
	     *        A method which takes the current state as an input and determines
	     *        whether the state changed or not.
	     * @param {boolean} isValue
	     *        true if the traversal is being done for a css value state.
	     */
	    let traverseBackwards = function (check, isValue) {
	      let location;
	      // Backward loop to determine the beginning location of the selector.
	      do {
	        let lineText = sourceArray[line];
	        if (line == caret.line) lineText = lineText.substring(0, caret.ch);

	        let tokens = Array.from(cssTokenizer(lineText));
	        let found = false;
	        let ech = 0;
	        for (let i = tokens.length - 1; i >= 0; i--) {
	          let token = tokens[i];
	          // If the line is completely spaces, handle it differently
	          if (lineText.trim() == "") {
	            limitedSource = limitedSource.slice(0, -1 * lineText.length);
	          } else {
	            let length = token.endOffset - token.startOffset;
	            limitedSource = limitedSource.slice(0, -1 * length);
	          }

	          // Whitespace cannot change state.
	          if (token.tokenType == "whitespace") continue;

	          let state = _this2.resolveState(limitedSource, {
	            line: line,
	            ch: token.startOffset
	          });
	          if (check(state)) {
	            if (tokens[i + 1] && tokens[i + 1].tokenType == "whitespace") token = tokens[i + 1];
	            location = {
	              line: line,
	              ch: isValue ? token.endOffset : token.startOffset
	            };
	            found = true;
	            break;
	          }
	        }
	        limitedSource = limitedSource.slice(0, -1);
	        if (found) break;
	      } while (line-- >= 0);
	      return location;
	    };

	    if (state == CSS_STATES.selector) {
	      // For selector state, the ending and starting point of the selector is
	      // either when the state changes or the selector becomes empty and a
	      // single selector can span multiple lines.
	      // Backward loop to determine the beginning location of the selector.
	      let start = traverseBackwards(function (state) {
	        return state != CSS_STATES.selector || _this2.selector == "" && _this2.selectorBeforeNot == null;
	      });

	      line = caret.line;
	      limitedSource = limit(source, caret);
	      // Forward loop to determine the ending location of the selector.
	      let end = traverseForward(function (state) {
	        return state != CSS_STATES.selector || _this2.selector == "" && _this2.selectorBeforeNot == null;
	      });

	      // Since we have start and end positions, figure out the whole selector.
	      let selector = source.split("\n").slice(start.line, end.line + 1);
	      selector[selector.length - 1] = selector[selector.length - 1].substring(0, end.ch);
	      selector[0] = selector[0].substring(start.ch);
	      selector = selector.join("\n");
	      return {
	        state: state,
	        selector: selector,
	        loc: {
	          start: start,
	          end: end
	        }
	      };
	    } else if (state == CSS_STATES.property) {
	      // A property can only be a single word and thus very easy to calculate.
	      let tokens = cssTokenizer(sourceArray[line]);
	      for (let token of tokens) {
	        // Note that, because we're tokenizing a single line, the
	        // token's offset is also the column number.
	        if (token.startOffset <= ch && token.endOffset >= ch) {
	          return {
	            state: state,
	            propertyName: token.text,
	            selectors: this.selectors,
	            loc: {
	              start: {
	                line: line,
	                ch: token.startOffset
	              },
	              end: {
	                line: line,
	                ch: token.endOffset
	              }
	            }
	          };
	        }
	      }
	    } else if (state == CSS_STATES.value) {
	      // CSS value can be multiline too, so we go forward and backwards to
	      // determine the bounds of the value at caret
	      let start = traverseBackwards(function (state) {
	        return state != CSS_STATES.value;
	      }, true);

	      line = caret.line;
	      limitedSource = limit(source, caret);
	      let end = traverseForward(function (state) {
	        return state != CSS_STATES.value;
	      });

	      let value = source.split("\n").slice(start.line, end.line + 1);
	      value[value.length - 1] = value[value.length - 1].substring(0, end.ch);
	      value[0] = value[0].substring(start.ch);
	      value = value.join("\n");
	      return {
	        state: state,
	        propertyName: propertyName,
	        selectors: this.selectors,
	        value: value,
	        loc: {
	          start: start,
	          end: end
	        }
	      };
	    }
	    return null;
	  }
	};

	/**
	 * Returns a list of all property names and a map of property name vs possible
	 * CSS values provided by the Gecko engine.
	 *
	 * @return {Object} An object with following properties:
	 *         - propertyNames {Array} Array of string containing all the possible
	 *                         CSS property names.
	 *         - properties {Object|Map} A map where key is the property name and
	 *                      value is an array of string containing all the possible
	 *                      CSS values the property can have.
	 */
	function getCSSKeywords() {
	  return {
	    properties: {},
	    propertyNames: []
	  };
	  let domUtils = Cc("@mozilla.org/inspector/dom-utils;1").getService(Ci.inIDOMUtils);
	  let props = {};
	  let propNames = domUtils.getCSSPropertyNames(domUtils.INCLUDE_ALIASES);
	  propNames.forEach(function (prop) {
	    props[prop] = domUtils.getCSSValuesForProperty(prop).sort();
	  });
	  return {
	    properties: props,
	    propertyNames: propNames.sort()
	  };
	}

	module.exports = CSSCompleter;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// This file holds various CSS parsing and rewriting utilities.
	// Some entry points of note are:
	// parseDeclarations - parse a CSS rule into declarations
	// RuleRewriter - rewrite CSS rule text
	// parsePseudoClassesAndAttributes - parse selector and extract
	//     pseudo-classes
	// parseSingleValue - parse a single CSS property value

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	const promise = __webpack_require__(6);

	var _require2 = __webpack_require__(38);

	const Task = _require2.Task;
	// loader.lazyGetter(this, "DOMUtils", () => {
	//   return Cc("@mozilla.org/inspector/dom-utils;1").getService(Ci.inIDOMUtils);
	// });

	const SELECTOR_ATTRIBUTE = exports.SELECTOR_ATTRIBUTE = 1;
	const SELECTOR_ELEMENT = exports.SELECTOR_ELEMENT = 2;
	const SELECTOR_PSEUDO_CLASS = exports.SELECTOR_PSEUDO_CLASS = 3;

	// Used to test whether a newline appears anywhere in some text.
	const NEWLINE_RX = /[\r\n]/;
	// Used to test whether a bit of text starts an empty comment, either
	// an "ordinary" /* ... */ comment, or a "heuristic bypass" comment
	// like /*! ... */.
	const EMPTY_COMMENT_START_RX = /^\/\*!?[ \r\n\t\f]*$/;
	// Used to test whether a bit of text ends an empty comment.
	const EMPTY_COMMENT_END_RX = /^[ \r\n\t\f]*\*\//;
	// Used to test whether a string starts with a blank line.
	const BLANK_LINE_RX = /^[ \t]*(?:\r\n|\n|\r|\f|$)/;

	// When commenting out a declaration, we put this character into the
	// comment opener so that future parses of the commented text know to
	// bypass the property name validity heuristic.
	const COMMENT_PARSING_HEURISTIC_BYPASS_CHAR = "!";

	/**
	 * A generator function that lexes a CSS source string, yielding the
	 * CSS tokens.  Comment tokens are dropped.
	 *
	 * @param {String} CSS source string
	 * @yield {CSSToken} The next CSSToken that is lexed
	 * @see CSSToken for details about the returned tokens
	 */
	function* cssTokenizer(string) {
	  let lexer = DOMUtils.getCSSLexer(string);
	  while (true) {
	    let token = lexer.nextToken();
	    if (!token) {
	      break;
	    }
	    // None of the existing consumers want comments.
	    if (token.tokenType !== "comment") {
	      yield token;
	    }
	  }
	}

	/**
	 * Pass |string| to the CSS lexer and return an array of all the
	 * returned tokens.  Comment tokens are not included.  In addition to
	 * the usual information, each token will have starting and ending
	 * line and column information attached.  Specifically, each token
	 * has an additional "loc" attribute.  This attribute is an object
	 * of the form {line: L, column: C}.  Lines and columns are both zero
	 * based.
	 *
	 * It's best not to add new uses of this function.  In general it is
	 * simpler and better to use the CSSToken offsets, rather than line
	 * and column.  Also, this function lexes the entire input string at
	 * once, rather than lazily yielding a token stream.  Use
	 * |cssTokenizer| or |DOMUtils.getCSSLexer| instead.
	 *
	 * @param{String} string The input string.
	 * @return {Array} An array of tokens (@see CSSToken) that have
	 *        line and column information.
	 */
	function cssTokenizerWithLineColumn(string) {
	  let lexer = DOMUtils.getCSSLexer(string);
	  let result = [];
	  let prevToken = undefined;
	  while (true) {
	    let token = lexer.nextToken();
	    let lineNumber = lexer.lineNumber;
	    let columnNumber = lexer.columnNumber;

	    if (prevToken) {
	      prevToken.loc.end = {
	        line: lineNumber,
	        column: columnNumber
	      };
	    }

	    if (!token) {
	      break;
	    }

	    if (token.tokenType === "comment") {
	      // We've already dealt with the previous token's location.
	      prevToken = undefined;
	    } else {
	      let startLoc = {
	        line: lineNumber,
	        column: columnNumber
	      };
	      token.loc = { start: startLoc };

	      result.push(token);
	      prevToken = token;
	    }
	  }

	  return result;
	}

	/**
	 * Escape a comment body.  Find the comment start and end strings in a
	 * string and inserts backslashes so that the resulting text can
	 * itself be put inside a comment.
	 *
	 * @param {String} inputString
	 *                 input string
	 * @return {String} the escaped result
	 */
	function escapeCSSComment(inputString) {
	  let result = inputString.replace(/\/(\\*)\*/g, "/\\$1*");
	  return result.replace(/\*(\\*)\//g, "*\\$1/");
	}

	/**
	 * Un-escape a comment body.  This undoes any comment escaping that
	 * was done by escapeCSSComment.  That is, given input like "/\*
	 * comment *\/", it will strip the backslashes.
	 *
	 * @param {String} inputString
	 *                 input string
	 * @return {String} the un-escaped result
	 */
	function unescapeCSSComment(inputString) {
	  let result = inputString.replace(/\/\\(\\*)\*/g, "/$1*");
	  return result.replace(/\*\\(\\*)\//g, "*$1/");
	}

	/**
	 * A helper function for parseDeclarations that implements a heuristic
	 * to decide whether a given bit of comment text should be parsed as a
	 * declaration.
	 *
	 * @param {String} name the property name that has been parsed
	 * @return {Boolean} true if the property should be parsed, false if
	 *                        the remainder of the comment should be skipped
	 */
	function shouldParsePropertyInComment(name) {
	  try {
	    // If the property name is invalid, the cssPropertyIsShorthand
	    // will throw an exception.  But if it is valid, no exception will
	    // be thrown; so we just ignore the return value.
	    DOMUtils.cssPropertyIsShorthand(name);
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	/**
	 * A helper function for @see parseDeclarations that handles parsing
	 * of comment text.  This wraps a recursive call to parseDeclarations
	 * with the processing needed to ensure that offsets in the result
	 * refer back to the original, unescaped, input string.
	 *
	 * @param {String} commentText The text of the comment, without the
	 *                             delimiters.
	 * @param {Number} startOffset The offset of the comment opener
	 *                             in the original text.
	 * @param {Number} endOffset The offset of the comment closer
	 *                           in the original text.
	 * @return {array} Array of declarations of the same form as returned
	 *                 by parseDeclarations.
	 */
	function parseCommentDeclarations(commentText, startOffset, endOffset) {
	  let commentOverride = false;
	  if (commentText === "") {
	    return [];
	  } else if (commentText[0] === COMMENT_PARSING_HEURISTIC_BYPASS_CHAR) {
	    // This is the special sign that the comment was written by
	    // rewriteDeclarations and so we should bypass the usual
	    // heuristic.
	    commentOverride = true;
	    commentText = commentText.substring(1);
	  }

	  let rewrittenText = unescapeCSSComment(commentText);

	  // We might have rewritten an embedded comment.  For example
	  // /\* ... *\/ would turn into /* ... */.
	  // This rewriting is necessary for proper lexing, but it means
	  // that the offsets we get back can be off.  So now we compute
	  // a map so that we can rewrite offsets later.  The map is the same
	  // length as |rewrittenText| and tells us how to map an index
	  // into |rewrittenText| to an index into |commentText|.
	  //
	  // First, we find the location of each comment starter or closer in
	  // |rewrittenText|.  At these spots we put a 1 into |rewrites|.
	  // Then we walk the array again, using the elements to compute a
	  // delta, which we use to make the final mapping.
	  //
	  // Note we allocate one extra entry because we can see an ending
	  // offset that is equal to the length.
	  let rewrites = new Array(rewrittenText.length + 1).fill(0);

	  let commentRe = /\/\\*\*|\*\\*\//g;
	  while (true) {
	    let matchData = commentRe.exec(rewrittenText);
	    if (!matchData) {
	      break;
	    }
	    rewrites[matchData.index] = 1;
	  }

	  let delta = 0;
	  for (let i = 0; i <= rewrittenText.length; ++i) {
	    delta += rewrites[i];
	    // |startOffset| to add the offset from the comment starter, |+2|
	    // for the length of the "/*", then |i| and |delta| as described
	    // above.
	    rewrites[i] = startOffset + 2 + i + delta;
	    if (commentOverride) {
	      ++rewrites[i];
	    }
	  }

	  // Note that we pass "false" for parseComments here.  It doesn't
	  // seem worthwhile to support declarations in comments-in-comments
	  // here, as there's no way to generate those using the tools, and
	  // users would be crazy to write such things.
	  let newDecls = parseDeclarationsInternal(rewrittenText, false, true, commentOverride);
	  for (let decl of newDecls) {
	    decl.offsets[0] = rewrites[decl.offsets[0]];
	    decl.offsets[1] = rewrites[decl.offsets[1]];
	    decl.colonOffsets[0] = rewrites[decl.colonOffsets[0]];
	    decl.colonOffsets[1] = rewrites[decl.colonOffsets[1]];
	    decl.commentOffsets = [startOffset, endOffset];
	  }
	  return newDecls;
	}

	/**
	 * A helper function for parseDeclarationsInternal that creates a new
	 * empty declaration.
	 *
	 * @return {object} an empty declaration of the form returned by
	 *                  parseDeclarations
	 */
	function getEmptyDeclaration() {
	  return { name: "", value: "", priority: "",
	    terminator: "",
	    offsets: [undefined, undefined],
	    colonOffsets: false };
	}

	/**
	 * A helper function that does all the parsing work for
	 * parseDeclarations.  This is separate because it has some arguments
	 * that don't make sense in isolation.
	 *
	 * The return value and arguments are like parseDeclarations, with
	 * these additional arguments.
	 *
	 * @param {Boolean} inComment
	 *        If true, assume that this call is parsing some text
	 *        which came from a comment in another declaration.
	 *        In this case some heuristics are used to avoid parsing
	 *        text which isn't obviously a series of declarations.
	 * @param {Boolean} commentOverride
	 *        This only makes sense when inComment=true.
	 *        When true, assume that the comment was generated by
	 *        rewriteDeclarations, and skip the usual name-checking
	 *        heuristic.
	 */
	function parseDeclarationsInternal(inputString, parseComments, inComment, commentOverride) {
	  if (inputString === null || inputString === undefined) {
	    throw new Error("empty input string");
	  }

	  let lexer = DOMUtils.getCSSLexer(inputString);

	  let declarations = [getEmptyDeclaration()];
	  let lastProp = declarations[0];

	  let current = "",
	      hasBang = false;
	  while (true) {
	    let token = lexer.nextToken();
	    if (!token) {
	      break;
	    }

	    // Ignore HTML comment tokens (but parse anything they might
	    // happen to surround).
	    if (token.tokenType === "htmlcomment") {
	      continue;
	    }

	    // Update the start and end offsets of the declaration, but only
	    // when we see a significant token.
	    if (token.tokenType !== "whitespace" && token.tokenType !== "comment") {
	      if (lastProp.offsets[0] === undefined) {
	        lastProp.offsets[0] = token.startOffset;
	      }
	      lastProp.offsets[1] = token.endOffset;
	    } else if (lastProp.name && !current && !hasBang && !lastProp.priority && lastProp.colonOffsets[1]) {
	      // Whitespace appearing after the ":" is attributed to it.
	      lastProp.colonOffsets[1] = token.endOffset;
	    }

	    if (token.tokenType === "symbol" && token.text === ":") {
	      if (!lastProp.name) {
	        // Set the current declaration name if there's no name yet
	        lastProp.name = current.trim();
	        lastProp.colonOffsets = [token.startOffset, token.endOffset];
	        current = "";
	        hasBang = false;

	        // When parsing a comment body, if the left-hand-side is not a
	        // valid property name, then drop it and stop parsing.
	        if (inComment && !commentOverride && !shouldParsePropertyInComment(lastProp.name)) {
	          lastProp.name = null;
	          break;
	        }
	      } else {
	        // Otherwise, just append ':' to the current value (declaration value
	        // with colons)
	        current += ":";
	      }
	    } else if (token.tokenType === "symbol" && token.text === ";") {
	      lastProp.terminator = "";
	      // When parsing a comment, if the name hasn't been set, then we
	      // have probably just seen an ordinary semicolon used in text,
	      // so drop this and stop parsing.
	      if (inComment && !lastProp.name) {
	        current = "";
	        break;
	      }
	      lastProp.value = current.trim();
	      current = "";
	      hasBang = false;
	      declarations.push(getEmptyDeclaration());
	      lastProp = declarations[declarations.length - 1];
	    } else if (token.tokenType === "ident") {
	      if (token.text === "important" && hasBang) {
	        lastProp.priority = "important";
	        hasBang = false;
	      } else {
	        if (hasBang) {
	          current += "!";
	        }
	        current += token.text;
	      }
	    } else if (token.tokenType === "symbol" && token.text === "!") {
	      hasBang = true;
	    } else if (token.tokenType === "whitespace") {
	      if (current !== "") {
	        current += " ";
	      }
	    } else if (token.tokenType === "comment") {
	      if (parseComments && !lastProp.name && !lastProp.value) {
	        let commentText = inputString.substring(token.startOffset + 2, token.endOffset - 2);
	        let newDecls = parseCommentDeclarations(commentText, token.startOffset, token.endOffset);

	        // Insert the new declarations just before the final element.
	        let lastDecl = declarations.pop();
	        declarations = [...declarations, ...newDecls, lastDecl];
	      }
	    } else {
	      current += inputString.substring(token.startOffset, token.endOffset);
	    }
	  }

	  // Handle whatever trailing properties or values might still be there
	  if (current) {
	    if (!lastProp.name) {
	      // Ignore this case in comments.
	      if (!inComment) {
	        // Trailing property found, e.g. p1:v1;p2:v2;p3
	        lastProp.name = current.trim();
	      }
	    } else {
	      // Trailing value found, i.e. value without an ending ;
	      lastProp.value = current.trim();
	      let terminator = lexer.performEOFFixup("", true);
	      lastProp.terminator = terminator + ";";
	      // If the input was unterminated, attribute the remainder to
	      // this property.  This avoids some bad behavior when rewriting
	      // an unterminated comment.
	      if (terminator) {
	        lastProp.offsets[1] = inputString.length;
	      }
	    }
	  }

	  // Remove declarations that have neither a name nor a value
	  declarations = declarations.filter(function (prop) {
	    return prop.name || prop.value;
	  });

	  return declarations;
	}

	/**
	 * Returns an array of CSS declarations given a string.
	 * For example, parseDeclarations("width: 1px; height: 1px") would return
	 * [{name:"width", value: "1px"}, {name: "height", "value": "1px"}]
	 *
	 * The input string is assumed to only contain declarations so { and }
	 * characters will be treated as part of either the property or value,
	 * depending where it's found.
	 *
	 * @param {String} inputString
	 *        An input string of CSS
	 * @param {Boolean} parseComments
	 *        If true, try to parse the contents of comments as well.
	 *        A comment will only be parsed if it occurs outside of
	 *        the body of some other declaration.
	 * @return {Array} an array of objects with the following signature:
	 *         [{"name": string, "value": string, "priority": string,
	 *           "terminator": string,
	 *           "offsets": [start, end], "colonOffsets": [start, end]},
	 *          ...]
	 *         Here, "offsets" holds the offsets of the start and end
	 *         of the declaration text, in a form suitable for use with
	 *         String.substring.
	 *         "terminator" is a string to use to terminate the declaration,
	 *         usually "" to mean no additional termination is needed.
	 *         "colonOffsets" holds the start and end locations of the
	 *         ":" that separates the property name from the value.
	 *         If the declaration appears in a comment, then there will
	 *         be an additional {"commentOffsets": [start, end] property
	 *         on the object, which will hold the offsets of the start
	 *         and end of the enclosing comment.
	 */
	function parseDeclarations(inputString, parseComments = false) {
	  return parseDeclarationsInternal(inputString, parseComments, false, false);
	}

	/**
	 * Return an object that can be used to rewrite declarations in some
	 * source text.  The source text and parsing are handled in the same
	 * way as @see parseDeclarations, with |parseComments| being true.
	 * Rewriting is done by calling one of the modification functions like
	 * setPropertyEnabled.  The returned object has the same interface
	 * as @see RuleModificationList.
	 *
	 * An example showing how to disable the 3rd property in a rule:
	 *
	 *    let rewriter = new RuleRewriter(ruleActor, ruleActor.authoredText);
	 *    rewriter.setPropertyEnabled(3, "color", false);
	 *    rewriter.apply().then(() => { ... the change is made ... });
	 *
	 * The exported rewriting methods are |renameProperty|, |setPropertyEnabled|,
	 * |createProperty|, |setProperty|, and |removeProperty|.  The |apply|
	 * method can be used to send the edited text to the StyleRuleActor;
	 * |getDefaultIndentation| is useful for the methods requiring a
	 * default indentation value; and |getResult| is useful for testing.
	 *
	 * Additionally, editing will set the |changedDeclarations| property
	 * on this object.  This property has the same form as the |changed|
	 * property of the object returned by |getResult|.
	 *
	 * @param {StyleRuleFront} rule The style rule to use.  Note that this
	 *        is only needed by the |apply| and |getDefaultIndentation| methods;
	 *        and in particular for testing it can be |null|.
	 * @param {String} inputString The CSS source text to parse and modify.
	 * @return {Object} an object that can be used to rewrite the input text.
	 */
	function RuleRewriter(rule, inputString) {
	  this.rule = rule;
	  this.inputString = inputString;
	  // Whether there are any newlines in the input text.
	  this.hasNewLine = /[\r\n]/.test(this.inputString);
	  // Keep track of which any declarations we had to rewrite while
	  // performing the requested action.
	  this.changedDeclarations = {};
	  // The declarations.
	  this.declarations = parseDeclarations(this.inputString, true);

	  this.decl = null;
	  this.result = null;
	  // If not null, a promise that must be wait upon before |apply| can
	  // do its work.
	  this.editPromise = null;

	  // If the |defaultIndentation| property is set, then it is used;
	  // otherwise the RuleRewriter will try to compute the default
	  // indentation based on the style sheet's text.  This override
	  // facility is for testing.
	  this.defaultIndentation = null;
	}

	RuleRewriter.prototype = {
	  /**
	   * An internal function to complete initialization and set some
	   * properties for further processing.
	   *
	   * @param {Number} index The index of the property to modify
	   */
	  completeInitialization: function (index) {
	    if (index < 0) {
	      throw new Error("Invalid index " + index + ". Expected positive integer");
	    }
	    // |decl| is the declaration to be rewritten, or null if there is no
	    // declaration corresponding to |index|.
	    // |result| is used to accumulate the result text.
	    if (index < this.declarations.length) {
	      this.decl = this.declarations[index];
	      this.result = this.inputString.substring(0, this.decl.offsets[0]);
	    } else {
	      this.decl = null;
	      this.result = this.inputString;
	    }
	  },

	  /**
	   * A helper function to compute the indentation of some text.  This
	   * examines the rule's existing text to guess the indentation to use;
	   * unlike |getDefaultIndentation|, which examines the entire style
	   * sheet.
	   *
	   * @param {String} string the input text
	   * @param {Number} offset the offset at which to compute the indentation
	   * @return {String} the indentation at the indicated position
	   */
	  getIndentation: function (string, offset) {
	    let originalOffset = offset;
	    for (--offset; offset >= 0; --offset) {
	      let c = string[offset];
	      if (c === "\r" || c === "\n" || c === "\f") {
	        return string.substring(offset + 1, originalOffset);
	      }
	      if (c !== " " && c !== "\t") {
	        // Found some non-whitespace character before we found a newline
	        // -- let's reset the starting point and keep going, as we saw
	        // something on the line before the declaration.
	        originalOffset = offset;
	      }
	    }
	    // Ran off the end.
	    return "";
	  },

	  /**
	   * Modify a property value to ensure it is "lexically safe" for
	   * insertion into a style sheet.  This function doesn't attempt to
	   * ensure that the resulting text is a valid value for the given
	   * property; but rather just that inserting the text into the style
	   * sheet will not cause unwanted changes to other rules or
	   * declarations.
	   *
	   * @param {String} text The input text.  This should include the trailing ";".
	   * @return {Array} An array of the form [anySanitized, text], where
	   *                 |anySanitized| is a boolean that indicates
	   *                  whether anything substantive has changed; and
	   *                  where |text| is the text that has been rewritten
	   *                  to be "lexically safe".
	   */
	  sanitizePropertyValue: function (text) {
	    let lexer = DOMUtils.getCSSLexer(text);

	    let result = "";
	    let previousOffset = 0;
	    let braceDepth = 0;
	    let anySanitized = false;
	    while (true) {
	      let token = lexer.nextToken();
	      if (!token) {
	        break;
	      }

	      if (token.tokenType === "symbol") {
	        switch (token.text) {
	          case ";":
	            // We simply drop the ";" here.  This lets us cope with
	            // declarations that don't have a ";" and also other
	            // termination.  The caller handles adding the ";" again.
	            result += text.substring(previousOffset, token.startOffset);
	            previousOffset = token.endOffset;
	            break;

	          case "{":
	            ++braceDepth;
	            break;

	          case "}":
	            --braceDepth;
	            if (braceDepth < 0) {
	              // Found an unmatched close bracket.
	              braceDepth = 0;
	              // Copy out text from |previousOffset|.
	              result += text.substring(previousOffset, token.startOffset);
	              // Quote the offending symbol.
	              result += "\\" + token.text;
	              previousOffset = token.endOffset;
	              anySanitized = true;
	            }
	            break;
	        }
	      }
	    }

	    // Copy out any remaining text, then any needed terminators.
	    result += text.substring(previousOffset, text.length);
	    let eofFixup = lexer.performEOFFixup("", true);
	    if (eofFixup) {
	      anySanitized = true;
	      result += eofFixup;
	    }
	    return [anySanitized, result];
	  },

	  /**
	   * Start at |index| and skip whitespace
	   * backward in |string|.  Return the index of the first
	   * non-whitespace character, or -1 if the entire string was
	   * whitespace.
	   * @param {String} string the input string
	   * @param {Number} index the index at which to start
	   * @return {Number} index of the first non-whitespace character, or -1
	   */
	  skipWhitespaceBackward: function (string, index) {
	    for (--index; index >= 0 && (string[index] === " " || string[index] === "\t"); --index) {
	      // Nothing.
	    }
	    return index;
	  },

	  /**
	   * Terminate a given declaration, if needed.
	   *
	   * @param {Number} index The index of the rule to possibly
	   *                       terminate.  It might be invalid, so this
	   *                       function must check for that.
	   */
	  maybeTerminateDecl: function (index) {
	    if (index < 0 || index >= this.declarations.length
	    // No need to rewrite declarations in comments.
	     || "commentOffsets" in this.declarations[index]) {
	      return;
	    }

	    let termDecl = this.declarations[index];
	    let endIndex = termDecl.offsets[1];
	    // Due to an oddity of the lexer, we might have gotten a bit of
	    // extra whitespace in a trailing bad_url token -- so be sure to
	    // skip that as well.
	    endIndex = this.skipWhitespaceBackward(this.result, endIndex) + 1;

	    let trailingText = this.result.substring(endIndex);
	    if (termDecl.terminator) {
	      // Insert the terminator just at the end of the declaration,
	      // before any trailing whitespace.
	      this.result = this.result.substring(0, endIndex) + termDecl.terminator + trailingText;
	      // In a couple of cases, we may have had to add something to
	      // terminate the declaration, but the termination did not
	      // actually affect the property's value -- and at this spot, we
	      // only care about reporting value changes.  In particular, we
	      // might have added a plain ";", or we might have terminated a
	      // comment with "*/;".  Neither of these affect the value.
	      if (termDecl.terminator !== ";" && termDecl.terminator !== "*/;") {
	        this.changedDeclarations[index] = termDecl.value + termDecl.terminator.slice(0, -1);
	      }
	    }
	    // If the rule generally has newlines, but this particular
	    // declaration doesn't have a trailing newline, insert one now.
	    // Maybe this style is too weird to bother with.
	    if (this.hasNewLine && !NEWLINE_RX.test(trailingText)) {
	      this.result += "\n";
	    }
	  },

	  /**
	   * Sanitize the given property value and return the sanitized form.
	   * If the property is rewritten during sanitization, make a note in
	   * |changedDeclarations|.
	   *
	   * @param {String} text The property text.
	   * @param {Number} index The index of the property.
	   * @return {String} The sanitized text.
	   */
	  sanitizeText: function (text, index) {
	    var _sanitizePropertyValu = this.sanitizePropertyValue(text);

	    var _sanitizePropertyValu2 = _slicedToArray(_sanitizePropertyValu, 2);

	    let anySanitized = _sanitizePropertyValu2[0];
	    let sanitizedText = _sanitizePropertyValu2[1];

	    if (anySanitized) {
	      this.changedDeclarations[index] = sanitizedText;
	    }
	    return sanitizedText;
	  },

	  /**
	   * Rename a declaration.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name current name of the property
	   * @param {String} newName new name of the property
	   */
	  renameProperty: function (index, name, newName) {
	    this.completeInitialization(index);
	    this.result += CSS.escape(newName);
	    // We could conceivably compute the name offsets instead so we
	    // could preserve white space and comments on the LHS of the ":".
	    this.completeCopying(this.decl.colonOffsets[0]);
	  },

	  /**
	   * Enable or disable a declaration
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name current name of the property
	   * @param {Boolean} isEnabled true if the property should be enabled;
	   *                        false if it should be disabled
	   */
	  setPropertyEnabled: function (index, name, isEnabled) {
	    this.completeInitialization(index);
	    const decl = this.decl;
	    let copyOffset = decl.offsets[1];
	    if (isEnabled) {
	      // Enable it.  First see if the comment start can be deleted.
	      let commentStart = decl.commentOffsets[0];
	      if (EMPTY_COMMENT_START_RX.test(this.result.substring(commentStart))) {
	        this.result = this.result.substring(0, commentStart);
	      } else {
	        this.result += "*/ ";
	      }

	      // Insert the name and value separately, so we can report
	      // sanitization changes properly.
	      let commentNamePart = this.inputString.substring(decl.offsets[0], decl.colonOffsets[1]);
	      this.result += unescapeCSSComment(commentNamePart);

	      // When uncommenting, we must be sure to sanitize the text, to
	      // avoid things like /* decl: }; */, which will be accepted as
	      // a property but which would break the entire style sheet.
	      let newText = this.inputString.substring(decl.colonOffsets[1], decl.offsets[1]);
	      newText = unescapeCSSComment(newText).trimRight();
	      this.result += this.sanitizeText(newText, index) + ";";

	      // See if the comment end can be deleted.
	      let trailingText = this.inputString.substring(decl.offsets[1]);
	      if (EMPTY_COMMENT_END_RX.test(trailingText)) {
	        copyOffset = decl.commentOffsets[1];
	      } else {
	        this.result += " /*";
	      }
	    } else {
	      // Disable it.  Note that we use our special comment syntax
	      // here.
	      let declText = this.inputString.substring(decl.offsets[0], decl.offsets[1]);
	      this.result += "/*" + COMMENT_PARSING_HEURISTIC_BYPASS_CHAR + " " + escapeCSSComment(declText) + " */";
	    }
	    this.completeCopying(copyOffset);
	  },

	  /**
	   * Return a promise that will be resolved to the default indentation
	   * of the rule.  This is a helper for internalCreateProperty.
	   *
	   * @return {Promise} a promise that will be resolved to a string
	   *         that holds the default indentation that should be used
	   *         for edits to the rule.
	   */
	  getDefaultIndentation: function () {
	    return this.rule.parentStyleSheet.guessIndentation();
	  },

	  /**
	   * An internal function to create a new declaration.  This does all
	   * the work of |createProperty|.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name name of the new property
	   * @param {String} value value of the new property
	   * @param {String} priority priority of the new property; either
	   *                          the empty string or "important"
	   * @return {Promise} a promise that is resolved when the edit has
	   *                   completed
	   */
	  internalCreateProperty: Task.async(function* (index, name, value, priority) {
	    this.completeInitialization(index);
	    let newIndentation = "";
	    if (this.hasNewLine) {
	      if (this.declarations.length > 0) {
	        newIndentation = this.getIndentation(this.inputString, this.declarations[0].offsets[0]);
	      } else if (this.defaultIndentation) {
	        newIndentation = this.defaultIndentation;
	      } else {
	        newIndentation = yield this.getDefaultIndentation();
	      }
	    }

	    this.maybeTerminateDecl(index - 1);

	    // If we generally have newlines, and if skipping whitespace
	    // backward stops at a newline, then insert our text before that
	    // whitespace.  This ensures the indentation we computed is what
	    // is actually used.
	    let savedWhitespace = "";
	    if (this.hasNewLine) {
	      let wsOffset = this.skipWhitespaceBackward(this.result, this.result.length);
	      if (this.result[wsOffset] === "\r" || this.result[wsOffset] === "\n") {
	        savedWhitespace = this.result.substring(wsOffset + 1);
	        this.result = this.result.substring(0, wsOffset + 1);
	      }
	    }

	    this.result += newIndentation + CSS.escape(name) + ": " + this.sanitizeText(value, index);

	    if (priority === "important") {
	      this.result += " !important";
	    }
	    this.result += ";";
	    if (this.hasNewLine) {
	      this.result += "\n";
	    }
	    this.result += savedWhitespace;

	    if (this.decl) {
	      // Still want to copy in the declaration previously at this
	      // index.
	      this.completeCopying(this.decl.offsets[0]);
	    }
	  }),

	  /**
	   * Create a new declaration.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name name of the new property
	   * @param {String} value value of the new property
	   * @param {String} priority priority of the new property; either
	   *                          the empty string or "important"
	   */
	  createProperty: function (index, name, value, priority) {
	    this.editPromise = this.internalCreateProperty(index, name, value, priority);
	  },

	  /**
	   * Set a declaration's value.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name the property's name
	   * @param {String} value the property's value
	   * @param {String} priority the property's priority, either the empty
	   *                          string or "important"
	   */
	  setProperty: function (index, name, value, priority) {
	    this.completeInitialization(index);
	    // We might see a "set" on a previously non-existent property; in
	    // that case, act like "create".
	    if (!this.decl) {
	      return this.createProperty(index, name, value, priority);
	    }

	    // Note that this assumes that "set" never operates on disabled
	    // properties.
	    this.result += this.inputString.substring(this.decl.offsets[0], this.decl.colonOffsets[1]) + this.sanitizeText(value, index);

	    if (priority === "important") {
	      this.result += " !important";
	    }
	    this.result += ";";
	    this.completeCopying(this.decl.offsets[1]);
	  },

	  /**
	   * Remove a declaration.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name the name of the property to remove
	   */
	  removeProperty: function (index, name) {
	    this.completeInitialization(index);
	    let copyOffset = this.decl.offsets[1];
	    // Maybe removing this rule left us with a completely blank
	    // line.  In this case, we'll delete the whole thing.  We only
	    // bother with this if we're looking at sources that already
	    // have a newline somewhere.
	    if (this.hasNewLine) {
	      let nlOffset = this.skipWhitespaceBackward(this.result, this.decl.offsets[0]);
	      if (nlOffset < 0 || this.result[nlOffset] === "\r" || this.result[nlOffset] === "\n") {
	        let trailingText = this.inputString.substring(copyOffset);
	        let match = BLANK_LINE_RX.exec(trailingText);
	        if (match) {
	          this.result = this.result.substring(0, nlOffset + 1);
	          copyOffset += match[0].length;
	        }
	      }
	    }
	    this.completeCopying(copyOffset);
	  },

	  /**
	   * An internal function to copy any trailing text to the output
	   * string.
	   *
	   * @param {Number} copyOffset Offset into |inputString| of the
	   *        final text to copy to the output string.
	   */
	  completeCopying: function (copyOffset) {
	    // Add the trailing text.
	    this.result += this.inputString.substring(copyOffset);
	  },

	  /**
	   * Apply the modifications in this object to the associated rule.
	   *
	   * @return {Promise} A promise which will be resolved when the modifications
	   *         are complete.
	   */
	  apply: function () {
	    var _this = this;

	    return promise.resolve(this.editPromise).then(function () {
	      return _this.rule.setRuleText(_this.result);
	    });
	  },

	  /**
	   * Get the result of the rewriting.  This is used for testing.
	   *
	   * @return {object} an object of the form {changed: object, text: string}
	   *                  |changed| is an object where each key is
	   *                  the index of a property whose value had to be
	   *                  rewritten during the sanitization process, and
	   *                  whose value is the new text of the property.
	   *                  |text| is the rewritten text of the rule.
	   */
	  getResult: function () {
	    return { changed: this.changedDeclarations, text: this.result };
	  }
	};

	/**
	 * Returns an array of the parsed CSS selector value and type given a string.
	 *
	 * The components making up the CSS selector can be extracted into 3 different
	 * types: element, attribute and pseudoclass. The object that is appended to
	 * the returned array contains the value related to one of the 3 types described
	 * along with the actual type.
	 *
	 * The following are the 3 types that can be returned in the object signature:
	 * (1) SELECTOR_ATTRIBUTE
	 * (2) SELECTOR_ELEMENT
	 * (3) SELECTOR_PSEUDO_CLASS
	 *
	 * @param {String} value
	 *        The CSS selector text.
	 * @return {Array} an array of objects with the following signature:
	 *         [{ "value": string, "type": integer }, ...]
	 */
	function parsePseudoClassesAndAttributes(value) {
	  if (!value) {
	    throw new Error("empty input string");
	  }

	  let tokens = cssTokenizer(value);
	  let result = [];
	  let current = "";
	  let functionCount = 0;
	  let hasAttribute = false;
	  let hasColon = false;

	  for (let token of tokens) {
	    if (token.tokenType === "ident") {
	      current += value.substring(token.startOffset, token.endOffset);

	      if (hasColon && !functionCount) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_PSEUDO_CLASS });
	        }

	        current = "";
	        hasColon = false;
	      }
	    } else if (token.tokenType === "symbol" && token.text === ":") {
	      if (!hasColon) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_ELEMENT });
	        }

	        current = "";
	        hasColon = true;
	      }

	      current += token.text;
	    } else if (token.tokenType === "function") {
	      current += value.substring(token.startOffset, token.endOffset);
	      functionCount++;
	    } else if (token.tokenType === "symbol" && token.text === ")") {
	      current += token.text;

	      if (hasColon && functionCount == 1) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_PSEUDO_CLASS });
	        }

	        current = "";
	        functionCount--;
	        hasColon = false;
	      } else {
	        functionCount--;
	      }
	    } else if (token.tokenType === "symbol" && token.text === "[") {
	      if (!hasAttribute && !functionCount) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_ELEMENT });
	        }

	        current = "";
	        hasAttribute = true;
	      }

	      current += token.text;
	    } else if (token.tokenType === "symbol" && token.text === "]") {
	      current += token.text;

	      if (hasAttribute && !functionCount) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_ATTRIBUTE });
	        }

	        current = "";
	        hasAttribute = false;
	      }
	    } else {
	      current += value.substring(token.startOffset, token.endOffset);
	    }
	  }

	  if (current) {
	    result.push({ value: current, type: SELECTOR_ELEMENT });
	  }

	  return result;
	}

	/**
	 * Expects a single CSS value to be passed as the input and parses the value
	 * and priority.
	 *
	 * @param {String} value
	 *        The value from the text editor.
	 * @return {Object} an object with 'value' and 'priority' properties.
	 */
	function parseSingleValue(value) {
	  let declaration = parseDeclarations("a: " + value + ";")[0];
	  return {
	    value: declaration ? declaration.value : "",
	    priority: declaration ? declaration.priority : ""
	  };
	}

	exports.cssTokenizer = cssTokenizer;
	exports.cssTokenizerWithLineColumn = cssTokenizerWithLineColumn;
	exports.escapeCSSComment = escapeCSSComment;
	// unescapeCSSComment is exported for testing.
	exports._unescapeCSSComment = unescapeCSSComment;
	exports.parseDeclarations = parseDeclarations;
	// parseCommentDeclarations is exported for testing.
	exports._parseCommentDeclarations = parseCommentDeclarations;
	exports.RuleRewriter = RuleRewriter;
	exports.parsePseudoClassesAndAttributes = parsePseudoClassesAndAttributes;
	exports.parseSingleValue = parseSingleValue;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;
	// const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";

	const XUL_NS = "http://www.w3.org/1999/xhtml";

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	var _require3 = __webpack_require__(16);

	const gDevTools = _require3.gDevTools;

	const events = __webpack_require__(7);

	/**
	 * Autocomplete popup UI implementation.
	 *
	 * @constructor
	 * @param nsIDOMDocument aDocument
	 *        The document you want the popup attached to.
	 * @param Object aOptions
	 *        An object consiting any of the following options:
	 *        - panelId {String} The id for the popup panel.
	 *        - listBoxId {String} The id for the richlistbox inside the panel.
	 *        - position {String} The position for the popup panel.
	 *        - theme {String} String related to the theme of the popup.
	 *        - autoSelect {Boolean} Boolean to allow the first entry of the popup
	 *                     panel to be automatically selected when the popup shows.
	 *        - direction {String} The direction of the text in the panel. rtl or ltr
	 *        - onSelect {String} The select event handler for the richlistbox
	 *        - onClick {String} The click event handler for the richlistbox.
	 *        - onKeypress {String} The keypress event handler for the richlistitems.
	 */
	function AutocompletePopup(aDocument, aOptions = {}) {
	  this._document = aDocument;

	  this.autoSelect = aOptions.autoSelect || false;
	  this.position = aOptions.position || "after_start";
	  this.direction = aOptions.direction || "ltr";

	  this.onSelect = aOptions.onSelect;
	  this.onClick = aOptions.onClick;
	  this.onKeypress = aOptions.onKeypress;

	  let id = aOptions.panelId || "devtools_autoCompletePopup";
	  let theme = aOptions.theme || "dark";
	  // If theme is auto, use the devtools.theme pref
	  if (theme == "auto") {
	    theme = "light"; // XXX: Services.prefs.getCharPref("devtools.theme");
	    this.autoThemeEnabled = true;
	    // Setup theme change listener.
	    this._handleThemeChange = this._handleThemeChange.bind(this);
	    // gDevTools.on("pref-changed", this._handleThemeChange);
	  }
	  // Reuse the existing popup elements.
	  this._panel = this._document.getElementById(id);
	  if (!this._panel) {
	    this._panel = this._document.createElementNS(XUL_NS, "panel");
	    this._panel.setAttribute("id", id);
	    this._panel.className = "devtools-autocomplete-popup devtools-monospace " + theme + "-theme";

	    this._panel.setAttribute("noautofocus", "true");
	    this._panel.setAttribute("level", "top");
	    if (!aOptions.onKeypress) {
	      this._panel.setAttribute("ignorekeys", "true");
	    }
	    // Stop this appearing as an alert to accessibility.
	    this._panel.setAttribute("role", "presentation");

	    let mainPopupSet = this._document.getElementById("mainPopupSet");
	    if (mainPopupSet) {
	      mainPopupSet.appendChild(this._panel);
	    } else {
	      this._document.documentElement.appendChild(this._panel);
	    }
	  } else {
	    this._list = this._panel.firstChild;
	  }

	  if (!this._list) {
	    this._list = this._document.createElementNS(XUL_NS, "richlistbox");
	    this._panel.appendChild(this._list);

	    // Open and hide the panel, so we initialize the API of the richlistbox.
	    // XXXX
	    // this._panel.openPopup(null, this.position, 0, 0);
	    // this._panel.hidePopup();
	  }

	  this._list.setAttribute("flex", "1");
	  this._list.setAttribute("seltype", "single");

	  if (aOptions.listBoxId) {
	    this._list.setAttribute("id", aOptions.listBoxId);
	  }
	  this._list.className = "devtools-autocomplete-listbox " + theme + "-theme";

	  if (this.onSelect) {
	    this._list.addEventListener("select", this.onSelect, false);
	  }

	  if (this.onClick) {
	    this._list.addEventListener("click", this.onClick, false);
	  }

	  if (this.onKeypress) {
	    this._list.addEventListener("keypress", this.onKeypress, false);
	  }
	  this._itemIdCounter = 0;

	  events.decorate(this);
	}
	exports.AutocompletePopup = AutocompletePopup;

	AutocompletePopup.prototype = {
	  _document: null,
	  _panel: null,
	  _list: null,
	  __scrollbarWidth: null,

	  // Event handlers.
	  onSelect: null,
	  onClick: null,
	  onKeypress: null,

	  /**
	   * Open the autocomplete popup panel.
	   *
	   * @param nsIDOMNode aAnchor
	   *        Optional node to anchor the panel to.
	   * @param Number aXOffset
	   *        Horizontal offset in pixels from the left of the node to the left
	   *        of the popup.
	   * @param Number aYOffset
	   *        Vertical offset in pixels from the top of the node to the starting
	   *        of the popup.
	   */
	  openPopup: function AP_openPopup(aAnchor, aXOffset = 0, aYOffset = 0) {
	    // XXX
	    // this.__maxLabelLength = -1;
	    // this._updateSize();
	    // this._panel.openPopup(aAnchor, this.position, aXOffset, aYOffset);

	    // if (this.autoSelect) {
	    //   this.selectFirstItem();
	    // }

	    this.emit("popup-opened");
	  },

	  /**
	   * Hide the autocomplete popup panel.
	   */
	  hidePopup: function AP_hidePopup() {
	    // Return accessibility focus to the input.
	    // this._document.activeElement.removeAttribute("aria-activedescendant");
	    // this._panel.hidePopup();
	  },

	  /**
	   * Check if the autocomplete popup is open.
	   */
	  get isOpen() {
	    return this._panel && (this._panel.state == "open" || this._panel.state == "showing");
	  },

	  /**
	   * Destroy the object instance. Please note that the panel DOM elements remain
	   * in the DOM, because they might still be in use by other instances of the
	   * same code. It is the responsability of the client code to perform DOM
	   * cleanup.
	   */
	  destroy: function AP_destroy() {
	    if (this.isOpen) {
	      this.hidePopup();
	    }

	    if (this.onSelect) {
	      this._list.removeEventListener("select", this.onSelect, false);
	    }

	    if (this.onClick) {
	      this._list.removeEventListener("click", this.onClick, false);
	    }

	    if (this.onKeypress) {
	      this._list.removeEventListener("keypress", this.onKeypress, false);
	    }

	    if (this.autoThemeEnabled) {
	      // gDevTools.off("pref-changed", this._handleThemeChange);
	    }

	    this._list.remove();
	    this._panel.remove();
	    this._document = null;
	    this._list = null;
	    this._panel = null;
	  },

	  /**
	   * Get the autocomplete items array.
	   *
	   * @param Number aIndex The index of the item what is wanted.
	   *
	   * @return The autocomplete item at index aIndex.
	   */
	  getItemAtIndex: function AP_getItemAtIndex(aIndex) {
	    return this._list.getItemAtIndex(aIndex)._autocompleteItem;
	  },

	  /**
	   * Get the autocomplete items array.
	   *
	   * @return array
	   *         The array of autocomplete items.
	   */
	  getItems: function AP_getItems() {
	    let items = [];

	    Array.forEach(this._list.childNodes, function (aItem) {
	      items.push(aItem._autocompleteItem);
	    });

	    return items;
	  },

	  /**
	   * Set the autocomplete items list, in one go.
	   *
	   * @param array aItems
	   *        The list of items you want displayed in the popup list.
	   */
	  setItems: function AP_setItems(aItems) {
	    this.clearItems();
	    aItems.forEach(this.appendItem, this);

	    // Make sure that the new content is properly fitted by the XUL richlistbox.
	    if (this.isOpen) {
	      if (this.autoSelect) {
	        this.selectFirstItem();
	      }
	      this._updateSize();
	    }
	  },

	  /**
	   * Selects the first item of the richlistbox. Note that first item here is the
	   * item closes to the input element, which means that 0th index if position is
	   * below, and last index if position is above.
	   */
	  selectFirstItem: function AP_selectFirstItem() {
	    if (this.position.includes("before")) {
	      this.selectedIndex = this.itemCount - 1;
	    } else {
	      this.selectedIndex = 0;
	    }
	    this._list.ensureIndexIsVisible(this._list.selectedIndex);
	  },

	  __maxLabelLength: -1,

	  get _maxLabelLength() {
	    if (this.__maxLabelLength != -1) {
	      return this.__maxLabelLength;
	    }

	    let max = 0;
	    for (let i = 0; i < this._list.childNodes.length; i++) {
	      let item = this._list.childNodes[i]._autocompleteItem;
	      let str = item.label;
	      if (item.count) {
	        str += item.count + "";
	      }
	      max = Math.max(str.length, max);
	    }

	    this.__maxLabelLength = max;
	    return this.__maxLabelLength;
	  },

	  /**
	   * Update the panel size to fit the content.
	   *
	   * @private
	   */
	  _updateSize: function AP__updateSize() {
	    if (!this._panel) {
	      return;
	    }

	    this._list.style.width = this._maxLabelLength + 3 + "ch";
	    this._list.ensureIndexIsVisible(this._list.selectedIndex);
	  },

	  /**
	   * Update accessibility appropriately when the selected item is changed.
	   *
	   * @private
	   */
	  _updateAriaActiveDescendant: function AP__updateAriaActiveDescendant() {
	    if (!this._list.selectedItem) {
	      // Return accessibility focus to the input.
	      this._document.activeElement.removeAttribute("aria-activedescendant");
	      return;
	    }
	    // Focus this for accessibility so users know about the selected item.
	    this._document.activeElement.setAttribute("aria-activedescendant", this._list.selectedItem.id);
	  },

	  /**
	   * Clear all the items from the autocomplete list.
	   */
	  clearItems: function AP_clearItems() {
	    // Reset the selectedIndex to -1 before clearing the list
	    this.selectedIndex = -1;

	    while (this._list.hasChildNodes()) {
	      this._list.removeChild(this._list.firstChild);
	    }

	    this.__maxLabelLength = -1;

	    // Reset the panel and list dimensions. New dimensions are calculated when
	    // a new set of items is added to the autocomplete popup.
	    this._list.width = "";
	    this._list.style.width = "";
	    this._list.height = "";
	    this._panel.width = "";
	    this._panel.height = "";
	    this._panel.top = "";
	    this._panel.left = "";
	  },

	  /**
	   * Getter for the index of the selected item.
	   *
	   * @type number
	   */
	  get selectedIndex() {
	    return this._list.selectedIndex;
	  },

	  /**
	   * Setter for the selected index.
	   *
	   * @param number aIndex
	   *        The number (index) of the item you want to select in the list.
	   */
	  set selectedIndex(aIndex) {
	    this._list.selectedIndex = aIndex;
	    if (this.isOpen && this._list.ensureIndexIsVisible) {
	      this._list.ensureIndexIsVisible(this._list.selectedIndex);
	    }
	    this._updateAriaActiveDescendant();
	  },

	  /**
	   * Getter for the selected item.
	   * @type object
	   */
	  get selectedItem() {
	    return this._list.selectedItem ? this._list.selectedItem._autocompleteItem : null;
	  },

	  /**
	   * Setter for the selected item.
	   *
	   * @param object aItem
	   *        The object you want selected in the list.
	   */
	  set selectedItem(aItem) {
	    this._list.selectedItem = this._findListItem(aItem);
	    if (this.isOpen) {
	      this._list.ensureIndexIsVisible(this._list.selectedIndex);
	    }
	    this._updateAriaActiveDescendant();
	  },

	  /**
	   * Append an item into the autocomplete list.
	   *
	   * @param object aItem
	   *        The item you want appended to the list.
	   *        The item object can have the following properties:
	   *        - label {String} Property which is used as the displayed value.
	   *        - preLabel {String} [Optional] The String that will be displayed
	   *                   before the label indicating that this is the already
	   *                   present text in the input box, and label is the text
	   *                   that will be auto completed. When this property is
	   *                   present, |preLabel.length| starting characters will be
	   *                   removed from label.
	   *        - count {Number} [Optional] The number to represent the count of
	   *                autocompleted label.
	   */
	  appendItem: function AP_appendItem(aItem) {
	    let listItem = this._document.createElementNS(XUL_NS, "richlistitem");
	    // Items must have an id for accessibility.
	    listItem.id = this._panel.id + "_item_" + this._itemIdCounter++;
	    if (this.direction) {
	      listItem.setAttribute("dir", this.direction);
	    }
	    let label = this._document.createElementNS(XUL_NS, "label");
	    label.setAttribute("value", aItem.label);
	    label.setAttribute("class", "autocomplete-value");
	    if (aItem.preLabel) {
	      let preDesc = this._document.createElementNS(XUL_NS, "label");
	      preDesc.setAttribute("value", aItem.preLabel);
	      preDesc.setAttribute("class", "initial-value");
	      listItem.appendChild(preDesc);
	      label.setAttribute("value", aItem.label.slice(aItem.preLabel.length));
	    }
	    listItem.appendChild(label);
	    if (aItem.count && aItem.count > 1) {
	      let countDesc = this._document.createElementNS(XUL_NS, "label");
	      countDesc.setAttribute("value", aItem.count);
	      countDesc.setAttribute("flex", "1");
	      countDesc.setAttribute("class", "autocomplete-count");
	      listItem.appendChild(countDesc);
	    }
	    listItem._autocompleteItem = aItem;

	    this._list.appendChild(listItem);
	  },

	  /**
	   * Find the richlistitem element that belongs to an item.
	   *
	   * @private
	   *
	   * @param object aItem
	   *        The object you want found in the list.
	   *
	   * @return nsIDOMNode|null
	   *         The nsIDOMNode that belongs to the given item object. This node is
	   *         the richlistitem element.
	   */
	  _findListItem: function AP__findListItem(aItem) {
	    for (let i = 0; i < this._list.childNodes.length; i++) {
	      let child = this._list.childNodes[i];
	      if (child._autocompleteItem == aItem) {
	        return child;
	      }
	    }
	    return null;
	  },

	  /**
	   * Remove an item from the popup list.
	   *
	   * @param object aItem
	   *        The item you want removed.
	   */
	  removeItem: function AP_removeItem(aItem) {
	    let item = this._findListItem(aItem);
	    if (!item) {
	      throw new Error("Item not found!");
	    }
	    this._list.removeChild(item);
	  },

	  /**
	   * Getter for the number of items in the popup.
	   * @type number
	   */
	  get itemCount() {
	    return this._list.childNodes.length;
	  },

	  /**
	   * Getter for the height of each item in the list.
	   *
	   * @private
	   *
	   * @type number
	   */
	  get _itemHeight() {
	    return this._list.selectedItem.clientHeight;
	  },

	  /**
	   * Select the next item in the list.
	   *
	   * @return object
	   *         The newly selected item object.
	   */
	  selectNextItem: function AP_selectNextItem() {
	    if (this.selectedIndex < this.itemCount - 1) {
	      this.selectedIndex++;
	    } else {
	      this.selectedIndex = 0;
	    }

	    return this.selectedItem;
	  },

	  /**
	   * Select the previous item in the list.
	   *
	   * @return object
	   *         The newly-selected item object.
	   */
	  selectPreviousItem: function AP_selectPreviousItem() {
	    if (this.selectedIndex > 0) {
	      this.selectedIndex--;
	    } else {
	      this.selectedIndex = this.itemCount - 1;
	    }

	    return this.selectedItem;
	  },

	  /**
	   * Select the top-most item in the next page of items or
	   * the last item in the list.
	   *
	   * @return object
	   *         The newly-selected item object.
	   */
	  selectNextPageItem: function AP_selectNextPageItem() {
	    let itemsPerPane = Math.floor(this._list.scrollHeight / this._itemHeight);
	    let nextPageIndex = this.selectedIndex + itemsPerPane + 1;
	    this.selectedIndex = nextPageIndex > this.itemCount - 1 ? this.itemCount - 1 : nextPageIndex;

	    return this.selectedItem;
	  },

	  /**
	   * Select the bottom-most item in the previous page of items,
	   * or the first item in the list.
	   *
	   * @return object
	   *         The newly-selected item object.
	   */
	  selectPreviousPageItem: function AP_selectPreviousPageItem() {
	    let itemsPerPane = Math.floor(this._list.scrollHeight / this._itemHeight);
	    let prevPageIndex = this.selectedIndex - itemsPerPane - 1;
	    this.selectedIndex = prevPageIndex < 0 ? 0 : prevPageIndex;

	    return this.selectedItem;
	  },

	  /**
	   * Focuses the richlistbox.
	   */
	  focus: function AP_focus() {
	    this._list.focus();
	  },

	  /**
	   * Manages theme switching for the popup based on the devtools.theme pref.
	   *
	   * @private
	   *
	   * @param String aEvent
	   *        The name of the event. In this case, "pref-changed".
	   * @param Object aData
	   *        An object passed by the emitter of the event. In this case, the
	   *        object consists of three properties:
	   *        - pref {String} The name of the preference that was modified.
	   *        - newValue {Object} The new value of the preference.
	   *        - oldValue {Object} The old value of the preference.
	   */
	  _handleThemeChange: function AP__handleThemeChange(aEvent, aData) {
	    if (aData.pref == "devtools.theme") {
	      this._panel.classList.toggle(aData.oldValue + "-theme", false);
	      this._panel.classList.toggle(aData.newValue + "-theme", true);
	      this._list.classList.toggle(aData.oldValue + "-theme", false);
	      this._list.classList.toggle(aData.newValue + "-theme", true);
	    }
	  }
	};

/***/ },
/* 45 */
/***/ function(module, exports) {

	"use strict";module.exports = {"!name":"browser","location":{"assign":{"!type":"fn(url: string)","!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"Load the document at the provided URL."},"replace":{"!type":"fn(url: string)","!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"Replace the current document with the one at the provided URL. The difference from the assign() method is that after using replace() the current page will not be saved in session history, meaning the user won't be able to use the Back button to navigate to it."},"reload":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"Reload the document from the current URL. forceget is a boolean, which, when it is true, causes the page to always be reloaded from the server. If it is false or not specified, the browser may reload the page from its cache."},"origin":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"The origin of the URL."},"hash":{"!type":"string","!url":"https://developer.mthat follows the # symbol, including the # symbol."},"search":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"The part of the URL that follows the ? symbol, including the ? symbol."},"pathname":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"The path (relative to the host)."},"port":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"The port number of the URL."},"hostname":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"The host name (without the port number or square brackets)."},"host":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"The host name and port number."},"protocol":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"The protocol of the URL."},"href":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"The entire URL."},"!url":"https://developer.mozilla.org/en/docs/DOM/window.location","!doc":"Returns a location object with information about the current location of the document. Assigning to the location property changes the current page to the new address."},"Node":{"!type":"fn()","prototype":{"parentElement":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Node.parentElement","!doc":"Returns the DOM node's parent Element, or null if the node either has no parent, or its parent isn't a DOM Element."},"textContent":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Node.textContent","!doc":"Gets or sets the text content of a node and its descendants."},"baseURI":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Node.baseURI","!doc":"The absolute base URI of a node or null if unable to obtain an absolute URI."},"localName":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Node.localName","!doc":"Returns the local part of the qualified name of this node."},"prefix":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Node.prefix","!doc":"Returns the namespace prefix of the specified node, or null if no prefix is specified. This property is read only."},"namespaceURI":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Node.namespaceURI","!doc":"The namespace URI of the node, or null if the node is not in a namespace (read-only). When the node is a document, it returns the XML namespace for the current document."},"ownerDocument":{"!type":"+Document","!url":"https://developer.mozilla.org/en/docs/DOM/Node.ownerDocument","!doc":"The ownerDocument property returns the top-level document object for this node."},"attributes":{"!type":"+NamedNodeMap","!url":"https://developer.mozilla.org/en/docs/DOM/Node.attributes","!doc":"A collection of all attribute nodes registered to the specified node. It is a NamedNodeMap,not an Array, so it has no Array methods and the Attr nodes' indexes may differ among browsers."},"nextSibling":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Node.nextSibling","!doc":"Returns the node immediately following the specified one in its parent's childNodes list, or null if the specified node is the last node in that list."},"previousSibling":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Node.previousSibling","!doc":"Returns the node immediately preceding the specified one in its parent's childNodes list, null if the specified node is the first in that list."},"lastChild":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Node.lastChild","!doc":"Returns the last child of a node."},"firstChild":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Node.firstChild","!doc":"Returns the node's first child in the tree, or null if the node is childless. If the node is a Document, it returns the first node in the list of its direct children."},"childNodes":{"!type":"+NodeList","!url":"https://developer.mozilla.org/en/docs/DOM/Node.childNodes","!doc":"Returns a collection of child nodes of the given element."},"parentNode":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Node.parentNode","!doc":"Returns the parent of the specified node in the DOM tree."},"nodeType":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/Node.nodeType","!doc":"Returns an integer code representing the type of the node."},"nodeValue":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Node.nodeValue","!doc":"Returns or sets the value of the current node."},"nodeName":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Node.nodeName","!doc":"Returns the name of the current node as a string."},"tagName":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Node.nodeName","!doc":"Returns the name of the current node as a string."},"insertBefore":{"!type":"fn(newElt: +Element, before: +Element) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/Node.insertBefore","!doc":"Inserts the specified node before a reference element as a child of the current node."},"replaceChild":{"!type":"fn(newElt: +Element, oldElt: +Element) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/Node.replaceChild","!doc":"Replaces one child node of the specified element with another."},"removeChild":{"!type":"fn(oldElt: +Element) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/Node.removeChild","!doc":"Removes a child node from the DOM. Returns removed node."},"appendChild":{"!type":"fn(newElt: +Element) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/Node.appendChild","!doc":"Adds a node to the end of the list of children of a specified parent node. If the node already exists it is removed from current parent node, then added to new parent node."},"hasChildNodes":{"!type":"fn() -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/Node.hasChildNodes","!doc":"Returns a Boolean value indicating whether the current Node has child nodes or not."},"cloneNode":{"!type":"fn(deep: bool) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/Node.cloneNode","!doc":"Returns a duplicate of the node on which this method was called."},"normalize":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/Node.normalize","!doc":"Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized subtree, no text nodes in the subtree are empty and there are no adjacent text nodes."},"isSupported":{"!type":"fn(features: string, version: number) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/Node.isSupported","!doc":"Tests whether the DOM implementation implements a specific feature and that feature is supported by this node."},"hasAttributes":{"!type":"fn() -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/Node.hasAttributes","!doc":"Returns a boolean value of true or false, indicating if the current element has any attributes or not."},"lookupPrefix":{"!type":"fn(uri: string) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/Node.lookupPrefix","!doc":"Returns the prefix for a given namespaceURI if present, and null if not. When multiple prefixes are possible, the result is implementation-dependent."},"isDefaultNamespace":{"!type":"fn(uri: string) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/Node.isDefaultNamespace","!doc":"Accepts a namespace URI as an argument and returns true if the namespace is the default namespace on the given node or false if not."},"lookupNamespaceURI":{"!type":"fn(uri: string) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/Node.lookupNamespaceURI","!doc":"Takes a prefix and returns the namespaceURI associated with it on the given node if found (and null if not). Supplying null for the prefix will return the default namespace."},"addEventListener":{"!type":"fn(type: string, listener: fn(e: +Event), capture: bool)","!url":"https://developer.mozilla.org/en/docs/DOM/EventTarget.addEventListener","!doc":"Registers a single event listener on a single target. The event target may be a single element in a document, the document itself, a window, or an XMLHttpRequest."},"removeEventListener":{"!type":"fn(type: string, listener: fn(), capture: bool)","!url":"https://developer.mozilla.org/en/docs/DOM/EventTarget.removeEventListener","!doc":"Allows the removal of event listeners from the event target."},"isSameNode":{"!type":"fn(other: +Node) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/Node.isSameNode","!doc":"Tests whether two nodes are the same, that is they reference the same object."},"isEqualNode":{"!type":"fn(other: +Node) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/Node.isEqualNode","!doc":"Tests whether two nodes are equal."},"compareDocumentPosition":{"!type":"fn(other: +Node) -> number","!url":"https://developer.mozilla.org/en/docs/DOM/Node.compareDocumentPosition","!doc":"Compares the position of the current node against another node in any other document."},"contains":{"!type":"fn(other: +Node) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/Node.contains","!doc":"Indicates whether a node is a descendent of a given node."},"dispatchEvent":{"!type":"fn(event: +Event) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/EventTarget.dispatchEvent","!doc":"Dispatches an event into the event system. The event is subject to the same capturing and bubbling behavior as directly dispatched events."},"ELEMENT_NODE":"number","ATTRIBUTE_NODE":"number","TEXT_NODE":"number","CDATA_SECTION_NODE":"number","ENTITY_REFERENCE_NODE":"number","ENTITY_NODE":"number","PROCESSING_INSTRUCTION_NODE":"number","COMMENT_NODE":"number","DOCUMENT_NODE":"number","DOCUMENT_TYPE_NODE":"number","DOCUMENT_FRAGMENT_NODE":"number","NOTATION_NODE":"number","DOCUMENT_POSITION_DISCONNECTED":"number","DOCUMENT_POSITION_PRECEDING":"number","DOCUMENT_POSITION_FOLLOWING":"number","DOCUMENT_POSITION_CONTAINS":"number","DOCUMENT_POSITION_CONTAINED_BY":"number","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC":"number"},"!url":"https://developer.mozilla.org/en/docs/DOM/Node","!doc":"A Node is an interface from which a number of DOM types inherit, and allows these various types to be treated (or tested) similarly."},"Element":{"!type":"fn()","prototype":{"!proto":"Node.prototype","getAttribute":{"!type":"fn(name: string) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/element.getAttribute","!doc":"Returns the value of the named attribute on the specified element. If the named attribute does not exist, the value returned will either be null or \"\" (the empty string)."},"setAttribute":{"!type":"fn(name: string, value: string)","!url":"https://developer.mozilla.org/en/docs/DOM/element.setAttribute","!doc":"Adds a new attribute or changes the value of an existing attribute on the specified element."},"removeAttribute":{"!type":"fn(name: string)","!url":"https://developer.mozilla.org/en/docs/DOM/element.removeAttribute","!doc":"Removes an attribute from the specified element."},"getAttributeNode":{"!type":"fn(name: string) -> +Attr","!url":"https://developer.mozilla.org/en/docs/DOM/element.getAttributeNode","!doc":"Returns the specified attribute of the specified element, as an Attr node."},"getElementsByTagName":{"!type":"fn(tagName: string) -> +NodeList","!url":"https://developer.mozilla.org/en/docs/DOM/element.getElementsByTagName","!doc":"Returns a list of elements with the given tag name. The subtree underneath the specified element is searched, excluding the element itself. The returned list is live, meaning that it updates itself with the DOM tree automatically. Consequently, there is no need to call several times element.getElementsByTagName with the same element and arguments."},"getElementsByTagNameNS":{"!type":"fn(ns: string, tagName: string) -> +NodeList","!url":"https://developer.mozilla.org/en/docs/DOM/element.getElementsByTagNameNS","!doc":"Returns a list of elements with the given tag name belonging to the given namespace."},"getAttributeNS":{"!type":"fn(ns: string, name: string) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/element.getAttributeNS","!doc":"Returns the string value of the attribute with the specified namespace and name. If the named attribute does not exist, the value returned will either be null or \"\" (the empty string)."},"setAttributeNS":{"!type":"fn(ns: string, name: string, value: string)","!url":"https://developer.mozilla.org/en/docs/DOM/element.setAttributeNS","!doc":"Adds a new attribute or changes the value of an attribute with the given namespace and name."},"removeAttributeNS":{"!type":"fn(ns: string, name: string)","!url":"https://developer.mozilla.org/en/docs/DOM/element.removeAttributeNS","!doc":"removeAttributeNS removes the specified attribute from an element."},"getAttributeNodeNS":{"!type":"fn(ns: string, name: string) -> +Attr","!url":"https://developer.mozilla.org/en/docs/DOM/element.getAttributeNodeNS","!doc":"Returns the Attr node for the attribute with the given namespace and name."},"hasAttribute":{"!type":"fn(name: string) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/element.hasAttribute","!doc":"hasAttribute returns a boolean value indicating whether the specified element has the specified attribute or not."},"hasAttributeNS":{"!type":"fn(ns: string, name: string) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/element.hasAttributeNS","!doc":"hasAttributeNS returns a boolean value indicating whether the current element has the specified attribute."},"focus":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/element.focus","!doc":"Sets focus on the specified element, if it can be focused."},"blur":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/element.blur","!doc":"The blur method removes keyboard focus from the current element."},"scrollIntoView":{"!type":"fn(top: bool)","!url":"https://developer.mozilla.org/en/docs/DOM/element.scrollIntoView","!doc":"The scrollIntoView() method scrolls the element into view."},"scrollByLines":{"!type":"fn(lines: number)","!url":"https://developer.mozilla.org/en/docs/DOM/window.scrollByLines","!doc":"Scrolls the document by the given number of lines."},"scrollByPages":{"!type":"fn(pages: number)","!url":"https://developer.mozilla.org/en/docs/DOM/window.scrollByPages","!doc":"Scrolls the current document by the specified number of pages."},"getElementsByClassName":{"!type":"fn(name: string) -> +NodeList","!url":"https://developer.mozilla.org/en/docs/DOM/document.getElementsByClassName","!doc":"Returns a set of elements which have all the given class names. When called on the document object, the complete document is searched, including the root node. You may also call getElementsByClassName on any element; it will return only elements which are descendants of the specified root element with the given class names."},"querySelector":{"!type":"fn(selectors: string) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/Element.querySelector","!doc":"Returns the first element that is a descendent of the element on which it is invoked that matches the specified group of selectors."},"querySelectorAll":{"!type":"fn(selectors: string) -> +NodeList","!url":"https://developer.mozilla.org/en/docs/DOM/Element.querySelectorAll","!doc":"Returns a non-live NodeList of all elements descended from the element on which it is invoked that match the specified group of CSS selectors."},"getClientRects":{"!type":"fn() -> [+ClientRect]","!url":"https://developer.mozilla.org/en/docs/DOM/element.getClientRects","!doc":"Returns a collection of rectangles that indicate the bounding rectangles for each box in a client."},"getBoundingClientRect":{"!type":"fn() -> +ClientRect","!url":"https://developer.mozilla.org/en/docs/DOM/element.getBoundingClientRect","!doc":"Returns a text rectangle object that encloses a group of text rectangles."},"setAttributeNode":{"!type":"fn(attr: +Attr) -> +Attr","!url":"https://developer.mozilla.org/en/docs/DOM/element.setAttributeNode","!doc":"Adds a new Attr node to the specified element."},"removeAttributeNode":{"!type":"fn(attr: +Attr) -> +Attr","!url":"https://developer.mozilla.org/en/docs/DOM/element.removeAttributeNode","!doc":"Removes the specified attribute from the current element."},"setAttributeNodeNS":{"!type":"fn(attr: +Attr) -> +Attr","!url":"https://developer.mozilla.org/en/docs/DOM/element.setAttributeNodeNS","!doc":"Adds a new namespaced attribute node to an element."},"insertAdjacentHTML":{"!type":"fn(position: string, text: string)","!url":"https://developer.mozilla.org/en/docs/DOM/element.insertAdjacentHTML","!doc":"Parses the specified text as HTML or XML and inserts the resulting nodes into the DOM tree at a specified position. It does not reparse the element it is being used on and thus it does not corrupt the existing elements inside the element. This, and avoiding the extra step of serialization make it much faster than direct innerHTML manipulation."},"children":{"!type":"+HTMLCollection","!url":"https://developer.mozilla.org/en/docs/DOM/Element.children","!doc":"Returns a collection of child elements of the given element."},"childElementCount":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/Element.childElementCount","!doc":"Returns the number of child elements of the given element."},"className":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/element.className","!doc":"Gets and sets the value of the class attribute of the specified element."},"style":{"cssText":"string","alignmentBaseline":"string","background":"string","backgroundAttachment":"string","backgroundClip":"string","backgroundColor":"string","backgroundImage":"string","backgroundOrigin":"string","backgroundPosition":"string","backgroundPositionX":"string","backgroundPositionY":"string","backgroundRepeat":"string","backgroundRepeatX":"string","backgroundRepeatY":"string","backgroundSize":"string","baselineShift":"string","border":"string","borderBottom":"string","borderBottomColor":"string","borderBottomLeftRadius":"string","borderBottomRightRadius":"string","borderBottomStyle":"string","borderBottomWidth":"string","borderCollapse":"string","borderColor":"string","borderImage":"string","borderImageOutset":"string","borderImageRepeat":"string","borderImageSlice":"string","borderImageSource":"string","borderImageWidth":"string","borderLeft":"string","borderLeftColor":"string","borderLeftStyle":"string","borderLeftWidth":"string","borderRadius":"string","borderRight":"string","borderRightColor":"string","borderRightStyle":"string","borderRightWidth":"string","borderSpacing":"string","borderStyle":"string","borderTop":"string","borderTopColor":"string","borderTopLeftRadius":"string","borderTopRightRadius":"string","borderTopStyle":"string","borderTopWidth":"string","borderWidth":"string","bottom":"string","boxShadow":"string","boxSizing":"string","captionSide":"string","clear":"string","clip":"string","clipPath":"string","clipRule":"string","color":"string","colorInterpolation":"string","colorInterpolationFilters":"string","colorProfile":"string","colorRendering":"string","content":"string","counterIncrement":"string","counterReset":"string","cursor":"string","direction":"string","display":"string","dominantBaseline":"string","emptyCells":"string","enableBackground":"string","fill":"string","fillOpacity":"string","fillRule":"string","filter":"string","float":"string","floodColor":"string","floodOpacity":"string","font":"string","fontFamily":"string","fontSize":"string","fontStretch":"string","fontStyle":"string","fontVariant":"string","fontWeight":"string","glyphOrientationHorizontal":"string","glyphOrientationVertical":"string","height":"string","imageRendering":"string","kerning":"string","left":"string","letterSpacing":"string","lightingColor":"string","lineHeight":"string","listStyle":"string","listStyleImage":"string","listStylePosition":"string","listStyleType":"string","margin":"string","marginBottom":"string","marginLeft":"string","marginRight":"string","marginTop":"string","marker":"string","markerEnd":"string","markerMid":"string","markerStart":"string","mask":"string","maxHeight":"string","maxWidth":"string","minHeight":"string","minWidth":"string","opacity":"string","orphans":"string","outline":"string","outlineColor":"string","outlineOffset":"string","outlineStyle":"string","outlineWidth":"string","overflow":"string","overflowWrap":"string","overflowX":"string","overflowY":"string","padding":"string","paddingBottom":"string","paddingLeft":"string","paddingRight":"string","paddingTop":"string","page":"string","pageBreakAfter":"string","pageBreakBefore":"string","pageBreakInside":"string","pointerEvents":"string","position":"string","quotes":"string","resize":"string","right":"string","shapeRendering":"string","size":"string","speak":"string","src":"string","stopColor":"string","stopOpacity":"string","stroke":"string","strokeDasharray":"string","strokeDashoffset":"string","strokeLinecap":"string","strokeLinejoin":"string","strokeMiterlimit":"string","strokeOpacity":"string","strokeWidth":"string","tabSize":"string","tableLayout":"string","textAlign":"string","textAnchor":"string","textDecoration":"string","textIndent":"string","textLineThrough":"string","textLineThroughColor":"string","textLineThroughMode":"string","textLineThroughStyle":"string","textLineThroughWidth":"string","textOverflow":"string","textOverline":"string","textOverlineColor":"string","textOverlineMode":"string","textOverlineStyle":"string","textOverlineWidth":"string","textRendering":"string","textShadow":"string","textTransform":"string","textUnderline":"string","textUnderlineColor":"string","textUnderlineMode":"string","textUnderlineStyle":"string","textUnderlineWidth":"string","top":"string","unicodeBidi":"string","unicodeRange":"string","vectorEffect":"string","verticalAlign":"string","visibility":"string","whiteSpace":"string","width":"string","wordBreak":"string","wordSpacing":"string","wordWrap":"string","writingMode":"string","zIndex":"string","zoom":"string","!url":"https://developer.mozilla.org/en/docs/DOM/element.style","!doc":"Returns an object that represents the element's style attribute."},"classList":{"!type":"+DOMTokenList","!url":"https://developer.mozilla.org/en/docs/DOM/element.classList","!doc":"Returns a token list of the class attribute of the element."},"contentEditable":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/Element.contentEditable","!doc":"Indicates whether or not the element is editable."},"firstElementChild":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Element.firstElementChild","!doc":"Returns the element's first child element or null if there are no child elements."},"lastElementChild":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Element.lastElementChild","!doc":"Returns the element's last child element or null if there are no child elements."},"nextElementSibling":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Element.nextElementSibling","!doc":"Returns the element immediately following the specified one in its parent's children list, or null if the specified element is the last one in the list."},"previousElementSibling":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Element.previousElementSibling","!doc":"Returns the element immediately prior to the specified one in its parent's children list, or null if the specified element is the first one in the list."},"tabIndex":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.tabIndex","!doc":"Gets/sets the tab order of the current element."},"title":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/element.title","!doc":"Establishes the text to be displayed in a 'tool tip' popup when the mouse is over the displayed node."},"width":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.offsetWidth","!doc":"Returns the layout width of an element."},"height":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.offsetHeight","!doc":"Height of an element relative to the element's offsetParent."},"getContext":{"!type":"fn(id: string) -> CanvasRenderingContext2D","!url":"https://developer.mozilla.org/en/docs/DOM/HTMLCanvasElement","!doc":"DOM canvas elements expose the HTMLCanvasElement interface, which provides properties and methods for manipulating the layout and presentation of canvas elements. The HTMLCanvasElement interface inherits the properties and methods of the element object interface."},"supportsContext":"fn(id: string) -> bool","oncopy":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.oncopy","!doc":"The oncopy property returns the onCopy event handler code on the current element."},"oncut":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.oncut","!doc":"The oncut property returns the onCut event handler code on the current element."},"onpaste":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onpaste","!doc":"The onpaste property returns the onPaste event handler code on the current element."},"onbeforeunload":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/HTML/Element/body","!doc":"The HTML <body> element represents the main content of an HTML document. There is only one <body> element in a document."},"onfocus":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onfocus","!doc":"The onfocus property returns the onFocus event handler code on the current element."},"onblur":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onblur","!doc":"The onblur property returns the onBlur event handler code, if any, that exists on the current element."},"onchange":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onchange","!doc":"The onchange property sets and returns the onChange event handler code for the current element."},"onclick":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onclick","!doc":"The onclick property returns the onClick event handler code on the current element."},"ondblclick":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.ondblclick","!doc":"The ondblclick property returns the onDblClick event handler code on the current element."},"onmousedown":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onmousedown","!doc":"The onmousedown property returns the onMouseDown event handler code on the current element."},"onmouseup":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onmouseup","!doc":"The onmouseup property returns the onMouseUp event handler code on the current element."},"onmousewheel":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/wheel","!doc":"The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. This event deprecates the legacy mousewheel event."},"onmouseover":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onmouseover","!doc":"The onmouseover property returns the onMouseOver event handler code on the current element."},"onmouseout":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onmouseout","!doc":"The onmouseout property returns the onMouseOut event handler code on the current element."},"onmousemove":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onmousemove","!doc":"The onmousemove property returns the mousemove event handler code on the current element."},"oncontextmenu":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.oncontextmenu","!doc":"An event handler property for right-click events on the window. Unless the default behavior is prevented, the browser context menu will activate. Note that this event will occur with any non-disabled right-click event and does not depend on an element possessing the \"contextmenu\" attribute."},"onkeydown":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onkeydown","!doc":"The onkeydown property returns the onKeyDown event handler code on the current element."},"onkeyup":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onkeyup","!doc":"The onkeyup property returns the onKeyUp event handler code for the current element."},"onkeypress":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onkeypress","!doc":"The onkeypress property sets and returns the onKeyPress event handler code for the current element."},"onresize":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onresize","!doc":"onresize returns the element's onresize event handler code. It can also be used to set the code to be executed when the resize event occurs."},"onscroll":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onscroll","!doc":"The onscroll property returns the onScroll event handler code on the current element."},"ondragstart":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations","!doc":"The following describes the steps that occur during a drag and drop operation."},"ondragover":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragover","!doc":"The dragover event is fired when an element or text selection is being dragged over a valid drop target (every few hundred milliseconds)."},"ondragleave":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragleave","!doc":"The dragleave event is fired when a dragged element or text selection leaves a valid drop target."},"ondragenter":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragenter","!doc":"The dragenter event is fired when a dragged element or text selection enters a valid drop target."},"ondragend":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragend","!doc":"The dragend event is fired when a drag operation is being ended (by releasing a mouse button or hitting the escape key)."},"ondrag":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/drag","!doc":"The drag event is fired when an element or text selection is being dragged (every few hundred milliseconds)."},"offsetTop":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.offsetTop","!doc":"Returns the distance of the current element relative to the top of the offsetParent node."},"offsetLeft":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.offsetLeft","!doc":"Returns the number of pixels that the upper left corner of the current element is offset to the left within the offsetParent node."},"offsetHeight":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.offsetHeight","!doc":"Height of an element relative to the element's offsetParent."},"offsetWidth":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.offsetWidth","!doc":"Returns the layout width of an element."},"scrollTop":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.scrollTop","!doc":"Gets or sets the number of pixels that the content of an element is scrolled upward."},"scrollLeft":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.scrollLeft","!doc":"Gets or sets the number of pixels that an element's content is scrolled to the left."},"scrollHeight":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.scrollHeight","!doc":"Height of the scroll view of an element; it includes the element padding but not its margin."},"scrollWidth":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.scrollWidth","!doc":"Read-only property that returns either the width in pixels of the content of an element or the width of the element itself, whichever is greater."},"clientTop":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.clientTop","!doc":"The width of the top border of an element in pixels. It does not include the top margin or padding. clientTop is read-only."},"clientLeft":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.clientLeft","!doc":"The width of the left border of an element in pixels. It includes the width of the vertical scrollbar if the text direction of the element is right-to-left and if there is an overflow causing a left vertical scrollbar to be rendered. clientLeft does not include the left margin or the left padding. clientLeft is read-only."},"clientHeight":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.clientHeight","!doc":"Returns the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin."},"clientWidth":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.clientWidth","!doc":"The inner width of an element in pixels. It includes padding but not the vertical scrollbar (if present, if rendered), border or margin."},"innerHTML":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/element.innerHTML","!doc":"Sets or gets the HTML syntax describing the element's descendants."}},"!url":"https://developer.mozilla.org/en/docs/DOM/Element","!doc":"Represents an element in an HTML or XML document."},"Text":{"!type":"fn()","prototype":{"!proto":"Node.prototype","wholeText":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Text.wholeText","!doc":"Returns all text of all Text nodes logically adjacent to the node.  The text is concatenated in document order.  This allows you to specify any text node and obtain all adjacent text as a single string."},"splitText":{"!type":"fn(offset: number) -> +Text","!url":"https://developer.mozilla.org/en/docs/DOM/Text.splitText","!doc":"Breaks the Text node into two nodes at the specified offset, keeping both nodes in the tree as siblings."}},"!url":"https://developer.mozilla.org/en/docs/DOM/Text","!doc":"In the DOM, the Text interface represents the textual content of an Element or Attr.  If an element has no markup within its content, it has a single child implementing Text that contains the element's text.  However, if the element contains markup, it is parsed into information items and Text nodes that form its children."},"Document":{"!type":"fn()","prototype":{"!proto":"Node.prototype","activeElement":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/document.activeElement","!doc":"Returns the currently focused element, that is, the element that will get keystroke events if the user types any. This attribute is read only."},"compatMode":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.compatMode","!doc":"Indicates whether the document is rendered in Quirks mode or Strict mode."},"designMode":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.designMode","!doc":"Can be used to make any document editable, for example in a <iframe />:"},"dir":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Document.dir","!doc":"This property should indicate and allow the setting of the directionality of the text of the document, whether left to right (default) or right to left."},"height":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/document.height","!doc":"Returns the height of the <body> element of the current document."},"width":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/document.width","!doc":"Returns the width of the <body> element of the current document in pixels."},"characterSet":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.characterSet","!doc":"Returns the character encoding of the current document."},"readyState":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.readyState","!doc":"Returns \"loading\" while the document is loading, \"interactive\" once it is finished parsing but still loading sub-resources, and \"complete\" once it has loaded."},"location":{"!type":"location","!url":"https://developer.mozilla.org/en/docs/DOM/document.location","!doc":"Returns a Location object, which contains information about the URL of the document and provides methods for changing that URL."},"lastModified":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.lastModified","!doc":"Returns a string containing the date and time on which the current document was last modified."},"head":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/document.head","!doc":"Returns the <head> element of the current document. If there are more than one <head> elements, the first one is returned."},"body":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/document.body","!doc":"Returns the <body> or <frameset> node of the current document."},"cookie":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.cookie","!doc":"Get and set the cookies associated with the current document."},"URL":"string","domain":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.domain","!doc":"Gets/sets the domain portion of the origin of the current document, as used by the same origin policy."},"referrer":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.referrer","!doc":"Returns the URI of the page that linked to this page."},"title":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.title","!doc":"Gets or sets the title of the document."},"defaultView":{"!url":"https://developer.mozilla.org/en/docs/DOM/document.defaultView","!doc":"In browsers returns the window object associated with the document or null if none available."},"documentURI":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.documentURI","!doc":"Returns the document location as string. It is read-only per DOM4 specification."},"xmlStandalone":"bool","xmlVersion":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.xmlVersion","!doc":"Returns the version number as specified in the XML declaration (e.g., <?xml version=\"1.0\"?>) or \"1.0\" if the declaration is absent."},"xmlEncoding":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Document.xmlEncoding","!doc":"Returns the encoding as determined by the XML declaration. Should be null if unspecified or unknown."},"inputEncoding":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/document.inputEncoding","!doc":"Returns a string representing the encoding under which the document was parsed (e.g. ISO-8859-1)."},"documentElement":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/document.documentElement","!doc":"Read-only"},"implementation":{"hasFeature":"fn(feature: string, version: number) -> bool","createDocumentType":{"!type":"fn(qualifiedName: string, publicId: string, systemId: string) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/DOMImplementation.createDocumentType","!doc":"Returns a DocumentType object which can either be used with DOMImplementation.createDocument upon document creation or they can be put into the document via Node.insertBefore() or Node.replaceChild(): http://www.w3.org/TR/DOM-Level-3-Cor...l#ID-B63ED1A31 (less ideal due to features not likely being as accessible: http://www.w3.org/TR/DOM-Level-3-Cor...createDocument ). In any case, entity declarations and notations will not be available: http://www.w3.org/TR/DOM-Level-3-Cor...-createDocType   "},"createHTMLDocument":{"!type":"fn(title: string) -> +Document","!url":"https://developer.mozilla.org/en/docs/DOM/DOMImplementation.createHTMLDocument","!doc":"This method (available from document.implementation) creates a new HTML document."},"createDocument":{"!type":"fn(namespaceURI: string, qualifiedName: string, type: +Node) -> +Document","!url":"https://developer.mozilla.org/en-US/docs/DOM/DOMImplementation.createHTMLDocument","!doc":"This method creates a new HTML document."},"!url":"https://developer.mozilla.org/en/docs/DOM/document.implementation","!doc":"Returns a DOMImplementation object associated with the current document."},"doctype":{"!type":"+Node","!url":"https://developer.mozilla.org/en/docs/DOM/document.doctype","!doc":"Returns the Document Type Declaration (DTD) associated with current document. The returned object implements the DocumentType interface. Use DOMImplementation.createDocumentType() to create a DocumentType."},"open":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/document.open","!doc":"The document.open() method opens a document for writing."},"close":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/document.close","!doc":"The document.close() method finishes writing to a document, opened with document.open()."},"write":{"!type":"fn(html: string)","!url":"https://developer.mozilla.org/en/docs/DOM/document.write","!doc":"Writes a string of text to a document stream opened by document.open()."},"writeln":{"!type":"fn(html: string)","!url":"https://developer.mozilla.org/en/docs/DOM/document.writeln","!doc":"Writes a string of text followed by a newline character to a document."},"clear":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/document.clear","!doc":"In recent versions of Mozilla-based applications as well as in Internet Explorer and Netscape 4 this method does nothing."},"hasFocus":{"!type":"fn() -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/document.hasFocus","!doc":"Returns a Boolean value indicating whether the document or any element inside the document has focus. This method can be used to determine whether the active element in a document has focus."},"createElement":{"!type":"fn(tagName: string) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/document.createElement","!doc":"Creates the specified element."},"createElementNS":{"!type":"fn(ns: string, tagName: string) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/document.createElementNS","!doc":"Creates an element with the specified namespace URI and qualified name."},"createDocumentFragment":{"!type":"fn() -> +DocumentFragment","!url":"https://developer.mozilla.org/en/docs/DOM/document.createDocumentFragment","!doc":"Creates a new empty DocumentFragment."},"createTextNode":{"!type":"fn(content: string) -> +Text","!url":"https://developer.mozilla.org/en/docs/DOM/document.createTextNode","!doc":"Creates a new Text node."},"createComment":{"!type":"fn(content: string) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/document.createComment","!doc":"Creates a new comment node, and returns it."},"createCDATASection":{"!type":"fn(content: string) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/document.createCDATASection","!doc":"Creates a new CDATA section node, and returns it. "},"createProcessingInstruction":{"!type":"fn(content: string) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/document.createProcessingInstruction","!doc":"Creates a new processing instruction node, and returns it."},"createAttribute":{"!type":"fn(name: string) -> +Attr","!url":"https://developer.mozilla.org/en/docs/DOM/document.createAttribute","!doc":"Creates a new attribute node, and returns it."},"createAttributeNS":{"!type":"fn(ns: string, name: string) -> +Attr","!url":"https://developer.mozilla.org/en/docs/DOM/Attr","!doc":"This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."},"importNode":{"!type":"fn(node: +Node, deep: bool) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/document.importNode","!doc":"Creates a copy of a node from an external document that can be inserted into the current document."},"getElementById":{"!type":"fn(id: string) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/document.getElementById","!doc":"Returns a reference to the element by its ID."},"getElementsByTagName":{"!type":"fn(tagName: string) -> +NodeList","!url":"https://developer.mozilla.org/en/docs/DOM/document.getElementsByTagName","!doc":"Returns a NodeList of elements with the given tag name. The complete document is searched, including the root node. The returned NodeList is live, meaning that it updates itself automatically to stay in sync with the DOM tree without having to call document.getElementsByTagName again."},"getElementsByTagNameNS":{"!type":"fn(ns: string, tagName: string) -> +NodeList","!url":"https://developer.mozilla.org/en/docs/DOM/document.getElementsByTagNameNS","!doc":"Returns a list of elements with the given tag name belonging to the given namespace. The complete document is searched, including the root node."},"createEvent":{"!type":"fn(type: string) -> +Event","!url":"https://developer.mozilla.org/en/docs/DOM/document.createEvent","!doc":"Creates an event of the type specified. The returned object should be first initialized and can then be passed to element.dispatchEvent."},"createRange":{"!type":"fn() -> +Range","!url":"https://developer.mozilla.org/en/docs/DOM/document.createRange","!doc":"Returns a new Range object."},"evaluate":{"!type":"fn(expr: ?) -> +XPathResult","!url":"https://developer.mozilla.org/en/docs/DOM/document.evaluate","!doc":"Returns an XPathResult based on an XPath expression and other given parameters."},"execCommand":{"!type":"fn(cmd: string)","!url":"https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla#Executing_Commands","!doc":"Run command to manipulate the contents of an editable region."},"queryCommandEnabled":{"!type":"fn(cmd: string) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/document","!doc":"Returns true if the Midas command can be executed on the current range."},"queryCommandIndeterm":{"!type":"fn(cmd: string) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/document","!doc":"Returns true if the Midas command is in a indeterminate state on the current range."},"queryCommandState":{"!type":"fn(cmd: string) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/document","!doc":"Returns true if the Midas command has been executed on the current range."},"queryCommandSupported":{"!type":"fn(cmd: string) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/document.queryCommandSupported","!doc":"Reports whether or not the specified editor query command is supported by the browser."},"queryCommandValue":{"!type":"fn(cmd: string) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/document","!doc":"Returns the current value of the current range for Midas command."},"getElementsByName":{"!type":"fn(name: string) -> +HTMLCollection","!url":"https://developer.mozilla.org/en/docs/DOM/document.getElementsByName","!doc":"Returns a list of elements with a given name in the HTML document."},"elementFromPoint":{"!type":"fn(x: number, y: number) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/document.elementFromPoint","!doc":"Returns the element from the document whose elementFromPoint method is being called which is the topmost element which lies under the given point.  To get an element, specify the point via coordinates, in CSS pixels, relative to the upper-left-most point in the window or frame containing the document."},"getSelection":{"!type":"fn() -> +Selection","!url":"https://developer.mozilla.org/en/docs/DOM/document.getSelection","!doc":"The DOM getSelection() method is available on the Window and Document interfaces."},"adoptNode":{"!type":"fn(node: +Node) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/document.adoptNode","!doc":"Adopts a node from an external document. The node and its subtree is removed from the document it's in (if any), and its ownerDocument is changed to the current document. The node can then be inserted into the current document."},"createTreeWalker":{"!type":"fn(root: +Node, mask: number) -> ?","!url":"https://developer.mozilla.org/en/docs/DOM/document.createTreeWalker","!doc":"Returns a new TreeWalker object."},"createExpression":{"!type":"fn(text: string) -> ?","!url":"https://developer.mozilla.org/en/docs/DOM/document.createExpression","!doc":"This method compiles an XPathExpression which can then be used for (repeated) evaluations."},"createNSResolver":{"!type":"fn(node: +Node)","!url":"https://developer.mozilla.org/en/docs/DOM/document.createNSResolver","!doc":"Creates an XPathNSResolver which resolves namespaces with respect to the definitions in scope for a specified node."},"scripts":{"!type":"+HTMLCollection","!url":"https://developer.mozilla.org/en/docs/DOM/Document.scripts","!doc":"Returns a list of the <script> elements in the document. The returned object is an HTMLCollection."},"plugins":{"!type":"+HTMLCollection","!url":"https://developer.mozilla.org/en/docs/DOM/document.plugins","!doc":"Returns an HTMLCollection object containing one or more HTMLEmbedElements or null which represent the <embed> elements in the current document."},"embeds":{"!type":"+HTMLCollection","!url":"https://developer.mozilla.org/en/docs/DOM/document.embeds","!doc":"Returns a list of the embedded OBJECTS within the current document."},"anchors":{"!type":"+HTMLCollection","!url":"https://developer.mozilla.org/en/docs/DOM/document.anchors","!doc":"Returns a list of all of the anchors in the document."},"links":{"!type":"+HTMLCollection","!url":"https://developer.mozilla.org/en/docs/DOM/document.links","!doc":"The links property returns a collection of all AREA elements and anchor elements in a document with a value for the href attribute. "},"forms":{"!type":"+HTMLCollection","!url":"https://developer.mozilla.org/en/docs/DOM/document.forms","!doc":"Returns a collection (an HTMLCollection) of the form elements within the current document."},"styleSheets":{"!type":"+HTMLCollection","!url":"https://developer.mozilla.org/en/docs/DOM/document.styleSheets","!doc":"Returns a list of stylesheet objects for stylesheets explicitly linked into or embedded in a document."},"querySelector":"Element.prototype.querySelector","querySelectorAll":"Element.prototype.querySelectorAll"},"!url":"https://developer.mozilla.org/en/docs/DOM/document","!doc":"Each web page loaded in the browser has its own document object. This object serves as an entry point to the web page's content (the DOM tree, including elements such as <body> and <table>) and provides functionality global to the document (such as obtaining the page's URL and creating new elements in the document)."},"document":{"!type":"+Document","!url":"https://developer.mozilla.org/en/docs/DOM/document","!doc":"Each web page loaded in the browser has its own document object. This object serves as an entry point to the web page's content (the DOM tree, including elements such as <body> and <table>) and provides functionality global to the document (such as obtaining the page's URL and creating new elements in the document)."},"XMLDocument":{"!type":"fn()","prototype":"Document.prototype","!url":"https://developer.mozilla.org/en/docs/Parsing_and_serializing_XML","!doc":"The Web platform provides the following objects for parsing and serializing XML:"},"Attr":{"!type":"fn()","prototype":{"isId":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/Attr","!doc":"This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."},"name":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Attr","!doc":"This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."},"value":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Attr","!doc":"This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."}},"!url":"https://developer.mozilla.org/en/docs/DOM/Attr","!doc":"This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."},"NodeList":{"!type":"fn()","prototype":{"length":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.length","!doc":"Returns the number of items in a NodeList."},"item":{"!type":"fn(i: number) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/NodeList.item","!doc":"Returns a node from a NodeList by index."},"<i>":"+Element"},"!url":"https://developer.mozilla.org/en/docs/DOM/NodeList","!doc":"NodeList objects are collections of nodes returned by getElementsByTagName, getElementsByTagNameNS, Node.childNodes, querySelectorAll, getElementsByClassName, etc."},"HTMLCollection":{"!type":"fn()","prototype":{"length":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/HTMLCollection","!doc":"The number of items in the collection."},"item":{"!type":"fn(i: number) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/HTMLCollection","!doc":"Returns the specific node at the given zero-based index into the list. Returns null if the index is out of range."},"namedItem":{"!type":"fn(name: string) -> +Element","!url":"https://developer.mozilla.org/en/docs/DOM/HTMLCollection","!doc":"Returns the specific node whose ID or, as a fallback, name matches the string specified by name. Matching by name is only done as a last resort, only in HTML, and only if the referenced element supports the name attribute. Returns null if no node exists by the given name."},"<i>":"+Element"},"!url":"https://developer.mozilla.org/en/docs/DOM/HTMLCollection","!doc":"HTMLCollection is an interface representing a generic collection of elements (in document order) and offers methods and properties for traversing the list."},"NamedNodeMap":{"!type":"fn()","prototype":{"length":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/NamedNodeMap","!doc":"The number of items in the map."},"getNamedItem":{"!type":"fn(name: string) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/NamedNodeMap","!doc":"Gets a node by name."},"setNamedItem":{"!type":"fn(node: +Node) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/NamedNodeMap","!doc":"Adds (or replaces) a node by its nodeName."},"removeNamedItem":{"!type":"fn(name: string) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/NamedNodeMap","!doc":"Removes a node (or if an attribute, may reveal a default if present)."},"item":{"!type":"fn(i: number) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/NamedNodeMap","!doc":"Returns the item at the given index (or null if the index is higher or equal to the number of nodes)."},"getNamedItemNS":{"!type":"fn(ns: string, name: string) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/NamedNodeMap","!doc":"Gets a node by namespace and localName."},"setNamedItemNS":{"!type":"fn(node: +Node) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/NamedNodeMap","!doc":"Adds (or replaces) a node by its localName and namespaceURI."},"removeNamedItemNS":{"!type":"fn(ns: string, name: string) -> +Node","!url":"https://developer.mozilla.org/en/docs/DOM/NamedNodeMap","!doc":"Removes a node (or if an attribute, may reveal a default if present)."},"<i>":"+Node"},"!url":"https://developer.mozilla.org/en/docs/DOM/NamedNodeMap","!doc":"A collection of nodes returned by Element.attributes (also potentially for DocumentType.entities, DocumentType.notations). NamedNodeMaps are not in any particular order (unlike NodeList), although they may be accessed by an index as in an array (they may also be accessed with the item() method). A NamedNodeMap object are live and will thus be auto-updated if changes are made to their contents internally or elsewhere."},"DocumentFragment":{"!type":"fn()","prototype":{"!proto":"Node.prototype"},"!url":"https://developer.mozilla.org/en/docs/DOM/document.createDocumentFragment","!doc":"Creates a new empty DocumentFragment."},"DOMTokenList":{"!type":"fn()","prototype":{"length":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/DOMTokenList","!doc":"The amount of items in the list."},"item":{"!type":"fn(i: number) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/DOMTokenList","!doc":"Returns an item in the list by its index."},"contains":{"!type":"fn(token: string) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/DOMTokenList","!doc":"Return true if the underlying string contains token, otherwise false."},"add":{"!type":"fn(token: string)","!url":"https://developer.mozilla.org/en/docs/DOM/DOMTokenList","!doc":"Adds token to the underlying string."},"remove":{"!type":"fn(token: string)","!url":"https://developer.mozilla.org/en/docs/DOM/DOMTokenList","!doc":"Remove token from the underlying string."},"toggle":{"!type":"fn(token: string) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/DOMTokenList","!doc":"Removes token from string and returns false. If token doesn't exist it's added and the function returns true."},"<i>":"string"},"!url":"https://developer.mozilla.org/en/docs/DOM/DOMTokenList","!doc":"This type represents a set of space-separated tokens. Commonly returned by HTMLElement.classList, HTMLLinkElement.relList, HTMLAnchorElement.relList or HTMLAreaElement.relList. It is indexed beginning with 0 as with JavaScript arrays. DOMTokenList is always case-sensitive."},"XPathResult":{"!type":"fn()","prototype":{"boolValue":"bool","invalidIteratorState":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript","!doc":"This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."},"numberValue":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/XPathResult","!doc":"Refer to nsIDOMXPathResult for more detail."},"resultType":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/document.evaluate","!doc":"Returns an XPathResult based on an XPath expression and other given parameters."},"singleNodeValue":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript","!doc":"This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."},"snapshotLength":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/XPathResult","!doc":"Refer to nsIDOMXPathResult for more detail."},"stringValue":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript","!doc":"This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."},"iterateNext":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript","!doc":"This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."},"snapshotItem":{"!type":"fn()","!url":"https://developer.mozilla.org/en-US/docs/XPathResult#snapshotItem()"},"ANY_TYPE":"number","NUMBER_TYPE":"number","STRING_TYPE":"number","BOOL_TYPE":"number","UNORDERED_NODE_ITERATOR_TYPE":"number","ORDERED_NODE_ITERATOR_TYPE":"number","UNORDERED_NODE_SNAPSHOT_TYPE":"number","ORDERED_NODE_SNAPSHOT_TYPE":"number","ANY_UNORDERED_NODE_TYPE":"number","FIRST_ORDERED_NODE_TYPE":"number"},"!url":"https://developer.mozilla.org/en/docs/XPathResult","!doc":"Refer to nsIDOMXPathResult for more detail."},"ClientRect":{"!type":"fn()","prototype":{"top":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.getClientRects","!doc":"Top of the box, in pixels, relative to the viewport."},"left":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.getClientRects","!doc":"Left of the box, in pixels, relative to the viewport."},"bottom":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.getClientRects","!doc":"Bottom of the box, in pixels, relative to the viewport."},"right":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/element.getClientRects","!doc":"Right of the box, in pixels, relative to the viewport."}},"!url":"https://developer.mozilla.org/en/docs/DOM/element.getClientRects","!doc":"Returns a collection of rectangles that indicate the bounding rectangles for each box in a client."},"Event":{"!type":"fn()","prototype":{"stopPropagation":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/event.stopPropagation","!doc":"Prevents further propagation of the current event."},"preventDefault":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/event.preventDefault","!doc":"Cancels the event if it is cancelable, without stopping further propagation of the event."},"initEvent":{"!type":"fn(type: string, bubbles: bool, cancelable: bool)","!url":"https://developer.mozilla.org/en/docs/DOM/event.initEvent","!doc":"The initEvent method is used to initialize the value of an event created using document.createEvent."},"stopImmediatePropagation":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/event.stopImmediatePropagation","!doc":"Prevents other listeners of the same event to be called."},"NONE":"number","CAPTURING_PHASE":"number","AT_TARGET":"number","BUBBLING_PHASE":"number","MOUSEDOWN":"number","MOUSEUP":"number","MOUSEOVER":"number","MOUSEOUT":"number","MOUSEMOVE":"number","MOUSEDRAG":"number","CLICK":"number","DBLCLICK":"number","KEYDOWN":"number","KEYUP":"number","KEYPRESS":"number","DRAGDROP":"number","FOCUS":"number","BLUR":"number","SELECT":"number","CHANGE":"number","target":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/EventTarget","!doc":"An EventTarget is a DOM interface implemented by objects that can receive DOM events and have listeners for them. The most common EventTargets are DOM elements, although other objects can be EventTargets too, for example document, window, XMLHttpRequest, and others."},"relatedTarget":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/event.relatedTarget","!doc":"Identifies a secondary target for the event."},"pageX":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/event.pageX","!doc":"Returns the horizontal coordinate of the event relative to whole document."},"pageY":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/event.pageY","!doc":"Returns the vertical coordinate of the event relative to the whole document."},"clientX":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/event.clientX","!doc":"Returns the horizontal coordinate within the application's client area at which the event occurred (as opposed to the coordinates within the page). For example, clicking in the top-left corner of the client area will always result in a mouse event with a clientX value of 0, regardless of whether the page is scrolled horizontally."},"clientY":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/event.clientY","!doc":"Returns the vertical coordinate within the application's client area at which the event occurred (as opposed to the coordinates within the page). For example, clicking in the top-left corner of the client area will always result in a mouse event with a clientY value of 0, regardless of whether the page is scrolled vertically."},"keyCode":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/event.keyCode","!doc":"Returns the Unicode value of a non-character key in a keypress event or any key in any other type of keyboard event."},"charCode":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/event.charCode","!doc":"Returns the Unicode value of a character key pressed during a keypress event."},"which":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/event.which","!doc":"Returns the numeric keyCode of the key pressed, or the character code (charCode) for an alphanumeric key pressed."},"button":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/event.button","!doc":"Indicates which mouse button caused the event."},"shiftKey":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/event.shiftKey","!doc":"Indicates whether the SHIFT key was pressed when the event fired."},"ctrlKey":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/event.ctrlKey","!doc":"Indicates whether the CTRL key was pressed when the event fired."},"altKey":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/event.altKey","!doc":"Indicates whether the ALT key was pressed when the event fired."},"metaKey":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/event.metaKey","!doc":"Indicates whether the META key was pressed when the event fired."},"returnValue":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/window.onbeforeunload","!doc":"An event that fires when a window is about to unload its resources. The document is still visible and the event is still cancelable."},"cancelBubble":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/event.cancelBubble","!doc":"bool is the boolean value of true or false."},"dataTransfer":{"dropEffect":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DragDrop/DataTransfer","!doc":"The actual effect that will be used, and should always be one of the possible values of effectAllowed."},"effectAllowed":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations","!doc":"Specifies the effects that are allowed for this drag."},"files":{"!type":"+FileList","!url":"https://developer.mozilla.org/en/docs/DragDrop/DataTransfer","!doc":"Contains a list of all the local files available on the data transfer."},"types":{"!type":"[string]","!url":"https://developer.mozilla.org/en-US/docs/DragDrop/DataTransfer","!doc":"Holds a list of the format types of the data that is stored for the first item, in the same order the data was added. An empty list will be returned if no data was added."},"addElement":{"!type":"fn(element: +Element)","!url":"https://developer.mozilla.org/en/docs/DragDrop/DataTransfer","!doc":"Set the drag source."},"clearData":{"!type":"fn(type?: string)","!url":"https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations","!doc":"Remove the data associated with a given type."},"getData":{"!type":"fn(type: string) -> string","!url":"https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations","!doc":"Retrieves the data for a given type, or an empty string if data for that type does not exist or the data transfer contains no data."},"setData":{"!type":"fn(type: string, data: string)","!url":"https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations","!doc":"Set the data for a given type."},"setDragImage":{"!type":"fn(image: +Element)","!url":"https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations","!doc":"Set the image to be used for dragging if a custom one is desired."},"!url":"https://developer.mozilla.org/en/docs/DragDrop/DataTransfer","!doc":"This object is available from the dataTransfer property of all drag events. It cannot be created separately."}},"!url":"https://developer.mozilla.org/en-US/docs/DOM/event","!doc":"The DOM Event interface is accessible from within the handler function, via the event object passed as the first argument."},"TouchEvent":{"!type":"fn()","prototype":"Event.prototype","!url":"https://developer.mozilla.org/en/docs/DOM/Touch_events","!doc":"In order to provide quality support for touch-based user interfaces, touch events offer the ability to interpret finger activity on touch screens or trackpads."},"WheelEvent":{"!type":"fn()","prototype":"Event.prototype","!url":"https://developer.mozilla.org/en/docs/DOM/WheelEvent","!doc":"The DOM WheelEvent represents events that occur due to the user moving a mouse wheel or similar input device."},"MouseEvent":{"!type":"fn()","prototype":"Event.prototype","!url":"https://developer.mozilla.org/en/docs/DOM/MouseEvent","!doc":"The DOM MouseEvent represents events that occur due to the user interacting with a pointing device (such as a mouse). It's represented by the nsINSDOMMouseEvent interface, which extends the nsIDOMMouseEvent interface."},"KeyboardEvent":{"!type":"fn()","prototype":"Event.prototype","!url":"https://developer.mozilla.org/en/docs/DOM/KeyboardEvent","!doc":"KeyboardEvent objects describe a user interaction with the keyboard. Each event describes a key; the event type (keydown, keypress, or keyup) identifies what kind of activity was performed."},"HashChangeEvent":{"!type":"fn()","prototype":"Event.prototype","!url":"https://developer.mozilla.org/en/docs/DOM/window.onhashchange","!doc":"The hashchange event fires when a window's hash changes."},"ErrorEvent":{"!type":"fn()","prototype":"Event.prototype","!url":"https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/error","!doc":"The error event is fired whenever a resource fails to load."},"CustomEvent":{"!type":"fn()","prototype":"Event.prototype","!url":"https://developer.mozilla.org/en/docs/DOM/Event/CustomEvent","!doc":"The DOM CustomEvent are events initialized by an application for any purpose."},"BeforeLoadEvent":{"!type":"fn()","prototype":"Event.prototype","!url":"https://developer.mozilla.org/en/docs/DOM/window","!doc":"This section provides a brief reference for all of the methods, properties, and events available through the DOM window object. The window object implements the Window interface, which in turn inherits from the AbstractView interface. Some additional global functions, namespaces objects, and constructors, not typically associated with the window, but available on it, are listed in the JavaScript Reference."},"WebSocket":{"!type":"fn(url: string)","prototype":{"close":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/CloseEvent","!doc":"A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute."},"send":{"!type":"fn(data: string)","!url":"https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket","!doc":"The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."},"binaryType":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket","!doc":"The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."},"bufferedAmount":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications","!doc":"WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."},"extensions":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket","!doc":"The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."},"onclose":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/CloseEvent","!doc":"A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute."},"onerror":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications","!doc":"WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."},"onmessage":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket","!doc":"The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."},"onopen":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket","!doc":"The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."},"protocol":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/WebSockets","!doc":"WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply."},"url":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications","!doc":"WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."},"CONNECTING":"number","OPEN":"number","CLOSING":"number","CLOSED":"number"},"!url":"https://developer.mozilla.org/en/docs/WebSockets","!doc":"WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply."},"Worker":{"!type":"fn(scriptURL: string)","prototype":{"postMessage":{"!type":"fn(message: ?)","!url":"https://developer.mozilla.org/en/docs/DOM/Worker","!doc":"Sends a message to the worker's inner scope. This accepts a single parameter, which is the data to send to the worker. The data may be any value or JavaScript object handled by the structured clone algorithm, which includes cyclical references."},"terminate":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/Worker","!doc":"Immediately terminates the worker. This does not offer the worker an opportunity to finish its operations; it is simply stopped at once."},"onmessage":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/Worker","!doc":"An event listener that is called whenever a MessageEvent with type message bubbles through the worker. The message is stored in the event's data member."},"onerror":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/Worker","!doc":"An event listener that is called whenever an ErrorEvent with type error bubbles through the worker."}},"!url":"https://developer.mozilla.org/en/docs/DOM/Worker","!doc":"Workers are background tasks that can be easily created and can send messages back to their creators. Creating a worker is as simple as calling the Worker() constructor, specifying a script to be run in the worker thread."},"localStorage":{"setItem":{"!type":"fn(name: string, value: string)","!url":"https://developer.mozilla.org/en/docs/DOM/Storage","!doc":"Store an item in storage."},"getItem":{"!type":"fn(name: string) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/Storage","!doc":"Retrieve an item from storage."},"!url":"https://developer.mozilla.org/en/docs/DOM/Storage","!doc":"The DOM Storage mechanism is a means through which string key/value pairs can be securely stored and later retrieved for use."},"sessionStorage":{"setItem":{"!type":"fn(name: string, value: string)","!url":"https://developer.mozilla.org/en/docs/DOM/Storage","!doc":"Store an item in storage."},"getItem":{"!type":"fn(name: string) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/Storage","!doc":"Retrieve an item from storage."},"!url":"https://developer.mozilla.org/en/docs/DOM/Storage","!doc":"This is a global object (sessionStorage) that maintains a storage area that's available for the duration of the page session. A page session lasts for as long as the browser is open and survives over page reloads and restores. Opening a page in a new tab or window will cause a new session to be initiated."},"FileList":{"!type":"fn()","prototype":{"length":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/FileList","!doc":"A read-only value indicating the number of files in the list."},"item":{"!type":"fn(i: number) -> +File","!url":"https://developer.mozilla.org/en/docs/DOM/FileList","!doc":"Returns a File object representing the file at the specified index in the file list."},"<i>":"+File"},"!url":"https://developer.mozilla.org/en/docs/DOM/FileList","!doc":"An object of this type is returned by the files property of the HTML input element; this lets you access the list of files selected with the <input type=\"file\"> element. It's also used for a list of files dropped into web content when using the drag and drop API."},"File":{"!type":"fn()","prototype":{"!proto":"Blob.prototype","fileName":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/File.fileName","!doc":"Returns the name of the file. For security reasons the path is excluded from this property."},"fileSize":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/File.fileSize","!doc":"Returns the size of a file in bytes."},"lastModifiedDate":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/File.lastModifiedDate","!doc":"Returns the last modified date of the file. Files without a known last modified date use the current date instead."},"name":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/File.name","!doc":"Returns the name of the file. For security reasons, the path is excluded from this property."}},"!url":"https://developer.mozilla.org/en/docs/DOM/File","!doc":"The File object provides information about -- and access to the contents of -- files. These are generally retrieved from a FileList object returned as a result of a user selecting files using the input element, or from a drag and drop operation's DataTransfer object."},"Blob":{"!type":"fn(parts: [?], properties?: ?)","prototype":{"size":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/Blob","!doc":"The size, in bytes, of the data contained in the Blob object. Read only."},"type":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/Blob","!doc":"An ASCII-encoded string, in all lower case, indicating the MIME type of the data contained in the Blob. If the type is unknown, this string is empty. Read only."},"slice":{"!type":"fn(start: number, end?: number, type?: string) -> +Blob","!url":"https://developer.mozilla.org/en/docs/DOM/Blob","!doc":"Returns a new Blob object containing the data in the specified range of bytes of the source Blob."}},"!url":"https://developer.mozilla.org/en/docs/DOM/Blob","!doc":"A Blob object represents a file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system."},"FileReader":{"!type":"fn()","prototype":{"abort":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Aborts the read operation. Upon return, the readyState will be DONE."},"readAsArrayBuffer":{"!type":"fn(blob: +Blob)","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Starts reading the contents of the specified Blob, producing an ArrayBuffer."},"readAsBinaryString":{"!type":"fn(blob: +Blob)","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Starts reading the contents of the specified Blob, producing raw binary data."},"readAsDataURL":{"!type":"fn(blob: +Blob)","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Starts reading the contents of the specified Blob, producing a data: url."},"readAsText":{"!type":"fn(blob: +Blob, encoding?: string)","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Starts reading the contents of the specified Blob, producing a string."},"EMPTY":"number","LOADING":"number","DONE":"number","error":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"The error that occurred while reading the file. Read only."},"readyState":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Indicates the state of the FileReader. This will be one of the State constants. Read only."},"result":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"The file's contents. This property is only valid after the read operation is complete, and the format of the data depends on which of the methods was used to initiate the read operation. Read only."},"onabort":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Called when the read operation is aborted."},"onerror":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Called when an error occurs."},"onload":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Called when the read operation is successfully completed."},"onloadend":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Called when the read is completed, whether successful or not. This is called after either onload or onerror."},"onloadstart":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Called when reading the data is about to begin."},"onprogress":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"Called periodically while the data is being read."}},"!url":"https://developer.mozilla.org/en/docs/DOM/FileReader","!doc":"The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read. File objects may be obtained from a FileList object returned as a result of a user selecting files using the <input> element, from a drag and drop operation's DataTransfer object, or from the mozGetAsFile() API on an HTMLCanvasElement."},"Range":{"!type":"fn()","prototype":{"collapsed":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/range.collapsed","!doc":"Returns a boolean indicating whether the range's start and end points are at the same position."},"commonAncestorContainer":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/range.commonAncestorContainer","!doc":"Returns the deepest Node that contains the  startContainer and  endContainer Nodes."},"endContainer":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/range.endContainer","!doc":"Returns the Node within which the Range ends."},"endOffset":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/range.endOffset","!doc":"Returns a number representing where in the  endContainer the Range ends."},"startContainer":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/range.startContainer","!doc":"Returns the Node within which the Range starts."},"startOffset":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/range.startOffset","!doc":"Returns a number representing where in the startContainer the Range starts."},"setStart":{"!type":"fn(node: +Element, offset: number)","!url":"https://developer.mozilla.org/en/docs/DOM/range.setStart","!doc":"Sets the start position of a Range."},"setEnd":{"!type":"fn(node: +Element, offset: number)","!url":"https://developer.mozilla.org/en/docs/DOM/range.setEnd","!doc":"Sets the end position of a Range."},"setStartBefore":{"!type":"fn(node: +Element)","!url":"https://developer.mozilla.org/en/docs/DOM/range.setStartBefore","!doc":"Sets the start position of a Range relative to another Node."},"setStartAfter":{"!type":"fn(node: +Element)","!url":"https://developer.mozilla.org/en/docs/DOM/range.setStartAfter","!doc":"Sets the start position of a Range relative to a Node."},"setEndBefore":{"!type":"fn(node: +Element)","!url":"https://developer.mozilla.org/en/docs/DOM/range.setEndBefore","!doc":"Sets the end position of a Range relative to another Node."},"setEndAfter":{"!type":"fn(node: +Element)","!url":"https://developer.mozilla.org/en/docs/DOM/range.setEndAfter","!doc":"Sets the end position of a Range relative to another Node."},"selectNode":{"!type":"fn(node: +Element)","!url":"https://developer.mozilla.org/en/docs/DOM/range.selectNode","!doc":"Sets the Range to contain the Node and its contents."},"selectNodeContents":{"!type":"fn(node: +Element)","!url":"https://developer.mozilla.org/en/docs/DOM/range.selectNodeContents","!doc":"Sets the Range to contain the contents of a Node."},"collapse":{"!type":"fn(toStart: bool)","!url":"https://developer.mozilla.org/en/docs/DOM/range.collapse","!doc":"Collapses the Range to one of its boundary points."},"cloneContents":{"!type":"fn() -> +DocumentFragment","!url":"https://developer.mozilla.org/en/docs/DOM/range.cloneContents","!doc":"Returns a DocumentFragment copying the Nodes of a Range."},"deleteContents":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/range.deleteContents","!doc":"Removes the contents of a Range from the Document."},"extractContents":{"!type":"fn() -> +DocumentFragment","!url":"https://developer.mozilla.org/en/docs/DOM/range.extractContents","!doc":"Moves contents of a Range from the document tree into a DocumentFragment."},"insertNode":{"!type":"fn(node: +Element)","!url":"https://developer.mozilla.org/en/docs/DOM/range.insertNode","!doc":"Insert a node at the start of a Range."},"surroundContents":{"!type":"fn(node: +Element)","!url":"https://developer.mozilla.org/en/docs/DOM/range.surroundContents","!doc":"Moves content of a Range into a new node, placing the new node at the start of the specified range."},"compareBoundaryPoints":{"!type":"fn(how: number, other: +Range) -> number","!url":"https://developer.mozilla.org/en/docs/DOM/range.compareBoundaryPoints","!doc":"Compares the boundary points of two Ranges."},"cloneRange":{"!type":"fn() -> +Range","!url":"https://developer.mozilla.org/en/docs/DOM/range.cloneRange","!doc":"Returns a Range object with boundary points identical to the cloned Range."},"detach":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/range.detach","!doc":"Releases a Range from use to improve performance. This lets the browser choose to release resources associated with this Range. Subsequent attempts to use the detached range will result in a DOMException being thrown with an error code of INVALID_STATE_ERR."},"END_TO_END":"number","END_TO_START":"number","START_TO_END":"number","START_TO_START":"number"},"!url":"https://developer.mozilla.org/en/docs/DOM/range.detach","!doc":"Releases a Range from use to improve performance. This lets the browser choose to release resources associated with this Range. Subsequent attempts to use the detached range will result in a DOMException being thrown with an error code of INVALID_STATE_ERR."},"XMLHttpRequest":{"!type":"fn()","prototype":{"abort":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"Aborts the request if it has already been sent."},"getAllResponseHeaders":{"!type":"fn() -> string","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"Returns all the response headers as a string, or null if no response has been received. Note: For multipart requests, this returns the headers from the current part of the request, not from the original channel."},"getResponseHeader":{"!type":"fn(header: string) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"Returns the string containing the text of the specified header, or null if either the response has not yet been received or the header doesn't exist in the response."},"open":{"!type":"fn(method: string, url: string, async?: bool, user?: string, password?: string)","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"Initializes a request."},"overrideMimeType":{"!type":"fn(type: string)","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"Overrides the MIME type returned by the server."},"send":{"!type":"fn(data?: string)","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent. If the request is synchronous, this method doesn't return until the response has arrived."},"setRequestHeader":{"!type":"fn(header: string, value: string)","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"Sets the value of an HTTP request header.You must call setRequestHeader() after open(), but before send()."},"onreadystatechange":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"A JavaScript function object that is called whenever the readyState attribute changes."},"readyState":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"The state of the request. (0=unsent, 1=opened, 2=headers_received, 3=loading, 4=done)"},"response":{"!type":"+Document","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"The response entity body according to responseType, as an ArrayBuffer, Blob, Document, JavaScript object (for \"json\"), or string. This is null if the request is not complete or was not successful."},"responseText":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"The response to the request as text, or null if the request was unsuccessful or has not yet been sent."},"responseType":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"Can be set to change the response type."},"responseXML":{"!type":"+Document","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"The response to the request as a DOM Document object, or null if the request was unsuccessful, has not yet been sent, or cannot be parsed as XML or HTML."},"status":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"The status of the response to the request. This is the HTTP result code"},"statusText":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"The response string returned by the HTTP server. Unlike status, this includes the entire text of the response message (\"200 OK\", for example)."},"timeout":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest/Synchronous_and_Asynchronous_Requests","!doc":"The number of milliseconds a request can take before automatically being terminated. A value of 0 (which is the default) means there is no timeout."},"UNSENT":"number","OPENED":"number","HEADERS_RECEIVED":"number","LOADING":"number","DONE":"number"},"!url":"https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest","!doc":"XMLHttpRequest is a JavaScript object that was designed by Microsoft and adopted by Mozilla, Apple, and Google. It's now being standardized in the W3C. It provides an easy way to retrieve data at a URL. Despite its name, XMLHttpRequest can be used to retrieve any type of data, not just XML, and it supports protocols other than HTTP (including file and ftp)."},"DOMParser":{"!type":"fn()","prototype":{"parseFromString":{"!type":"fn(data: string, mime: string) -> +Document","!url":"https://developer.mozilla.org/en/docs/DOM/DOMParser","!doc":"DOMParser can parse XML or HTML source stored in a string into a DOM Document. DOMParser is specified in DOM Parsing and Serialization."}},"!url":"https://developer.mozilla.org/en/docs/DOM/DOMParser","!doc":"DOMParser can parse XML or HTML source stored in a string into a DOM Document. DOMParser is specified in DOM Parsing and Serialization."},"Selection":{"!type":"fn()","prototype":{"anchorNode":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/anchorNode","!doc":"Returns the node in which the selection begins."},"anchorOffset":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/anchorOffset","!doc":"Returns the number of characters that the selection's anchor is offset within the anchorNode."},"focusNode":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/focusNode","!doc":"Returns the node in which the selection ends."},"focusOffset":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/focusOffset","!doc":"Returns the number of characters that the selection's focus is offset within the focusNode. "},"isCollapsed":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/isCollapsed","!doc":"Returns a boolean indicating whether the selection's start and end points are at the same position."},"rangeCount":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/rangeCount","!doc":"Returns the number of ranges in the selection."},"getRangeAt":{"!type":"fn(i: number) -> +Range","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/getRangeAt","!doc":"Returns a range object representing one of the ranges currently selected."},"collapse":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/collapse","!doc":"Collapses the current selection to a single point. The document is not modified. If the content is focused and editable, the caret will blink there."},"extend":{"!type":"fn(node: +Element, offset: number)","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/extend","!doc":"Moves the focus of the selection to a specified point. The anchor of the selection does not move. The selection will be from the anchor to the new focus regardless of direction."},"collapseToStart":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/collapseToStart","!doc":"Collapses the selection to the start of the first range in the selection.  If the content of the selection is focused and editable, the caret will blink there."},"collapseToEnd":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/collapseToEnd","!doc":"Collapses the selection to the end of the last range in the selection.  If the content the selection is in is focused and editable, the caret will blink there."},"selectAllChildren":{"!type":"fn(node: +Element)","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/selectAllChildren","!doc":"Adds all the children of the specified node to the selection. Previous selection is lost."},"addRange":{"!type":"fn(range: +Range)","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/addRange","!doc":"Adds a Range to a Selection."},"removeRange":{"!type":"fn(range: +Range)","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/removeRange","!doc":"Removes a range from the selection."},"removeAllRanges":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/removeAllRanges","!doc":"Removes all ranges from the selection, leaving the anchorNode and focusNode properties equal to null and leaving nothing selected. "},"deleteFromDocument":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/deleteFromDocument","!doc":"Deletes the actual text being represented by a selection object from the document's DOM."},"containsNode":{"!type":"fn(node: +Element) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/Selection/containsNode","!doc":"Indicates if the node is part of the selection."}},"!url":"https://developer.mozilla.org/en/docs/DOM/Selection","!doc":"Selection is the class of the object returned by window.getSelection() and other methods. It represents the text selection in the greater page, possibly spanning multiple elements, when the user drags over static text and other parts of the page. For information about text selection in an individual text editing element."},"console":{"error":{"!type":"fn(text: string)","!url":"https://developer.mozilla.org/en/docs/DOM/console.error","!doc":"Outputs an error message to the Web Console."},"info":{"!type":"fn(text: string)","!url":"https://developer.mozilla.org/en/docs/DOM/console.info","!doc":"Outputs an informational message to the Web Console."},"log":{"!type":"fn(text: string)","!url":"https://developer.mozilla.org/en/docs/DOM/console.log","!doc":"Outputs a message to the Web Console."},"warn":{"!type":"fn(text: string)","!url":"https://developer.mozilla.org/en/docs/DOM/console.warn","!doc":"Outputs a warning message to the Web Console."},"!url":"https://developer.mozilla.org/en/docs/DOM/console","!doc":"The console object provides access to the browser's debugging console. The specifics of how it works vary from browser to browser, but there is a de facto set of features that are typically provided."},"top":{"!type":"<top>","!url":"https://developer.mozilla.org/en/docs/DOM/window.top","!doc":"Returns a reference to the topmost window in the window hierarchy."},"parent":{"!type":"<top>","!url":"https://developer.mozilla.org/en/docs/DOM/window.parent","!doc":"A reference to the parent of the current window or subframe."},"window":{"!type":"<top>","!url":"https://developer.mozilla.org/en/docs/DOM/window","!doc":"This section provides a brief reference for all of the methods, properties, and events available through the DOM window object. The window object implements the Window interface, which in turn inherits from the AbstractView interface. Some additional global functions, namespaces objects, and constructors, not typically associated with the window, but available on it, are listed in the JavaScript Reference."},"opener":{"!type":"<top>","!url":"https://developer.mozilla.org/en/docs/DOM/window.opener","!doc":"Returns a reference to the window that opened this current window."},"self":{"!type":"<top>","!url":"https://developer.mozilla.org/en/docs/DOM/window.self","!doc":"Returns an object reference to the window object. "},"devicePixelRatio":"number","name":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/Function/name","!doc":"The name of the function."},"closed":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/window.closed","!doc":"This property indicates whether the referenced window is closed or not."},"pageYOffset":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.scrollY","!doc":"Returns the number of pixels that the document has already been scrolled vertically."},"pageXOffset":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.scrollX","!doc":"Returns the number of pixels that the document has already been scrolled vertically."},"scrollY":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.scrollY","!doc":"Returns the number of pixels that the document has already been scrolled vertically."},"scrollX":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.scrollX","!doc":"Returns the number of pixels that the document has already been scrolled vertically."},"screenTop":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.screen.top","!doc":"Returns the distance in pixels from the top side of the current screen."},"screenLeft":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.screen.left","!doc":"Returns the distance in pixels from the left side of the main screen to the left side of the current screen."},"screenY":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/event.screenY","!doc":"Returns the vertical coordinate of the event within the screen as a whole."},"screenX":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/event.screenX","!doc":"Returns the horizontal coordinate of the event within the screen as a whole."},"innerWidth":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.innerWidth","!doc":"Width (in pixels) of the browser window viewport including, if rendered, the vertical scrollbar."},"innerHeight":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.innerHeight","!doc":"Height (in pixels) of the browser window viewport including, if rendered, the horizontal scrollbar."},"outerWidth":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.outerWidth","!doc":"window.outerWidth gets the width of the outside of the browser window. It represents the width of the whole browser window including sidebar (if expanded), window chrome and window resizing borders/handles."},"outerHeight":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.outerHeight","!doc":"window.outerHeight gets the height in pixels of the whole browser window."},"frameElement":{"!type":"+Element","!url":"https://developer.mozilla.org/en/docs/DOM/window.frameElement","!doc":"Returns the element (such as <iframe> or <object>) in which the window is embedded, or null if the window is top-level."},"crypto":{"getRandomValues":{"!type":"fn([number])","!url":"https://developer.mozilla.org/en/docs/DOM/window.crypto.getRandomValues","!doc":"This methods lets you get cryptographically random values."},"!url":"https://developer.mozilla.org/en/docs/DOM/window.crypto.getRandomValues","!doc":"This methods lets you get cryptographically random values."},"navigator":{"appName":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.navigator.appName","!doc":"Returns the name of the browser. The HTML5 specification also allows any browser to return \"Netscape\" here, for compatibility reasons."},"appVersion":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.navigator.appVersion","!doc":"Returns the version of the browser as a string. It may be either a plain version number, like \"5.0\", or a version number followed by more detailed information. The HTML5 specification also allows any browser to return \"4.0\" here, for compatibility reasons."},"language":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.navigator.language","!doc":"Returns a string representing the language version of the browser."},"platform":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.navigator.platform","!doc":"Returns a string representing the platform of the browser."},"plugins":{"!type":"[?]","!url":"https://developer.mozilla.org/en/docs/DOM/window.navigator.plugins","!doc":"Returns a PluginArray object, listing the plugins installed in the application."},"userAgent":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.navigator.userAgent","!doc":"Returns the user agent string for the current browser."},"vendor":{"!type":"string","!url":"https://developer.mozilla.org/en/docs/DOM/window.navigator.vendor","!doc":"Returns the name of the browser vendor for the current browser."},"javaEnabled":{"!type":"bool","!url":"https://developer.mozilla.org/en/docs/DOM/window.navigator.javaEnabled","!doc":"This method indicates whether the current browser is Java-enabled or not."},"!url":"https://developer.mozilla.org/en/docs/DOM/window.navigator","!doc":"Returns a reference to the navigator object, which can be queried for information about the application running the script."},"history":{"state":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history","!doc":"The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."},"length":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history","!doc":"The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."},"go":{"!type":"fn(delta: number)","!url":"https://developer.mozilla.org/en/docs/DOM/window.history","!doc":"Returns a reference to the History object, which provides an interface for manipulating the browser session history (pages visited in the tab or frame that the current page is loaded in)."},"forward":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history","!doc":"The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."},"back":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history","!doc":"The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."},"pushState":{"!type":"fn(data: ?, title: string, url?: string)","!url":"https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history","!doc":"The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."},"replaceState":{"!type":"fn(data: ?, title: string, url?: string)","!url":"https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history","!doc":"The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."},"!url":"https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history","!doc":"The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."},"screen":{"availWidth":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.screen.availWidth","!doc":"Returns the amount of horizontal space in pixels available to the window."},"availHeight":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.screen.availHeight","!doc":"Returns the amount of vertical space available to the window on the screen."},"availTop":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.screen.availTop","!doc":"Specifies the y-coordinate of the first pixel that is not allocated to permanent or semipermanent user interface features."},"availLeft":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.screen.availLeft","!doc":"Returns the first available pixel available from the left side of the screen."},"pixelDepth":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.screen.pixelDepth","!doc":"Returns the bit depth of the screen."},"colorDepth":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.screen.colorDepth","!doc":"Returns the color depth of the screen."},"width":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.screen.width","!doc":"Returns the width of the screen."},"height":{"!type":"number","!url":"https://developer.mozilla.org/en/docs/DOM/window.screen.height","!doc":"Returns the height of the screen in pixels."},"!url":"https://developer.mozilla.org/en/docs/DOM/window.screen","!doc":"Returns a reference to the screen object associated with the window."},"postMessage":{"!type":"fn(message: string, targetOrigin: string)","!url":"https://developer.mozilla.org/en/docs/DOM/window.postMessage","!doc":"window.postMessage, when called, causes a MessageEvent to be dispatched at the target window when any pending script that must be executed completes (e.g. remaining event handlers if window.postMessage is called from an event handler, previously-set pending timeouts, etc.). The MessageEvent has the type message, a data property which is set to the value of the first argument provided to window.postMessage, an origin property corresponding to the origin of the main document in the window calling window.postMessage at the time window.postMessage was called, and a source property which is the window from which window.postMessage is called. (Other standard properties of events are present with their expected values.)"},"close":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/window.close","!doc":"Closes the current window, or a referenced window."},"blur":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/element.blur","!doc":"The blur method removes keyboard focus from the current element."},"focus":{"!type":"fn()","!url":"https://developer.mozilla.org/en/docs/DOM/element.focus","!doc":"Sets focus on the specified element, if it can be focused."},"onload":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onload","!doc":"An event handler for the load event of a window."},"onunload":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onunload","!doc":"The unload event is raised when the window is unloading its content and resources. The resources removal is processed after the unload event occurs."},"onscroll":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onscroll","!doc":"Specifies the function to be called when the window is scrolled."},"onresize":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onresize","!doc":"An event handler for the resize event on the window."},"ononline":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/document.ononline","!doc":",fgh s dgkljgsdfl dfjg sdlgj sdlg sdlfj dlg jkdfkj dfjgdfkglsdfjsdlfkgj hdflkg hdlkfjgh dfkjgh"},"onoffline":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/Online_and_offline_events","!doc":"Some browsers implement Online/Offline events from the WHATWG Web Applications 1.0 specification."},"onmousewheel":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/mousewheel","!doc":"The DOM mousewheel event is fired asynchronously when mouse wheel or similar device is operated. It's represented by the MouseWheelEvent interface."},"onmouseup":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onmouseup","!doc":"An event handler for the mouseup event on the window."},"onmouseover":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onmouseover","!doc":"The onmouseover property returns the onMouseOver event handler code on the current element."},"onmouseout":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onmouseout","!doc":"The onmouseout property returns the onMouseOut event handler code on the current element."},"onmousemove":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onmousemove","!doc":"The onmousemove property returns the mousemove event handler code on the current element."},"onmousedown":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onmousedown","!doc":"An event handler for the mousedown event on the window."},"onclick":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onclick","!doc":"The onclick property returns the onClick event handler code on the current element."},"ondblclick":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.ondblclick","!doc":"The ondblclick property returns the onDblClick event handler code on the current element."},"onmessage":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/Worker","!doc":"Dedicated Web Workers provide a simple means for web content to run scripts in background threads.  Once created, a worker can send messages to the spawning task by posting messages to an event handler specified by the creator."},"onkeyup":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onkeyup","!doc":"The onkeyup property returns the onKeyUp event handler code for the current element."},"onkeypress":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onkeypress","!doc":"The onkeypress property sets and returns the onKeyPress event handler code for the current element."},"onkeydown":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onkeydown","!doc":"An event handler for the keydown event on the window."},"oninput":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/input","!doc":"The DOM input event is fired synchronously when the value of an <input> or <textarea> element is changed. Additionally, it's also fired on contenteditable editors when its contents are changed. In this case, the event target is the editing host element. If there are two or more elements which have contenteditable as true, \"editing host\" is the nearest ancestor element whose parent isn't editable. Similarly, it's also fired on root element of designMode editors."},"onpopstate":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onpopstate","!doc":"An event handler for the popstate event on the window."},"onhashchange":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onhashchange","!doc":"The hashchange event fires when a window's hash changes."},"onfocus":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onfocus","!doc":"The onfocus property returns the onFocus event handler code on the current element."},"onblur":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onblur","!doc":"The onblur property returns the onBlur event handler code, if any, that exists on the current element."},"onerror":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onerror","!doc":"An event handler for runtime script errors."},"ondrop":{"!type":"?","!url":"https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/drop","!doc":"The drop event is fired when an element or text selection is dropped on a valid drop target."},"ondragstart":{"!type":"?","!url":"https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragstart","!doc":"The dragstart event is fired when the user starts dragging an element or text selection."},"ondragover":{"!type":"?","!url":"https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragover","!doc":"The dragover event is fired when an element or text selection is being dragged over a valid drop target (every few hundred milliseconds)."},"ondragleave":{"!type":"?","!url":"https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragleave","!doc":"The dragleave event is fired when a dragged element or text selection leaves a valid drop target."},"ondragenter":{"!type":"?","!url":"https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragenter","!doc":"The dragenter event is fired when a dragged element or text selection enters a valid drop target."},"ondragend":{"!type":"?","!url":"https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragend","!doc":"The dragend event is fired when a drag operation is being ended (by releasing a mouse button or hitting the escape key)."},"ondrag":{"!type":"?","!url":"https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/drag","!doc":"The drag event is fired when an element or text selection is being dragged (every few hundred milliseconds)."},"oncontextmenu":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.oncontextmenu","!doc":"An event handler property for right-click events on the window. Unless the default behavior is prevented, the browser context menu will activate (though IE8 has a bug with this and will not activate the context menu if a contextmenu event handler is defined). Note that this event will occur with any non-disabled right-click event and does not depend on an element possessing the \"contextmenu\" attribute."},"onchange":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/element.onchange","!doc":"The onchange property sets and returns the onChange event handler code for the current element."},"onbeforeunload":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onbeforeunload","!doc":"An event that fires when a window is about to unload its resources. The document is still visible and the event is still cancelable."},"onabort":{"!type":"?","!url":"https://developer.mozilla.org/en/docs/DOM/window.onabort","!doc":"An event handler for abort events sent to the window."},"getSelection":{"!type":"fn() -> +Selection","!url":"https://developer.mozilla.org/en/docs/DOM/window.getSelection","!doc":"Returns a selection object representing the range of text selected by the user. "},"alert":{"!type":"fn(message: string)","!url":"https://developer.mozilla.org/en/docs/DOM/window.alert","!doc":"Display an alert dialog with the specified content and an OK button."},"confirm":{"!type":"fn(message: string) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/window.confirm","!doc":"Displays a modal dialog with a message and two buttons, OK and Cancel."},"prompt":{"!type":"fn(message: string, value: string) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/window.prompt","!doc":"Displays a dialog with a message prompting the user to input some text."},"scrollBy":{"!type":"fn(x: number, y: number)","!url":"https://developer.mozilla.org/en/docs/DOM/window.scrollBy","!doc":"Scrolls the document in the window by the given amount."},"scrollTo":{"!type":"fn(x: number, y: number)","!url":"https://developer.mozilla.org/en/docs/DOM/window.scrollTo","!doc":"Scrolls to a particular set of coordinates in the document."},"scroll":{"!type":"fn(x: number, y: number)","!url":"https://developer.mozilla.org/en/docs/DOM/window.scroll","!doc":"Scrolls the window to a particular place in the document."},"setTimeout":{"!type":"fn(f: fn(), ms: number) -> number","!url":"https://developer.mozilla.org/en/docs/DOM/window.setTimeout","!doc":"Calls a function or executes a code snippet after specified delay."},"clearTimeout":{"!type":"fn(timeout: number)","!url":"https://developer.mozilla.org/en/docs/DOM/window.clearTimeout","!doc":"Clears the delay set by window.setTimeout()."},"setInterval":{"!type":"fn(f: fn(), ms: number) -> number","!url":"https://developer.mozilla.org/en/docs/DOM/window.setInterval","!doc":"Calls a function or executes a code snippet repeatedly, with a fixed time delay between each call to that function."},"clearInterval":{"!type":"fn(interval: number)","!url":"https://developer.mozilla.org/en/docs/DOM/window.clearInterval","!doc":"Cancels repeated action which was set up using setInterval."},"atob":{"!type":"fn(encoded: string) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/window.atob","!doc":"Decodes a string of data which has been encoded using base-64 encoding."},"btoa":{"!type":"fn(data: string) -> string","!url":"https://developer.mozilla.org/en/docs/DOM/window.btoa","!doc":"Creates a base-64 encoded ASCII string from a string of binary data."},"addEventListener":{"!type":"fn(type: string, listener: fn(e: +Event), capture: bool)","!url":"https://developer.mozilla.org/en/docs/DOM/EventTarget.addEventListener","!doc":"Registers a single event listener on a single target. The event target may be a single element in a document, the document itself, a window, or an XMLHttpRequest."},"removeEventListener":{"!type":"fn(type: string, listener: fn(), capture: bool)","!url":"https://developer.mozilla.org/en/docs/DOM/EventTarget.removeEventListener","!doc":"Allows the removal of event listeners from the event target."},"dispatchEvent":{"!type":"fn(event: +Event) -> bool","!url":"https://developer.mozilla.org/en/docs/DOM/EventTarget.dispatchEvent","!doc":"Dispatches an event into the event system. The event is subject to the same capturing and bubbling behavior as directly dispatched events."},"getComputedStyle":{"!type":"fn(node: +Element, pseudo?: string) -> Element.prototype.style","!url":"https://developer.mozilla.org/en/docs/DOM/window.getComputedStyle","!doc":"Gives the final used values of all the CSS properties of an element."},"CanvasRenderingContext2D":{"canvas":"+Element","width":"number","height":"number","commit":"fn()","save":"fn()","restore":"fn()","currentTransform":"?","scale":"fn(x: number, y: number)","rotate":"fn(angle: number)","translate":"fn(x: number, y: number)","transform":"fn(a: number, b: number, c: number, d: number, e: number, f: number)","setTransform":"fn(a: number, b: number, c: number, d: number, e: number, f: number)","resetTransform":"fn()","globalAlpha":"number","globalCompositeOperation":"string","imageSmoothingEnabled":"bool","strokeStyle":"string","fillStyle":"string","createLinearGradient":"fn(x0: number, y0: number, x1: number, y1: number) -> ?","createPattern":"fn(image: ?, repetition: string) -> ?","shadowOffsetX":"number","shadowOffsetY":"number","shadowBlur":"number","shadowColor":"string","clearRect":"fn(x: number, y: number, w: number, h: number)","fillRect":"fn(x: number, y: number, w: number, h: number)","strokeRect":"fn(x: number, y: number, w: number, h: number)","fillRule":"string","fill":"fn()","beginPath":"fn()","stroke":"fn()","clip":"fn()","resetClip":"fn()","measureText":"fn(text: string) -> ?","drawImage":"fn(image: ?, dx: number, dy: number)","createImageData":"fn(sw: number, sh: number) -> ?","getImageData":"fn(sx: number, sy: number, sw: number, sh: number) -> ?","putImageData":"fn(imagedata: ?, dx: number, dy: number)","lineWidth":"number","lineCap":"string","lineJoin":"string","miterLimit":"number","setLineDash":"fn(segments: [number])","getLineDash":"fn() -> [number]","lineDashOffset":"number","font":"string","textAlign":"string","textBaseline":"string","direction":"string","closePath":"fn()","moveTo":"fn(x: number, y: number)","lineTo":"fn(x: number, y: number)","quadraticCurveTo":"fn(cpx: number, cpy: number, x: number, y: number)","bezierCurveTo":"fn(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number)","arcTo":"fn(x1: number, y1: number, x2: number, y2: number, radius: number)","rect":"fn(x: number, y: number, w: number, h: number)","arc":"fn(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: bool)","ellipse":"fn(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise: bool)"}};

/***/ },
/* 46 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  "!name": "ecma5",
	  "!define": { "Error.prototype": "Error.prototype" },
	  "Infinity": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Infinity",
	    "!doc": "A numeric value representing infinity."
	  },
	  "undefined": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/undefined",
	    "!doc": "The value undefined."
	  },
	  "NaN": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/NaN",
	    "!doc": "A value representing Not-A-Number."
	  },
	  "Object": {
	    "!type": "fn()",
	    "getPrototypeOf": {
	      "!type": "fn(obj: ?) -> ?",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getPrototypeOf",
	      "!doc": "Returns the prototype (i.e. the internal prototype) of the specified object."
	    },
	    "create": {
	      "!type": "fn(proto: ?) -> !custom:Object_create",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create",
	      "!doc": "Creates a new object with the specified prototype object and properties."
	    },
	    "defineProperty": {
	      "!type": "fn(obj: ?, prop: string, desc: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty",
	      "!doc": "Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article."
	    },
	    "defineProperties": {
	      "!type": "fn(obj: ?, props: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty",
	      "!doc": "Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article."
	    },
	    "getOwnPropertyDescriptor": {
	      "!type": "fn(obj: ?, prop: string) -> ?",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor",
	      "!doc": "Returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object."
	    },
	    "keys": {
	      "!type": "fn(obj: ?) -> [string]",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys",
	      "!doc": "Returns an array of a given object's own enumerable properties, in the same order as that provided by a for-in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well)."
	    },
	    "getOwnPropertyNames": {
	      "!type": "fn(obj: ?) -> [string]",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames",
	      "!doc": "Returns an array of all properties (enumerable or not) found directly upon a given object."
	    },
	    "seal": {
	      "!type": "fn(obj: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/seal",
	      "!doc": "Seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable."
	    },
	    "isSealed": {
	      "!type": "fn(obj: ?) -> bool",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isSealed",
	      "!doc": "Determine if an object is sealed."
	    },
	    "freeze": {
	      "!type": "fn(obj: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/freeze",
	      "!doc": "Freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen."
	    },
	    "isFrozen": {
	      "!type": "fn(obj: ?) -> bool",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isFrozen",
	      "!doc": "Determine if an object is frozen."
	    },
	    "prototype": {
	      "!stdProto": "Object",
	      "toString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toString",
	        "!doc": "Returns a string representing the object."
	      },
	      "toLocaleString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toLocaleString",
	        "!doc": "Returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes."
	      },
	      "valueOf": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/valueOf",
	        "!doc": "Returns the primitive value of the specified object"
	      },
	      "hasOwnProperty": {
	        "!type": "fn(prop: string) -> bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty",
	        "!doc": "Returns a boolean indicating whether the object has the specified property."
	      },
	      "propertyIsEnumerable": {
	        "!type": "fn(prop: string) -> bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable",
	        "!doc": "Returns a Boolean indicating whether the specified property is enumerable."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object",
	    "!doc": "Creates an object wrapper."
	  },
	  "Function": {
	    "!type": "fn(body: string) -> fn()",
	    "prototype": {
	      "!stdProto": "Function",
	      "apply": {
	        "!type": "fn(this: ?, args: [?])",
	        "!effects": ["call and return !this this=!0 !1.<i> !1.<i> !1.<i>"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply",
	        "!doc": "Calls a function with a given this value and arguments provided as an array (or an array like object)."
	      },
	      "call": {
	        "!type": "fn(this: ?, args?: ?) -> !this.!ret",
	        "!effects": ["call and return !this this=!0 !1 !2 !3 !4"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/call",
	        "!doc": "Calls a function with a given this value and arguments provided individually."
	      },
	      "bind": {
	        "!type": "fn(this: ?, args?: ?) -> !custom:Function_bind",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind",
	        "!doc": "Creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function was called."
	      },
	      "prototype": "?"
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function",
	    "!doc": "Every function in JavaScript is actually a Function object."
	  },
	  "Array": {
	    "!type": "fn(size: number) -> !custom:Array_ctor",
	    "isArray": {
	      "!type": "fn(value: ?) -> bool",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/isArray",
	      "!doc": "Returns true if an object is an array, false if it is not."
	    },
	    "prototype": {
	      "!stdProto": "Array",
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/length",
	        "!doc": "An unsigned, 32-bit integer that specifies the number of elements in an array."
	      },
	      "concat": {
	        "!type": "fn(other: [?]) -> !this",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/concat",
	        "!doc": "Returns a new array comprised of this array joined with other array(s) and/or value(s)."
	      },
	      "join": {
	        "!type": "fn(separator?: string) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/join",
	        "!doc": "Joins all elements of an array into a string."
	      },
	      "splice": {
	        "!type": "fn(pos: number, amount: number)",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/splice",
	        "!doc": "Changes the content of an array, adding new elements while removing old elements."
	      },
	      "pop": {
	        "!type": "fn() -> !this.<i>",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/pop",
	        "!doc": "Removes the last element from an array and returns that element."
	      },
	      "push": {
	        "!type": "fn(newelt: ?) -> number",
	        "!effects": ["propagate !0 !this.<i>"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/push",
	        "!doc": "Mutates an array by appending the given elements and returning the new length of the array."
	      },
	      "shift": {
	        "!type": "fn() -> !this.<i>",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/shift",
	        "!doc": "Removes the first element from an array and returns that element. This method changes the length of the array."
	      },
	      "unshift": {
	        "!type": "fn(newelt: ?) -> number",
	        "!effects": ["propagate !0 !this.<i>"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/unshift",
	        "!doc": "Adds one or more elements to the beginning of an array and returns the new length of the array."
	      },
	      "slice": {
	        "!type": "fn(from: number, to?: number) -> !this",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/slice",
	        "!doc": "Returns a shallow copy of a portion of an array."
	      },
	      "reverse": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/reverse",
	        "!doc": "Reverses an array in place.  The first array element becomes the last and the last becomes the first."
	      },
	      "sort": {
	        "!type": "fn(compare?: fn(a: ?, b: ?) -> number)",
	        "!effects": ["call !0 !this.<i> !this.<i>"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort",
	        "!doc": "Sorts the elements of an array in place and returns the array."
	      },
	      "indexOf": {
	        "!type": "fn(elt: ?, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf",
	        "!doc": "Returns the first index at which a given element can be found in the array, or -1 if it is not present."
	      },
	      "lastIndexOf": {
	        "!type": "fn(elt: ?, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/lastIndexOf",
	        "!doc": "Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array is searched backwards, starting at fromIndex."
	      },
	      "every": {
	        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> bool",
	        "!effects": ["call !0 this=!1 !this.<i> number"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/every",
	        "!doc": "Tests whether all elements in the array pass the test implemented by the provided function."
	      },
	      "some": {
	        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> bool",
	        "!effects": ["call !0 this=!1 !this.<i> number"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/some",
	        "!doc": "Tests whether some element in the array passes the test implemented by the provided function."
	      },
	      "filter": {
	        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> !this",
	        "!effects": ["call !0 this=!1 !this.<i> number"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/filter",
	        "!doc": "Creates a new array with all elements that pass the test implemented by the provided function."
	      },
	      "forEach": {
	        "!type": "fn(f: fn(elt: ?, i: number), context?: ?)",
	        "!effects": ["call !0 this=!1 !this.<i> number"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach",
	        "!doc": "Executes a provided function once per array element."
	      },
	      "map": {
	        "!type": "fn(f: fn(elt: ?, i: number) -> ?, context?: ?) -> [!0.!ret]",
	        "!effects": ["call !0 this=!1 !this.<i> number"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/map",
	        "!doc": "Creates a new array with the results of calling a provided function on every element in this array."
	      },
	      "reduce": {
	        "!type": "fn(combine: fn(sum: ?, elt: ?, i: number) -> ?, init?: ?) -> !0.!ret",
	        "!effects": ["call !0 !1 !this.<i> number"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/Reduce",
	        "!doc": "Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value."
	      },
	      "reduceRight": {
	        "!type": "fn(combine: fn(sum: ?, elt: ?, i: number) -> ?, init?: ?) -> !0.!ret",
	        "!effects": ["call !0 !1 !this.<i> number"],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/ReduceRight",
	        "!doc": "Apply a function simultaneously against two values of the array (from right-to-left) as to reduce it to a single value."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array",
	    "!doc": "The JavaScript Array global object is a constructor for arrays, which are high-level, list-like objects."
	  },
	  "String": {
	    "!type": "fn(value: ?) -> string",
	    "fromCharCode": {
	      "!type": "fn(code: number) -> string",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode",
	      "!doc": "Returns a string created by using the specified sequence of Unicode values."
	    },
	    "prototype": {
	      "!stdProto": "String",
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/String/length",
	        "!doc": "Represents the length of a string."
	      },
	      "<i>": "string",
	      "charAt": {
	        "!type": "fn(i: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charAt",
	        "!doc": "Returns the specified character from a string."
	      },
	      "charCodeAt": {
	        "!type": "fn(i: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charCodeAt",
	        "!doc": "Returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000)."
	      },
	      "indexOf": {
	        "!type": "fn(char: string, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/indexOf",
	        "!doc": "Returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex,\nreturns -1 if the value is not found."
	      },
	      "lastIndexOf": {
	        "!type": "fn(char: string, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/lastIndexOf",
	        "!doc": "Returns the index within the calling String object of the last occurrence of the specified value, or -1 if not found. The calling string is searched backward, starting at fromIndex."
	      },
	      "substring": {
	        "!type": "fn(from: number, to?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substring",
	        "!doc": "Returns a subset of a string between one index and another, or through the end of the string."
	      },
	      "substr": {
	        "!type": "fn(from: number, length?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substr",
	        "!doc": "Returns the characters in a string beginning at the specified location through the specified number of characters."
	      },
	      "slice": {
	        "!type": "fn(from: number, to?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/slice",
	        "!doc": "Extracts a section of a string and returns a new string."
	      },
	      "trim": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim",
	        "!doc": "Removes whitespace from both ends of the string."
	      },
	      "trimLeft": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/TrimLeft",
	        "!doc": "Removes whitespace from the left end of the string."
	      },
	      "trimRight": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/TrimRight",
	        "!doc": "Removes whitespace from the right end of the string."
	      },
	      "toUpperCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toUpperCase",
	        "!doc": "Returns the calling string value converted to uppercase."
	      },
	      "toLowerCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLowerCase",
	        "!doc": "Returns the calling string value converted to lowercase."
	      },
	      "toLocaleUpperCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase",
	        "!doc": "Returns the calling string value converted to upper case, according to any locale-specific case mappings."
	      },
	      "toLocaleLowerCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase",
	        "!doc": "Returns the calling string value converted to lower case, according to any locale-specific case mappings."
	      },
	      "split": {
	        "!type": "fn(pattern: string) -> [string]",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/split",
	        "!doc": "Splits a String object into an array of strings by separating the string into substrings."
	      },
	      "concat": {
	        "!type": "fn(other: string) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/concat",
	        "!doc": "Combines the text of two or more strings and returns a new string."
	      },
	      "localeCompare": {
	        "!type": "fn(other: string) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/localeCompare",
	        "!doc": "Returns a number indicating whether a reference string comes before or after or is the same as the given string in sort order."
	      },
	      "match": {
	        "!type": "fn(pattern: +RegExp) -> [string]",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/match",
	        "!doc": "Used to retrieve the matches when matching a string against a regular expression."
	      },
	      "replace": {
	        "!type": "fn(pattern: +RegExp, replacement: string) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/replace",
	        "!doc": "Returns a new string with some or all matches of a pattern replaced by a replacement.  The pattern can be a string or a RegExp, and the replacement can be a string or a function to be called for each match."
	      },
	      "search": {
	        "!type": "fn(pattern: +RegExp) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/search",
	        "!doc": "Executes the search for a match between a regular expression and this String object."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String",
	    "!doc": "The String global object is a constructor for strings, or a sequence of characters."
	  },
	  "Number": {
	    "!type": "fn(value: ?) -> number",
	    "MAX_VALUE": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MAX_VALUE",
	      "!doc": "The maximum numeric value representable in JavaScript."
	    },
	    "MIN_VALUE": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MIN_VALUE",
	      "!doc": "The smallest positive numeric value representable in JavaScript."
	    },
	    "POSITIVE_INFINITY": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY",
	      "!doc": "A value representing the positive Infinity value."
	    },
	    "NEGATIVE_INFINITY": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY",
	      "!doc": "A value representing the negative Infinity value."
	    },
	    "prototype": {
	      "!stdProto": "Number",
	      "toString": {
	        "!type": "fn(radix?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toString",
	        "!doc": "Returns a string representing the specified Number object"
	      },
	      "toFixed": {
	        "!type": "fn(digits: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed",
	        "!doc": "Formats a number using fixed-point notation"
	      },
	      "toExponential": {
	        "!type": "fn(digits: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toExponential",
	        "!doc": "Returns a string representing the Number object in exponential notation"
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number",
	    "!doc": "The Number JavaScript object is a wrapper object allowing you to work with numerical values. A Number object is created using the Number() constructor."
	  },
	  "Boolean": {
	    "!type": "fn(value: ?) -> bool",
	    "prototype": {
	      "!stdProto": "Boolean"
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Boolean",
	    "!doc": "The Boolean object is an object wrapper for a boolean value."
	  },
	  "RegExp": {
	    "!type": "fn(source: string, flags?: string)",
	    "prototype": {
	      "!stdProto": "RegExp",
	      "exec": {
	        "!type": "fn(input: string) -> [string]",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/exec",
	        "!doc": "Executes a search for a match in a specified string. Returns a result array, or null."
	      },
	      "compile": {
	        "!type": "fn(source: string, flags?: string)",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	        "!doc": "Creates a regular expression object for matching text with a pattern."
	      },
	      "test": {
	        "!type": "fn(input: string) -> bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/test",
	        "!doc": "Executes the search for a match between a regular expression and a specified string. Returns true or false."
	      },
	      "global": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	        "!doc": "Creates a regular expression object for matching text with a pattern."
	      },
	      "ignoreCase": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	        "!doc": "Creates a regular expression object for matching text with a pattern."
	      },
	      "multiline": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/multiline",
	        "!doc": "Reflects whether or not to search in strings across multiple lines.\n"
	      },
	      "source": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/source",
	        "!doc": "A read-only property that contains the text of the pattern, excluding the forward slashes.\n"
	      },
	      "lastIndex": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/lastIndex",
	        "!doc": "A read/write integer property that specifies the index at which to start the next match."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	    "!doc": "Creates a regular expression object for matching text with a pattern."
	  },
	  "Date": {
	    "!type": "fn(ms: number)",
	    "parse": {
	      "!type": "fn(source: string) -> +Date",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/parse",
	      "!doc": "Parses a string representation of a date, and returns the number of milliseconds since January 1, 1970, 00:00:00 UTC."
	    },
	    "UTC": {
	      "!type": "fn(year: number, month: number, date: number, hour?: number, min?: number, sec?: number, ms?: number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/UTC",
	      "!doc": "Accepts the same parameters as the longest form of the constructor, and returns the number of milliseconds in a Date object since January 1, 1970, 00:00:00, universal time."
	    },
	    "now": {
	      "!type": "fn() -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now",
	      "!doc": "Returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
	    },
	    "prototype": {
	      "toUTCString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toUTCString",
	        "!doc": "Converts a date to a string, using the universal time convention."
	      },
	      "toISOString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toISOString",
	        "!doc": "JavaScript provides a direct way to convert a date object into a string in ISO format, the ISO 8601 Extended Format."
	      },
	      "toDateString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toDateString",
	        "!doc": "Returns the date portion of a Date object in human readable form in American English."
	      },
	      "toTimeString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toTimeString",
	        "!doc": "Returns the time portion of a Date object in human readable form in American English."
	      },
	      "toLocaleDateString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleDateString",
	        "!doc": "Converts a date to a string, returning the \"date\" portion using the operating system's locale's conventions.\n"
	      },
	      "toLocaleTimeString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleTimeString",
	        "!doc": "Converts a date to a string, returning the \"time\" portion using the current locale's conventions."
	      },
	      "getTime": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTime",
	        "!doc": "Returns the numeric value corresponding to the time for the specified date according to universal time."
	      },
	      "getFullYear": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getFullYear",
	        "!doc": "Returns the year of the specified date according to local time."
	      },
	      "getYear": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getYear",
	        "!doc": "Returns the year in the specified date according to local time."
	      },
	      "getMonth": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMonth",
	        "!doc": "Returns the month in the specified date according to local time."
	      },
	      "getUTCMonth": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMonth",
	        "!doc": "Returns the month of the specified date according to universal time.\n"
	      },
	      "getDate": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDate",
	        "!doc": "Returns the day of the month for the specified date according to local time."
	      },
	      "getUTCDate": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDate",
	        "!doc": "Returns the day (date) of the month in the specified date according to universal time.\n"
	      },
	      "getDay": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDay",
	        "!doc": "Returns the day of the week for the specified date according to local time."
	      },
	      "getUTCDay": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDay",
	        "!doc": "Returns the day of the week in the specified date according to universal time.\n"
	      },
	      "getHours": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getHours",
	        "!doc": "Returns the hour for the specified date according to local time."
	      },
	      "getUTCHours": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCHours",
	        "!doc": "Returns the hours in the specified date according to universal time.\n"
	      },
	      "getMinutes": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMinutes",
	        "!doc": "Returns the minutes in the specified date according to local time."
	      },
	      "getUTCMinutes": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date",
	        "!doc": "Creates JavaScript Date instances which let you work with dates and times."
	      },
	      "getSeconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getSeconds",
	        "!doc": "Returns the seconds in the specified date according to local time."
	      },
	      "getUTCSeconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCSeconds",
	        "!doc": "Returns the seconds in the specified date according to universal time.\n"
	      },
	      "getMilliseconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMilliseconds",
	        "!doc": "Returns the milliseconds in the specified date according to local time."
	      },
	      "getUTCMilliseconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMilliseconds",
	        "!doc": "Returns the milliseconds in the specified date according to universal time.\n"
	      },
	      "getTimezoneOffset": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset",
	        "!doc": "Returns the time-zone offset from UTC, in minutes, for the current locale."
	      },
	      "setTime": {
	        "!type": "fn(date: +Date) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setTime",
	        "!doc": "Sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC.\n"
	      },
	      "setFullYear": {
	        "!type": "fn(year: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setFullYear",
	        "!doc": "Sets the full year for a specified date according to local time.\n"
	      },
	      "setUTCFullYear": {
	        "!type": "fn(year: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCFullYear",
	        "!doc": "Sets the full year for a specified date according to universal time.\n"
	      },
	      "setMonth": {
	        "!type": "fn(month: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMonth",
	        "!doc": "Set the month for a specified date according to local time."
	      },
	      "setUTCMonth": {
	        "!type": "fn(month: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMonth",
	        "!doc": "Sets the month for a specified date according to universal time.\n"
	      },
	      "setDate": {
	        "!type": "fn(day: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setDate",
	        "!doc": "Sets the day of the month for a specified date according to local time."
	      },
	      "setUTCDate": {
	        "!type": "fn(day: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCDate",
	        "!doc": "Sets the day of the month for a specified date according to universal time.\n"
	      },
	      "setHours": {
	        "!type": "fn(hour: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setHours",
	        "!doc": "Sets the hours for a specified date according to local time, and returns the number of milliseconds since 1 January 1970 00:00:00 UTC until the time represented by the updated Date instance."
	      },
	      "setUTCHours": {
	        "!type": "fn(hour: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCHours",
	        "!doc": "Sets the hour for a specified date according to universal time.\n"
	      },
	      "setMinutes": {
	        "!type": "fn(min: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMinutes",
	        "!doc": "Sets the minutes for a specified date according to local time."
	      },
	      "setUTCMinutes": {
	        "!type": "fn(min: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMinutes",
	        "!doc": "Sets the minutes for a specified date according to universal time.\n"
	      },
	      "setSeconds": {
	        "!type": "fn(sec: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setSeconds",
	        "!doc": "Sets the seconds for a specified date according to local time."
	      },
	      "setUTCSeconds": {
	        "!type": "fn(sec: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCSeconds",
	        "!doc": "Sets the seconds for a specified date according to universal time.\n"
	      },
	      "setMilliseconds": {
	        "!type": "fn(ms: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMilliseconds",
	        "!doc": "Sets the milliseconds for a specified date according to local time.\n"
	      },
	      "setUTCMilliseconds": {
	        "!type": "fn(ms: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMilliseconds",
	        "!doc": "Sets the milliseconds for a specified date according to universal time.\n"
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date",
	    "!doc": "Creates JavaScript Date instances which let you work with dates and times."
	  },
	  "Error": {
	    "!type": "fn(message: string)",
	    "prototype": {
	      "name": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/name",
	        "!doc": "A name for the type of error."
	      },
	      "message": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/message",
	        "!doc": "A human-readable description of the error."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error",
	    "!doc": "Creates an error object."
	  },
	  "SyntaxError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/SyntaxError",
	    "!doc": "Represents an error when trying to interpret syntactically invalid code."
	  },
	  "ReferenceError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/ReferenceError",
	    "!doc": "Represents an error when a non-existent variable is referenced."
	  },
	  "URIError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/URIError",
	    "!doc": "Represents an error when a malformed URI is encountered."
	  },
	  "EvalError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/EvalError",
	    "!doc": "Represents an error regarding the eval function."
	  },
	  "RangeError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RangeError",
	    "!doc": "Represents an error when a number is not within the correct range allowed."
	  },
	  "parseInt": {
	    "!type": "fn(string: string, radix?: number) -> number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseInt",
	    "!doc": "Parses a string argument and returns an integer of the specified radix or base."
	  },
	  "parseFloat": {
	    "!type": "fn(string: string) -> number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseFloat",
	    "!doc": "Parses a string argument and returns a floating point number."
	  },
	  "isNaN": {
	    "!type": "fn(value: number) -> bool",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/isNaN",
	    "!doc": "Determines whether a value is NaN or not. Be careful, this function is broken. You may be interested in ECMAScript 6 Number.isNaN."
	  },
	  "eval": {
	    "!type": "fn(code: string) -> ?",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/eval",
	    "!doc": "Evaluates JavaScript code represented as a string."
	  },
	  "encodeURI": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURI",
	    "!doc": "Encodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two \"surrogate\" characters)."
	  },
	  "encodeURIComponent": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent",
	    "!doc": "Encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two \"surrogate\" characters)."
	  },
	  "decodeURI": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURI",
	    "!doc": "Decodes a Uniform Resource Identifier (URI) previously created by encodeURI or by a similar routine."
	  },
	  "decodeURIComponent": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURIComponent",
	    "!doc": "Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a similar routine."
	  },
	  "Math": {
	    "E": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/E",
	      "!doc": "The base of natural logarithms, e, approximately 2.718."
	    },
	    "LN2": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN2",
	      "!doc": "The natural logarithm of 2, approximately 0.693."
	    },
	    "LN10": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN10",
	      "!doc": "The natural logarithm of 10, approximately 2.302."
	    },
	    "LOG2E": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG2E",
	      "!doc": "The base 2 logarithm of E (approximately 1.442)."
	    },
	    "LOG10E": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG10E",
	      "!doc": "The base 10 logarithm of E (approximately 0.434)."
	    },
	    "SQRT1_2": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT1_2",
	      "!doc": "The square root of 1/2; equivalently, 1 over the square root of 2, approximately 0.707."
	    },
	    "SQRT2": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT2",
	      "!doc": "The square root of 2, approximately 1.414."
	    },
	    "PI": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/PI",
	      "!doc": "The ratio of the circumference of a circle to its diameter, approximately 3.14159."
	    },
	    "abs": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/abs",
	      "!doc": "Returns the absolute value of a number."
	    },
	    "cos": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/cos",
	      "!doc": "Returns the cosine of a number."
	    },
	    "sin": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sin",
	      "!doc": "Returns the sine of a number."
	    },
	    "tan": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/tan",
	      "!doc": "Returns the tangent of a number."
	    },
	    "acos": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/acos",
	      "!doc": "Returns the arccosine (in radians) of a number."
	    },
	    "asin": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/asin",
	      "!doc": "Returns the arcsine (in radians) of a number."
	    },
	    "atan": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan",
	      "!doc": "Returns the arctangent (in radians) of a number."
	    },
	    "atan2": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan2",
	      "!doc": "Returns the arctangent of the quotient of its arguments."
	    },
	    "ceil": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/ceil",
	      "!doc": "Returns the smallest integer greater than or equal to a number."
	    },
	    "floor": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/floor",
	      "!doc": "Returns the largest integer less than or equal to a number."
	    },
	    "round": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/round",
	      "!doc": "Returns the value of a number rounded to the nearest integer."
	    },
	    "exp": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/exp",
	      "!doc": "Returns Ex, where x is the argument, and E is Euler's constant, the base of the natural logarithms."
	    },
	    "log": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/log",
	      "!doc": "Returns the natural logarithm (base E) of a number."
	    },
	    "sqrt": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sqrt",
	      "!doc": "Returns the square root of a number."
	    },
	    "pow": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/pow",
	      "!doc": "Returns base to the exponent power, that is, baseexponent."
	    },
	    "max": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/max",
	      "!doc": "Returns the largest of zero or more numbers."
	    },
	    "min": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/min",
	      "!doc": "Returns the smallest of zero or more numbers."
	    },
	    "random": {
	      "!type": "fn() -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random",
	      "!doc": "Returns a floating-point, pseudo-random number in the range [0, 1) that is, from 0 (inclusive) up to but not including 1 (exclusive), which you can then scale to your desired range."
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math",
	    "!doc": "A built-in object that has properties and methods for mathematical constants and functions."
	  },
	  "JSON": {
	    "parse": {
	      "!type": "fn(json: string) -> ?",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/parse",
	      "!doc": "Parse a string as JSON, optionally transforming the value produced by parsing."
	    },
	    "stringify": {
	      "!type": "fn(value: ?) -> string",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify",
	      "!doc": "Convert a value to JSON, optionally replacing values if a replacer function is specified, or optionally including only the specified properties if a replacer array is specified."
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JSON",
	    "!doc": "JSON (JavaScript Object Notation) is a data-interchange format.  It closely resembles a subset of JavaScript syntax, although it is not a strict subset. (See JSON in the JavaScript Reference for full details.)  It is useful when writing any kind of JavaScript-based application, including websites and browser extensions.  For example, you might store user information in JSON format in a cookie, or you might store extension preferences in JSON in a string-valued browser preference."
	  }
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// The Tern server object

	// A server is a stateful object that manages the analysis for a
	// project, and defines an interface for querying the code in the
	// project.

	const infer = __webpack_require__(48);
	const signal = __webpack_require__(52);
	const acorn = __webpack_require__(49);
	const walk = __webpack_require__(53);

	"use strict";

	var plugins = Object.create(null);
	exports.registerPlugin = function (name, init) {
	  plugins[name] = init;
	};

	var defaultOptions = exports.defaultOptions = {
	  debug: false,
	  async: false,
	  getFile: function (_f, c) {
	    if (this.async) c(null, null);
	  },
	  defs: [],
	  plugins: {},
	  fetchTimeout: 1000,
	  dependencyBudget: 20000
	};

	var queryTypes = {
	  completions: {
	    takesFile: true,
	    run: findCompletions
	  },
	  properties: {
	    run: findProperties
	  },
	  type: {
	    takesFile: true,
	    run: findTypeAt
	  },
	  documentation: {
	    takesFile: true,
	    run: findDocs
	  },
	  definition: {
	    takesFile: true,
	    run: findDef
	  },
	  refs: {
	    takesFile: true,
	    fullFile: true,
	    run: findRefs
	  },
	  rename: {
	    takesFile: true,
	    fullFile: true,
	    run: buildRename
	  },
	  files: {
	    run: listFiles
	  }
	};

	exports.defineQueryType = function (name, desc) {
	  queryTypes[name] = desc;
	};

	function File(name, parent) {
	  this.name = name;
	  this.parent = parent;
	  this.scope = this.text = this.ast = this.lineOffsets = null;
	}
	File.prototype.asLineChar = function (pos) {
	  return asLineChar(this, pos);
	};

	function updateText(file, text, srv) {
	  file.text = text;
	  file.ast = infer.parse(text, srv.passes, { directSourceFile: file, allowReturnOutsideFunction: true });
	  file.lineOffsets = null;
	}

	var Server = exports.Server = function (options) {
	  this.cx = null;
	  this.options = options || {};
	  for (var o in defaultOptions) if (!options.hasOwnProperty(o)) options[o] = defaultOptions[o];

	  this.handlers = Object.create(null);
	  this.files = [];
	  this.fileMap = Object.create(null);
	  this.budgets = Object.create(null);
	  this.uses = 0;
	  this.pending = 0;
	  this.asyncError = null;
	  this.passes = Object.create(null);

	  this.defs = options.defs.slice(0);
	  for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin) && plugin in plugins) {
	    var init = plugins[plugin](this, options.plugins[plugin]);
	    if (init && init.defs) {
	      if (init.loadFirst) this.defs.unshift(init.defs);else this.defs.push(init.defs);
	    }
	    if (init && init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type)) (this.passes[type] || (this.passes[type] = [])).push(init.passes[type]);
	  }

	  this.reset();
	};
	Server.prototype = signal.mixin({
	  addFile: function (name, /*optional*/text, parent) {
	    // Don't crash when sloppy plugins pass non-existent parent ids
	    if (parent && !parent in this.fileMap) parent = null;
	    ensureFile(this, name, parent, text);
	  },
	  delFile: function (name) {
	    for (var i = 0, f; i < this.files.length; ++i) if ((f = this.files[i]).name == name) {
	      clearFile(this, f, null, true);
	      this.files.splice(i--, 1);
	      delete this.fileMap[name];
	      return;
	    }
	  },
	  reset: function () {
	    this.signal("reset");
	    this.cx = new infer.Context(this.defs, this);
	    this.uses = 0;
	    this.budgets = Object.create(null);
	    for (var i = 0; i < this.files.length; ++i) {
	      var file = this.files[i];
	      file.scope = null;
	    }
	  },

	  request: function (doc, c) {
	    var inv = invalidDoc(doc);
	    if (inv) return c(inv);

	    var self = this;
	    doRequest(this, doc, function (err, data) {
	      c(err, data);
	      if (self.uses > 40) {
	        self.reset();
	        analyzeAll(self, null, function () {});
	      }
	    });
	  },

	  findFile: function (name) {
	    return this.fileMap[name];
	  },

	  flush: function (c) {
	    var cx = this.cx;
	    analyzeAll(this, null, function (err) {
	      if (err) return c(err);
	      infer.withContext(cx, c);
	    });
	  },

	  startAsyncAction: function () {
	    ++this.pending;
	  },
	  finishAsyncAction: function (err) {
	    if (err) this.asyncError = err;
	    if (--this.pending == 0) this.signal("everythingFetched");
	  }
	});

	function doRequest(srv, doc, c) {
	  if (doc.query && !queryTypes.hasOwnProperty(doc.query.type)) return c("No query type '" + doc.query.type + "' defined");

	  var query = doc.query;
	  // Respond as soon as possible when this just uploads files
	  if (!query) c(null, {});

	  var files = doc.files || [];
	  if (files.length) ++srv.uses;
	  for (var i = 0; i < files.length; ++i) {
	    var file = files[i];
	    ensureFile(srv, file.name, null, file.type == "full" ? file.text : null);
	  }

	  var timeBudget = typeof doc.timeout == "number" ? [doc.timeout] : null;
	  if (!query) {
	    analyzeAll(srv, timeBudget, function () {});
	    return;
	  }

	  var queryType = queryTypes[query.type];
	  if (queryType.takesFile) {
	    if (typeof query.file != "string") return c(".query.file must be a string");
	    if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);
	  }

	  analyzeAll(srv, timeBudget, function (err) {
	    if (err) return c(err);
	    var file = queryType.takesFile && resolveFile(srv, files, query.file);
	    if (queryType.fullFile && file.type == "part") return c("Can't run a " + query.type + " query on a file fragment");

	    function run() {
	      var result;
	      try {
	        result = queryType.run(srv, query, file);
	      } catch (e) {
	        if (srv.options.debug && e.name != "TernError") console.error(e.stack);
	        return c(e);
	      }
	      c(null, result);
	    }
	    infer.withContext(srv.cx, timeBudget ? function () {
	      infer.withTimeout(timeBudget[0], run);
	    } : run);
	  });
	}

	function analyzeFile(srv, file) {
	  infer.withContext(srv.cx, function () {
	    file.scope = srv.cx.topScope;
	    srv.signal("beforeLoad", file);
	    infer.markVariablesDefinedBy(file.scope, file.name);
	    infer.analyze(file.ast, file.name, file.scope, srv.passes);
	    infer.purgeMarkedVariables(file.scope);
	    srv.signal("afterLoad", file);
	  });
	  return file;
	}

	function ensureFile(srv, name, parent, text) {
	  var known = srv.findFile(name);
	  if (known) {
	    if (text != null) clearFile(srv, known, text);
	    if (parentDepth(known.parent) > parentDepth(parent)) {
	      known.parent = parent;
	      if (known.excluded) known.excluded = null;
	    }
	    return;
	  }

	  var file = new File(name, parent);
	  srv.files.push(file);
	  srv.fileMap[name] = file;
	  if (text != null) {
	    updateText(file, text, srv);
	  } else if (srv.options.async) {
	    srv.startAsyncAction();
	    srv.options.getFile(name, function (err, text) {
	      updateText(file, text || "", srv);
	      srv.finishAsyncAction(err);
	    });
	  } else {
	    updateText(file, srv.options.getFile(name) || "", srv);
	  }
	}

	function clearFile(srv, file, newText, purgeVars) {
	  if (file.scope) {
	    infer.withContext(srv.cx, function () {
	      // FIXME try to batch purges into a single pass (each call needs
	      // to traverse the whole graph)
	      infer.purgeTypes(file.name);
	      if (purgeVars) {
	        infer.markVariablesDefinedBy(file.scope, file.name);
	        infer.purgeMarkedVariables(file.scope);
	      }
	    });
	    file.scope = null;
	  }
	  if (newText != null) updateText(file, newText, srv);
	}

	function fetchAll(srv, c) {
	  var done = true,
	      returned = false;
	  for (var i = 0; i < srv.files.length; ++i) {
	    var file = srv.files[i];
	    if (file.text != null) continue;
	    if (srv.options.async) {
	      done = false;
	      srv.options.getFile(file.name, function (err, text) {
	        if (err && !returned) {
	          returned = true;return c(err);
	        }
	        updateText(file, text || "", srv);
	        fetchAll(srv, c);
	      });
	    } else {
	      try {
	        updateText(file, srv.options.getFile(file.name) || "", srv);
	      } catch (e) {
	        return c(e);
	      }
	    }
	  }
	  if (done) c();
	}

	function waitOnFetch(srv, timeBudget, c) {
	  var done = function () {
	    srv.off("everythingFetched", done);
	    clearTimeout(timeout);
	    analyzeAll(srv, timeBudget, c);
	  };
	  srv.on("everythingFetched", done);
	  var timeout = setTimeout(done, srv.options.fetchTimeout);
	}

	function analyzeAll(srv, timeBudget, c) {
	  if (srv.pending) return waitOnFetch(srv, timeBudget, c);

	  var e = srv.fetchError;
	  if (e) {
	    srv.fetchError = null;return c(e);
	  }

	  var done = true;
	  // The second inner loop might add new files. The outer loop keeps
	  // repeating both inner loops until all files have been looked at.
	  for (var i = 0; i < srv.files.length;) {
	    var toAnalyze = [];
	    for (; i < srv.files.length; ++i) {
	      var file = srv.files[i];
	      if (file.text == null) done = false;else if (file.scope == null && !file.excluded) toAnalyze.push(file);
	    }
	    toAnalyze.sort(function (a, b) {
	      return parentDepth(a.parent) - parentDepth(b.parent);
	    });
	    for (var j = 0; j < toAnalyze.length; j++) {
	      var file = toAnalyze[j];
	      if (file.parent && !chargeOnBudget(srv, file)) {
	        file.excluded = true;
	      } else if (timeBudget) {
	        var startTime = +new Date();
	        infer.withTimeout(timeBudget[0], function () {
	          analyzeFile(srv, file);
	        });
	        timeBudget[0] -= +new Date() - startTime;
	      } else {
	        analyzeFile(srv, file);
	      }
	    }
	  }
	  if (done) c();else waitOnFetch(srv, timeBudget, c);
	}

	function firstLine(str) {
	  var end = str.indexOf("\n");
	  if (end < 0) return str;
	  return str.slice(0, end);
	}

	function findMatchingPosition(line, file, near) {
	  var pos = Math.max(0, near - 500),
	      closest = null;
	  if (!/^\s*$/.test(line)) for (;;) {
	    var found = file.indexOf(line, pos);
	    if (found < 0 || found > near + 500) break;
	    if (closest == null || Math.abs(closest - near) > Math.abs(found - near)) closest = found;
	    pos = found + line.length;
	  }
	  return closest;
	}

	function scopeDepth(s) {
	  for (var i = 0; s; ++i, s = s.prev) {}
	  return i;
	}

	function ternError(msg) {
	  var err = new Error(msg);
	  err.name = "TernError";
	  return err;
	}

	function resolveFile(srv, localFiles, name) {
	  var isRef = name.match(/^#(\d+)$/);
	  if (!isRef) return srv.findFile(name);

	  var file = localFiles[isRef[1]];
	  if (!file) throw ternError("Reference to unknown file " + name);
	  if (file.type == "full") return srv.findFile(file.name);

	  // This is a partial file

	  var realFile = file.backing = srv.findFile(file.name);
	  var offset = file.offset;
	  if (file.offsetLines) offset = { line: file.offsetLines, ch: 0 };
	  file.offset = offset = resolvePos(realFile, file.offsetLines == null ? file.offset : { line: file.offsetLines, ch: 0 }, true);
	  var line = firstLine(file.text);
	  var foundPos = findMatchingPosition(line, realFile.text, offset);
	  var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf("\n", offset)) : foundPos;

	  infer.withContext(srv.cx, function () {
	    infer.purgeTypes(file.name, pos, pos + file.text.length);

	    var text = file.text,
	        m;
	    if (m = text.match(/(?:"([^"]*)"|([\w$]+))\s*:\s*function\b/)) {
	      var objNode = walk.findNodeAround(file.backing.ast, pos, "ObjectExpression");
	      if (objNode && objNode.node.objType) var inObject = { type: objNode.node.objType, prop: m[2] || m[1] };
	    }
	    if (foundPos && (m = line.match(/^(.*?)\bfunction\b/))) {
	      var cut = m[1].length,
	          white = "";
	      for (var i = 0; i < cut; ++i) white += " ";
	      text = white + text.slice(cut);
	      var atFunction = true;
	    }

	    var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);
	    var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);
	    var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;
	    infer.markVariablesDefinedBy(scopeStart, file.name, pos, pos + file.text.length);
	    file.ast = infer.parse(file.text, srv.passes, { directSourceFile: file, allowReturnOutsideFunction: true });
	    infer.analyze(file.ast, file.name, scope, srv.passes);
	    infer.purgeMarkedVariables(scopeStart);

	    // This is a kludge to tie together the function types (if any)
	    // outside and inside of the fragment, so that arguments and
	    // return values have some information known about them.
	    tieTogether: if (inObject || atFunction) {
	      var newInner = infer.scopeAt(file.ast, line.length, scopeStart);
	      if (!newInner.fnType) break tieTogether;
	      if (inObject) {
	        var prop = inObject.type.getProp(inObject.prop);
	        prop.addType(newInner.fnType);
	      } else if (atFunction) {
	        var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);
	        if (inner == scopeStart || !inner.fnType) break tieTogether;
	        var fOld = inner.fnType,
	            fNew = newInner.fnType;
	        if (!fNew || fNew.name != fOld.name && fOld.name) break tieTogether;
	        for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i) fOld.args[i].propagate(fNew.args[i]);
	        fOld.self.propagate(fNew.self);
	        fNew.retval.propagate(fOld.retval);
	      }
	    }
	  });
	  return file;
	}

	// Budget management

	function astSize(node) {
	  var size = 0;
	  walk.simple(node, { Expression: function () {
	      ++size;
	    } });
	  return size;
	}

	function parentDepth(srv, parent) {
	  var depth = 0;
	  while (parent) {
	    parent = srv.findFile(parent).parent;
	    ++depth;
	  }
	  return depth;
	}

	function budgetName(srv, file) {
	  for (;;) {
	    var parent = srv.findFile(file.parent);
	    if (!parent.parent) break;
	    file = parent;
	  }
	  return file.name;
	}

	function chargeOnBudget(srv, file) {
	  var bName = budgetName(srv, file);
	  var size = astSize(file.ast);
	  var known = srv.budgets[bName];
	  if (known == null) known = srv.budgets[bName] = srv.options.dependencyBudget;
	  if (known < size) return false;
	  srv.budgets[bName] = known - size;
	  return true;
	}

	// Query helpers

	function isPosition(val) {
	  return typeof val == "number" || typeof val == "object" && typeof val.line == "number" && typeof val.ch == "number";
	}

	// Baseline query document validation
	function invalidDoc(doc) {
	  if (doc.query) {
	    if (typeof doc.query.type != "string") return ".query.type must be a string";
	    if (doc.query.start && !isPosition(doc.query.start)) return ".query.start must be a position";
	    if (doc.query.end && !isPosition(doc.query.end)) return ".query.end must be a position";
	  }
	  if (doc.files) {
	    if (!Array.isArray(doc.files)) return "Files property must be an array";
	    for (var i = 0; i < doc.files.length; ++i) {
	      var file = doc.files[i];
	      if (typeof file != "object") return ".files[n] must be objects";else if (typeof file.text != "string") return ".files[n].text must be a string";else if (typeof file.name != "string") return ".files[n].name must be a string";else if (file.type == "part") {
	        if (!isPosition(file.offset) && typeof file.offsetLines != "number") return ".files[n].offset must be a position";
	      } else if (file.type != "full") return ".files[n].type must be \"full\" or \"part\"";
	    }
	  }
	}

	var offsetSkipLines = 25;

	function findLineStart(file, line) {
	  var text = file.text,
	      offsets = file.lineOffsets || (file.lineOffsets = [0]);
	  var pos = 0,
	      curLine = 0;
	  var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);
	  var pos = offsets[storePos],
	      curLine = storePos * offsetSkipLines;

	  while (curLine < line) {
	    ++curLine;
	    pos = text.indexOf("\n", pos) + 1;
	    if (pos == 0) return null;
	    if (curLine % offsetSkipLines == 0) offsets.push(pos);
	  }
	  return pos;
	}

	function resolvePos(file, pos, tolerant) {
	  if (typeof pos != "number") {
	    var lineStart = findLineStart(file, pos.line);
	    if (lineStart == null) {
	      if (tolerant) pos = file.text.length;else throw ternError("File doesn't contain a line " + pos.line);
	    } else {
	      pos = lineStart + pos.ch;
	    }
	  }
	  if (pos > file.text.length) {
	    if (tolerant) pos = file.text.length;else throw ternError("Position " + pos + " is outside of file.");
	  }
	  return pos;
	}

	function asLineChar(file, pos) {
	  if (!file) return { line: 0, ch: 0 };
	  var offsets = file.lineOffsets || (file.lineOffsets = [0]);
	  var text = file.text,
	      line,
	      lineStart;
	  for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {
	    line = i * offsetSkipLines;
	    lineStart = offsets[i];
	  }
	  for (;;) {
	    var eol = text.indexOf("\n", lineStart);
	    if (eol >= pos || eol < 0) break;
	    lineStart = eol + 1;
	    ++line;
	  }
	  return { line: line, ch: pos - lineStart };
	}

	function outputPos(query, file, pos) {
	  if (query.lineCharPositions) {
	    var out = asLineChar(file, pos);
	    if (file.type == "part") out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;
	    return out;
	  } else {
	    return pos + (file.type == "part" ? file.offset : 0);
	  }
	}

	// Delete empty fields from result objects
	function clean(obj) {
	  for (var prop in obj) if (obj[prop] == null) delete obj[prop];
	  return obj;
	}
	function maybeSet(obj, prop, val) {
	  if (val != null) obj[prop] = val;
	}

	// Built-in query types

	function compareCompletions(a, b) {
	  if (typeof a != "string") {
	    a = a.name;b = b.name;
	  }
	  var aUp = /^[A-Z]/.test(a),
	      bUp = /^[A-Z]/.test(b);
	  if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;else return aUp ? 1 : -1;
	}

	function isStringAround(node, start, end) {
	  return node.type == "Literal" && typeof node.value == "string" && node.start == start - 1 && node.end <= end + 1;
	}

	var jsKeywords = ("break do instanceof typeof case else new var " + "catch finally return void continue for switch while debugger " + "function this with default if throw delete in try").split(" ");

	function findCompletions(srv, query, file) {
	  if (query.end == null) throw ternError("missing .query.end field");
	  var wordStart = resolvePos(file, query.end),
	      wordEnd = wordStart,
	      text = file.text;
	  while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;
	  if (query.expandWordForward !== false) while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;
	  var word = text.slice(wordStart, wordEnd),
	      completions = [];
	  if (query.caseInsensitive) word = word.toLowerCase();
	  var wrapAsObjs = query.types || query.depths || query.docs || query.urls || query.origins;

	  function gather(prop, obj, depth) {
	    // 'hasOwnProperty' and such are usually just noise, leave them
	    // out when no prefix is provided.
	    if (query.omitObjectPrototype !== false && obj == srv.cx.protos.Object && !word) return;
	    if (query.filter !== false && word && (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) != 0) return;
	    for (var i = 0; i < completions.length; ++i) {
	      var c = completions[i];
	      if ((wrapAsObjs ? c.name : c) == prop) return;
	    }
	    var rec = wrapAsObjs ? { name: prop } : prop;
	    completions.push(rec);

	    if (query.types || query.docs || query.urls || query.origins) {
	      var val = obj ? obj.props[prop] : infer.ANull;
	      infer.resetGuessing();
	      var type = val.getType();
	      rec.guess = infer.didGuess();
	      if (query.types) rec.type = infer.toString(type);
	      if (query.docs) maybeSet(rec, "doc", val.doc || type && type.doc);
	      if (query.urls) maybeSet(rec, "url", val.url || type && type.url);
	      if (query.origins) maybeSet(rec, "origin", val.origin || type && type.origin);
	    }
	    if (query.depths) rec.depth = depth;
	  }

	  var memberExpr = infer.findExpressionAround(file.ast, null, wordStart, file.scope, "MemberExpression");
	  var hookname;
	  if (memberExpr && (memberExpr.node.computed ? isStringAround(memberExpr.node.property, wordStart, wordEnd) : memberExpr.node.object.end < wordStart)) {
	    var prop = memberExpr.node.property;
	    prop = prop.type == "Literal" ? prop.value.slice(1) : prop.name;
	    srv.cx.completingProperty = prop;

	    memberExpr.node = memberExpr.node.object;
	    var tp = infer.expressionType(memberExpr);
	    if (tp) infer.forAllPropertiesOf(tp, gather);

	    if (!completions.length && query.guess !== false && tp && tp.guessProperties) {
	      tp.guessProperties(function (p, o, d) {
	        if (p != prop && p != "✖") gather(p, o, d);
	      });
	    }
	    if (!completions.length && word.length >= 2 && query.guess !== false) for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);
	    hookname = "memberCompletion";
	  } else {
	    infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);
	    if (query.includeKeywords) jsKeywords.forEach(function (kw) {
	      gather(kw, null, 0);
	    });
	    hookname = "completion";
	  }
	  if (srv.passes[hookname]) srv.passes[hookname].forEach(function (hook) {
	    hook(file, wordStart, wordEnd, gather);
	  });

	  if (query.sort !== false) completions.sort(compareCompletions);
	  srv.cx.completingProperty = null;

	  return { start: outputPos(query, file, wordStart),
	    end: outputPos(query, file, wordEnd),
	    completions: completions };
	}

	function findProperties(srv, query) {
	  var prefix = query.prefix,
	      found = [];
	  for (var prop in srv.cx.props) if (prop != "<i>" && (!prefix || prop.indexOf(prefix) == 0)) found.push(prop);
	  if (query.sort !== false) found.sort(compareCompletions);
	  return { completions: found };
	}

	var findExpr = exports.findQueryExpr = function (file, query, wide) {
	  if (query.end == null) throw ternError("missing .query.end field");

	  if (query.variable) {
	    var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);
	    return { node: { type: "Identifier", name: query.variable, start: query.end, end: query.end + 1 },
	      state: scope };
	  } else {
	    var start = query.start && resolvePos(file, query.start),
	        end = resolvePos(file, query.end);
	    var expr = infer.findExpressionAt(file.ast, start, end, file.scope);
	    if (expr) return expr;
	    expr = infer.findExpressionAround(file.ast, start, end, file.scope);
	    if (expr && (wide || (start == null ? end : start) - expr.node.start < 20 || expr.node.end - end < 20)) return expr;
	    throw ternError("No expression at the given position.");
	  }
	};

	function findTypeAt(_srv, query, file) {
	  var expr = findExpr(file, query);
	  infer.resetGuessing();
	  var type = infer.expressionType(expr);
	  if (query.preferFunction) type = type.getFunctionType() || type.getType();else type = type.getType();

	  if (expr.node.type == "Identifier") var exprName = expr.node.name;else if (expr.node.type == "MemberExpression" && !expr.node.computed) var exprName = expr.node.property.name;

	  if (query.depth != null && typeof query.depth != "number") throw ternError(".query.depth must be a number");

	  var result = { guess: infer.didGuess(),
	    type: infer.toString(type, query.depth),
	    name: type && type.name,
	    exprName: exprName };
	  if (type) storeTypeDocs(type, result);

	  return clean(result);
	}

	function findDocs(_srv, query, file) {
	  var expr = findExpr(file, query);
	  var type = infer.expressionType(expr);
	  var result = { url: type.url, doc: type.doc };
	  var inner = type.getType();
	  if (inner) storeTypeDocs(inner, result);
	  return clean(result);
	}

	function storeTypeDocs(type, out) {
	  if (!out.url) out.url = type.url;
	  if (!out.doc) out.doc = type.doc;
	  if (!out.origin) out.origin = type.origin;
	  var ctor,
	      boring = infer.cx().protos;
	  if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) && type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {
	    out.url = ctor.url;
	    out.doc = ctor.doc;
	  }
	}

	var getSpan = exports.getSpan = function (obj) {
	  if (!obj.origin) return;
	  if (obj.originNode) {
	    var node = obj.originNode;
	    if (/^Function/.test(node.type) && node.id) node = node.id;
	    return { origin: obj.origin, node: node };
	  }
	  if (obj.span) return { origin: obj.origin, span: obj.span };
	};

	var storeSpan = exports.storeSpan = function (srv, query, span, target) {
	  target.origin = span.origin;
	  if (span.span) {
	    var m = /^(\d+)\[(\d+):(\d+)\]-(\d+)\[(\d+):(\d+)\]$/.exec(span.span);
	    target.start = query.lineCharPositions ? { line: Number(m[2]), ch: Number(m[3]) } : Number(m[1]);
	    target.end = query.lineCharPositions ? { line: Number(m[5]), ch: Number(m[6]) } : Number(m[4]);
	  } else {
	    var file = srv.findFile(span.origin);
	    target.start = outputPos(query, file, span.node.start);
	    target.end = outputPos(query, file, span.node.end);
	  }
	};

	function findDef(srv, query, file) {
	  var expr = findExpr(file, query);
	  infer.resetGuessing();
	  var type = infer.expressionType(expr);
	  if (infer.didGuess()) return {};

	  var span = getSpan(type);
	  var result = { url: type.url, doc: type.doc, origin: type.origin };

	  if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {
	    var tp = type.types[i];
	    storeTypeDocs(tp, result);
	    if (!span) span = getSpan(tp);
	  }

	  if (span && span.node) {
	    // refers to a loaded file
	    var spanFile = span.node.sourceFile || srv.findFile(span.origin);
	    var start = outputPos(query, spanFile, span.node.start),
	        end = outputPos(query, spanFile, span.node.end);
	    result.start = start;result.end = end;
	    result.file = span.origin;
	    var cxStart = Math.max(0, span.node.start - 50);
	    result.contextOffset = span.node.start - cxStart;
	    result.context = spanFile.text.slice(cxStart, cxStart + 50);
	  } else if (span) {
	    // external
	    result.file = span.origin;
	    storeSpan(srv, query, span, result);
	  }
	  return clean(result);
	}

	function findRefsToVariable(srv, query, file, expr, checkShadowing) {
	  var name = expr.node.name;

	  for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) {}
	  if (!scope) throw ternError("Could not find a definition for " + name + " " + !!srv.cx.topScope.props.x);

	  var type,
	      refs = [];
	  function storeRef(file) {
	    return function (node, scopeHere) {
	      if (checkShadowing) for (var s = scopeHere; s != scope; s = s.prev) {
	        var exists = s.hasProp(checkShadowing);
	        if (exists) throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would make a variable at line " + (asLineChar(file, node.start).line + 1) + " point to the definition at line " + (asLineChar(file, exists.name.start).line + 1));
	      }
	      refs.push({ file: file.name,
	        start: outputPos(query, file, node.start),
	        end: outputPos(query, file, node.end) });
	    };
	  }

	  if (scope.originNode) {
	    type = "local";
	    if (checkShadowing) {
	      for (var prev = scope.prev; prev; prev = prev.prev) if (checkShadowing in prev.props) break;
	      if (prev) infer.findRefs(scope.originNode, scope, checkShadowing, prev, function (node) {
	        throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would shadow the definition used at line " + (asLineChar(file, node.start).line + 1));
	      });
	    }
	    infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));
	  } else {
	    type = "global";
	    for (var i = 0; i < srv.files.length; ++i) {
	      var cur = srv.files[i];
	      infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));
	    }
	  }

	  return { refs: refs, type: type, name: name };
	}

	function findRefsToProperty(srv, query, expr, prop) {
	  var objType = infer.expressionType(expr).getType();
	  if (!objType) throw ternError("Couldn't determine type of base object.");

	  var refs = [];
	  function storeRef(file) {
	    return function (node) {
	      refs.push({ file: file.name,
	        start: outputPos(query, file, node.start),
	        end: outputPos(query, file, node.end) });
	    };
	  }
	  for (var i = 0; i < srv.files.length; ++i) {
	    var cur = srv.files[i];
	    infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));
	  }

	  return { refs: refs, name: prop.name };
	}

	function findRefs(srv, query, file) {
	  var expr = findExpr(file, query, true);
	  if (expr && expr.node.type == "Identifier") {
	    return findRefsToVariable(srv, query, file, expr);
	  } else if (expr && expr.node.type == "MemberExpression" && !expr.node.computed) {
	    var p = expr.node.property;
	    expr.node = expr.node.object;
	    return findRefsToProperty(srv, query, expr, p);
	  } else if (expr && expr.node.type == "ObjectExpression") {
	    var pos = resolvePos(file, query.end);
	    for (var i = 0; i < expr.node.properties.length; ++i) {
	      var k = expr.node.properties[i].key;
	      if (k.start <= pos && k.end >= pos) return findRefsToProperty(srv, query, expr, k);
	    }
	  }
	  throw ternError("Not at a variable or property name.");
	}

	function buildRename(srv, query, file) {
	  if (typeof query.newName != "string") throw ternError(".query.newName should be a string");
	  var expr = findExpr(file, query);
	  if (!expr || expr.node.type != "Identifier") throw ternError("Not at a variable.");

	  var data = findRefsToVariable(srv, query, file, expr, query.newName),
	      refs = data.refs;
	  delete data.refs;
	  data.files = srv.files.map(function (f) {
	    return f.name;
	  });

	  var changes = data.changes = [];
	  for (var i = 0; i < refs.length; ++i) {
	    var use = refs[i];
	    use.text = query.newName;
	    changes.push(use);
	  }

	  return data;
	}

	function listFiles(srv) {
	  return { files: srv.files.map(function (f) {
	      return f.name;
	    }) };
	}

	exports.version = "0.6.2";

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Main type inference engine

	// Walks an AST, building up a graph of abstract values and contraints
	// that cause types to flow from one node to another. Also defines a
	// number of utilities for accessing ASTs and scopes.

	// Analysis is done in a context, which is tracked by the dynamically
	// bound cx variable. Use withContext to set the current context.

	// For memory-saving reasons, individual types export an interface
	// similar to abstract values (which can hold multiple types), and can
	// thus be used in place abstract values that only ever contain a
	// single type.

	//(function(mod) {
	//  if (typeof exports == "object" && typeof module == "object") // CommonJS
	//    return mod(exports, require("acorn/acorn"), require("acorn/acorn_loose"), require("acorn/util/walk"),
	//               require("./def"), require("./signal"));
	//  if (typeof define == "function" && define.amd) // AMD
	//    return define(["exports", "acorn/acorn", "acorn/acorn_loose", "acorn/util/walk", "./def", "./signal"], mod);
	//  mod(self.tern || (self.tern = {}), acorn, acorn, acorn.walk, tern.def, tern.signal); // Plain browser env
	//})(function(exports, acorn, acorn_loose, walk, def, signal) {

	const acorn = __webpack_require__(49);
	const acorn_loose = __webpack_require__(50);
	const def = __webpack_require__(51);
	const signal = __webpack_require__(52);
	const walk = __webpack_require__(53);

	"use strict";

	var toString = exports.toString = function (type, maxDepth, parent) {
	  return !type || type == parent ? "?" : type.toString(maxDepth);
	};

	// A variant of AVal used for unknown, dead-end values. Also serves
	// as prototype for AVals, Types, and Constraints because it
	// implements 'empty' versions of all the methods that the code
	// expects.
	var ANull = exports.ANull = signal.mixin({
	  addType: function () {},
	  propagate: function () {},
	  getProp: function () {
	    return ANull;
	  },
	  forAllProps: function () {},
	  hasType: function () {
	    return false;
	  },
	  isEmpty: function () {
	    return true;
	  },
	  getFunctionType: function () {},
	  getType: function () {},
	  gatherProperties: function () {},
	  propagatesTo: function () {},
	  typeHint: function () {},
	  propHint: function () {}
	});

	function extend(proto, props) {
	  var obj = Object.create(proto);
	  if (props) for (var prop in props) obj[prop] = props[prop];
	  return obj;
	}

	// ABSTRACT VALUES

	var WG_DEFAULT = 100,
	    WG_NEW_INSTANCE = 90,
	    WG_MADEUP_PROTO = 10,
	    WG_MULTI_MEMBER = 5,
	    WG_CATCH_ERROR = 5,
	    WG_GLOBAL_THIS = 90,
	    WG_SPECULATIVE_THIS = 2;

	var AVal = exports.AVal = function () {
	  this.types = [];
	  this.forward = null;
	  this.maxWeight = 0;
	};
	AVal.prototype = extend(ANull, {
	  addType: function (type, weight) {
	    weight = weight || WG_DEFAULT;
	    if (this.maxWeight < weight) {
	      this.maxWeight = weight;
	      if (this.types.length == 1 && this.types[0] == type) return;
	      this.types.length = 0;
	    } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {
	      return;
	    }

	    this.signal("addType", type);
	    this.types.push(type);
	    var forward = this.forward;
	    if (forward) withWorklist(function (add) {
	      for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);
	    });
	  },

	  propagate: function (target, weight) {
	    if (target == ANull || target instanceof Type) return;
	    if (weight && weight < WG_DEFAULT) target = new Muffle(target, weight);
	    (this.forward || (this.forward = [])).push(target);
	    var types = this.types;
	    if (types.length) withWorklist(function (add) {
	      for (var i = 0; i < types.length; ++i) add(types[i], target, weight);
	    });
	  },

	  getProp: function (prop) {
	    if (prop == "__proto__" || prop == "✖") return ANull;
	    var found = (this.props || (this.props = Object.create(null)))[prop];
	    if (!found) {
	      found = this.props[prop] = new AVal();
	      this.propagate(new PropIsSubset(prop, found));
	    }
	    return found;
	  },

	  forAllProps: function (c) {
	    this.propagate(new ForAllProps(c));
	  },

	  hasType: function (type) {
	    return this.types.indexOf(type) > -1;
	  },
	  isEmpty: function () {
	    return this.types.length == 0;
	  },
	  getFunctionType: function () {
	    for (var i = this.types.length - 1; i >= 0; --i) if (this.types[i] instanceof Fn) return this.types[i];
	  },

	  getType: function (guess) {
	    if (this.types.length == 0 && guess !== false) return this.makeupType();
	    if (this.types.length == 1) return this.types[0];
	    return canonicalType(this.types);
	  },

	  computedPropType: function () {
	    if (!this.propertyOf || !this.propertyOf.hasProp("<i>")) return null;
	    var computedProp = this.propertyOf.getProp("<i>");
	    if (computedProp == this) return null;
	    return computedProp.getType();
	  },

	  makeupType: function () {
	    var computed = this.computedPropType();
	    if (computed) return computed;

	    if (!this.forward) return null;
	    for (var i = this.forward.length - 1; i >= 0; --i) {
	      var hint = this.forward[i].typeHint();
	      if (hint && !hint.isEmpty()) {
	        guessing = true;return hint;
	      }
	    }

	    var props = Object.create(null),
	        foundProp = null;
	    for (var i = 0; i < this.forward.length; ++i) {
	      var prop = this.forward[i].propHint();
	      if (prop && prop != "length" && prop != "<i>" && prop != "✖" && prop != cx.completingProperty) {
	        props[prop] = true;
	        foundProp = prop;
	      }
	    }
	    if (!foundProp) return null;

	    var objs = objsWithProp(foundProp);
	    if (objs) {
	      var matches = [];
	      search: for (var i = 0; i < objs.length; ++i) {
	        var obj = objs[i];
	        for (var prop in props) if (!obj.hasProp(prop)) continue search;
	        if (obj.hasCtor) obj = getInstance(obj);
	        matches.push(obj);
	      }
	      var canon = canonicalType(matches);
	      if (canon) {
	        guessing = true;return canon;
	      }
	    }
	  },

	  typeHint: function () {
	    return this.types.length ? this.getType() : null;
	  },
	  propagatesTo: function () {
	    return this;
	  },

	  gatherProperties: function (f, depth) {
	    for (var i = 0; i < this.types.length; ++i) this.types[i].gatherProperties(f, depth);
	  },

	  guessProperties: function (f) {
	    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
	      var prop = this.forward[i].propHint();
	      if (prop) f(prop, null, 0);
	    }
	    var guessed = this.makeupType();
	    if (guessed) guessed.gatherProperties(f);
	  }
	});

	function canonicalType(types) {
	  var arrays = 0,
	      fns = 0,
	      objs = 0,
	      prim = null;
	  for (var i = 0; i < types.length; ++i) {
	    var tp = types[i];
	    if (tp instanceof Arr) ++arrays;else if (tp instanceof Fn) ++fns;else if (tp instanceof Obj) ++objs;else if (tp instanceof Prim) {
	      if (prim && tp.name != prim.name) return null;
	      prim = tp;
	    }
	  }
	  var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);
	  if (kinds > 1) return null;
	  if (prim) return prim;

	  var maxScore = 0,
	      maxTp = null;
	  for (var i = 0; i < types.length; ++i) {
	    var tp = types[i],
	        score = 0;
	    if (arrays) {
	      score = tp.getProp("<i>").isEmpty() ? 1 : 2;
	    } else if (fns) {
	      score = 1;
	      for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;
	      if (!tp.retval.isEmpty()) ++score;
	    } else if (objs) {
	      score = tp.name ? 100 : 2;
	    }
	    if (score >= maxScore) {
	      maxScore = score;maxTp = tp;
	    }
	  }
	  return maxTp;
	}

	// PROPAGATION STRATEGIES

	function Constraint() {}
	Constraint.prototype = extend(ANull, {
	  init: function () {
	    this.origin = cx.curOrigin;
	  }
	});

	var constraint = exports.constraint = function (props, methods) {
	  var body = "this.init();";
	  props = props ? props.split(", ") : [];
	  for (var i = 0; i < props.length; ++i) body += "this." + props[i] + " = " + props[i] + ";";
	  var ctor = Function.apply(null, props.concat([body]));
	  ctor.prototype = Object.create(Constraint.prototype);
	  for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];
	  return ctor;
	};

	var PropIsSubset = constraint("prop, target", {
	  addType: function (type, weight) {
	    if (type.getProp) type.getProp(this.prop).propagate(this.target, weight);
	  },
	  propHint: function () {
	    return this.prop;
	  },
	  propagatesTo: function () {
	    if (this.prop == "<i>" || !/[^\w_]/.test(this.prop)) return { target: this.target, pathExt: "." + this.prop };
	  }
	});

	var PropHasSubset = exports.PropHasSubset = constraint("prop, type, originNode", {
	  addType: function (type, weight) {
	    if (!(type instanceof Obj)) return;
	    var prop = type.defProp(this.prop, this.originNode);
	    prop.origin = this.origin;
	    this.type.propagate(prop, weight);
	  },
	  propHint: function () {
	    return this.prop;
	  }
	});

	var ForAllProps = constraint("c", {
	  addType: function (type) {
	    if (!(type instanceof Obj)) return;
	    type.forAllProps(this.c);
	  }
	});

	function withDisabledComputing(fn, body) {
	  cx.disabledComputing = { fn: fn, prev: cx.disabledComputing };
	  try {
	    return body();
	  } finally {
	    cx.disabledComputing = cx.disabledComputing.prev;
	  }
	}
	var IsCallee = exports.IsCallee = constraint("self, args, argNodes, retval", {
	  init: function () {
	    Constraint.prototype.init();
	    this.disabled = cx.disabledComputing;
	  },
	  addType: function (fn, weight) {
	    if (!(fn instanceof Fn)) return;
	    for (var i = 0; i < this.args.length; ++i) {
	      if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);
	      if (fn.arguments) this.args[i].propagate(fn.arguments, weight);
	    }
	    this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);
	    var compute = fn.computeRet;
	    if (compute) for (var d = this.disabled; d; d = d.prev) if (d.fn == fn || fn.name && d.fn.name == fn.name) compute = null;
	    if (compute) compute(this.self, this.args, this.argNodes).propagate(this.retval, weight);else fn.retval.propagate(this.retval, weight);
	  },
	  typeHint: function () {
	    var names = [];
	    for (var i = 0; i < this.args.length; ++i) names.push("?");
	    return new Fn(null, this.self, this.args, names, ANull);
	  },
	  propagatesTo: function () {
	    return { target: this.retval, pathExt: ".!ret" };
	  }
	});

	var HasMethodCall = constraint("propName, args, argNodes, retval", {
	  init: function () {
	    Constraint.prototype.init();
	    this.disabled = cx.disabledComputing;
	  },
	  addType: function (obj, weight) {
	    var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);
	    callee.disabled = this.disabled;
	    obj.getProp(this.propName).propagate(callee, weight);
	  },
	  propHint: function () {
	    return this.propName;
	  }
	});

	var IsCtor = exports.IsCtor = constraint("target, noReuse", {
	  addType: function (f, weight) {
	    if (!(f instanceof Fn)) return;
	    f.getProp("prototype").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);
	  }
	});

	var getInstance = exports.getInstance = function (obj, ctor) {
	  if (ctor === false) return new Obj(obj);

	  if (!ctor) ctor = obj.hasCtor;
	  if (!obj.instances) obj.instances = [];
	  for (var i = 0; i < obj.instances.length; ++i) {
	    var cur = obj.instances[i];
	    if (cur.ctor == ctor) return cur.instance;
	  }
	  var instance = new Obj(obj, ctor && ctor.name);
	  instance.origin = obj.origin;
	  obj.instances.push({ ctor: ctor, instance: instance });
	  return instance;
	};

	var IsProto = exports.IsProto = constraint("ctor, target", {
	  addType: function (o, _weight) {
	    if (!(o instanceof Obj)) return;
	    if ((this.count = (this.count || 0) + 1) > 8) return;
	    if (o == cx.protos.Array) this.target.addType(new Arr());else this.target.addType(getInstance(o, this.ctor));
	  }
	});

	var FnPrototype = constraint("fn", {
	  addType: function (o, _weight) {
	    if (o instanceof Obj && !o.hasCtor) {
	      o.hasCtor = this.fn;
	      var adder = new SpeculativeThis(o, this.fn);
	      adder.addType(this.fn);
	      o.forAllProps(function (_prop, val, local) {
	        if (local) val.propagate(adder);
	      });
	    }
	  }
	});

	var IsAdded = constraint("other, target", {
	  addType: function (type, weight) {
	    if (type == cx.str) this.target.addType(cx.str, weight);else if (type == cx.num && this.other.hasType(cx.num)) this.target.addType(cx.num, weight);
	  },
	  typeHint: function () {
	    return this.other;
	  }
	});

	var IfObj = exports.IfObj = constraint("target", {
	  addType: function (t, weight) {
	    if (t instanceof Obj) this.target.addType(t, weight);
	  },
	  propagatesTo: function () {
	    return this.target;
	  }
	});

	var SpeculativeThis = constraint("obj, ctor", {
	  addType: function (tp) {
	    if (tp instanceof Fn && tp.self && tp.self.isEmpty()) tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_THIS);
	  }
	});

	var Muffle = constraint("inner, weight", {
	  addType: function (tp, weight) {
	    this.inner.addType(tp, Math.min(weight, this.weight));
	  },
	  propagatesTo: function () {
	    return this.inner.propagatesTo();
	  },
	  typeHint: function () {
	    return this.inner.typeHint();
	  },
	  propHint: function () {
	    return this.inner.propHint();
	  }
	});

	// TYPE OBJECTS

	var Type = exports.Type = function () {};
	Type.prototype = extend(ANull, {
	  constructor: Type,
	  propagate: function (c, w) {
	    c.addType(this, w);
	  },
	  hasType: function (other) {
	    return other == this;
	  },
	  isEmpty: function () {
	    return false;
	  },
	  typeHint: function () {
	    return this;
	  },
	  getType: function () {
	    return this;
	  }
	});

	var Prim = exports.Prim = function (proto, name) {
	  this.name = name;this.proto = proto;
	};
	Prim.prototype = extend(Type.prototype, {
	  constructor: Prim,
	  toString: function () {
	    return this.name;
	  },
	  getProp: function (prop) {
	    return this.proto.hasProp(prop) || ANull;
	  },
	  gatherProperties: function (f, depth) {
	    if (this.proto) this.proto.gatherProperties(f, depth);
	  }
	});

	var Obj = exports.Obj = function (proto, name) {
	  if (!this.props) this.props = Object.create(null);
	  this.proto = proto === true ? cx.protos.Object : proto;
	  if (proto && !name && proto.name && !(this instanceof Fn)) {
	    var match = /^(.*)\.prototype$/.exec(this.proto.name);
	    if (match) name = match[1];
	  }
	  this.name = name;
	  this.maybeProps = null;
	  this.origin = cx.curOrigin;
	};
	Obj.prototype = extend(Type.prototype, {
	  constructor: Obj,
	  toString: function (maxDepth) {
	    if (!maxDepth && this.name) return this.name;
	    var props = [],
	        etc = false;
	    for (var prop in this.props) if (prop != "<i>") {
	      if (props.length > 5) {
	        etc = true;break;
	      }
	      if (maxDepth) props.push(prop + ": " + toString(this.props[prop].getType(), maxDepth - 1));else props.push(prop);
	    }
	    props.sort();
	    if (etc) props.push("...");
	    return "{" + props.join(", ") + "}";
	  },
	  hasProp: function (prop, searchProto) {
	    var found = this.props[prop];
	    if (searchProto !== false) for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];
	    return found;
	  },
	  defProp: function (prop, originNode) {
	    var found = this.hasProp(prop, false);
	    if (found) {
	      if (found.maybePurge) found.maybePurge = false;
	      if (originNode && !found.originNode) found.originNode = originNode;
	      return found;
	    }
	    if (prop == "__proto__" || prop == "✖") return ANull;

	    var av = this.maybeProps && this.maybeProps[prop];
	    if (av) {
	      delete this.maybeProps[prop];
	      this.maybeUnregProtoPropHandler();
	    } else {
	      av = new AVal();
	      av.propertyOf = this;
	    }

	    this.props[prop] = av;
	    av.originNode = originNode;
	    av.origin = cx.curOrigin;
	    this.broadcastProp(prop, av, true);
	    return av;
	  },
	  getProp: function (prop) {
	    var found = this.hasProp(prop, true) || this.maybeProps && this.maybeProps[prop];
	    if (found) return found;
	    if (prop == "__proto__" || prop == "✖") return ANull;
	    var av = this.ensureMaybeProps()[prop] = new AVal();
	    av.propertyOf = this;
	    return av;
	  },
	  broadcastProp: function (prop, val, local) {
	    if (local) {
	      this.signal("addProp", prop, val);
	      // If this is a scope, it shouldn't be registered
	      if (!(this instanceof Scope)) registerProp(prop, this);
	    }

	    if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {
	      var h = this.onNewProp[i];
	      h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);
	    }
	  },
	  onProtoProp: function (prop, val, _local) {
	    var maybe = this.maybeProps && this.maybeProps[prop];
	    if (maybe) {
	      delete this.maybeProps[prop];
	      this.maybeUnregProtoPropHandler();
	      this.proto.getProp(prop).propagate(maybe);
	    }
	    this.broadcastProp(prop, val, false);
	  },
	  ensureMaybeProps: function () {
	    if (!this.maybeProps) {
	      if (this.proto) this.proto.forAllProps(this);
	      this.maybeProps = Object.create(null);
	    }
	    return this.maybeProps;
	  },
	  removeProp: function (prop) {
	    var av = this.props[prop];
	    delete this.props[prop];
	    this.ensureMaybeProps()[prop] = av;
	  },
	  forAllProps: function (c) {
	    if (!this.onNewProp) {
	      this.onNewProp = [];
	      if (this.proto) this.proto.forAllProps(this);
	    }
	    this.onNewProp.push(c);
	    for (var o = this; o; o = o.proto) for (var prop in o.props) {
	      if (c.onProtoProp) c.onProtoProp(prop, o.props[prop], o == this);else c(prop, o.props[prop], o == this);
	    }
	  },
	  maybeUnregProtoPropHandler: function () {
	    if (this.maybeProps) {
	      for (var _n in this.maybeProps) return;
	      this.maybeProps = null;
	    }
	    if (!this.proto || this.onNewProp && this.onNewProp.length) return;
	    this.proto.unregPropHandler(this);
	  },
	  unregPropHandler: function (handler) {
	    for (var i = 0; i < this.onNewProp.length; ++i) if (this.onNewProp[i] == handler) {
	      this.onNewProp.splice(i, 1);break;
	    }
	    this.maybeUnregProtoPropHandler();
	  },
	  gatherProperties: function (f, depth) {
	    for (var prop in this.props) if (prop != "<i>") f(prop, this, depth);
	    if (this.proto) this.proto.gatherProperties(f, depth + 1);
	  }
	});

	var Fn = exports.Fn = function (name, self, args, argNames, retval) {
	  Obj.call(this, cx.protos.Function, name);
	  this.self = self;
	  this.args = args;
	  this.argNames = argNames;
	  this.retval = retval;
	};
	Fn.prototype = extend(Obj.prototype, {
	  constructor: Fn,
	  toString: function (maxDepth) {
	    if (maxDepth) maxDepth--;
	    var str = "fn(";
	    for (var i = 0; i < this.args.length; ++i) {
	      if (i) str += ", ";
	      var name = this.argNames[i];
	      if (name && name != "?") str += name + ": ";
	      str += toString(this.args[i].getType(), maxDepth, this);
	    }
	    str += ")";
	    if (!this.retval.isEmpty()) str += " -> " + toString(this.retval.getType(), maxDepth, this);
	    return str;
	  },
	  getProp: function (prop) {
	    if (prop == "prototype") {
	      var known = this.hasProp(prop, false);
	      if (!known) {
	        known = this.defProp(prop);
	        var proto = new Obj(true, this.name && this.name + ".prototype");
	        proto.origin = this.origin;
	        known.addType(proto, WG_MADEUP_PROTO);
	      }
	      return known;
	    }
	    return Obj.prototype.getProp.call(this, prop);
	  },
	  defProp: function (prop, originNode) {
	    if (prop == "prototype") {
	      var found = this.hasProp(prop, false);
	      if (found) return found;
	      found = Obj.prototype.defProp.call(this, prop, originNode);
	      found.origin = this.origin;
	      found.propagate(new FnPrototype(this));
	      return found;
	    }
	    return Obj.prototype.defProp.call(this, prop, originNode);
	  },
	  getFunctionType: function () {
	    return this;
	  }
	});

	var Arr = exports.Arr = function (contentType) {
	  Obj.call(this, cx.protos.Array);
	  var content = this.defProp("<i>");
	  if (contentType) contentType.propagate(content);
	};
	Arr.prototype = extend(Obj.prototype, {
	  constructor: Arr,
	  toString: function (maxDepth) {
	    return "[" + toString(this.getProp("<i>").getType(), maxDepth, this) + "]";
	  }
	});

	// THE PROPERTY REGISTRY

	function registerProp(prop, obj) {
	  var data = cx.props[prop] || (cx.props[prop] = []);
	  data.push(obj);
	}

	function objsWithProp(prop) {
	  return cx.props[prop];
	}

	// INFERENCE CONTEXT

	exports.Context = function (defs, parent) {
	  this.parent = parent;
	  this.props = Object.create(null);
	  this.protos = Object.create(null);
	  this.origins = [];
	  this.curOrigin = "ecma5";
	  this.paths = Object.create(null);
	  this.definitions = Object.create(null);
	  this.purgeGen = 0;
	  this.workList = null;
	  this.disabledComputing = null;

	  exports.withContext(this, function () {
	    cx.protos.Object = new Obj(null, "Object.prototype");
	    cx.topScope = new Scope();
	    cx.topScope.name = "<top>";
	    cx.protos.Array = new Obj(true, "Array.prototype");
	    cx.protos.Function = new Obj(true, "Function.prototype");
	    cx.protos.RegExp = new Obj(true, "RegExp.prototype");
	    cx.protos.String = new Obj(true, "String.prototype");
	    cx.protos.Number = new Obj(true, "Number.prototype");
	    cx.protos.Boolean = new Obj(true, "Boolean.prototype");
	    cx.str = new Prim(cx.protos.String, "string");
	    cx.bool = new Prim(cx.protos.Boolean, "bool");
	    cx.num = new Prim(cx.protos.Number, "number");
	    cx.curOrigin = null;

	    if (defs) for (var i = 0; i < defs.length; ++i) def.load(defs[i]);
	  });
	};

	var cx = null;
	exports.cx = function () {
	  return cx;
	};

	exports.withContext = function (context, f) {
	  var old = cx;
	  cx = context;
	  try {
	    return f();
	  } finally {
	    cx = old;
	  }
	};

	exports.TimedOut = function () {
	  this.message = "Timed out";
	  this.stack = new Error().stack;
	};
	exports.TimedOut.prototype = Object.create(Error.prototype);
	exports.TimedOut.prototype.name = "infer.TimedOut";

	var timeout;
	exports.withTimeout = function (ms, f) {
	  var end = +new Date() + ms;
	  var oldEnd = timeout;
	  if (oldEnd && oldEnd < end) return f();
	  timeout = end;
	  try {
	    return f();
	  } finally {
	    timeout = oldEnd;
	  }
	};

	exports.addOrigin = function (origin) {
	  if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);
	};

	var baseMaxWorkDepth = 20,
	    reduceMaxWorkDepth = .0001;
	function withWorklist(f) {
	  if (cx.workList) return f(cx.workList);

	  var list = [],
	      depth = 0;
	  var add = cx.workList = function (type, target, weight) {
	    if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length) list.push(type, target, weight, depth);
	  };
	  try {
	    var ret = f(add);
	    for (var i = 0; i < list.length; i += 4) {
	      if (timeout && +new Date() >= timeout) throw new exports.TimedOut();
	      depth = list[i + 3] + 1;
	      list[i + 1].addType(list[i], list[i + 2]);
	    }
	    return ret;
	  } finally {
	    cx.workList = null;
	  }
	}

	// SCOPES

	var Scope = exports.Scope = function (prev) {
	  Obj.call(this, prev || true);
	  this.prev = prev;
	};
	Scope.prototype = extend(Obj.prototype, {
	  constructor: Scope,
	  defVar: function (name, originNode) {
	    for (var s = this;; s = s.proto) {
	      var found = s.props[name];
	      if (found) return found;
	      if (!s.prev) return s.defProp(name, originNode);
	    }
	  }
	});

	// RETVAL COMPUTATION HEURISTICS

	function maybeInstantiate(scope, score) {
	  if (scope.fnType) scope.fnType.instantiateScore = (scope.fnType.instantiateScore || 0) + score;
	}

	var NotSmaller = {};
	function nodeSmallerThan(node, n) {
	  try {
	    walk.simple(node, { Expression: function () {
	        if (--n <= 0) throw NotSmaller;
	      } });
	    return true;
	  } catch (e) {
	    if (e == NotSmaller) return false;
	    throw e;
	  }
	}

	function maybeTagAsInstantiated(node, scope) {
	  var score = scope.fnType.instantiateScore;
	  if (!cx.disabledComputing && score && scope.fnType.args.length && nodeSmallerThan(node, score * 5)) {
	    maybeInstantiate(scope.prev, score / 2);
	    setFunctionInstantiated(node, scope);
	    return true;
	  } else {
	    scope.fnType.instantiateScore = null;
	  }
	}

	function setFunctionInstantiated(node, scope) {
	  var fn = scope.fnType;
	  // Disconnect the arg avals, so that we can add info to them without side effects
	  for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal();
	  fn.self = new AVal();
	  fn.computeRet = function (self, args) {
	    // Prevent recursion
	    return withDisabledComputing(fn, function () {
	      var oldOrigin = cx.curOrigin;
	      cx.curOrigin = fn.origin;
	      var scopeCopy = new Scope(scope.prev);
	      scopeCopy.originNode = scope.originNode;
	      for (var v in scope.props) {
	        var local = scopeCopy.defProp(v, scope.props[v].originNode);
	        for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length) args[i].propagate(local);
	      }
	      var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;
	      while (argNames.length < args.length) argNames.push("?");
	      scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull);
	      if (fn.arguments) {
	        var argset = scopeCopy.fnType.arguments = new AVal();
	        scopeCopy.defProp("arguments").addType(new Arr(argset));
	        for (var i = 0; i < args.length; ++i) args[i].propagate(argset);
	      }
	      node.body.scope = scopeCopy;
	      walk.recursive(node.body, scopeCopy, null, scopeGatherer);
	      walk.recursive(node.body, scopeCopy, null, inferWrapper);
	      cx.curOrigin = oldOrigin;
	      return scopeCopy.fnType.retval;
	    });
	  };
	}

	function maybeTagAsGeneric(scope) {
	  var fn = scope.fnType,
	      target = fn.retval;
	  if (target == ANull) return;
	  var targetInner, asArray;
	  if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr) target = asArray = targetInner.getProp("<i>");

	  function explore(aval, path, depth) {
	    if (depth > 3 || !aval.forward) return;
	    for (var i = 0; i < aval.forward.length; ++i) {
	      var prop = aval.forward[i].propagatesTo();
	      if (!prop) continue;
	      var newPath = path,
	          dest;
	      if (prop instanceof AVal) {
	        dest = prop;
	      } else if (prop.target instanceof AVal) {
	        newPath += prop.pathExt;
	        dest = prop.target;
	      } else continue;
	      if (dest == target) return newPath;
	      var found = explore(dest, newPath, depth + 1);
	      if (found) return found;
	    }
	  }

	  var foundPath = explore(fn.self, "!this", 0);
	  for (var i = 0; !foundPath && i < fn.args.length; ++i) foundPath = explore(fn.args[i], "!" + i, 0);

	  if (foundPath) {
	    if (asArray) foundPath = "[" + foundPath + "]";
	    var p = new def.TypeParser(foundPath);
	    fn.computeRet = p.parseRetType();
	    fn.computeRetSource = foundPath;
	    return true;
	  }
	}

	// SCOPE GATHERING PASS

	function addVar(scope, nameNode) {
	  return scope.defProp(nameNode.name, nameNode);
	}

	var scopeGatherer = walk.make({
	  Function: function (node, scope, c) {
	    var inner = node.body.scope = new Scope(scope);
	    inner.originNode = node;
	    var argVals = [],
	        argNames = [];
	    for (var i = 0; i < node.params.length; ++i) {
	      var param = node.params[i];
	      argNames.push(param.name);
	      argVals.push(addVar(inner, param));
	    }
	    inner.fnType = new Fn(node.id && node.id.name, new AVal(), argVals, argNames, ANull);
	    inner.fnType.originNode = node;
	    if (node.id) {
	      var decl = node.type == "FunctionDeclaration";
	      addVar(decl ? scope : inner, node.id);
	    }
	    c(node.body, inner, "ScopeBody");
	  },
	  TryStatement: function (node, scope, c) {
	    c(node.block, scope, "Statement");
	    if (node.handler) {
	      var v = addVar(scope, node.handler.param);
	      c(node.handler.body, scope, "ScopeBody");
	      var e5 = cx.definitions.ecma5;
	      if (e5 && v.isEmpty()) getInstance(e5["Error.prototype"]).propagate(v, WG_CATCH_ERROR);
	    }
	    if (node.finalizer) c(node.finalizer, scope, "Statement");
	  },
	  VariableDeclaration: function (node, scope, c) {
	    for (var i = 0; i < node.declarations.length; ++i) {
	      var decl = node.declarations[i];
	      addVar(scope, decl.id);
	      if (decl.init) c(decl.init, scope, "Expression");
	    }
	  }
	});

	// CONSTRAINT GATHERING PASS

	function propName(node, scope, c) {
	  var prop = node.property;
	  if (!node.computed) return prop.name;
	  if (prop.type == "Literal" && typeof prop.value == "string") return prop.value;
	  if (c) infer(prop, scope, c, ANull);
	  return "<i>";
	}

	function unopResultType(op) {
	  switch (op) {
	    case "+":case "-":case "~":
	      return cx.num;
	    case "!":
	      return cx.bool;
	    case "typeof":
	      return cx.str;
	    case "void":case "delete":
	      return ANull;
	  }
	}
	function binopIsBoolean(op) {
	  switch (op) {
	    case "==":case "!=":case "===":case "!==":case "<":case ">":case ">=":case "<=":
	    case "in":case "instanceof":
	      return true;
	  }
	}
	function literalType(val) {
	  switch (typeof val) {
	    case "boolean":
	      return cx.bool;
	    case "number":
	      return cx.num;
	    case "string":
	      return cx.str;
	    case "object":
	    case "function":
	      if (!val) return ANull;
	      return getInstance(cx.protos.RegExp);
	  }
	}

	function ret(f) {
	  return function (node, scope, c, out, name) {
	    var r = f(node, scope, c, name);
	    if (out) r.propagate(out);
	    return r;
	  };
	}
	function fill(f) {
	  return function (node, scope, c, out, name) {
	    if (!out) out = new AVal();
	    f(node, scope, c, out, name);
	    return out;
	  };
	}

	var inferExprVisitor = {
	  ArrayExpression: ret(function (node, scope, c) {
	    var eltval = new AVal();
	    for (var i = 0; i < node.elements.length; ++i) {
	      var elt = node.elements[i];
	      if (elt) infer(elt, scope, c, eltval);
	    }
	    return new Arr(eltval);
	  }),
	  ObjectExpression: ret(function (node, scope, c, name) {
	    var obj = node.objType = new Obj(true, name);
	    obj.originNode = node;

	    for (var i = 0; i < node.properties.length; ++i) {
	      var prop = node.properties[i],
	          key = prop.key,
	          name;
	      if (key.type == "Identifier") {
	        name = key.name;
	      } else if (typeof key.value == "string") {
	        name = key.value;
	      } else {
	        infer(prop.value, scope, c, ANull);
	        continue;
	      }
	      var val = obj.defProp(name, key);
	      val.initializer = true;
	      infer(prop.value, scope, c, val, name);
	    }
	    return obj;
	  }),
	  FunctionExpression: ret(function (node, scope, c, name) {
	    var inner = node.body.scope,
	        fn = inner.fnType;
	    if (name && !fn.name) fn.name = name;
	    c(node.body, scope, "ScopeBody");
	    maybeTagAsInstantiated(node, inner) || maybeTagAsGeneric(inner);
	    if (node.id) inner.getProp(node.id.name).addType(fn);
	    return fn;
	  }),
	  SequenceExpression: ret(function (node, scope, c) {
	    for (var i = 0, l = node.expressions.length - 1; i < l; ++i) infer(node.expressions[i], scope, c, ANull);
	    return infer(node.expressions[l], scope, c);
	  }),
	  UnaryExpression: ret(function (node, scope, c) {
	    infer(node.argument, scope, c, ANull);
	    return unopResultType(node.operator);
	  }),
	  UpdateExpression: ret(function (node, scope, c) {
	    infer(node.argument, scope, c, ANull);
	    return cx.num;
	  }),
	  BinaryExpression: ret(function (node, scope, c) {
	    if (node.operator == "+") {
	      var lhs = infer(node.left, scope, c);
	      var rhs = infer(node.right, scope, c);
	      if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
	      if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;
	      var result = new AVal();
	      lhs.propagate(new IsAdded(rhs, result));
	      rhs.propagate(new IsAdded(lhs, result));
	      return result;
	    } else {
	      infer(node.left, scope, c, ANull);
	      infer(node.right, scope, c, ANull);
	      return binopIsBoolean(node.operator) ? cx.bool : cx.num;
	    }
	  }),
	  AssignmentExpression: ret(function (node, scope, c) {
	    var rhs, name, pName;
	    if (node.left.type == "MemberExpression") {
	      pName = propName(node.left, scope, c);
	      if (node.left.object.type == "Identifier") name = node.left.object.name + "." + pName;
	    } else {
	      name = node.left.name;
	    }

	    if (node.operator != "=" && node.operator != "+=") {
	      infer(node.right, scope, c, ANull);
	      rhs = cx.num;
	    } else {
	      rhs = infer(node.right, scope, c, null, name);
	    }

	    if (node.left.type == "MemberExpression") {
	      var obj = infer(node.left.object, scope, c);
	      if (pName == "prototype") maybeInstantiate(scope, 20);
	      if (pName == "<i>") {
	        // This is a hack to recognize for/in loops that copy
	        // properties, and do the copying ourselves, insofar as we
	        // manage, because such loops tend to be relevant for type
	        // information.
	        var v = node.left.property.name,
	            local = scope.props[v],
	            over = local && local.iteratesOver;
	        if (over) {
	          maybeInstantiate(scope, 20);
	          var fromRight = node.right.type == "MemberExpression" && node.right.computed && node.right.property.name == v;
	          over.forAllProps(function (prop, val, local) {
	            if (local && prop != "prototype" && prop != "<i>") obj.propagate(new PropHasSubset(prop, fromRight ? val : ANull));
	          });
	          return rhs;
	        }
	      }
	      obj.propagate(new PropHasSubset(pName, rhs, node.left.property));
	    } else {
	      // Identifier
	      var v = scope.defVar(node.left.name, node.left);
	      if (v.maybePurge) v.maybePurge = false;
	      rhs.propagate(v);
	    }
	    return rhs;
	  }),
	  LogicalExpression: fill(function (node, scope, c, out) {
	    infer(node.left, scope, c, out);
	    infer(node.right, scope, c, out);
	  }),
	  ConditionalExpression: fill(function (node, scope, c, out) {
	    infer(node.test, scope, c, ANull);
	    infer(node.consequent, scope, c, out);
	    infer(node.alternate, scope, c, out);
	  }),
	  NewExpression: fill(function (node, scope, c, out, name) {
	    if (node.callee.type == "Identifier" && node.callee.name in scope.props) maybeInstantiate(scope, 20);

	    for (var i = 0, args = []; i < node.arguments.length; ++i) args.push(infer(node.arguments[i], scope, c));
	    var callee = infer(node.callee, scope, c);
	    var self = new AVal();
	    callee.propagate(new IsCtor(self, name && /\.prototype$/.test(name)));
	    self.propagate(out, WG_NEW_INSTANCE);
	    callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));
	  }),
	  CallExpression: fill(function (node, scope, c, out) {
	    for (var i = 0, args = []; i < node.arguments.length; ++i) args.push(infer(node.arguments[i], scope, c));
	    if (node.callee.type == "MemberExpression") {
	      var self = infer(node.callee.object, scope, c);
	      var pName = propName(node.callee, scope, c);
	      if ((pName == "call" || pName == "apply") && scope.fnType && scope.fnType.args.indexOf(self) > -1) maybeInstantiate(scope, 30);
	      self.propagate(new HasMethodCall(pName, args, node.arguments, out));
	    } else {
	      var callee = infer(node.callee, scope, c);
	      if (scope.fnType && scope.fnType.args.indexOf(callee) > -1) maybeInstantiate(scope, 30);
	      var knownFn = callee.getFunctionType();
	      if (knownFn && knownFn.instantiateScore && scope.fnType) maybeInstantiate(scope, knownFn.instantiateScore / 5);
	      callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));
	    }
	  }),
	  MemberExpression: fill(function (node, scope, c, out) {
	    var name = propName(node, scope);
	    var obj = infer(node.object, scope, c);
	    var prop = obj.getProp(name);
	    if (name == "<i>") {
	      var propType = infer(node.property, scope, c);
	      if (!propType.hasType(cx.num)) return prop.propagate(out, WG_MULTI_MEMBER);
	    }
	    prop.propagate(out);
	  }),
	  Identifier: ret(function (node, scope) {
	    if (node.name == "arguments" && scope.fnType && !(node.name in scope.props)) scope.defProp(node.name, scope.fnType.originNode).addType(new Arr(scope.fnType.arguments = new AVal()));
	    return scope.getProp(node.name);
	  }),
	  ThisExpression: ret(function (_node, scope) {
	    return scope.fnType ? scope.fnType.self : cx.topScope;
	  }),
	  Literal: ret(function (node) {
	    return literalType(node.value);
	  })
	};

	function infer(node, scope, c, out, name) {
	  return inferExprVisitor[node.type](node, scope, c, out, name);
	}

	var inferWrapper = walk.make({
	  Expression: function (node, scope, c) {
	    infer(node, scope, c, ANull);
	  },

	  FunctionDeclaration: function (node, scope, c) {
	    var inner = node.body.scope,
	        fn = inner.fnType;
	    c(node.body, scope, "ScopeBody");
	    maybeTagAsInstantiated(node, inner) || maybeTagAsGeneric(inner);
	    var prop = scope.getProp(node.id.name);
	    prop.addType(fn);
	  },

	  VariableDeclaration: function (node, scope, c) {
	    for (var i = 0; i < node.declarations.length; ++i) {
	      var decl = node.declarations[i],
	          prop = scope.getProp(decl.id.name);
	      if (decl.init) infer(decl.init, scope, c, prop, decl.id.name);
	    }
	  },

	  ReturnStatement: function (node, scope, c) {
	    if (!node.argument) return;
	    var output = ANull;
	    if (scope.fnType) {
	      if (scope.fnType.retval == ANull) scope.fnType.retval = new AVal();
	      output = scope.fnType.retval;
	    }
	    infer(node.argument, scope, c, output);
	  },

	  ForInStatement: function (node, scope, c) {
	    var source = infer(node.right, scope, c);
	    if (node.right.type == "Identifier" && node.right.name in scope.props || node.right.type == "MemberExpression" && node.right.property.name == "prototype") {
	      maybeInstantiate(scope, 5);
	      var varName;
	      if (node.left.type == "Identifier") {
	        varName = node.left.name;
	      } else if (node.left.type == "VariableDeclaration") {
	        varName = node.left.declarations[0].id.name;
	      }
	      if (varName && varName in scope.props) scope.getProp(varName).iteratesOver = source;
	    }
	    c(node.body, scope, "Statement");
	  },

	  ScopeBody: function (node, scope, c) {
	    c(node, node.scope || scope);
	  }
	});

	// PARSING

	function runPasses(passes, pass) {
	  var arr = passes && passes[pass];
	  var args = Array.prototype.slice.call(arguments, 2);
	  if (arr) for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
	}

	var parse = exports.parse = function (text, passes, options) {
	  var ast;
	  try {
	    ast = acorn.parse(text, options);
	  } catch (e) {
	    ast = acorn_loose.parse_dammit(text, options);
	  }
	  runPasses(passes, "postParse", ast, text);
	  return ast;
	};

	// ANALYSIS INTERFACE

	exports.analyze = function (ast, name, scope, passes) {
	  if (typeof ast == "string") ast = parse(ast);

	  if (!name) name = "file#" + cx.origins.length;
	  exports.addOrigin(cx.curOrigin = name);

	  if (!scope) scope = cx.topScope;
	  walk.recursive(ast, scope, null, scopeGatherer);
	  runPasses(passes, "preInfer", ast, scope);
	  walk.recursive(ast, scope, null, inferWrapper);
	  runPasses(passes, "postInfer", ast, scope);

	  cx.curOrigin = null;
	};

	// PURGING

	exports.purgeTypes = function (origins, start, end) {
	  var test = makePredicate(origins, start, end);
	  ++cx.purgeGen;
	  cx.topScope.purge(test);
	  for (var prop in cx.props) {
	    var list = cx.props[prop];
	    for (var i = 0; i < list.length; ++i) {
	      var obj = list[i],
	          av = obj.props[prop];
	      if (!av || test(av, av.originNode)) list.splice(i--, 1);
	    }
	    if (!list.length) delete cx.props[prop];
	  }
	};

	function makePredicate(origins, start, end) {
	  var arr = Array.isArray(origins);
	  if (arr && origins.length == 1) {
	    origins = origins[0];arr = false;
	  }
	  if (arr) {
	    if (end == null) return function (n) {
	      return origins.indexOf(n.origin) > -1;
	    };
	    return function (n, pos) {
	      return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1;
	    };
	  } else {
	    if (end == null) return function (n) {
	      return n.origin == origins;
	    };
	    return function (n, pos) {
	      return pos && pos.start >= start && pos.end <= end && n.origin == origins;
	    };
	  }
	}

	AVal.prototype.purge = function (test) {
	  if (this.purgeGen == cx.purgeGen) return;
	  this.purgeGen = cx.purgeGen;
	  for (var i = 0; i < this.types.length; ++i) {
	    var type = this.types[i];
	    if (test(type, type.originNode)) this.types.splice(i--, 1);else type.purge(test);
	  }
	  if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
	    var f = this.forward[i];
	    if (test(f)) {
	      this.forward.splice(i--, 1);
	      if (this.props) this.props = null;
	    } else if (f.purge) {
	      f.purge(test);
	    }
	  }
	};
	ANull.purge = function () {};
	Obj.prototype.purge = function (test) {
	  if (this.purgeGen == cx.purgeGen) return true;
	  this.purgeGen = cx.purgeGen;
	  var props = [];
	  for (var p in this.props) {
	    var av = this.props[p];
	    if (test(av, av.originNode)) this.removeProp(p);
	    av.purge(test);
	  }
	};
	Fn.prototype.purge = function (test) {
	  if (Obj.prototype.purge.call(this, test)) return;
	  this.self.purge(test);
	  this.retval.purge(test);
	  for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);
	};

	exports.markVariablesDefinedBy = function (scope, origins, start, end) {
	  var test = makePredicate(origins, start, end);
	  for (var s = scope; s; s = s.prev) for (var p in s.props) {
	    var prop = s.props[p];
	    if (test(prop, prop.originNode)) {
	      prop.maybePurge = true;
	      if (start == null && prop.originNode) prop.originNode = null;
	    }
	  }
	};

	exports.purgeMarkedVariables = function (scope) {
	  for (var s = scope; s; s = s.prev) for (var p in s.props) if (s.props[p].maybePurge) delete s.props[p];
	};

	// EXPRESSION TYPE DETERMINATION

	function findByPropertyName(name) {
	  guessing = true;
	  var found = objsWithProp(name);
	  if (found) for (var i = 0; i < found.length; ++i) {
	    var val = found[i].getProp(name);
	    if (!val.isEmpty()) return val;
	  }
	  return ANull;
	}

	var typeFinder = {
	  ArrayExpression: function (node, scope) {
	    var eltval = new AVal();
	    for (var i = 0; i < node.elements.length; ++i) {
	      var elt = node.elements[i];
	      if (elt) findType(elt, scope).propagate(eltval);
	    }
	    return new Arr(eltval);
	  },
	  ObjectExpression: function (node) {
	    return node.objType;
	  },
	  FunctionExpression: function (node) {
	    return node.body.scope.fnType;
	  },
	  SequenceExpression: function (node, scope) {
	    return findType(node.expressions[node.expressions.length - 1], scope);
	  },
	  UnaryExpression: function (node) {
	    return unopResultType(node.operator);
	  },
	  UpdateExpression: function () {
	    return cx.num;
	  },
	  BinaryExpression: function (node, scope) {
	    if (binopIsBoolean(node.operator)) return cx.bool;
	    if (node.operator == "+") {
	      var lhs = findType(node.left, scope);
	      var rhs = findType(node.right, scope);
	      if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
	    }
	    return cx.num;
	  },
	  AssignmentExpression: function (node, scope) {
	    return findType(node.right, scope);
	  },
	  LogicalExpression: function (node, scope) {
	    var lhs = findType(node.left, scope);
	    return lhs.isEmpty() ? findType(node.right, scope) : lhs;
	  },
	  ConditionalExpression: function (node, scope) {
	    var lhs = findType(node.consequent, scope);
	    return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;
	  },
	  NewExpression: function (node, scope) {
	    var f = findType(node.callee, scope).getFunctionType();
	    var proto = f && f.getProp("prototype").getType();
	    if (!proto) return ANull;
	    return getInstance(proto, f);
	  },
	  CallExpression: function (node, scope) {
	    var f = findType(node.callee, scope).getFunctionType();
	    if (!f) return ANull;
	    if (f.computeRet) {
	      for (var i = 0, args = []; i < node.arguments.length; ++i) args.push(findType(node.arguments[i], scope));
	      var self = ANull;
	      if (node.callee.type == "MemberExpression") self = findType(node.callee.object, scope);
	      return f.computeRet(self, args, node.arguments);
	    } else {
	      return f.retval;
	    }
	  },
	  MemberExpression: function (node, scope) {
	    var propN = propName(node, scope),
	        obj = findType(node.object, scope).getType();
	    if (obj) return obj.getProp(propN);
	    if (propN == "<i>") return ANull;
	    return findByPropertyName(propN);
	  },
	  Identifier: function (node, scope) {
	    return scope.hasProp(node.name) || ANull;
	  },
	  ThisExpression: function (_node, scope) {
	    return scope.fnType ? scope.fnType.self : cx.topScope;
	  },
	  Literal: function (node) {
	    return literalType(node.value);
	  }
	};

	function findType(node, scope) {
	  var found = typeFinder[node.type](node, scope);
	  return found;
	}

	var searchVisitor = exports.searchVisitor = walk.make({
	  Function: function (node, _st, c) {
	    var scope = node.body.scope;
	    if (node.id) c(node.id, scope);
	    for (var i = 0; i < node.params.length; ++i) c(node.params[i], scope);
	    c(node.body, scope, "ScopeBody");
	  },
	  TryStatement: function (node, st, c) {
	    if (node.handler) c(node.handler.param, st);
	    walk.base.TryStatement(node, st, c);
	  },
	  VariableDeclaration: function (node, st, c) {
	    for (var i = 0; i < node.declarations.length; ++i) {
	      var decl = node.declarations[i];
	      c(decl.id, st);
	      if (decl.init) c(decl.init, st, "Expression");
	    }
	  }
	});
	exports.fullVisitor = walk.make({
	  MemberExpression: function (node, st, c) {
	    c(node.object, st, "Expression");
	    c(node.property, st, node.computed ? "Expression" : null);
	  },
	  ObjectExpression: function (node, st, c) {
	    for (var i = 0; i < node.properties.length; ++i) {
	      c(node.properties[i].value, st, "Expression");
	      c(node.properties[i].key, st);
	    }
	  }
	}, searchVisitor);

	exports.findExpressionAt = function (ast, start, end, defaultScope, filter) {
	  var test = filter || function (_t, node) {
	    return typeFinder.hasOwnProperty(node.type);
	  };
	  return walk.findNodeAt(ast, start, end, test, searchVisitor, defaultScope || cx.topScope);
	};

	exports.findExpressionAround = function (ast, start, end, defaultScope, filter) {
	  var test = filter || function (_t, node) {
	    if (start != null && node.start > start) return false;
	    return typeFinder.hasOwnProperty(node.type);
	  };
	  return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);
	};

	exports.expressionType = function (found) {
	  return findType(found.node, found.state);
	};

	// Flag used to indicate that some wild guessing was used to produce
	// a type or set of completions.
	var guessing = false;

	exports.resetGuessing = function (val) {
	  guessing = val;
	};
	exports.didGuess = function () {
	  return guessing;
	};

	exports.forAllPropertiesOf = function (type, f) {
	  type.gatherProperties(f, 0);
	};

	var refFindWalker = walk.make({}, searchVisitor);

	exports.findRefs = function (ast, baseScope, name, refScope, f) {
	  refFindWalker.Identifier = function (node, scope) {
	    if (node.name != name) return;
	    for (var s = scope; s; s = s.prev) {
	      if (s == refScope) f(node, scope);
	      if (name in s.props) return;
	    }
	  };
	  walk.recursive(ast, baseScope, null, refFindWalker);
	};

	var simpleWalker = walk.make({
	  Function: function (node, _st, c) {
	    c(node.body, node.body.scope, "ScopeBody");
	  }
	});

	exports.findPropRefs = function (ast, scope, objType, propName, f) {
	  walk.simple(ast, {
	    MemberExpression: function (node, scope) {
	      if (node.computed || node.property.name != propName) return;
	      if (findType(node.object, scope).getType() == objType) f(node.property);
	    },
	    ObjectExpression: function (node, scope) {
	      if (findType(node, scope).getType() != objType) return;
	      for (var i = 0; i < node.properties.length; ++i) if (node.properties[i].key.name == propName) f(node.properties[i].key);
	    }
	  }, simpleWalker, scope);
	};

	// LOCAL-VARIABLE QUERIES

	var scopeAt = exports.scopeAt = function (ast, pos, defaultScope) {
	  var found = walk.findNodeAround(ast, pos, function (tp, node) {
	    return tp == "ScopeBody" && node.scope;
	  });
	  if (found) return found.node.scope;else return defaultScope || cx.topScope;
	};

	exports.forAllLocalsAt = function (ast, pos, defaultScope, f) {
	  var scope = scopeAt(ast, pos, defaultScope);
	  scope.gatherProperties(f, 0);
	};

	// INIT DEF MODULE

	// Delayed initialization because of cyclic dependencies.
	def = exports.def = def.init({}, exports);
	//});

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	// Acorn is a tiny, fast JavaScript parser written in JavaScript.
	//
	// Acorn was written by Marijn Haverbeke and various contributors and
	// released under an MIT license. The Unicode regexps (for identifiers
	// and whitespace) were taken from [Esprima](http://esprima.org) by
	// Ariya Hidayat.
	//
	// Git repositories for Acorn are available at
	//
	//     http://marijnhaverbeke.nl/git/acorn
	//     https://github.com/marijnh/acorn.git
	//
	// Please use the [github bug tracker][ghbt] to report issues.
	//
	// [ghbt]: https://github.com/marijnh/acorn/issues
	//
	// This file defines the main parser interface. The library also comes
	// with a [error-tolerant parser][dammit] and an
	// [abstract syntax tree walker][walk], defined in other files.
	//
	// [dammit]: acorn_loose.js
	// [walk]: util/walk.js

	(function (root, mod) {
	  if (true) return mod(exports); // CommonJS
	  if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	  mod(root.acorn || (root.acorn = {})); // Plain browser env
	})(this, function (exports) {
	  "use strict";

	  exports.version = "0.11.1";

	  // The main exported interface (under `self.acorn` when in the
	  // browser) is a `parse` function that takes a code string and
	  // returns an abstract syntax tree as specified by [Mozilla parser
	  // API][api], with the caveat that inline XML is not recognized.
	  //
	  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

	  var options, input, inputLen, sourceFile;

	  exports.parse = function (inpt, opts) {
	    input = String(inpt);inputLen = input.length;
	    setOptions(opts);
	    initTokenState();
	    var startPos = options.locations ? [tokPos, curPosition()] : tokPos;
	    initParserState();
	    return parseTopLevel(options.program || startNodeAt(startPos));
	  };

	  // A second optional argument can be given to further configure
	  // the parser process. These options are recognized:

	  var defaultOptions = exports.defaultOptions = {
	    // `ecmaVersion` indicates the ECMAScript version to parse. Must
	    // be either 3, or 5, or 6. This influences support for strict
	    // mode, the set of reserved words, support for getters and
	    // setters and other features.
	    ecmaVersion: 5,
	    // Turn on `strictSemicolons` to prevent the parser from doing
	    // automatic semicolon insertion.
	    strictSemicolons: false,
	    // When `allowTrailingCommas` is false, the parser will not allow
	    // trailing commas in array and object literals.
	    allowTrailingCommas: true,
	    // By default, reserved words are not enforced. Enable
	    // `forbidReserved` to enforce them. When this option has the
	    // value "everywhere", reserved words and keywords can also not be
	    // used as property names.
	    forbidReserved: false,
	    // When enabled, a return at the top level is not considered an
	    // error.
	    allowReturnOutsideFunction: false,
	    // When enabled, import/export statements are not constrained to
	    // appearing at the top of the program.
	    allowImportExportEverywhere: false,
	    // When enabled, hashbang directive in the beginning of file
	    // is allowed and treated as a line comment.
	    allowHashBang: false,
	    // When `locations` is on, `loc` properties holding objects with
	    // `start` and `end` properties in `{line, column}` form (with
	    // line being 1-based and column 0-based) will be attached to the
	    // nodes.
	    locations: false,
	    // A function can be passed as `onToken` option, which will
	    // cause Acorn to call that function with object in the same
	    // format as tokenize() returns. Note that you are not
	    // allowed to call the parser from the callback—that will
	    // corrupt its internal state.
	    onToken: null,
	    // A function can be passed as `onComment` option, which will
	    // cause Acorn to call that function with `(block, text, start,
	    // end)` parameters whenever a comment is skipped. `block` is a
	    // boolean indicating whether this is a block (`/* */`) comment,
	    // `text` is the content of the comment, and `start` and `end` are
	    // character offsets that denote the start and end of the comment.
	    // When the `locations` option is on, two more parameters are
	    // passed, the full `{line, column}` locations of the start and
	    // end of the comments. Note that you are not allowed to call the
	    // parser from the callback—that will corrupt its internal state.
	    onComment: null,
	    // Nodes have their start and end characters offsets recorded in
	    // `start` and `end` properties (directly on the node, rather than
	    // the `loc` object, which holds line/column data. To also add a
	    // [semi-standardized][range] `range` property holding a `[start,
	    // end]` array with the same numbers, set the `ranges` option to
	    // `true`.
	    //
	    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
	    ranges: false,
	    // It is possible to parse multiple files into a single AST by
	    // passing the tree produced by parsing the first file as
	    // `program` option in subsequent parses. This will add the
	    // toplevel forms of the parsed file to the `Program` (top) node
	    // of an existing parse tree.
	    program: null,
	    // When `locations` is on, you can pass this to record the source
	    // file in every node's `loc` object.
	    sourceFile: null,
	    // This value, if given, is stored in every node, whether
	    // `locations` is on or off.
	    directSourceFile: null,
	    // When enabled, parenthesized expressions are represented by
	    // (non-standard) ParenthesizedExpression nodes
	    preserveParens: false
	  };

	  // This function tries to parse a single expression at a given
	  // offset in a string. Useful for parsing mixed-language formats
	  // that embed JavaScript expressions.

	  exports.parseExpressionAt = function (inpt, pos, opts) {
	    input = String(inpt);inputLen = input.length;
	    setOptions(opts);
	    initTokenState(pos);
	    initParserState();
	    return parseExpression();
	  };

	  var isArray = function (obj) {
	    return Object.prototype.toString.call(obj) === "[object Array]";
	  };

	  function setOptions(opts) {
	    options = {};
	    for (var opt in defaultOptions) options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
	    sourceFile = options.sourceFile || null;
	    if (isArray(options.onToken)) {
	      var tokens = options.onToken;
	      options.onToken = function (token) {
	        tokens.push(token);
	      };
	    }
	    if (isArray(options.onComment)) {
	      var comments = options.onComment;
	      options.onComment = function (block, text, start, end, startLoc, endLoc) {
	        var comment = {
	          type: block ? 'Block' : 'Line',
	          value: text,
	          start: start,
	          end: end
	        };
	        if (options.locations) {
	          comment.loc = new SourceLocation();
	          comment.loc.start = startLoc;
	          comment.loc.end = endLoc;
	        }
	        if (options.ranges) comment.range = [start, end];
	        comments.push(comment);
	      };
	    }
	    isKeyword = options.ecmaVersion >= 6 ? isEcma6Keyword : isEcma5AndLessKeyword;
	  }

	  // The `getLineInfo` function is mostly useful when the
	  // `locations` option is off (for performance reasons) and you
	  // want to find the line/column position for a given character
	  // offset. `input` should be the code string that the offset refers
	  // into.

	  var getLineInfo = exports.getLineInfo = function (input, offset) {
	    for (var line = 1, cur = 0;;) {
	      lineBreak.lastIndex = cur;
	      var match = lineBreak.exec(input);
	      if (match && match.index < offset) {
	        ++line;
	        cur = match.index + match[0].length;
	      } else break;
	    }
	    return { line: line, column: offset - cur };
	  };

	  function Token() {
	    this.type = tokType;
	    this.value = tokVal;
	    this.start = tokStart;
	    this.end = tokEnd;
	    if (options.locations) {
	      this.loc = new SourceLocation();
	      this.loc.end = tokEndLoc;
	      // TODO: remove in next major release
	      this.startLoc = tokStartLoc;
	      this.endLoc = tokEndLoc;
	    }
	    if (options.ranges) this.range = [tokStart, tokEnd];
	  }

	  exports.Token = Token;

	  // Acorn is organized as a tokenizer and a recursive-descent parser.
	  // The `tokenize` export provides an interface to the tokenizer.
	  // Because the tokenizer is optimized for being efficiently used by
	  // the Acorn parser itself, this interface is somewhat crude and not
	  // very modular. Performing another parse or call to `tokenize` will
	  // reset the internal state, and invalidate existing tokenizers.

	  exports.tokenize = function (inpt, opts) {
	    input = String(inpt);inputLen = input.length;
	    setOptions(opts);
	    initTokenState();
	    skipSpace();

	    function getToken() {
	      lastEnd = tokEnd;
	      readToken();
	      return new Token();
	    }
	    getToken.jumpTo = function (pos, exprAllowed) {
	      tokPos = pos;
	      if (options.locations) {
	        tokCurLine = 1;
	        tokLineStart = lineBreak.lastIndex = 0;
	        var match;
	        while ((match = lineBreak.exec(input)) && match.index < pos) {
	          ++tokCurLine;
	          tokLineStart = match.index + match[0].length;
	        }
	      }
	      tokExprAllowed = !!exprAllowed;
	      skipSpace();
	    };
	    getToken.options = options;
	    return getToken;
	  };

	  // State is kept in (closure-)global variables. We already saw the
	  // `options`, `input`, and `inputLen` variables above.

	  // The current position of the tokenizer in the input.

	  var tokPos;

	  // The start and end offsets of the current token.

	  var tokStart, tokEnd;

	  // When `options.locations` is true, these hold objects
	  // containing the tokens start and end line/column pairs.

	  var tokStartLoc, tokEndLoc;

	  // The type and value of the current token. Token types are objects,
	  // named by variables against which they can be compared, and
	  // holding properties that describe them (indicating, for example,
	  // the precedence of an infix operator, and the original name of a
	  // keyword token). The kind of value that's held in `tokVal` depends
	  // on the type of the token. For literals, it is the literal value,
	  // for operators, the operator name, and so on.

	  var tokType, tokVal;

	  // Internal state for the tokenizer. To distinguish between division
	  // operators and regular expressions, it remembers whether the last
	  // token was one that is allowed to be followed by an expression. In
	  // some cases, notably after ')' or '}' tokens, the situation
	  // depends on the context before the matching opening bracket, so
	  // tokContext keeps a stack of information about current bracketed
	  // forms.

	  var tokContext, tokExprAllowed;

	  // When `options.locations` is true, these are used to keep
	  // track of the current line, and know when a new line has been
	  // entered.

	  var tokCurLine, tokLineStart;

	  // These store the position of the previous token, which is useful
	  // when finishing a node and assigning its `end` position.

	  var lastStart, lastEnd, lastEndLoc;

	  // This is the parser's state. `inFunction` is used to reject
	  // `return` statements outside of functions, `inGenerator` to
	  // reject `yield`s outside of generators, `labels` to verify
	  // that `break` and `continue` have somewhere to jump to, and
	  // `strict` indicates whether strict mode is on.

	  var inFunction, inGenerator, labels, strict;

	  // This counter is used for checking that arrow expressions did
	  // not contain nested parentheses in argument list.

	  var metParenL;

	  // This is used by the tokenizer to track the template strings it is
	  // inside, and count the amount of open braces seen inside them, to
	  // be able to switch back to a template token when the } to match ${
	  // is encountered. It will hold an array of integers.

	  var templates;

	  function initParserState() {
	    lastStart = lastEnd = tokPos;
	    if (options.locations) lastEndLoc = curPosition();
	    inFunction = inGenerator = strict = false;
	    labels = [];
	    skipSpace();
	    readToken();
	  }

	  // This function is used to raise exceptions on parse errors. It
	  // takes an offset integer (into the current `input`) to indicate
	  // the location of the error, attaches the position to the end
	  // of the error message, and then raises a `SyntaxError` with that
	  // message.

	  function raise(pos, message) {
	    var loc = getLineInfo(input, pos);
	    message += " (" + loc.line + ":" + loc.column + ")";
	    var err = new SyntaxError(message);
	    err.pos = pos;err.loc = loc;err.raisedAt = tokPos;
	    throw err;
	  }

	  // Reused empty array added for node fields that are always empty.

	  var empty = [];

	  // ## Token types

	  // The assignment of fine-grained, information-carrying type objects
	  // allows the tokenizer to store the information it has about a
	  // token in a way that is very cheap for the parser to look up.

	  // All token type variables start with an underscore, to make them
	  // easy to recognize.

	  // These are the general types. The `type` property is only used to
	  // make them recognizeable when debugging.

	  var _num = { type: "num" },
	      _regexp = { type: "regexp" },
	      _string = { type: "string" };
	  var _name = { type: "name" },
	      _eof = { type: "eof" };

	  // Keyword tokens. The `keyword` property (also used in keyword-like
	  // operators) indicates that the token originated from an
	  // identifier-like word, which is used when parsing property names.
	  //
	  // The `beforeExpr` property is used to disambiguate between regular
	  // expressions and divisions. It is set on all token types that can
	  // be followed by an expression (thus, a slash after them would be a
	  // regular expression).
	  //
	  // `isLoop` marks a keyword as starting a loop, which is important
	  // to know when parsing a label, in order to allow or disallow
	  // continue jumps to that label.

	  var _break = { keyword: "break" },
	      _case = { keyword: "case", beforeExpr: true },
	      _catch = { keyword: "catch" };
	  var _continue = { keyword: "continue" },
	      _debugger = { keyword: "debugger" },
	      _default = { keyword: "default" };
	  var _do = { keyword: "do", isLoop: true },
	      _else = { keyword: "else", beforeExpr: true };
	  var _finally = { keyword: "finally" },
	      _for = { keyword: "for", isLoop: true },
	      _function = { keyword: "function" };
	  var _if = { keyword: "if" },
	      _return = { keyword: "return", beforeExpr: true },
	      _switch = { keyword: "switch" };
	  var _throw = { keyword: "throw", beforeExpr: true },
	      _try = { keyword: "try" },
	      _var = { keyword: "var" };
	  var _let = { keyword: "let" },
	      _const = { keyword: "const" };
	  var _while = { keyword: "while", isLoop: true },
	      _with = { keyword: "with" },
	      _new = { keyword: "new", beforeExpr: true };
	  var _this = { keyword: "this" };
	  var _class = { keyword: "class" },
	      _extends = { keyword: "extends", beforeExpr: true };
	  var _export = { keyword: "export" },
	      _import = { keyword: "import" };
	  var _yield = { keyword: "yield", beforeExpr: true };

	  // The keywords that denote values.

	  var _null = { keyword: "null", atomValue: null },
	      _true = { keyword: "true", atomValue: true };
	  var _false = { keyword: "false", atomValue: false };

	  // Some keywords are treated as regular operators. `in` sometimes
	  // (when parsing `for`) needs to be tested against specifically, so
	  // we assign a variable name to it for quick comparing.

	  var _in = { keyword: "in", binop: 7, beforeExpr: true };

	  // Map keyword names to token types.

	  var keywordTypes = { "break": _break, "case": _case, "catch": _catch,
	    "continue": _continue, "debugger": _debugger, "default": _default,
	    "do": _do, "else": _else, "finally": _finally, "for": _for,
	    "function": _function, "if": _if, "return": _return, "switch": _switch,
	    "throw": _throw, "try": _try, "var": _var, "let": _let, "const": _const,
	    "while": _while, "with": _with,
	    "null": _null, "true": _true, "false": _false, "new": _new, "in": _in,
	    "instanceof": { keyword: "instanceof", binop: 7, beforeExpr: true }, "this": _this,
	    "typeof": { keyword: "typeof", prefix: true, beforeExpr: true },
	    "void": { keyword: "void", prefix: true, beforeExpr: true },
	    "delete": { keyword: "delete", prefix: true, beforeExpr: true },
	    "class": _class, "extends": _extends,
	    "export": _export, "import": _import, "yield": _yield };

	  // Punctuation token types. Again, the `type` property is purely for debugging.

	  var _bracketL = { type: "[", beforeExpr: true },
	      _bracketR = { type: "]" },
	      _braceL = { type: "{", beforeExpr: true };
	  var _braceR = { type: "}" },
	      _parenL = { type: "(", beforeExpr: true },
	      _parenR = { type: ")" };
	  var _comma = { type: ",", beforeExpr: true },
	      _semi = { type: ";", beforeExpr: true };
	  var _colon = { type: ":", beforeExpr: true },
	      _dot = { type: "." },
	      _question = { type: "?", beforeExpr: true };
	  var _arrow = { type: "=>", beforeExpr: true },
	      _template = { type: "template" },
	      _templateContinued = { type: "templateContinued" };
	  var _ellipsis = { type: "...", prefix: true, beforeExpr: true };

	  // Operators. These carry several kinds of properties to help the
	  // parser use them properly (the presence of these properties is
	  // what categorizes them as operators).
	  //
	  // `binop`, when present, specifies that this operator is a binary
	  // operator, and will refer to its precedence.
	  //
	  // `prefix` and `postfix` mark the operator as a prefix or postfix
	  // unary operator. `isUpdate` specifies that the node produced by
	  // the operator should be of type UpdateExpression rather than
	  // simply UnaryExpression (`++` and `--`).
	  //
	  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
	  // binary operators with a very low precedence, that should result
	  // in AssignmentExpression nodes.

	  var _slash = { binop: 10, beforeExpr: true },
	      _eq = { isAssign: true, beforeExpr: true };
	  var _assign = { isAssign: true, beforeExpr: true };
	  var _incDec = { postfix: true, prefix: true, isUpdate: true },
	      _prefix = { prefix: true, beforeExpr: true };
	  var _logicalOR = { binop: 1, beforeExpr: true };
	  var _logicalAND = { binop: 2, beforeExpr: true };
	  var _bitwiseOR = { binop: 3, beforeExpr: true };
	  var _bitwiseXOR = { binop: 4, beforeExpr: true };
	  var _bitwiseAND = { binop: 5, beforeExpr: true };
	  var _equality = { binop: 6, beforeExpr: true };
	  var _relational = { binop: 7, beforeExpr: true };
	  var _bitShift = { binop: 8, beforeExpr: true };
	  var _plusMin = { binop: 9, prefix: true, beforeExpr: true };
	  var _modulo = { binop: 10, beforeExpr: true };

	  // '*' may be multiply or have special meaning in ES6
	  var _star = { binop: 10, beforeExpr: true };

	  // Provide access to the token types for external users of the
	  // tokenizer.

	  exports.tokTypes = { bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,
	    parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,
	    dot: _dot, ellipsis: _ellipsis, question: _question, slash: _slash, eq: _eq,
	    name: _name, eof: _eof, num: _num, regexp: _regexp, string: _string,
	    arrow: _arrow, template: _template, templateContinued: _templateContinued, star: _star,
	    assign: _assign };
	  for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

	  // This is a trick taken from Esprima. It turns out that, on
	  // non-Chrome browsers, to check whether a string is in a set, a
	  // predicate containing a big ugly `switch` statement is faster than
	  // a regular expression, and on Chrome the two are about on par.
	  // This function uses `eval` (non-lexical) to produce such a
	  // predicate from a space-separated string of words.
	  //
	  // It starts by sorting the words by length.

	  function makePredicate(words) {
	    words = words.split(" ");
	    var f = "",
	        cats = [];
	    out: for (var i = 0; i < words.length; ++i) {
	      for (var j = 0; j < cats.length; ++j) if (cats[j][0].length == words[i].length) {
	        cats[j].push(words[i]);
	        continue out;
	      }
	      cats.push([words[i]]);
	    }
	    function compareTo(arr) {
	      if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
	      f += "switch(str){";
	      for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
	      f += "return true}return false;";
	    }

	    // When there are more than three length categories, an outer
	    // switch first dispatches on the lengths, to save on comparisons.

	    if (cats.length > 3) {
	      cats.sort(function (a, b) {
	        return b.length - a.length;
	      });
	      f += "switch(str.length){";
	      for (var i = 0; i < cats.length; ++i) {
	        var cat = cats[i];
	        f += "case " + cat[0].length + ":";
	        compareTo(cat);
	      }
	      f += "}";

	      // Otherwise, simply generate a flat `switch` statement.
	    } else {
	        compareTo(words);
	      }
	    return new Function("str", f);
	  }

	  // The ECMAScript 3 reserved word list.

	  var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");

	  // ECMAScript 5 reserved words.

	  var isReservedWord5 = makePredicate("class enum extends super const export import");

	  // The additional reserved words in strict mode.

	  var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");

	  // The forbidden variable names in strict mode.

	  var isStrictBadIdWord = makePredicate("eval arguments");

	  // And the keywords.

	  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

	  var isEcma5AndLessKeyword = makePredicate(ecma5AndLessKeywords);

	  var isEcma6Keyword = makePredicate(ecma5AndLessKeywords + " let const class extends export import yield");

	  var isKeyword = isEcma5AndLessKeyword;

	  // ## Character categories

	  // Big ugly regular expressions that match characters in the
	  // whitespace, identifier, and identifier-start categories. These
	  // are only applied when a character is found to actually have a
	  // code point above 128.
	  // Generated by `tools/generate-identifier-regex.js`.

	  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
	  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
	  var nonASCIIidentifierChars = "\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19B0-\u19C0\u19C8\u19C9\u19D0-\u19D9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
	  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

	  // Whether a single character denotes a newline.

	  var newline = /[\n\r\u2028\u2029]/;

	  function isNewLine(code) {
	    return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
	  }

	  // Matches a whole line break (where CRLF is considered a single
	  // line break). Used to count lines.

	  var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

	  // Test whether a given character code starts an identifier.

	  var isIdentifierStart = exports.isIdentifierStart = function (code) {
	    if (code < 65) return code === 36;
	    if (code < 91) return true;
	    if (code < 97) return code === 95;
	    if (code < 123) return true;
	    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
	  };

	  // Test whether a given character is part of an identifier.

	  var isIdentifierChar = exports.isIdentifierChar = function (code) {
	    if (code < 48) return code === 36;
	    if (code < 58) return true;
	    if (code < 65) return false;
	    if (code < 91) return true;
	    if (code < 97) return code === 95;
	    if (code < 123) return true;
	    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
	  };

	  // ## Tokenizer

	  // These are used when `options.locations` is on, for the
	  // `tokStartLoc` and `tokEndLoc` properties.

	  function Position(line, col) {
	    this.line = line;
	    this.column = col;
	  }

	  Position.prototype.offset = function (n) {
	    return new Position(this.line, this.column + n);
	  };

	  function curPosition() {
	    return new Position(tokCurLine, tokPos - tokLineStart);
	  }

	  // Reset the token state. Used at the start of a parse.

	  function initTokenState(pos) {
	    if (pos) {
	      tokPos = pos;
	      tokLineStart = Math.max(0, input.lastIndexOf("\n", pos));
	      tokCurLine = input.slice(0, tokLineStart).split(newline).length;
	    } else {
	      tokCurLine = 1;
	      tokPos = tokLineStart = 0;
	    }
	    tokType = _eof;
	    tokContext = [];
	    tokExprAllowed = true;
	    metParenL = 0;
	    templates = [];
	    if (tokPos === 0 && options.allowHashBang && input.slice(0, 2) === '#!') {
	      skipLineComment(2);
	    }
	  }

	  // The algorithm used to determine whether a regexp can appear at a
	  // given point in the program is loosely based on sweet.js' approach.
	  // See https://github.com/mozilla/sweet.js/wiki/design

	  var b_stat = { token: "{", isExpr: false },
	      b_expr = { token: "{", isExpr: true };
	  var p_stat = { token: "(", isExpr: false },
	      p_expr = { token: "(", isExpr: true };

	  function braceIsBlock(prevType) {
	    var parent;
	    if (prevType === _colon && (parent = tokContext[tokContext.length - 1]).token == "{") return !parent.isExpr;
	    if (prevType === _return) return newline.test(input.slice(lastEnd, tokStart));
	    if (prevType === _else || prevType === _semi || prevType === _eof) return true;
	    if (prevType == _braceL) return tokContext[tokContext.length - 1] === b_stat;
	    return !tokExprAllowed;
	  }

	  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and
	  // maintains `tokContext` and `tokExprAllowed`, and skips the space
	  // after the token, so that the next one's `tokStart` will point at
	  // the right position.

	  function finishToken(type, val, shouldSkipSpace) {
	    tokEnd = tokPos;
	    if (options.locations) tokEndLoc = curPosition();
	    var prevType = tokType;
	    tokType = type;
	    if (shouldSkipSpace !== false) skipSpace();
	    tokVal = val;

	    // Update context info
	    if (type === _parenR || type === _braceR) {
	      var out = tokContext.pop();
	      tokExprAllowed = !(out && out.isExpr);
	    } else if (type === _braceL) {
	      tokContext.push(braceIsBlock(prevType) ? b_stat : b_expr);
	      tokExprAllowed = true;
	    } else if (type == _parenL) {
	      var statementParens = prevType === _if || prevType === _for || prevType === _with || prevType === _while;
	      tokContext.push(statementParens ? p_stat : p_expr);
	      tokExprAllowed = true;
	    } else if (type == _incDec) {
	      // tokExprAllowed stays unchanged
	    } else if (type.keyword && prevType == _dot) {
	        tokExprAllowed = false;
	      } else if (tokExprAllowed && type == _function) {
	        tokExprAllowed = null;
	      } else {
	        tokExprAllowed = type.beforeExpr;
	      }
	  }

	  function skipBlockComment() {
	    var startLoc = options.onComment && options.locations && curPosition();
	    var start = tokPos,
	        end = input.indexOf("*/", tokPos += 2);
	    if (end === -1) raise(tokPos - 2, "Unterminated comment");
	    tokPos = end + 2;
	    if (options.locations) {
	      lineBreak.lastIndex = start;
	      var match;
	      while ((match = lineBreak.exec(input)) && match.index < tokPos) {
	        ++tokCurLine;
	        tokLineStart = match.index + match[0].length;
	      }
	    }
	    if (options.onComment) options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && curPosition());
	  }

	  function skipLineComment(startSkip) {
	    var start = tokPos;
	    var startLoc = options.onComment && options.locations && curPosition();
	    var ch = input.charCodeAt(tokPos += startSkip);
	    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	      ++tokPos;
	      ch = input.charCodeAt(tokPos);
	    }
	    if (options.onComment) options.onComment(false, input.slice(start + startSkip, tokPos), start, tokPos, startLoc, options.locations && curPosition());
	  }

	  // Called at the start of the parse and after every token. Skips
	  // whitespace and comments, and.

	  function skipSpace() {
	    while (tokPos < inputLen) {
	      var ch = input.charCodeAt(tokPos);
	      if (ch === 32) {
	        // ' '
	        ++tokPos;
	      } else if (ch === 13) {
	        ++tokPos;
	        var next = input.charCodeAt(tokPos);
	        if (next === 10) {
	          ++tokPos;
	        }
	        if (options.locations) {
	          ++tokCurLine;
	          tokLineStart = tokPos;
	        }
	      } else if (ch === 10 || ch === 8232 || ch === 8233) {
	        ++tokPos;
	        if (options.locations) {
	          ++tokCurLine;
	          tokLineStart = tokPos;
	        }
	      } else if (ch > 8 && ch < 14) {
	        ++tokPos;
	      } else if (ch === 47) {
	        // '/'
	        var next = input.charCodeAt(tokPos + 1);
	        if (next === 42) {
	          // '*'
	          skipBlockComment();
	        } else if (next === 47) {
	          // '/'
	          skipLineComment(2);
	        } else break;
	      } else if (ch === 160) {
	        // '\xa0'
	        ++tokPos;
	      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	        ++tokPos;
	      } else {
	        break;
	      }
	    }
	  }

	  // ### Token reading

	  // This is the function that is called to fetch the next token. It
	  // is somewhat obscure, because it works in character codes rather
	  // than characters, and because operator parsing has been inlined
	  // into it.
	  //
	  // All in the name of speed.
	  //
	  function readToken_dot() {
	    var next = input.charCodeAt(tokPos + 1);
	    if (next >= 48 && next <= 57) return readNumber(true);
	    var next2 = input.charCodeAt(tokPos + 2);
	    if (options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
	      // 46 = dot '.'
	      tokPos += 3;
	      return finishToken(_ellipsis);
	    } else {
	      ++tokPos;
	      return finishToken(_dot);
	    }
	  }

	  function readToken_slash() {
	    // '/'
	    var next = input.charCodeAt(tokPos + 1);
	    if (tokExprAllowed) {
	      ++tokPos;return readRegexp();
	    }
	    if (next === 61) return finishOp(_assign, 2);
	    return finishOp(_slash, 1);
	  }

	  function readToken_mult_modulo(code) {
	    // '%*'
	    var next = input.charCodeAt(tokPos + 1);
	    if (next === 61) return finishOp(_assign, 2);
	    return finishOp(code === 42 ? _star : _modulo, 1);
	  }

	  function readToken_pipe_amp(code) {
	    // '|&'
	    var next = input.charCodeAt(tokPos + 1);
	    if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
	    if (next === 61) return finishOp(_assign, 2);
	    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
	  }

	  function readToken_caret() {
	    // '^'
	    var next = input.charCodeAt(tokPos + 1);
	    if (next === 61) return finishOp(_assign, 2);
	    return finishOp(_bitwiseXOR, 1);
	  }

	  function readToken_plus_min(code) {
	    // '+-'
	    var next = input.charCodeAt(tokPos + 1);
	    if (next === code) {
	      if (next == 45 && input.charCodeAt(tokPos + 2) == 62 && newline.test(input.slice(lastEnd, tokPos))) {
	        // A `-->` line comment
	        skipLineComment(3);
	        skipSpace();
	        return readToken();
	      }
	      return finishOp(_incDec, 2);
	    }
	    if (next === 61) return finishOp(_assign, 2);
	    return finishOp(_plusMin, 1);
	  }

	  function readToken_lt_gt(code) {
	    // '<>'
	    var next = input.charCodeAt(tokPos + 1);
	    var size = 1;
	    if (next === code) {
	      size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
	      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
	      return finishOp(_bitShift, size);
	    }
	    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 && input.charCodeAt(tokPos + 3) == 45) {
	      // `<!--`, an XML-style comment that should be interpreted as a line comment
	      skipLineComment(4);
	      skipSpace();
	      return readToken();
	    }
	    if (next === 61) size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
	    return finishOp(_relational, size);
	  }

	  function readToken_eq_excl(code) {
	    // '=!', '=>'
	    var next = input.charCodeAt(tokPos + 1);
	    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
	    if (code === 61 && next === 62 && options.ecmaVersion >= 6) {
	      // '=>'
	      tokPos += 2;
	      return finishToken(_arrow);
	    }
	    return finishOp(code === 61 ? _eq : _prefix, 1);
	  }

	  function getTokenFromCode(code) {
	    switch (code) {
	      // The interpretation of a dot depends on whether it is followed
	      // by a digit or another two dots.
	      case 46:
	        // '.'
	        return readToken_dot();

	      // Punctuation tokens.
	      case 40:
	        ++tokPos;return finishToken(_parenL);
	      case 41:
	        ++tokPos;return finishToken(_parenR);
	      case 59:
	        ++tokPos;return finishToken(_semi);
	      case 44:
	        ++tokPos;return finishToken(_comma);
	      case 91:
	        ++tokPos;return finishToken(_bracketL);
	      case 93:
	        ++tokPos;return finishToken(_bracketR);
	      case 123:
	        ++tokPos;
	        if (templates.length) ++templates[templates.length - 1];
	        return finishToken(_braceL);
	      case 125:
	        ++tokPos;
	        if (templates.length && --templates[templates.length - 1] === 0) return readTemplateString(_templateContinued);else return finishToken(_braceR);
	      case 58:
	        ++tokPos;return finishToken(_colon);
	      case 63:
	        ++tokPos;return finishToken(_question);

	      case 96:
	        // '`'
	        if (options.ecmaVersion >= 6) {
	          ++tokPos;
	          return readTemplateString(_template);
	        }

	      case 48:
	        // '0'
	        var next = input.charCodeAt(tokPos + 1);
	        if (next === 120 || next === 88) return readRadixNumber(16); // '0x', '0X' - hex number
	        if (options.ecmaVersion >= 6) {
	          if (next === 111 || next === 79) return readRadixNumber(8); // '0o', '0O' - octal number
	          if (next === 98 || next === 66) return readRadixNumber(2); // '0b', '0B' - binary number
	        }
	      // Anything else beginning with a digit is an integer, octal
	      // number, or float.
	      case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
	        // 1-9
	        return readNumber(false);

	      // Quotes produce strings.
	      case 34:case 39:
	        // '"', "'"
	        return readString(code);

	      // Operators are parsed inline in tiny state machines. '=' (61) is
	      // often referred to. `finishOp` simply skips the amount of
	      // characters it is given as second argument, and returns a token
	      // of the type given by its first argument.

	      case 47:
	        // '/'
	        return readToken_slash();

	      case 37:case 42:
	        // '%*'
	        return readToken_mult_modulo(code);

	      case 124:case 38:
	        // '|&'
	        return readToken_pipe_amp(code);

	      case 94:
	        // '^'
	        return readToken_caret();

	      case 43:case 45:
	        // '+-'
	        return readToken_plus_min(code);

	      case 60:case 62:
	        // '<>'
	        return readToken_lt_gt(code);

	      case 61:case 33:
	        // '=!'
	        return readToken_eq_excl(code);

	      case 126:
	        // '~'
	        return finishOp(_prefix, 1);
	    }

	    return false;
	  }

	  function readToken() {
	    tokStart = tokPos;
	    if (options.locations) tokStartLoc = curPosition();
	    if (tokPos >= inputLen) return finishToken(_eof);

	    var code = input.charCodeAt(tokPos);

	    // Identifier or keyword. '\uXXXX' sequences are allowed in
	    // identifiers, so '\' also dispatches to that.
	    if (isIdentifierStart(code) || code === 92 /* '\' */) return readWord();

	    var tok = getTokenFromCode(code);

	    if (tok === false) {
	      // If we are here, we either found a non-ASCII identifier
	      // character, or something that's entirely disallowed.
	      var ch = String.fromCharCode(code);
	      if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
	      raise(tokPos, "Unexpected character '" + ch + "'");
	    }
	    return tok;
	  }

	  function finishOp(type, size) {
	    var str = input.slice(tokPos, tokPos + size);
	    tokPos += size;
	    finishToken(type, str);
	  }

	  var regexpUnicodeSupport = false;
	  try {
	    new RegExp("\uffff", "u");regexpUnicodeSupport = true;
	  } catch (e) {}

	  // Parse a regular expression. Some context-awareness is necessary,
	  // since a '/' inside a '[]' set does not end the expression.

	  function readRegexp() {
	    var content = "",
	        escaped,
	        inClass,
	        start = tokPos;
	    for (;;) {
	      if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
	      var ch = input.charAt(tokPos);
	      if (newline.test(ch)) raise(start, "Unterminated regular expression");
	      if (!escaped) {
	        if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
	        escaped = ch === "\\";
	      } else escaped = false;
	      ++tokPos;
	    }
	    var content = input.slice(start, tokPos);
	    ++tokPos;
	    // Need to use `readWord1` because '\uXXXX' sequences are allowed
	    // here (don't ask).
	    var mods = readWord1();
	    var tmp = content;
	    if (mods) {
	      var validFlags = /^[gmsiy]*$/;
	      if (options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
	      if (!validFlags.test(mods)) raise(start, "Invalid regular expression flag");
	      if (mods.indexOf('u') >= 0 && !regexpUnicodeSupport) {
	        // Replace each astral symbol and every Unicode code point
	        // escape sequence that represents such a symbol with a single
	        // ASCII symbol to avoid throwing on regular expressions that
	        // are only valid in combination with the `/u` flag.
	        tmp = tmp.replace(/\\u\{([0-9a-fA-F]{5,6})\}/g, "x").replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
	      }
	    }
	    // Detect invalid regular expressions.
	    try {
	      new RegExp(tmp);
	    } catch (e) {
	      if (e instanceof SyntaxError) raise(start, "Error parsing regular expression: " + e.message);
	      raise(e);
	    }
	    // Get a regular expression object for this pattern-flag pair, or `null` in
	    // case the current environment doesn't support the flags it uses.
	    try {
	      var value = new RegExp(content, mods);
	    } catch (err) {
	      value = null;
	    }
	    return finishToken(_regexp, { pattern: content, flags: mods, value: value });
	  }

	  // Read an integer in the given radix. Return null if zero digits
	  // were read, the integer value otherwise. When `len` is given, this
	  // will return `null` unless the integer has exactly `len` digits.

	  function readInt(radix, len) {
	    var start = tokPos,
	        total = 0;
	    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	      var code = input.charCodeAt(tokPos),
	          val;
	      if (code >= 97) val = code - 97 + 10; // a
	      else if (code >= 65) val = code - 65 + 10; // A
	        else if (code >= 48 && code <= 57) val = code - 48; // 0-9
	          else val = Infinity;
	      if (val >= radix) break;
	      ++tokPos;
	      total = total * radix + val;
	    }
	    if (tokPos === start || len != null && tokPos - start !== len) return null;

	    return total;
	  }

	  function readRadixNumber(radix) {
	    tokPos += 2; // 0x
	    var val = readInt(radix);
	    if (val == null) raise(tokStart + 2, "Expected number in radix " + radix);
	    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
	    return finishToken(_num, val);
	  }

	  // Read an integer, octal integer, or floating-point number.

	  function readNumber(startsWithDot) {
	    var start = tokPos,
	        isFloat = false,
	        octal = input.charCodeAt(tokPos) === 48;
	    if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
	    if (input.charCodeAt(tokPos) === 46) {
	      ++tokPos;
	      readInt(10);
	      isFloat = true;
	    }
	    var next = input.charCodeAt(tokPos);
	    if (next === 69 || next === 101) {
	      // 'eE'
	      next = input.charCodeAt(++tokPos);
	      if (next === 43 || next === 45) ++tokPos; // '+-'
	      if (readInt(10) === null) raise(start, "Invalid number");
	      isFloat = true;
	    }
	    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");

	    var str = input.slice(start, tokPos),
	        val;
	    if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || strict) raise(start, "Invalid number");else val = parseInt(str, 8);
	    return finishToken(_num, val);
	  }

	  // Read a string value, interpreting backslash-escapes.

	  function readCodePoint() {
	    var ch = input.charCodeAt(tokPos),
	        code;

	    if (ch === 123) {
	      if (options.ecmaVersion < 6) unexpected();
	      ++tokPos;
	      code = readHexChar(input.indexOf('}', tokPos) - tokPos);
	      ++tokPos;
	      if (code > 0x10FFFF) unexpected();
	    } else {
	      code = readHexChar(4);
	    }

	    // UTF-16 Encoding
	    if (code <= 0xFFFF) {
	      return String.fromCharCode(code);
	    }
	    var cu1 = (code - 0x10000 >> 10) + 0xD800;
	    var cu2 = (code - 0x10000 & 1023) + 0xDC00;
	    return String.fromCharCode(cu1, cu2);
	  }

	  function readString(quote) {
	    ++tokPos;
	    var out = "";
	    for (;;) {
	      if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
	      var ch = input.charCodeAt(tokPos);
	      if (ch === quote) {
	        ++tokPos;
	        return finishToken(_string, out);
	      }
	      if (ch === 92) {
	        // '\'
	        out += readEscapedChar();
	      } else {
	        ++tokPos;
	        if (isNewLine(ch)) {
	          raise(tokStart, "Unterminated string constant");
	        }
	        out += String.fromCharCode(ch); // '\'
	      }
	    }
	  }

	  function readTemplateString(type) {
	    if (type == _templateContinued) templates.pop();
	    var out = "",
	        start = tokPos;;
	    for (;;) {
	      if (tokPos >= inputLen) raise(tokStart, "Unterminated template");
	      var ch = input.charAt(tokPos);
	      if (ch === "`" || ch === "$" && input.charCodeAt(tokPos + 1) === 123) {
	        // '`', '${'
	        var raw = input.slice(start, tokPos);
	        ++tokPos;
	        if (ch == "$") {
	          ++tokPos;templates.push(1);
	        }
	        return finishToken(type, { cooked: out, raw: raw });
	      }

	      if (ch === "\\") {
	        // '\'
	        out += readEscapedChar();
	      } else {
	        ++tokPos;
	        if (newline.test(ch)) {
	          if (ch === "\r" && input.charCodeAt(tokPos) === 10) {
	            ++tokPos;
	            ch = "\n";
	          }
	          if (options.locations) {
	            ++tokCurLine;
	            tokLineStart = tokPos;
	          }
	        }
	        out += ch;
	      }
	    }
	  }

	  // Used to read escaped characters

	  function readEscapedChar() {
	    var ch = input.charCodeAt(++tokPos);
	    var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
	    if (octal) octal = octal[0];
	    while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
	    if (octal === "0") octal = null;
	    ++tokPos;
	    if (octal) {
	      if (strict) raise(tokPos - 2, "Octal literal in strict mode");
	      tokPos += octal.length - 1;
	      return String.fromCharCode(parseInt(octal, 8));
	    } else {
	      switch (ch) {
	        case 110:
	          return "\n"; // 'n' -> '\n'
	        case 114:
	          return "\r"; // 'r' -> '\r'
	        case 120:
	          return String.fromCharCode(readHexChar(2)); // 'x'
	        case 117:
	          return readCodePoint(); // 'u'
	        case 116:
	          return "\t"; // 't' -> '\t'
	        case 98:
	          return "\b"; // 'b' -> '\b'
	        case 118:
	          return "\u000b"; // 'v' -> '\u000b'
	        case 102:
	          return "\f"; // 'f' -> '\f'
	        case 48:
	          return "\0"; // 0 -> '\0'
	        case 13:
	          if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\r\n'
	        case 10:
	          // ' \n'
	          if (options.locations) {
	            tokLineStart = tokPos;++tokCurLine;
	          }
	          return "";
	        default:
	          return String.fromCharCode(ch);
	      }
	    }
	  }

	  // Used to read character escape sequences ('\x', '\u', '\U').

	  function readHexChar(len) {
	    var n = readInt(16, len);
	    if (n === null) raise(tokStart, "Bad character escape sequence");
	    return n;
	  }

	  // Used to signal to callers of `readWord1` whether the word
	  // contained any escape sequences. This is needed because words with
	  // escape sequences must not be interpreted as keywords.

	  var containsEsc;

	  // Read an identifier, and return it as a string. Sets `containsEsc`
	  // to whether the word contained a '\u' escape.
	  //
	  // Only builds up the word character-by-character when it actually
	  // containeds an escape, as a micro-optimization.

	  function readWord1() {
	    containsEsc = false;
	    var word,
	        first = true,
	        start = tokPos;
	    for (;;) {
	      var ch = input.charCodeAt(tokPos);
	      if (isIdentifierChar(ch)) {
	        if (containsEsc) word += input.charAt(tokPos);
	        ++tokPos;
	      } else if (ch === 92) {
	        // "\"
	        if (!containsEsc) word = input.slice(start, tokPos);
	        containsEsc = true;
	        if (input.charCodeAt(++tokPos) != 117) // "u"
	          raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
	        ++tokPos;
	        var esc = readHexChar(4);
	        var escStr = String.fromCharCode(esc);
	        if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
	        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) raise(tokPos - 4, "Invalid Unicode escape");
	        word += escStr;
	      } else {
	        break;
	      }
	      first = false;
	    }
	    return containsEsc ? word : input.slice(start, tokPos);
	  }

	  // Read an identifier or keyword token. Will check for reserved
	  // words when necessary.

	  function readWord() {
	    var word = readWord1();
	    var type = _name;
	    if (!containsEsc && isKeyword(word)) type = keywordTypes[word];
	    return finishToken(type, word);
	  }

	  // ## Parser

	  // A recursive descent parser operates by defining functions for all
	  // syntactic elements, and recursively calling those, each function
	  // advancing the input stream and returning an AST node. Precedence
	  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
	  // instead of `(!x)[1]` is handled by the fact that the parser
	  // function that parses unary prefix operators is called first, and
	  // in turn calls the function that parses `[]` subscripts — that
	  // way, it'll receive the node for `x[1]` already parsed, and wraps
	  // *that* in the unary operator node.
	  //
	  // Acorn uses an [operator precedence parser][opp] to handle binary
	  // operator precedence, because it is much more compact than using
	  // the technique outlined above, which uses different, nesting
	  // functions to specify precedence, for all of the ten binary
	  // precedence levels that JavaScript defines.
	  //
	  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

	  // ### Parser utilities

	  // Continue to the next token.

	  function next() {
	    if (options.onToken) options.onToken(new Token());

	    lastStart = tokStart;
	    lastEnd = tokEnd;
	    lastEndLoc = tokEndLoc;
	    readToken();
	  }

	  // Enter strict mode. Re-reads the next token to please pedantic
	  // tests ("use strict"; 010; -- should fail).

	  function setStrict(strct) {
	    strict = strct;
	    tokPos = tokStart;
	    if (options.locations) {
	      while (tokPos < tokLineStart) {
	        tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
	        --tokCurLine;
	      }
	    }
	    skipSpace();
	    readToken();
	  }

	  // Start an AST node, attaching a start offset.

	  function Node() {
	    this.type = null;
	    this.start = tokStart;
	    this.end = null;
	  }

	  exports.Node = Node;

	  function SourceLocation() {
	    this.start = tokStartLoc;
	    this.end = null;
	    if (sourceFile !== null) this.source = sourceFile;
	  }

	  function startNode() {
	    var node = new Node();
	    if (options.locations) node.loc = new SourceLocation();
	    if (options.directSourceFile) node.sourceFile = options.directSourceFile;
	    if (options.ranges) node.range = [tokStart, 0];
	    return node;
	  }

	  // Sometimes, a node is only started *after* the token stream passed
	  // its start position. The functions below help storing a position
	  // and creating a node from a previous position.

	  function storeCurrentPos() {
	    return options.locations ? [tokStart, tokStartLoc] : tokStart;
	  }

	  function startNodeAt(pos) {
	    var node = new Node(),
	        start = pos;
	    if (options.locations) {
	      node.loc = new SourceLocation();
	      node.loc.start = start[1];
	      start = pos[0];
	    }
	    node.start = start;
	    if (options.directSourceFile) node.sourceFile = options.directSourceFile;
	    if (options.ranges) node.range = [start, 0];

	    return node;
	  }

	  // Finish an AST node, adding `type` and `end` properties.

	  function finishNode(node, type) {
	    node.type = type;
	    node.end = lastEnd;
	    if (options.locations) node.loc.end = lastEndLoc;
	    if (options.ranges) node.range[1] = lastEnd;
	    return node;
	  }

	  function finishNodeAt(node, type, pos) {
	    if (options.locations) {
	      node.loc.end = pos[1];pos = pos[0];
	    }
	    node.type = type;
	    node.end = pos;
	    if (options.ranges) node.range[1] = pos;
	    return node;
	  }

	  // Test whether a statement node is the string literal `"use strict"`.

	  function isUseStrict(stmt) {
	    return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
	  }

	  // Predicate that tests whether the next token is of the given
	  // type, and if yes, consumes it as a side effect.

	  function eat(type) {
	    if (tokType === type) {
	      next();
	      return true;
	    } else {
	      return false;
	    }
	  }

	  // Test whether a semicolon can be inserted at the current position.

	  function canInsertSemicolon() {
	    return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
	  }

	  // Consume a semicolon, or, failing that, see if we are allowed to
	  // pretend that there is a semicolon at this position.

	  function semicolon() {
	    if (!eat(_semi) && !canInsertSemicolon()) unexpected();
	  }

	  // Expect a token of a given type. If found, consume it, otherwise,
	  // raise an unexpected token error.

	  function expect(type) {
	    eat(type) || unexpected();
	  }

	  // Raise an unexpected token error.

	  function unexpected(pos) {
	    raise(pos != null ? pos : tokStart, "Unexpected token");
	  }

	  // Checks if hash object has a property.

	  function has(obj, propName) {
	    return Object.prototype.hasOwnProperty.call(obj, propName);
	  }
	  // Convert existing expression atom to assignable pattern
	  // if possible.

	  function toAssignable(node, allowSpread, checkType) {
	    if (options.ecmaVersion >= 6 && node) {
	      switch (node.type) {
	        case "Identifier":
	        case "MemberExpression":
	          break;

	        case "ObjectExpression":
	          node.type = "ObjectPattern";
	          for (var i = 0; i < node.properties.length; i++) {
	            var prop = node.properties[i];
	            if (prop.kind !== "init") unexpected(prop.key.start);
	            toAssignable(prop.value, false, checkType);
	          }
	          break;

	        case "ArrayExpression":
	          node.type = "ArrayPattern";
	          for (var i = 0, lastI = node.elements.length - 1; i <= lastI; i++) {
	            toAssignable(node.elements[i], i === lastI, checkType);
	          }
	          break;

	        case "SpreadElement":
	          if (allowSpread) {
	            toAssignable(node.argument, false, checkType);
	            checkSpreadAssign(node.argument);
	          } else {
	            unexpected(node.start);
	          }
	          break;

	        case "AssignmentExpression":
	          if (node.operator === "=") {
	            node.type = "AssignmentPattern";
	          } else {
	            unexpected(node.left.end);
	          }
	          break;

	        default:
	          if (checkType) unexpected(node.start);
	      }
	    }
	    return node;
	  }

	  // Checks if node can be assignable spread argument.

	  function checkSpreadAssign(node) {
	    if (node.type !== "Identifier" && node.type !== "ArrayPattern") unexpected(node.start);
	  }

	  // Verify that argument names are not repeated, and it does not
	  // try to bind the words `eval` or `arguments`.

	  function checkFunctionParam(param, nameHash) {
	    switch (param.type) {
	      case "Identifier":
	        if (isStrictReservedWord(param.name) || isStrictBadIdWord(param.name)) raise(param.start, "Defining '" + param.name + "' in strict mode");
	        if (has(nameHash, param.name)) raise(param.start, "Argument name clash in strict mode");
	        nameHash[param.name] = true;
	        break;

	      case "ObjectPattern":
	        for (var i = 0; i < param.properties.length; i++) checkFunctionParam(param.properties[i].value, nameHash);
	        break;

	      case "ArrayPattern":
	        for (var i = 0; i < param.elements.length; i++) {
	          var elem = param.elements[i];
	          if (elem) checkFunctionParam(elem, nameHash);
	        }
	        break;
	    }
	  }

	  // Check if property name clashes with already added.
	  // Object/class getters and setters are not allowed to clash —
	  // either with each other or with an init property — and in
	  // strict mode, init properties are also not allowed to be repeated.

	  function checkPropClash(prop, propHash) {
	    if (options.ecmaVersion >= 6) return;
	    var key = prop.key,
	        name;
	    switch (key.type) {
	      case "Identifier":
	        name = key.name;break;
	      case "Literal":
	        name = String(key.value);break;
	      default:
	        return;
	    }
	    var kind = prop.kind || "init",
	        other;
	    if (has(propHash, name)) {
	      other = propHash[name];
	      var isGetSet = kind !== "init";
	      if ((strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) raise(key.start, "Redefinition of property");
	    } else {
	      other = propHash[name] = {
	        init: false,
	        get: false,
	        set: false
	      };
	    }
	    other[kind] = true;
	  }

	  // Verify that a node is an lval — something that can be assigned
	  // to.

	  function checkLVal(expr, isBinding) {
	    switch (expr.type) {
	      case "Identifier":
	        if (strict && (isStrictBadIdWord(expr.name) || isStrictReservedWord(expr.name))) raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
	        break;

	      case "MemberExpression":
	        if (isBinding) raise(expr.start, "Binding to member expression");
	        break;

	      case "ObjectPattern":
	        for (var i = 0; i < expr.properties.length; i++) checkLVal(expr.properties[i].value, isBinding);
	        break;

	      case "ArrayPattern":
	        for (var i = 0; i < expr.elements.length; i++) {
	          var elem = expr.elements[i];
	          if (elem) checkLVal(elem, isBinding);
	        }
	        break;

	      case "AssignmentPattern":
	      case "SpreadElement":
	        break;

	      default:
	        raise(expr.start, "Assigning to rvalue");
	    }
	  }

	  // ### Statement parsing

	  // Parse a program. Initializes the parser, reads any number of
	  // statements, and wraps them in a Program node.  Optionally takes a
	  // `program` argument.  If present, the statements will be appended
	  // to its body instead of creating a new node.

	  function parseTopLevel(node) {
	    var first = true;
	    if (!node.body) node.body = [];
	    while (tokType !== _eof) {
	      var stmt = parseStatement(true);
	      node.body.push(stmt);
	      if (first && isUseStrict(stmt)) setStrict(true);
	      first = false;
	    }

	    next();
	    return finishNode(node, "Program");
	  }

	  var loopLabel = { kind: "loop" },
	      switchLabel = { kind: "switch" };

	  // Parse a single statement.
	  //
	  // If expecting a statement and finding a slash operator, parse a
	  // regular expression literal. This is to handle cases like
	  // `if (foo) /blah/.exec(foo);`, where looking at the previous token
	  // does not help.

	  function parseStatement(topLevel) {
	    var starttype = tokType,
	        node = startNode();

	    // Most types of statements are recognized by the keyword they
	    // start with. Many are trivial to parse, some require a bit of
	    // complexity.

	    switch (starttype) {
	      case _break:case _continue:
	        return parseBreakContinueStatement(node, starttype.keyword);
	      case _debugger:
	        return parseDebuggerStatement(node);
	      case _do:
	        return parseDoStatement(node);
	      case _for:
	        return parseForStatement(node);
	      case _function:
	        return parseFunctionStatement(node);
	      case _class:
	        return parseClass(node, true);
	      case _if:
	        return parseIfStatement(node);
	      case _return:
	        return parseReturnStatement(node);
	      case _switch:
	        return parseSwitchStatement(node);
	      case _throw:
	        return parseThrowStatement(node);
	      case _try:
	        return parseTryStatement(node);
	      case _var:case _let:case _const:
	        return parseVarStatement(node, starttype.keyword);
	      case _while:
	        return parseWhileStatement(node);
	      case _with:
	        return parseWithStatement(node);
	      case _braceL:
	        return parseBlock(); // no point creating a function for this
	      case _semi:
	        return parseEmptyStatement(node);
	      case _export:
	      case _import:
	        if (!topLevel && !options.allowImportExportEverywhere) raise(tokStart, "'import' and 'export' may only appear at the top level");
	        return starttype === _import ? parseImport(node) : parseExport(node);

	      // If the statement does not start with a statement keyword or a
	      // brace, it's an ExpressionStatement or LabeledStatement. We
	      // simply start parsing an expression, and afterwards, if the
	      // next token is a colon and the expression was a simple
	      // Identifier node, we switch to interpreting it as a label.
	      default:
	        var maybeName = tokVal,
	            expr = parseExpression();
	        if (starttype === _name && expr.type === "Identifier" && eat(_colon)) return parseLabeledStatement(node, maybeName, expr);else return parseExpressionStatement(node, expr);
	    }
	  }

	  function parseBreakContinueStatement(node, keyword) {
	    var isBreak = keyword == "break";
	    next();
	    if (eat(_semi) || canInsertSemicolon()) node.label = null;else if (tokType !== _name) unexpected();else {
	      node.label = parseIdent();
	      semicolon();
	    }

	    // Verify that there is an actual destination to break or
	    // continue to.
	    for (var i = 0; i < labels.length; ++i) {
	      var lab = labels[i];
	      if (node.label == null || lab.name === node.label.name) {
	        if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
	        if (node.label && isBreak) break;
	      }
	    }
	    if (i === labels.length) raise(node.start, "Unsyntactic " + keyword);
	    return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
	  }

	  function parseDebuggerStatement(node) {
	    next();
	    semicolon();
	    return finishNode(node, "DebuggerStatement");
	  }

	  function parseDoStatement(node) {
	    next();
	    labels.push(loopLabel);
	    node.body = parseStatement();
	    labels.pop();
	    expect(_while);
	    node.test = parseParenExpression();
	    if (options.ecmaVersion >= 6) eat(_semi);else semicolon();
	    return finishNode(node, "DoWhileStatement");
	  }

	  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
	  // loop is non-trivial. Basically, we have to parse the init `var`
	  // statement or expression, disallowing the `in` operator (see
	  // the second parameter to `parseExpression`), and then check
	  // whether the next token is `in` or `of`. When there is no init
	  // part (semicolon immediately after the opening parenthesis), it
	  // is a regular `for` loop.

	  function parseForStatement(node) {
	    next();
	    labels.push(loopLabel);
	    expect(_parenL);
	    if (tokType === _semi) return parseFor(node, null);
	    if (tokType === _var || tokType === _let) {
	      var init = startNode(),
	          varKind = tokType.keyword,
	          isLet = tokType === _let;
	      next();
	      parseVar(init, true, varKind);
	      finishNode(init, "VariableDeclaration");
	      if ((tokType === _in || options.ecmaVersion >= 6 && tokType === _name && tokVal === "of") && init.declarations.length === 1 && !(isLet && init.declarations[0].init)) return parseForIn(node, init);
	      return parseFor(node, init);
	    }
	    var init = parseExpression(false, true);
	    if (tokType === _in || options.ecmaVersion >= 6 && tokType === _name && tokVal === "of") {
	      checkLVal(init);
	      return parseForIn(node, init);
	    }
	    return parseFor(node, init);
	  }

	  function parseFunctionStatement(node) {
	    next();
	    return parseFunction(node, true);
	  }

	  function parseIfStatement(node) {
	    next();
	    node.test = parseParenExpression();
	    node.consequent = parseStatement();
	    node.alternate = eat(_else) ? parseStatement() : null;
	    return finishNode(node, "IfStatement");
	  }

	  function parseReturnStatement(node) {
	    if (!inFunction && !options.allowReturnOutsideFunction) raise(tokStart, "'return' outside of function");
	    next();

	    // In `return` (and `break`/`continue`), the keywords with
	    // optional arguments, we eagerly look for a semicolon or the
	    // possibility to insert one.

	    if (eat(_semi) || canInsertSemicolon()) node.argument = null;else {
	      node.argument = parseExpression();semicolon();
	    }
	    return finishNode(node, "ReturnStatement");
	  }

	  function parseSwitchStatement(node) {
	    next();
	    node.discriminant = parseParenExpression();
	    node.cases = [];
	    expect(_braceL);
	    labels.push(switchLabel);

	    // Statements under must be grouped (by label) in SwitchCase
	    // nodes. `cur` is used to keep the node that we are currently
	    // adding statements to.

	    for (var cur, sawDefault; tokType != _braceR;) {
	      if (tokType === _case || tokType === _default) {
	        var isCase = tokType === _case;
	        if (cur) finishNode(cur, "SwitchCase");
	        node.cases.push(cur = startNode());
	        cur.consequent = [];
	        next();
	        if (isCase) cur.test = parseExpression();else {
	          if (sawDefault) raise(lastStart, "Multiple default clauses");sawDefault = true;
	          cur.test = null;
	        }
	        expect(_colon);
	      } else {
	        if (!cur) unexpected();
	        cur.consequent.push(parseStatement());
	      }
	    }
	    if (cur) finishNode(cur, "SwitchCase");
	    next(); // Closing brace
	    labels.pop();
	    return finishNode(node, "SwitchStatement");
	  }

	  function parseThrowStatement(node) {
	    next();
	    if (newline.test(input.slice(lastEnd, tokStart))) raise(lastEnd, "Illegal newline after throw");
	    node.argument = parseExpression();
	    semicolon();
	    return finishNode(node, "ThrowStatement");
	  }

	  function parseTryStatement(node) {
	    next();
	    node.block = parseBlock();
	    node.handler = null;
	    if (tokType === _catch) {
	      var clause = startNode();
	      next();
	      expect(_parenL);
	      clause.param = parseIdent();
	      if (strict && isStrictBadIdWord(clause.param.name)) raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
	      expect(_parenR);
	      clause.guard = null;
	      clause.body = parseBlock();
	      node.handler = finishNode(clause, "CatchClause");
	    }
	    node.guardedHandlers = empty;
	    node.finalizer = eat(_finally) ? parseBlock() : null;
	    if (!node.handler && !node.finalizer) raise(node.start, "Missing catch or finally clause");
	    return finishNode(node, "TryStatement");
	  }

	  function parseVarStatement(node, kind) {
	    next();
	    parseVar(node, false, kind);
	    semicolon();
	    return finishNode(node, "VariableDeclaration");
	  }

	  function parseWhileStatement(node) {
	    next();
	    node.test = parseParenExpression();
	    labels.push(loopLabel);
	    node.body = parseStatement();
	    labels.pop();
	    return finishNode(node, "WhileStatement");
	  }

	  function parseWithStatement(node) {
	    if (strict) raise(tokStart, "'with' in strict mode");
	    next();
	    node.object = parseParenExpression();
	    node.body = parseStatement();
	    return finishNode(node, "WithStatement");
	  }

	  function parseEmptyStatement(node) {
	    next();
	    return finishNode(node, "EmptyStatement");
	  }

	  function parseLabeledStatement(node, maybeName, expr) {
	    for (var i = 0; i < labels.length; ++i) if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
	    var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
	    labels.push({ name: maybeName, kind: kind });
	    node.body = parseStatement();
	    labels.pop();
	    node.label = expr;
	    return finishNode(node, "LabeledStatement");
	  }

	  function parseExpressionStatement(node, expr) {
	    node.expression = expr;
	    semicolon();
	    return finishNode(node, "ExpressionStatement");
	  }

	  // Used for constructs like `switch` and `if` that insist on
	  // parentheses around their expression.

	  function parseParenExpression() {
	    expect(_parenL);
	    var val = parseExpression();
	    expect(_parenR);
	    return val;
	  }

	  // Parse a semicolon-enclosed block of statements, handling `"use
	  // strict"` declarations when `allowStrict` is true (used for
	  // function bodies).

	  function parseBlock(allowStrict) {
	    var node = startNode(),
	        first = true,
	        oldStrict;
	    node.body = [];
	    expect(_braceL);
	    while (!eat(_braceR)) {
	      var stmt = parseStatement();
	      node.body.push(stmt);
	      if (first && allowStrict && isUseStrict(stmt)) {
	        oldStrict = strict;
	        setStrict(strict = true);
	      }
	      first = false;
	    }
	    if (oldStrict === false) setStrict(false);
	    return finishNode(node, "BlockStatement");
	  }

	  // Parse a regular `for` loop. The disambiguation code in
	  // `parseStatement` will already have parsed the init statement or
	  // expression.

	  function parseFor(node, init) {
	    node.init = init;
	    expect(_semi);
	    node.test = tokType === _semi ? null : parseExpression();
	    expect(_semi);
	    node.update = tokType === _parenR ? null : parseExpression();
	    expect(_parenR);
	    node.body = parseStatement();
	    labels.pop();
	    return finishNode(node, "ForStatement");
	  }

	  // Parse a `for`/`in` and `for`/`of` loop, which are almost
	  // same from parser's perspective.

	  function parseForIn(node, init) {
	    var type = tokType === _in ? "ForInStatement" : "ForOfStatement";
	    next();
	    node.left = init;
	    node.right = parseExpression();
	    expect(_parenR);
	    node.body = parseStatement();
	    labels.pop();
	    return finishNode(node, type);
	  }

	  // Parse a list of variable declarations.

	  function parseVar(node, noIn, kind) {
	    node.declarations = [];
	    node.kind = kind;
	    for (;;) {
	      var decl = startNode();
	      decl.id = options.ecmaVersion >= 6 ? toAssignable(parseExprAtom()) : parseIdent();
	      checkLVal(decl.id, true);
	      decl.init = eat(_eq) ? parseExpression(true, noIn) : kind === _const.keyword ? unexpected() : null;
	      node.declarations.push(finishNode(decl, "VariableDeclarator"));
	      if (!eat(_comma)) break;
	    }
	    return node;
	  }

	  // ### Expression parsing

	  // These nest, from the most general expression type at the top to
	  // 'atomic', nondivisible expression types at the bottom. Most of
	  // the functions will simply let the function(s) below them parse,
	  // and, *if* the syntactic construct they handle is present, wrap
	  // the AST node that the inner parser gave them in another node.

	  // Parse a full expression. The arguments are used to forbid comma
	  // sequences (in argument lists, array literals, or object literals)
	  // or the `in` operator (in for loops initalization expressions).

	  function parseExpression(noComma, noIn) {
	    var start = storeCurrentPos();
	    var expr = parseMaybeAssign(noIn);
	    if (!noComma && tokType === _comma) {
	      var node = startNodeAt(start);
	      node.expressions = [expr];
	      while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));
	      return finishNode(node, "SequenceExpression");
	    }
	    return expr;
	  }

	  // Parse an assignment expression. This includes applications of
	  // operators like `+=`.

	  function parseMaybeAssign(noIn) {
	    var start = storeCurrentPos();
	    var left = parseMaybeConditional(noIn);
	    if (tokType.isAssign) {
	      var node = startNodeAt(start);
	      node.operator = tokVal;
	      node.left = tokType === _eq ? toAssignable(left) : left;
	      checkLVal(left);
	      next();
	      node.right = parseMaybeAssign(noIn);
	      return finishNode(node, "AssignmentExpression");
	    }
	    return left;
	  }

	  // Parse a ternary conditional (`?:`) operator.

	  function parseMaybeConditional(noIn) {
	    var start = storeCurrentPos();
	    var expr = parseExprOps(noIn);
	    if (eat(_question)) {
	      var node = startNodeAt(start);
	      node.test = expr;
	      node.consequent = parseExpression(true);
	      expect(_colon);
	      node.alternate = parseExpression(true, noIn);
	      return finishNode(node, "ConditionalExpression");
	    }
	    return expr;
	  }

	  // Start the precedence parser.

	  function parseExprOps(noIn) {
	    var start = storeCurrentPos();
	    return parseExprOp(parseMaybeUnary(), start, -1, noIn);
	  }

	  // Parse binary operators with the operator precedence parsing
	  // algorithm. `left` is the left-hand side of the operator.
	  // `minPrec` provides context that allows the function to stop and
	  // defer further parser to one of its callers when it encounters an
	  // operator that has a lower precedence than the set it is parsing.

	  function parseExprOp(left, leftStart, minPrec, noIn) {
	    var prec = tokType.binop;
	    if (prec != null && (!noIn || tokType !== _in)) {
	      if (prec > minPrec) {
	        var node = startNodeAt(leftStart);
	        node.left = left;
	        node.operator = tokVal;
	        var op = tokType;
	        next();
	        var start = storeCurrentPos();
	        node.right = parseExprOp(parseMaybeUnary(), start, prec, noIn);
	        finishNode(node, op === _logicalOR || op === _logicalAND ? "LogicalExpression" : "BinaryExpression");
	        return parseExprOp(node, leftStart, minPrec, noIn);
	      }
	    }
	    return left;
	  }

	  // Parse unary operators, both prefix and postfix.

	  function parseMaybeUnary() {
	    if (tokType.prefix) {
	      var node = startNode(),
	          update = tokType.isUpdate,
	          nodeType;
	      if (tokType === _ellipsis) {
	        nodeType = "SpreadElement";
	      } else {
	        nodeType = update ? "UpdateExpression" : "UnaryExpression";
	        node.operator = tokVal;
	        node.prefix = true;
	      }
	      next();
	      node.argument = parseMaybeUnary();
	      if (update) checkLVal(node.argument);else if (strict && node.operator === "delete" && node.argument.type === "Identifier") raise(node.start, "Deleting local variable in strict mode");
	      return finishNode(node, nodeType);
	    }
	    var start = storeCurrentPos();
	    var expr = parseExprSubscripts();
	    while (tokType.postfix && !canInsertSemicolon()) {
	      var node = startNodeAt(start);
	      node.operator = tokVal;
	      node.prefix = false;
	      node.argument = expr;
	      checkLVal(expr);
	      next();
	      expr = finishNode(node, "UpdateExpression");
	    }
	    return expr;
	  }

	  // Parse call, dot, and `[]`-subscript expressions.

	  function parseExprSubscripts() {
	    var start = storeCurrentPos();
	    return parseSubscripts(parseExprAtom(), start);
	  }

	  function parseSubscripts(base, start, noCalls) {
	    if (eat(_dot)) {
	      var node = startNodeAt(start);
	      node.object = base;
	      node.property = parseIdent(true);
	      node.computed = false;
	      return parseSubscripts(finishNode(node, "MemberExpression"), start, noCalls);
	    } else if (eat(_bracketL)) {
	      var node = startNodeAt(start);
	      node.object = base;
	      node.property = parseExpression();
	      node.computed = true;
	      expect(_bracketR);
	      return parseSubscripts(finishNode(node, "MemberExpression"), start, noCalls);
	    } else if (!noCalls && eat(_parenL)) {
	      var node = startNodeAt(start);
	      node.callee = base;
	      node.arguments = parseExprList(_parenR, false);
	      return parseSubscripts(finishNode(node, "CallExpression"), start, noCalls);
	    } else if (tokType === _template) {
	      var node = startNodeAt(start);
	      node.tag = base;
	      node.quasi = parseTemplate();
	      return parseSubscripts(finishNode(node, "TaggedTemplateExpression"), start, noCalls);
	    }return base;
	  }

	  // Parse an atomic expression — either a single token that is an
	  // expression, an expression started by a keyword like `function` or
	  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
	  // or `{}`.

	  function parseExprAtom() {
	    switch (tokType) {
	      case _this:
	        var node = startNode();
	        next();
	        return finishNode(node, "ThisExpression");

	      case _yield:
	        if (inGenerator) return parseYield();

	      case _name:
	        var start = storeCurrentPos();
	        var id = parseIdent(tokType !== _name);
	        if (eat(_arrow)) {
	          return parseArrowExpression(startNodeAt(start), [id]);
	        }
	        return id;

	      case _regexp:
	        var node = startNode();
	        node.regex = { pattern: tokVal.pattern, flags: tokVal.flags };
	        node.value = tokVal.value;
	        node.raw = input.slice(tokStart, tokEnd);
	        next();
	        return finishNode(node, "Literal");

	      case _num:case _string:
	        var node = startNode();
	        node.value = tokVal;
	        node.raw = input.slice(tokStart, tokEnd);
	        next();
	        return finishNode(node, "Literal");

	      case _null:case _true:case _false:
	        var node = startNode();
	        node.value = tokType.atomValue;
	        node.raw = tokType.keyword;
	        next();
	        return finishNode(node, "Literal");

	      case _parenL:
	        var start = storeCurrentPos();
	        var val, exprList;
	        next();
	        // check whether this is generator comprehension or regular expression
	        if (options.ecmaVersion >= 7 && tokType === _for) {
	          val = parseComprehension(startNodeAt(start), true);
	        } else {
	          var oldParenL = ++metParenL;
	          if (tokType !== _parenR) {
	            val = parseExpression();
	            exprList = val.type === "SequenceExpression" ? val.expressions : [val];
	          } else {
	            exprList = [];
	          }
	          expect(_parenR);
	          // if '=>' follows '(...)', convert contents to arguments
	          if (metParenL === oldParenL && eat(_arrow)) {
	            val = parseArrowExpression(startNodeAt(start), exprList);
	          } else {
	            // forbid '()' before everything but '=>'
	            if (!val) unexpected(lastStart);
	            // forbid '...' in sequence expressions
	            if (options.ecmaVersion >= 6) {
	              for (var i = 0; i < exprList.length; i++) {
	                if (exprList[i].type === "SpreadElement") unexpected();
	              }
	            }

	            if (options.preserveParens) {
	              var par = startNodeAt(start);
	              par.expression = val;
	              val = finishNode(par, "ParenthesizedExpression");
	            }
	          }
	        }
	        return val;

	      case _bracketL:
	        var node = startNode();
	        next();
	        // check whether this is array comprehension or regular array
	        if (options.ecmaVersion >= 7 && tokType === _for) {
	          return parseComprehension(node, false);
	        }
	        node.elements = parseExprList(_bracketR, true, true);
	        return finishNode(node, "ArrayExpression");

	      case _braceL:
	        return parseObj();

	      case _function:
	        var node = startNode();
	        next();
	        return parseFunction(node, false);

	      case _class:
	        return parseClass(startNode(), false);

	      case _new:
	        return parseNew();

	      case _template:
	        return parseTemplate();

	      default:
	        unexpected();
	    }
	  }

	  // New's precedence is slightly tricky. It must allow its argument
	  // to be a `[]` or dot subscript expression, but not a call — at
	  // least, not without wrapping it in parentheses. Thus, it uses the

	  function parseNew() {
	    var node = startNode();
	    next();
	    var start = storeCurrentPos();
	    node.callee = parseSubscripts(parseExprAtom(), start, true);
	    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);else node.arguments = empty;
	    return finishNode(node, "NewExpression");
	  }

	  // Parse template expression.

	  function parseTemplateElement() {
	    var elem = startNodeAt(options.locations ? [tokStart + 1, tokStartLoc.offset(1)] : tokStart + 1);
	    elem.value = tokVal;
	    elem.tail = input.charCodeAt(tokEnd - 1) !== 123; // '{'
	    next();
	    var endOff = elem.tail ? 1 : 2;
	    return finishNodeAt(elem, "TemplateElement", options.locations ? [lastEnd - endOff, lastEndLoc.offset(-endOff)] : lastEnd - endOff);
	  }

	  function parseTemplate() {
	    var node = startNode();
	    node.expressions = [];
	    var curElt = parseTemplateElement();
	    node.quasis = [curElt];
	    while (!curElt.tail) {
	      node.expressions.push(parseExpression());
	      if (tokType !== _templateContinued) unexpected();
	      node.quasis.push(curElt = parseTemplateElement());
	    }
	    return finishNode(node, "TemplateLiteral");
	  }

	  // Parse an object literal.

	  function parseObj() {
	    var node = startNode(),
	        first = true,
	        propHash = {};
	    node.properties = [];
	    next();
	    while (!eat(_braceR)) {
	      if (!first) {
	        expect(_comma);
	        if (options.allowTrailingCommas && eat(_braceR)) break;
	      } else first = false;

	      var prop = startNode(),
	          isGenerator;
	      if (options.ecmaVersion >= 6) {
	        prop.method = false;
	        prop.shorthand = false;
	        isGenerator = eat(_star);
	      }
	      parsePropertyName(prop);
	      if (eat(_colon)) {
	        prop.value = parseExpression(true);
	        prop.kind = "init";
	      } else if (options.ecmaVersion >= 6 && tokType === _parenL) {
	        prop.kind = "init";
	        prop.method = true;
	        prop.value = parseMethod(isGenerator);
	      } else if (options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && tokType != _comma && tokType != _braceR) {
	        if (isGenerator) unexpected();
	        prop.kind = prop.key.name;
	        parsePropertyName(prop);
	        prop.value = parseMethod(false);
	      } else if (options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	        prop.kind = "init";
	        prop.value = prop.key;
	        prop.shorthand = true;
	      } else unexpected();

	      checkPropClash(prop, propHash);
	      node.properties.push(finishNode(prop, "Property"));
	    }
	    return finishNode(node, "ObjectExpression");
	  }

	  function parsePropertyName(prop) {
	    if (options.ecmaVersion >= 6) {
	      if (eat(_bracketL)) {
	        prop.computed = true;
	        prop.key = parseExpression();
	        expect(_bracketR);
	        return;
	      } else {
	        prop.computed = false;
	      }
	    }
	    prop.key = tokType === _num || tokType === _string ? parseExprAtom() : parseIdent(true);
	  }

	  // Initialize empty function node.

	  function initFunction(node) {
	    node.id = null;
	    node.params = [];
	    if (options.ecmaVersion >= 6) {
	      node.defaults = [];
	      node.rest = null;
	      node.generator = false;
	    }
	  }

	  // Parse a function declaration or literal (depending on the
	  // `isStatement` parameter).

	  function parseFunction(node, isStatement, allowExpressionBody) {
	    initFunction(node);
	    if (options.ecmaVersion >= 6) {
	      node.generator = eat(_star);
	    }
	    if (isStatement || tokType === _name) {
	      node.id = parseIdent();
	    }
	    parseFunctionParams(node);
	    parseFunctionBody(node, allowExpressionBody);
	    return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
	  }

	  // Parse object or class method.

	  function parseMethod(isGenerator) {
	    var node = startNode();
	    initFunction(node);
	    parseFunctionParams(node);
	    var allowExpressionBody;
	    if (options.ecmaVersion >= 6) {
	      node.generator = isGenerator;
	      allowExpressionBody = true;
	    } else {
	      allowExpressionBody = false;
	    }
	    parseFunctionBody(node, allowExpressionBody);
	    return finishNode(node, "FunctionExpression");
	  }

	  // Parse arrow function expression with given parameters.

	  function parseArrowExpression(node, params) {
	    initFunction(node);

	    var defaults = node.defaults,
	        hasDefaults = false;

	    for (var i = 0, lastI = params.length - 1; i <= lastI; i++) {
	      var param = params[i];

	      if (param.type === "AssignmentExpression" && param.operator === "=") {
	        hasDefaults = true;
	        params[i] = param.left;
	        defaults.push(param.right);
	      } else {
	        toAssignable(param, i === lastI, true);
	        defaults.push(null);
	        if (param.type === "SpreadElement") {
	          params.length--;
	          node.rest = param.argument;
	          break;
	        }
	      }
	    }

	    node.params = params;
	    if (!hasDefaults) node.defaults = [];

	    parseFunctionBody(node, true);
	    return finishNode(node, "ArrowFunctionExpression");
	  }

	  // Parse function parameters.

	  function parseFunctionParams(node) {
	    var defaults = [],
	        hasDefaults = false;

	    expect(_parenL);
	    for (;;) {
	      if (eat(_parenR)) {
	        break;
	      } else if (options.ecmaVersion >= 6 && eat(_ellipsis)) {
	        node.rest = toAssignable(parseExprAtom(), false, true);
	        checkSpreadAssign(node.rest);
	        expect(_parenR);
	        defaults.push(null);
	        break;
	      } else {
	        node.params.push(options.ecmaVersion >= 6 ? toAssignable(parseExprAtom(), false, true) : parseIdent());
	        if (options.ecmaVersion >= 6) {
	          if (eat(_eq)) {
	            hasDefaults = true;
	            defaults.push(parseExpression(true));
	          } else {
	            defaults.push(null);
	          }
	        }
	        if (!eat(_comma)) {
	          expect(_parenR);
	          break;
	        }
	      }
	    }

	    if (hasDefaults) node.defaults = defaults;
	  }

	  // Parse function body and check parameters.

	  function parseFunctionBody(node, allowExpression) {
	    var isExpression = allowExpression && tokType !== _braceL;

	    if (isExpression) {
	      node.body = parseExpression(true);
	      node.expression = true;
	    } else {
	      // Start a new scope with regard to labels and the `inFunction`
	      // flag (restore them to their old value afterwards).
	      var oldInFunc = inFunction,
	          oldInGen = inGenerator,
	          oldLabels = labels;
	      inFunction = true;inGenerator = node.generator;labels = [];
	      node.body = parseBlock(true);
	      node.expression = false;
	      inFunction = oldInFunc;inGenerator = oldInGen;labels = oldLabels;
	    }

	    // If this is a strict mode function, verify that argument names
	    // are not repeated, and it does not try to bind the words `eval`
	    // or `arguments`.
	    if (strict || !isExpression && node.body.body.length && isUseStrict(node.body.body[0])) {
	      var nameHash = {};
	      if (node.id) checkFunctionParam(node.id, {});
	      for (var i = 0; i < node.params.length; i++) checkFunctionParam(node.params[i], nameHash);
	      if (node.rest) checkFunctionParam(node.rest, nameHash);
	    }
	  }

	  // Parse a class declaration or literal (depending on the
	  // `isStatement` parameter).

	  function parseClass(node, isStatement) {
	    next();
	    node.id = tokType === _name ? parseIdent() : isStatement ? unexpected() : null;
	    node.superClass = eat(_extends) ? parseExprSubscripts() : null;
	    var classBody = startNode();
	    classBody.body = [];
	    expect(_braceL);
	    while (!eat(_braceR)) {
	      var method = startNode();
	      if (tokType === _name && tokVal === "static") {
	        next();
	        method['static'] = true;
	      } else {
	        method['static'] = false;
	      }
	      var isGenerator = eat(_star);
	      parsePropertyName(method);
	      if (tokType !== _parenL && !method.computed && method.key.type === "Identifier" && (method.key.name === "get" || method.key.name === "set")) {
	        if (isGenerator) unexpected();
	        method.kind = method.key.name;
	        parsePropertyName(method);
	      } else {
	        method.kind = "";
	      }
	      method.value = parseMethod(isGenerator);
	      classBody.body.push(finishNode(method, "MethodDefinition"));
	      eat(_semi);
	    }
	    node.body = finishNode(classBody, "ClassBody");
	    return finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	  }

	  // Parses a comma-separated list of expressions, and returns them as
	  // an array. `close` is the token type that ends the list, and
	  // `allowEmpty` can be turned on to allow subsequent commas with
	  // nothing in between them to be parsed as `null` (which is needed
	  // for array literals).

	  function parseExprList(close, allowTrailingComma, allowEmpty) {
	    var elts = [],
	        first = true;
	    while (!eat(close)) {
	      if (!first) {
	        expect(_comma);
	        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
	      } else first = false;

	      if (allowEmpty && tokType === _comma) elts.push(null);else elts.push(parseExpression(true));
	    }
	    return elts;
	  }

	  // Parse the next token as an identifier. If `liberal` is true (used
	  // when parsing properties), it will also convert keywords into
	  // identifiers.

	  function parseIdent(liberal) {
	    var node = startNode();
	    if (liberal && options.forbidReserved == "everywhere") liberal = false;
	    if (tokType === _name) {
	      if (!liberal && (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) || strict && isStrictReservedWord(tokVal)) && input.slice(tokStart, tokEnd).indexOf("\\") == -1) raise(tokStart, "The keyword '" + tokVal + "' is reserved");
	      node.name = tokVal;
	    } else if (liberal && tokType.keyword) {
	      node.name = tokType.keyword;
	    } else {
	      unexpected();
	    }
	    next();
	    return finishNode(node, "Identifier");
	  }

	  // Parses module export declaration.

	  function parseExport(node) {
	    next();
	    // export var|const|let|function|class ...;
	    if (tokType === _var || tokType === _const || tokType === _let || tokType === _function || tokType === _class) {
	      node.declaration = parseStatement();
	      node['default'] = false;
	      node.specifiers = null;
	      node.source = null;
	    } else
	      // export default ...;
	      if (eat(_default)) {
	        node.declaration = parseExpression(true);
	        node['default'] = true;
	        node.specifiers = null;
	        node.source = null;
	        semicolon();
	      } else {
	        // export * from '...';
	        // export { x, y as z } [from '...'];
	        var isBatch = tokType === _star;
	        node.declaration = null;
	        node['default'] = false;
	        node.specifiers = parseExportSpecifiers();
	        if (tokType === _name && tokVal === "from") {
	          next();
	          node.source = tokType === _string ? parseExprAtom() : unexpected();
	        } else {
	          if (isBatch) unexpected();
	          node.source = null;
	        }
	        semicolon();
	      }
	    return finishNode(node, "ExportDeclaration");
	  }

	  // Parses a comma-separated list of module exports.

	  function parseExportSpecifiers() {
	    var nodes = [],
	        first = true;
	    if (tokType === _star) {
	      // export * from '...'
	      var node = startNode();
	      next();
	      nodes.push(finishNode(node, "ExportBatchSpecifier"));
	    } else {
	      // export { x, y as z } [from '...']
	      expect(_braceL);
	      while (!eat(_braceR)) {
	        if (!first) {
	          expect(_comma);
	          if (options.allowTrailingCommas && eat(_braceR)) break;
	        } else first = false;

	        var node = startNode();
	        node.id = parseIdent(tokType === _default);
	        if (tokType === _name && tokVal === "as") {
	          next();
	          node.name = parseIdent(true);
	        } else {
	          node.name = null;
	        }
	        nodes.push(finishNode(node, "ExportSpecifier"));
	      }
	    }
	    return nodes;
	  }

	  // Parses import declaration.

	  function parseImport(node) {
	    next();
	    // import '...';
	    if (tokType === _string) {
	      node.specifiers = [];
	      node.source = parseExprAtom();
	      node.kind = "";
	    } else {
	      node.specifiers = parseImportSpecifiers();
	      if (tokType !== _name || tokVal !== "from") unexpected();
	      next();
	      node.source = tokType === _string ? parseExprAtom() : unexpected();
	    }
	    semicolon();
	    return finishNode(node, "ImportDeclaration");
	  }

	  // Parses a comma-separated list of module imports.

	  function parseImportSpecifiers() {
	    var nodes = [],
	        first = true;
	    if (tokType === _name) {
	      // import defaultObj, { x, y as z } from '...'
	      var node = startNode();
	      node.id = parseIdent();
	      checkLVal(node.id, true);
	      node.name = null;
	      node['default'] = true;
	      nodes.push(finishNode(node, "ImportSpecifier"));
	      if (!eat(_comma)) return nodes;
	    }
	    if (tokType === _star) {
	      var node = startNode();
	      next();
	      if (tokType !== _name || tokVal !== "as") unexpected();
	      next();
	      node.name = parseIdent();
	      checkLVal(node.name, true);
	      nodes.push(finishNode(node, "ImportBatchSpecifier"));
	      return nodes;
	    }
	    expect(_braceL);
	    while (!eat(_braceR)) {
	      if (!first) {
	        expect(_comma);
	        if (options.allowTrailingCommas && eat(_braceR)) break;
	      } else first = false;

	      var node = startNode();
	      node.id = parseIdent(true);
	      if (tokType === _name && tokVal === "as") {
	        next();
	        node.name = parseIdent();
	      } else {
	        node.name = null;
	      }
	      checkLVal(node.name || node.id, true);
	      node['default'] = false;
	      nodes.push(finishNode(node, "ImportSpecifier"));
	    }
	    return nodes;
	  }

	  // Parses yield expression inside generator.

	  function parseYield() {
	    var node = startNode();
	    next();
	    if (eat(_semi) || canInsertSemicolon()) {
	      node.delegate = false;
	      node.argument = null;
	    } else {
	      node.delegate = eat(_star);
	      node.argument = parseExpression(true);
	    }
	    return finishNode(node, "YieldExpression");
	  }

	  // Parses array and generator comprehensions.

	  function parseComprehension(node, isGenerator) {
	    node.blocks = [];
	    while (tokType === _for) {
	      var block = startNode();
	      next();
	      expect(_parenL);
	      block.left = toAssignable(parseExprAtom());
	      checkLVal(block.left, true);
	      if (tokType !== _name || tokVal !== "of") unexpected();
	      next();
	      // `of` property is here for compatibility with Esprima's AST
	      // which also supports deprecated [for (... in ...) expr]
	      block.of = true;
	      block.right = parseExpression();
	      expect(_parenR);
	      node.blocks.push(finishNode(block, "ComprehensionBlock"));
	    }
	    node.filter = eat(_if) ? parseParenExpression() : null;
	    node.body = parseExpression();
	    expect(isGenerator ? _parenR : _bracketR);
	    node.generator = isGenerator;
	    return finishNode(node, "ComprehensionExpression");
	  }
	});

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	// Acorn: Loose parser
	//
	// This module provides an alternative parser (`parse_dammit`) that
	// exposes that same interface as `parse`, but will try to parse
	// anything as JavaScript, repairing syntax error the best it can.
	// There are circumstances in which it will raise an error and give
	// up, but they are very rare. The resulting AST will be a mostly
	// valid JavaScript AST (as per the [Mozilla parser API][api], except
	// that:
	//
	// - Return outside functions is allowed
	//
	// - Label consistency (no conflicts, break only to existing labels)
	//   is not enforced.
	//
	// - Bogus Identifier nodes with a name of `"✖"` are inserted whenever
	//   the parser got too confused to return anything meaningful.
	//
	// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
	//
	// The expected use for this is to *first* try `acorn.parse`, and only
	// if that fails switch to `parse_dammit`. The loose parser might
	// parse badly indented code incorrectly, so **don't** use it as
	// your default parser.
	//
	// Quite a lot of acorn.js is duplicated here. The alternative was to
	// add a *lot* of extra cruft to that file, making it less readable
	// and slower. Copying and editing the code allowed me to make
	// invasive changes and simplifications without creating a complicated
	// tangle.

	(function (root, mod) {
	  if (true) return mod(exports, __webpack_require__(49)); // CommonJS
	  if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(49)], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	  mod(root.acorn || (root.acorn = {}), root.acorn); // Plain browser env
	})(this, function (exports, acorn) {
	  "use strict";

	  var tt = acorn.tokTypes;

	  var options, input, fetchToken, context;

	  acorn.defaultOptions.tabSize = 4;

	  exports.parse_dammit = function (inpt, opts) {
	    if (!opts) opts = {};
	    input = String(inpt);
	    fetchToken = acorn.tokenize(input, opts);
	    options = fetchToken.options;
	    sourceFile = options.sourceFile || null;
	    context = [];
	    nextLineStart = 0;
	    ahead.length = 0;
	    next();
	    return parseTopLevel();
	  };

	  var lastEnd,
	      token = { start: 0, end: 0 },
	      ahead = [];
	  var curLineStart, nextLineStart, curIndent, lastEndLoc, sourceFile;

	  function next(forceRegexp) {
	    lastEnd = token.end;
	    if (options.locations) lastEndLoc = token.endLoc;
	    if (forceRegexp) ahead.length = 0;

	    token = ahead.shift() || readToken(forceRegexp);

	    if (token.start >= nextLineStart) {
	      while (token.start >= nextLineStart) {
	        curLineStart = nextLineStart;
	        nextLineStart = lineEnd(curLineStart) + 1;
	      }
	      curIndent = indentationAfter(curLineStart);
	    }
	  }

	  function readToken(forceRegexp) {
	    for (;;) {
	      try {
	        var tok = fetchToken(forceRegexp);
	        if (tok.type === tt.dot && input.substr(tok.end, 1) === '.') {
	          tok = fetchToken();
	          tok.start--;
	          tok.type = tt.ellipsis;
	        }
	        return tok;
	      } catch (e) {
	        if (!(e instanceof SyntaxError)) throw e;

	        // Try to skip some text, based on the error message, and then continue
	        var msg = e.message,
	            pos = e.raisedAt,
	            replace = true;
	        if (/unterminated/i.test(msg)) {
	          pos = lineEnd(e.pos + 1);
	          if (/string/.test(msg)) {
	            replace = { start: e.pos, end: pos, type: tt.string, value: input.slice(e.pos + 1, pos) };
	          } else if (/regular expr/i.test(msg)) {
	            var re = input.slice(e.pos, pos);
	            try {
	              re = new RegExp(re);
	            } catch (e) {}
	            replace = { start: e.pos, end: pos, type: tt.regexp, value: re };
	          } else if (/template/.test(msg)) {
	            replace = { start: e.pos, end: pos,
	              type: input.charAt(e.pos) == "`" ? tt.template : tt.templateContinued,
	              value: input.slice(e.pos + 1, pos) };
	          } else {
	            replace = false;
	          }
	        } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number/i.test(msg)) {
	          while (pos < input.length && !isSpace(input.charCodeAt(pos))) ++pos;
	        } else if (/character escape|expected hexadecimal/i.test(msg)) {
	          while (pos < input.length) {
	            var ch = input.charCodeAt(pos++);
	            if (ch === 34 || ch === 39 || isNewline(ch)) break;
	          }
	        } else if (/unexpected character/i.test(msg)) {
	          pos++;
	          replace = false;
	        } else if (/regular expression/i.test(msg)) {
	          replace = true;
	        } else {
	          throw e;
	        }
	        resetTo(pos);
	        if (replace === true) replace = { start: pos, end: pos, type: tt.name, value: "✖" };
	        if (replace) {
	          if (options.locations) {
	            replace.startLoc = acorn.getLineInfo(input, replace.start);
	            replace.endLoc = acorn.getLineInfo(input, replace.end);
	          }
	          return replace;
	        }
	      }
	    }
	  }

	  function resetTo(pos) {
	    for (;;) {
	      try {
	        var ch = input.charAt(pos - 1);
	        var reAllowed = !ch || /[\[\{\(,;:?\/*=+\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(input.slice(pos - 10, pos));
	        return fetchToken.jumpTo(pos, reAllowed);
	      } catch (e) {
	        if (!(e instanceof SyntaxError && /unterminated comment/i.test(e.message))) throw e;
	        pos = lineEnd(e.pos + 1);
	        if (pos >= input.length) return;
	      }
	    }
	  }

	  function lookAhead(n) {
	    while (n > ahead.length) ahead.push(readToken());
	    return ahead[n - 1];
	  }

	  var newline = /[\n\r\u2028\u2029]/;

	  function isNewline(ch) {
	    return ch === 10 || ch === 13 || ch === 8232 || ch === 8329;
	  }
	  function isSpace(ch) {
	    return ch < 14 && ch > 8 || ch === 32 || ch === 160 || isNewline(ch);
	  }

	  function pushCx() {
	    context.push(curIndent);
	  }
	  function popCx() {
	    curIndent = context.pop();
	  }

	  function lineEnd(pos) {
	    while (pos < input.length && !isNewline(input.charCodeAt(pos))) ++pos;
	    return pos;
	  }
	  function indentationAfter(pos) {
	    for (var count = 0;; ++pos) {
	      var ch = input.charCodeAt(pos);
	      if (ch === 32) ++count;else if (ch === 9) count += options.tabSize;else return count;
	    }
	  }

	  function closes(closeTok, indent, line, blockHeuristic) {
	    if (token.type === closeTok || token.type === tt.eof) return true;
	    if (line != curLineStart && curIndent < indent && tokenStartsLine() && (!blockHeuristic || nextLineStart >= input.length || indentationAfter(nextLineStart) < indent)) return true;
	    return false;
	  }

	  function tokenStartsLine() {
	    for (var p = token.start - 1; p >= curLineStart; --p) {
	      var ch = input.charCodeAt(p);
	      if (ch !== 9 && ch !== 32) return false;
	    }
	    return true;
	  }

	  function Node(start) {
	    this.type = null;
	    this.start = start;
	    this.end = null;
	  }
	  Node.prototype = acorn.Node.prototype;

	  function SourceLocation(start) {
	    this.start = start || token.startLoc || { line: 1, column: 0 };
	    this.end = null;
	    if (sourceFile !== null) this.source = sourceFile;
	  }

	  function startNode() {
	    var node = new Node(token.start);
	    if (options.locations) node.loc = new SourceLocation();
	    if (options.directSourceFile) node.sourceFile = options.directSourceFile;
	    if (options.ranges) node.range = [token.start, 0];
	    return node;
	  }

	  function storeCurrentPos() {
	    return options.locations ? [token.start, token.startLoc] : token.start;
	  }

	  function startNodeAt(pos) {
	    var node;
	    if (options.locations) {
	      node = new Node(pos[0]);
	      node.loc = new SourceLocation(pos[1]);
	    } else {
	      node = new Node(pos);
	    }
	    if (options.directSourceFile) node.sourceFile = options.directSourceFile;
	    if (options.ranges) node.range = [pos[0], 0];
	    return node;
	  }

	  function finishNode(node, type) {
	    node.type = type;
	    node.end = lastEnd;
	    if (options.locations) node.loc.end = lastEndLoc;
	    if (options.ranges) node.range[1] = lastEnd;
	    return node;
	  }

	  function finishNodeAt(node, type, pos) {
	    if (options.locations) {
	      node.loc.end = pos[1];pos = pos[0];
	    }
	    node.type = type;
	    node.end = pos;
	    if (options.ranges) node.range[1] = pos;
	    return node;
	  }

	  function dummyIdent() {
	    var dummy = startNode();
	    dummy.name = "✖";
	    return finishNode(dummy, "Identifier");
	  }
	  function isDummy(node) {
	    return node.name == "✖";
	  }

	  function eat(type) {
	    if (token.type === type) {
	      next();
	      return true;
	    } else {
	      return false;
	    }
	  }

	  function canInsertSemicolon() {
	    return token.type === tt.eof || token.type === tt.braceR || newline.test(input.slice(lastEnd, token.start));
	  }
	  function semicolon() {
	    return eat(tt.semi);
	  }

	  function expect(type) {
	    if (eat(type)) return true;
	    if (lookAhead(1).type == type) {
	      next();next();
	      return true;
	    }
	    if (lookAhead(2).type == type) {
	      next();next();next();
	      return true;
	    }
	  }

	  function checkLVal(expr) {
	    if (!expr) return expr;
	    switch (expr.type) {
	      case "Identifier":
	      case "MemberExpression":
	      case "ObjectPattern":
	      case "ArrayPattern":
	      case "SpreadElement":
	      case "AssignmentPattern":
	        return expr;

	      default:
	        return dummyIdent();
	    }
	  }

	  function parseTopLevel() {
	    var node = startNodeAt(options.locations ? [0, acorn.getLineInfo(input, 0)] : 0);
	    node.body = [];
	    while (token.type !== tt.eof) node.body.push(parseStatement());
	    lastEnd = token.end;
	    lastEndLoc = token.endLoc;
	    return finishNode(node, "Program");
	  }

	  function parseStatement() {
	    if (token.type === tt.slash || token.type === tt.assign && token.value === "/=") next(true);

	    var starttype = token.type,
	        node = startNode();

	    switch (starttype) {
	      case tt._break:case tt._continue:
	        next();
	        var isBreak = starttype === tt._break;
	        if (semicolon() || canInsertSemicolon()) {
	          node.label = null;
	        } else {
	          node.label = token.type === tt.name ? parseIdent() : null;
	          semicolon();
	        }
	        return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

	      case tt._debugger:
	        next();
	        semicolon();
	        return finishNode(node, "DebuggerStatement");

	      case tt._do:
	        next();
	        node.body = parseStatement();
	        node.test = eat(tt._while) ? parseParenExpression() : dummyIdent();
	        semicolon();
	        return finishNode(node, "DoWhileStatement");

	      case tt._for:
	        next();
	        pushCx();
	        expect(tt.parenL);
	        if (token.type === tt.semi) return parseFor(node, null);
	        if (token.type === tt._var || token.type === tt._let) {
	          var init = parseVar(true);
	          if (init.declarations.length === 1 && (token.type === tt._in || token.type === tt.name && token.value === "of")) {
	            return parseForIn(node, init);
	          }
	          return parseFor(node, init);
	        }
	        var init = parseExpression(false, true);
	        if (token.type === tt._in || token.type === tt.name && token.value === "of") {
	          return parseForIn(node, checkLVal(init));
	        }
	        return parseFor(node, init);

	      case tt._function:
	        next();
	        return parseFunction(node, true);

	      case tt._if:
	        next();
	        node.test = parseParenExpression();
	        node.consequent = parseStatement();
	        node.alternate = eat(tt._else) ? parseStatement() : null;
	        return finishNode(node, "IfStatement");

	      case tt._return:
	        next();
	        if (eat(tt.semi) || canInsertSemicolon()) node.argument = null;else {
	          node.argument = parseExpression();semicolon();
	        }
	        return finishNode(node, "ReturnStatement");

	      case tt._switch:
	        var blockIndent = curIndent,
	            line = curLineStart;
	        next();
	        node.discriminant = parseParenExpression();
	        node.cases = [];
	        pushCx();
	        expect(tt.braceL);

	        for (var cur; !closes(tt.braceR, blockIndent, line, true);) {
	          if (token.type === tt._case || token.type === tt._default) {
	            var isCase = token.type === tt._case;
	            if (cur) finishNode(cur, "SwitchCase");
	            node.cases.push(cur = startNode());
	            cur.consequent = [];
	            next();
	            if (isCase) cur.test = parseExpression();else cur.test = null;
	            expect(tt.colon);
	          } else {
	            if (!cur) {
	              node.cases.push(cur = startNode());
	              cur.consequent = [];
	              cur.test = null;
	            }
	            cur.consequent.push(parseStatement());
	          }
	        }
	        if (cur) finishNode(cur, "SwitchCase");
	        popCx();
	        eat(tt.braceR);
	        return finishNode(node, "SwitchStatement");

	      case tt._throw:
	        next();
	        node.argument = parseExpression();
	        semicolon();
	        return finishNode(node, "ThrowStatement");

	      case tt._try:
	        next();
	        node.block = parseBlock();
	        node.handler = null;
	        if (token.type === tt._catch) {
	          var clause = startNode();
	          next();
	          expect(tt.parenL);
	          clause.param = parseIdent();
	          expect(tt.parenR);
	          clause.guard = null;
	          clause.body = parseBlock();
	          node.handler = finishNode(clause, "CatchClause");
	        }
	        node.finalizer = eat(tt._finally) ? parseBlock() : null;
	        if (!node.handler && !node.finalizer) return node.block;
	        return finishNode(node, "TryStatement");

	      case tt._var:
	      case tt._let:
	      case tt._const:
	        return parseVar();

	      case tt._while:
	        next();
	        node.test = parseParenExpression();
	        node.body = parseStatement();
	        return finishNode(node, "WhileStatement");

	      case tt._with:
	        next();
	        node.object = parseParenExpression();
	        node.body = parseStatement();
	        return finishNode(node, "WithStatement");

	      case tt.braceL:
	        return parseBlock();

	      case tt.semi:
	        next();
	        return finishNode(node, "EmptyStatement");

	      case tt._class:
	        return parseObj(true, true);

	      case tt._import:
	        return parseImport();

	      case tt._export:
	        return parseExport();

	      default:
	        var expr = parseExpression();
	        if (isDummy(expr)) {
	          next();
	          if (token.type === tt.eof) return finishNode(node, "EmptyStatement");
	          return parseStatement();
	        } else if (starttype === tt.name && expr.type === "Identifier" && eat(tt.colon)) {
	          node.body = parseStatement();
	          node.label = expr;
	          return finishNode(node, "LabeledStatement");
	        } else {
	          node.expression = expr;
	          semicolon();
	          return finishNode(node, "ExpressionStatement");
	        }
	    }
	  }

	  function parseBlock() {
	    var node = startNode();
	    pushCx();
	    expect(tt.braceL);
	    var blockIndent = curIndent,
	        line = curLineStart;
	    node.body = [];
	    while (!closes(tt.braceR, blockIndent, line, true)) node.body.push(parseStatement());
	    popCx();
	    eat(tt.braceR);
	    return finishNode(node, "BlockStatement");
	  }

	  function parseFor(node, init) {
	    node.init = init;
	    node.test = node.update = null;
	    if (eat(tt.semi) && token.type !== tt.semi) node.test = parseExpression();
	    if (eat(tt.semi) && token.type !== tt.parenR) node.update = parseExpression();
	    popCx();
	    expect(tt.parenR);
	    node.body = parseStatement();
	    return finishNode(node, "ForStatement");
	  }

	  function parseForIn(node, init) {
	    var type = token.type === tt._in ? "ForInStatement" : "ForOfStatement";
	    next();
	    node.left = init;
	    node.right = parseExpression();
	    popCx();
	    expect(tt.parenR);
	    node.body = parseStatement();
	    return finishNode(node, type);
	  }

	  function parseVar(noIn) {
	    var node = startNode();
	    node.kind = token.type.keyword;
	    next();
	    node.declarations = [];
	    do {
	      var decl = startNode();
	      decl.id = options.ecmaVersion >= 6 ? toAssignable(parseExprAtom()) : parseIdent();
	      decl.init = eat(tt.eq) ? parseExpression(true, noIn) : null;
	      node.declarations.push(finishNode(decl, "VariableDeclarator"));
	    } while (eat(tt.comma));
	    if (!node.declarations.length) {
	      var decl = startNode();
	      decl.id = dummyIdent();
	      node.declarations.push(finishNode(decl, "VariableDeclarator"));
	    }
	    if (!noIn) semicolon();
	    return finishNode(node, "VariableDeclaration");
	  }

	  function parseExpression(noComma, noIn) {
	    var start = storeCurrentPos();
	    var expr = parseMaybeAssign(noIn);
	    if (!noComma && token.type === tt.comma) {
	      var node = startNodeAt(start);
	      node.expressions = [expr];
	      while (eat(tt.comma)) node.expressions.push(parseMaybeAssign(noIn));
	      return finishNode(node, "SequenceExpression");
	    }
	    return expr;
	  }

	  function parseParenExpression() {
	    pushCx();
	    expect(tt.parenL);
	    var val = parseExpression();
	    popCx();
	    expect(tt.parenR);
	    return val;
	  }

	  function parseMaybeAssign(noIn) {
	    var start = storeCurrentPos();
	    var left = parseMaybeConditional(noIn);
	    if (token.type.isAssign) {
	      var node = startNodeAt(start);
	      node.operator = token.value;
	      node.left = token.type === tt.eq ? toAssignable(left) : checkLVal(left);
	      next();
	      node.right = parseMaybeAssign(noIn);
	      return finishNode(node, "AssignmentExpression");
	    }
	    return left;
	  }

	  function parseMaybeConditional(noIn) {
	    var start = storeCurrentPos();
	    var expr = parseExprOps(noIn);
	    if (eat(tt.question)) {
	      var node = startNodeAt(start);
	      node.test = expr;
	      node.consequent = parseExpression(true);
	      node.alternate = expect(tt.colon) ? parseExpression(true, noIn) : dummyIdent();
	      return finishNode(node, "ConditionalExpression");
	    }
	    return expr;
	  }

	  function parseExprOps(noIn) {
	    var start = storeCurrentPos();
	    var indent = curIndent,
	        line = curLineStart;
	    return parseExprOp(parseMaybeUnary(noIn), start, -1, noIn, indent, line);
	  }

	  function parseExprOp(left, start, minPrec, noIn, indent, line) {
	    if (curLineStart != line && curIndent < indent && tokenStartsLine()) return left;
	    var prec = token.type.binop;
	    if (prec != null && (!noIn || token.type !== tt._in)) {
	      if (prec > minPrec) {
	        var node = startNodeAt(start);
	        node.left = left;
	        node.operator = token.value;
	        next();
	        if (curLineStart != line && curIndent < indent && tokenStartsLine()) {
	          node.right = dummyIdent();
	        } else {
	          var rightStart = storeCurrentPos();
	          node.right = parseExprOp(parseMaybeUnary(noIn), rightStart, prec, noIn, indent, line);
	        }
	        finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
	        return parseExprOp(node, start, minPrec, noIn, indent, line);
	      }
	    }
	    return left;
	  }

	  function parseMaybeUnary(noIn) {
	    if (token.type.prefix) {
	      var node = startNode(),
	          update = token.type.isUpdate,
	          nodeType;
	      if (token.type === tt.ellipsis) {
	        nodeType = "SpreadElement";
	      } else {
	        nodeType = update ? "UpdateExpression" : "UnaryExpression";
	        node.operator = token.value;
	        node.prefix = true;
	      }
	      node.operator = token.value;
	      node.prefix = true;
	      next();
	      node.argument = parseMaybeUnary(noIn);
	      if (update) node.argument = checkLVal(node.argument);
	      return finishNode(node, nodeType);
	    }
	    var start = storeCurrentPos();
	    var expr = parseExprSubscripts();
	    while (token.type.postfix && !canInsertSemicolon()) {
	      var node = startNodeAt(start);
	      node.operator = token.value;
	      node.prefix = false;
	      node.argument = checkLVal(expr);
	      next();
	      expr = finishNode(node, "UpdateExpression");
	    }
	    return expr;
	  }

	  function parseExprSubscripts() {
	    var start = storeCurrentPos();
	    return parseSubscripts(parseExprAtom(), start, false, curIndent, curLineStart);
	  }

	  function parseSubscripts(base, start, noCalls, startIndent, line) {
	    for (;;) {
	      if (curLineStart != line && curIndent <= startIndent && tokenStartsLine()) {
	        if (token.type == tt.dot && curIndent == startIndent) --startIndent;else return base;
	      }

	      if (eat(tt.dot)) {
	        var node = startNodeAt(start);
	        node.object = base;
	        if (curLineStart != line && curIndent <= startIndent && tokenStartsLine()) node.property = dummyIdent();else node.property = parsePropertyAccessor() || dummyIdent();
	        node.computed = false;
	        base = finishNode(node, "MemberExpression");
	      } else if (token.type == tt.bracketL) {
	        pushCx();
	        next();
	        var node = startNodeAt(start);
	        node.object = base;
	        node.property = parseExpression();
	        node.computed = true;
	        popCx();
	        expect(tt.bracketR);
	        base = finishNode(node, "MemberExpression");
	      } else if (!noCalls && token.type == tt.parenL) {
	        pushCx();
	        var node = startNodeAt(start);
	        node.callee = base;
	        node.arguments = parseExprList(tt.parenR);
	        base = finishNode(node, "CallExpression");
	      } else if (token.type == tt.template) {
	        var node = startNodeAt(start);
	        node.tag = base;
	        node.quasi = parseTemplate();
	        base = finishNode(node, "TaggedTemplateExpression");
	      } else {
	        return base;
	      }
	    }
	  }

	  function parseExprAtom() {
	    switch (token.type) {
	      case tt._this:
	        var node = startNode();
	        next();
	        return finishNode(node, "ThisExpression");

	      case tt.name:
	        var start = storeCurrentPos();
	        var id = parseIdent();
	        return eat(tt.arrow) ? parseArrowExpression(startNodeAt(start), [id]) : id;

	      case tt.regexp:
	        var node = startNode();
	        var val = token.value;
	        node.regex = { pattern: val.pattern, flags: val.flags };
	        node.value = val.value;
	        node.raw = input.slice(token.start, token.end);
	        next();
	        return finishNode(node, "Literal");

	      case tt.num:case tt.string:
	        var node = startNode();
	        node.value = token.value;
	        node.raw = input.slice(token.start, token.end);
	        next();
	        return finishNode(node, "Literal");

	      case tt._null:case tt._true:case tt._false:
	        var node = startNode();
	        node.value = token.type.atomValue;
	        node.raw = token.type.keyword;
	        next();
	        return finishNode(node, "Literal");

	      case tt.parenL:
	        var start = storeCurrentPos();
	        next();
	        var val = parseExpression();
	        expect(tt.parenR);
	        if (eat(tt.arrow)) {
	          return parseArrowExpression(startNodeAt(start), val.expressions || (isDummy(val) ? [] : [val]));
	        }
	        if (options.preserveParens) {
	          var par = startNodeAt(start);
	          par.expression = val;
	          val = finishNode(par, "ParenthesizedExpression");
	        }
	        return val;

	      case tt.bracketL:
	        var node = startNode();
	        pushCx();
	        node.elements = parseExprList(tt.bracketR, true);
	        return finishNode(node, "ArrayExpression");

	      case tt.braceL:
	        return parseObj();

	      case tt._class:
	        return parseObj(true);

	      case tt._function:
	        var node = startNode();
	        next();
	        return parseFunction(node, false);

	      case tt._new:
	        return parseNew();

	      case tt._yield:
	        var node = startNode();
	        next();
	        if (semicolon() || canInsertSemicolon()) {
	          node.delegate = false;
	          node.argument = null;
	        } else {
	          node.delegate = eat(tt.star);
	          node.argument = parseExpression(true);
	        }
	        return finishNode(node, "YieldExpression");

	      case tt.template:
	        return parseTemplate();

	      default:
	        return dummyIdent();
	    }
	  }

	  function parseNew() {
	    var node = startNode(),
	        startIndent = curIndent,
	        line = curLineStart;
	    next();
	    var start = storeCurrentPos();
	    node.callee = parseSubscripts(parseExprAtom(), start, true, startIndent, line);
	    if (token.type == tt.parenL) {
	      pushCx();
	      node.arguments = parseExprList(tt.parenR);
	    } else {
	      node.arguments = [];
	    }
	    return finishNode(node, "NewExpression");
	  }

	  function parseTemplateElement() {
	    var elem = startNodeAt(options.locations ? [token.start + 1, token.startLoc.offset(1)] : token.start + 1);
	    elem.value = token.value;
	    elem.tail = input.charCodeAt(token.end - 1) !== 123; // '{'
	    var endOff = elem.tail ? 1 : 2;
	    var endPos = options.locations ? [token.end - endOff, token.endLoc.offset(-endOff)] : token.end - endOff;
	    next();
	    return finishNodeAt(elem, "TemplateElement", endPos);
	  }

	  function parseTemplate() {
	    var node = startNode();
	    node.expressions = [];
	    var curElt = parseTemplateElement();
	    node.quasis = [curElt];
	    while (!curElt.tail) {
	      var next = parseExpression();
	      if (isDummy(next)) {
	        node.quasis[node.quasis.length - 1].tail = true;
	        break;
	      }
	      node.expressions.push(next);
	      if (token.type === tt.templateContinued) {
	        node.quasis.push(curElt = parseTemplateElement());
	      } else {
	        curElt = startNode();
	        curElt.value = { cooked: "", raw: "" };
	        curElt.tail = true;
	        node.quasis.push(curElt);
	      }
	    }
	    return finishNode(node, "TemplateLiteral");
	  }

	  function parseObj(isClass, isStatement) {
	    var node = startNode();
	    if (isClass) {
	      next();
	      if (token.type === tt.name) node.id = parseIdent();else if (isStatement) node.id = dummyIdent();
	      node.superClass = eat(tt._extends) ? parseExpression() : null;
	      node.body = startNode();
	      node.body.body = [];
	    } else {
	      node.properties = [];
	    }
	    pushCx();
	    var indent = curIndent + 1,
	        line = curLineStart;
	    eat(tt.braceL);
	    if (curIndent + 1 < indent) {
	      indent = curIndent;line = curLineStart;
	    }
	    while (!closes(tt.braceR, indent, line)) {
	      var prop = startNode(),
	          isGenerator;
	      if (options.ecmaVersion >= 6) {
	        if (isClass) {
	          if (prop['static'] = token.type === tt.name && token.value === "static") next();
	        } else {
	          prop.method = false;
	          prop.shorthand = false;
	        }
	        isGenerator = eat(tt.star);
	      }
	      parsePropertyName(prop);
	      if (isDummy(prop.key)) {
	        if (isDummy(parseExpression(true))) next();eat(tt.comma);continue;
	      }
	      if (!isClass && eat(tt.colon)) {
	        prop.kind = "init";
	        prop.value = parseExpression(true);
	      } else if (options.ecmaVersion >= 6 && (token.type === tt.parenL || token.type === tt.braceL)) {
	        if (isClass) {
	          prop.kind = "";
	        } else {
	          prop.kind = "init";
	          prop.method = true;
	        }
	        prop.value = parseMethod(isGenerator);
	      } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && token.type != tt.comma && token.type != tt.braceR) {
	        prop.kind = prop.key.name;
	        parsePropertyName(prop);
	        prop.value = parseMethod(false);
	      } else if (isClass) {
	        prop.kind = "";
	        prop.value = parseMethod(isGenerator);
	      } else {
	        prop.kind = "init";
	        prop.value = options.ecmaVersion >= 6 ? prop.key : dummyIdent();
	        prop.shorthand = true;
	      }

	      if (isClass) {
	        node.body.body.push(finishNode(prop, "MethodDefinition"));
	        semicolon();
	      } else {
	        node.properties.push(finishNode(prop, "Property"));
	        eat(tt.comma);
	      }
	    }
	    popCx();
	    if (!eat(tt.braceR)) {
	      // If there is no closing brace, make the node span to the start
	      // of the next token (this is useful for Tern)
	      lastEnd = token.start;
	      if (options.locations) lastEndLoc = token.startLoc;
	    }
	    if (isClass) {
	      semicolon();
	      finishNode(node.body, "ClassBody");
	      return finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	    } else {
	      return finishNode(node, "ObjectExpression");
	    }
	  }

	  function parsePropertyName(prop) {
	    if (options.ecmaVersion >= 6) {
	      if (eat(tt.bracketL)) {
	        prop.computed = true;
	        prop.key = parseExpression();
	        expect(tt.bracketR);
	        return;
	      } else {
	        prop.computed = false;
	      }
	    }
	    var key = token.type === tt.num || token.type === tt.string ? parseExprAtom() : parseIdent();
	    prop.key = key || dummyIdent();
	  }

	  function parsePropertyAccessor() {
	    if (token.type === tt.name || token.type.keyword) return parseIdent();
	  }

	  function parseIdent() {
	    var node = startNode();
	    node.name = token.type === tt.name ? token.value : token.type.keyword;
	    next();
	    return finishNode(node, "Identifier");
	  }

	  function initFunction(node) {
	    node.id = null;
	    node.params = [];
	    if (options.ecmaVersion >= 6) {
	      node.defaults = [];
	      node.rest = null;
	      node.generator = false;
	      node.expression = false;
	    }
	  }

	  // Convert existing expression atom to assignable pattern
	  // if possible.

	  function toAssignable(node) {
	    if (options.ecmaVersion >= 6 && node) {
	      switch (node.type) {
	        case "ObjectExpression":
	          node.type = "ObjectPattern";
	          var props = node.properties;
	          for (var i = 0; i < props.length; i++) {
	            props[i].value = toAssignable(props[i].value);
	          }
	          break;

	        case "ArrayExpression":
	          node.type = "ArrayPattern";
	          var elms = node.elements;
	          for (var i = 0; i < elms.length; i++) {
	            elms[i] = toAssignable(elms[i]);
	          }
	          break;

	        case "SpreadElement":
	          node.argument = toAssignable(node.argument);
	          break;

	        case "AssignmentExpression":
	          if (node.operator === "=") node.type = "AssignmentPattern";
	          break;
	      }
	    }
	    return checkLVal(node);
	  }

	  function parseFunctionParams(node, params) {
	    var defaults = [],
	        hasDefaults = false;

	    if (!params) {
	      pushCx();
	      params = parseExprList(tt.parenR);
	    }
	    for (var i = 0; i < params.length; i++) {
	      var param = params[i],
	          defValue = null;
	      if (param.type === "AssignmentExpression") {
	        defValue = param.right;
	        param = param.left;
	      }
	      param = toAssignable(param);
	      if (param.type === "SpreadElement") {
	        param = param.argument;
	        if (i === params.length - 1) {
	          node.rest = param;
	          continue;
	        }
	      }
	      node.params.push(param);
	      defaults.push(defValue);
	      if (defValue) hasDefaults = true;
	    }

	    if (hasDefaults) node.defaults = defaults;
	  }

	  function parseFunction(node, isStatement) {
	    initFunction(node);
	    if (options.ecmaVersion >= 6) {
	      node.generator = eat(tt.star);
	    }
	    if (token.type === tt.name) node.id = parseIdent();else if (isStatement) node.id = dummyIdent();
	    parseFunctionParams(node);
	    node.body = parseBlock();
	    return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
	  }

	  function parseMethod(isGenerator) {
	    var node = startNode();
	    initFunction(node);
	    parseFunctionParams(node);
	    node.generator = isGenerator || false;
	    node.expression = options.ecmaVersion >= 6 && token.type !== tt.braceL;
	    node.body = node.expression ? parseExpression(true) : parseBlock();
	    return finishNode(node, "FunctionExpression");
	  }

	  function parseArrowExpression(node, params) {
	    initFunction(node);
	    parseFunctionParams(node, params);
	    node.expression = token.type !== tt.braceL;
	    node.body = node.expression ? parseExpression(true) : parseBlock();
	    return finishNode(node, "ArrowFunctionExpression");
	  }

	  function parseExport() {
	    var node = startNode();
	    next();
	    node['default'] = eat(tt._default);
	    node.specifiers = node.source = null;
	    if (node['default']) {
	      node.declaration = parseExpression();
	      semicolon();
	    } else if (token.type.keyword) {
	      node.declaration = parseStatement();
	    } else {
	      node.declaration = null;
	      parseSpecifierList(node, "Export");
	    }
	    semicolon();
	    return finishNode(node, "ExportDeclaration");
	  }

	  function parseImport() {
	    var node = startNode();
	    next();
	    if (token.type === tt.string) {
	      node.specifiers = [];
	      node.source = parseExprAtom();
	      node.kind = '';
	    } else {
	      if (token.type === tt.name && token.value !== "from") {
	        var elt = startNode();
	        elt.id = parseIdent();
	        elt.name = null;
	        elt['default'] = true;
	        finishNode(elt, "ImportSpecifier");
	        eat(tt.comma);
	      }
	      parseSpecifierList(node, "Import");
	      var specs = node.specifiers;
	      for (var i = 0; i < specs.length; i++) specs[i]['default'] = false;
	      if (elt) node.specifiers.unshift(elt);
	    }
	    semicolon();
	    return finishNode(node, "ImportDeclaration");
	  }

	  function parseSpecifierList(node, prefix) {
	    var elts = node.specifiers = [];
	    if (token.type === tt.star) {
	      var elt = startNode();
	      next();
	      if (token.type === tt.name && token.value === "as") {
	        next();
	        elt.name = parseIdent();
	      }
	      elts.push(finishNode(elt, prefix + "BatchSpecifier"));
	    } else {
	      var indent = curIndent,
	          line = curLineStart,
	          continuedLine = nextLineStart;
	      pushCx();
	      eat(tt.braceL);
	      if (curLineStart > continuedLine) continuedLine = curLineStart;
	      while (!closes(tt.braceR, indent + (curLineStart <= continuedLine ? 1 : 0), line)) {
	        var elt = startNode();
	        if (token.type === tt.star) {
	          next();
	          if (token.type === tt.name && token.value === "as") {
	            next();
	            elt.name = parseIdent();
	          }
	          finishNode(elt, prefix + "BatchSpecifier");
	        } else {
	          if (token.type === tt.name && token.value === "from") break;
	          elt.id = parseIdent();
	          if (token.type === tt.name && token.value === "as") {
	            next();
	            elt.name = parseIdent();
	          } else {
	            elt.name = null;
	          }
	          finishNode(elt, prefix + "Specifier");
	        }
	        elts.push(elt);
	        eat(tt.comma);
	      }
	      eat(tt.braceR);
	      popCx();
	    }
	    if (token.type === tt.name && token.value === "from") {
	      next();
	      node.source = parseExprAtom();
	    } else {
	      node.source = null;
	    }
	  }

	  function parseExprList(close, allowEmpty) {
	    var indent = curIndent,
	        line = curLineStart,
	        elts = [];
	    next(); // Opening bracket
	    while (!closes(close, indent + 1, line)) {
	      if (eat(tt.comma)) {
	        elts.push(allowEmpty ? null : dummyIdent());
	        continue;
	      }
	      var elt = parseExpression(true);
	      if (isDummy(elt)) {
	        if (closes(close, indent, line)) break;
	        next();
	      } else {
	        elts.push(elt);
	      }
	      eat(tt.comma);
	    }
	    popCx();
	    if (!eat(close)) {
	      // If there is no closing brace, make the node span to the start
	      // of the next token (this is useful for Tern)
	      lastEnd = token.start;
	      if (options.locations) lastEndLoc = token.startLoc;
	    }
	    return elts;
	  }
	});

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Type description parser
	//
	// Type description JSON files (such as ecma5.json and browser.json)
	// are used to
	//
	// A) describe types that come from native code
	//
	// B) to cheaply load the types for big libraries, or libraries that
	//    can't be inferred well

	(function (mod) {
	  if (true) // CommonJS
	    return exports.init = mod;
	  if (true) // AMD
	    return !(module.exports = { init: mod });
	  tern.def = { init: mod };
	})(function (exports, infer) {
	  "use strict";

	  function hop(obj, prop) {
	    return Object.prototype.hasOwnProperty.call(obj, prop);
	  }

	  var TypeParser = exports.TypeParser = function (spec, start, base, forceNew) {
	    this.pos = start || 0;
	    this.spec = spec;
	    this.base = base;
	    this.forceNew = forceNew;
	  };
	  TypeParser.prototype = {
	    eat: function (str) {
	      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {
	        this.pos += str.length;
	        return true;
	      }
	    },
	    word: function (re) {
	      var word = "",
	          ch,
	          re = re || /[\w$]/;
	      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) {
	        word += ch;++this.pos;
	      }
	      return word;
	    },
	    error: function () {
	      throw new Error("Unrecognized type spec: " + this.spec + " (at " + this.pos + ")");
	    },
	    parseFnType: function (name, top) {
	      var args = [],
	          names = [];
	      if (!this.eat(")")) for (var i = 0;; ++i) {
	        var colon = this.spec.indexOf(": ", this.pos),
	            argname;
	        if (colon != -1) {
	          argname = this.spec.slice(this.pos, colon);
	          if (/^[$\w?]+$/.test(argname)) this.pos = colon + 2;else argname = null;
	        }
	        names.push(argname);
	        args.push(this.parseType());
	        if (!this.eat(", ")) {
	          this.eat(")") || this.error();
	          break;
	        }
	      }
	      var retType, computeRet, computeRetStart, fn;
	      if (this.eat(" -> ")) {
	        if (top && this.spec.indexOf("!", this.pos) > -1) {
	          retType = infer.ANull;
	          computeRetStart = this.pos;
	          computeRet = this.parseRetType();
	        } else retType = this.parseType();
	      } else retType = infer.ANull;
	      if (top && (fn = this.base)) infer.Fn.call(this.base, name, infer.ANull, args, names, retType);else fn = new infer.Fn(name, infer.ANull, args, names, retType);
	      if (computeRet) fn.computeRet = computeRet;
	      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);
	      return fn;
	    },
	    parseType: function (name, top) {
	      if (this.eat("fn(")) {
	        return this.parseFnType(name, top);
	      } else if (this.eat("[")) {
	        var inner = this.parseType();
	        if (inner == infer.ANull && this.spec == "[b.<i>]") {
	          var b = parsePath("b");
	          console.log(b.props["<i>"].types.length);
	        }
	        this.eat("]") || this.error();
	        if (top && this.base) {
	          infer.Arr.call(this.base, inner);
	          return this.base;
	        }
	        return new infer.Arr(inner);
	      } else if (this.eat("+")) {
	        var path = this.word(/[\w$<>\.!]/);
	        var base = parsePath(path + ".prototype");
	        if (!(base instanceof infer.Obj)) base = parsePath(path);
	        if (!(base instanceof infer.Obj)) return base;
	        if (top && this.forceNew) return new infer.Obj(base);
	        return infer.getInstance(base);
	      } else if (this.eat("?")) {
	        return infer.ANull;
	      } else {
	        return this.fromWord(this.word(/[\w$<>\.!`]/));
	      }
	    },
	    fromWord: function (spec) {
	      var cx = infer.cx();
	      switch (spec) {
	        case "number":
	          return cx.num;
	        case "string":
	          return cx.str;
	        case "bool":
	          return cx.bool;
	        case "<top>":
	          return cx.topScope;
	      }
	      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];
	      return parsePath(spec);
	    },
	    parseBaseRetType: function () {
	      if (this.eat("[")) {
	        var inner = this.parseRetType();
	        this.eat("]") || this.error();
	        return function (self, args) {
	          return new infer.Arr(inner(self, args));
	        };
	      } else if (this.eat("+")) {
	        var base = this.parseRetType();
	        return function (self, args) {
	          return infer.getInstance(base(self, args));
	        };
	      } else if (this.eat("!")) {
	        var arg = this.word(/\d/);
	        if (arg) {
	          arg = Number(arg);
	          return function (_self, args) {
	            return args[arg] || infer.ANull;
	          };
	        } else if (this.eat("this")) {
	          return function (self) {
	            return self;
	          };
	        } else if (this.eat("custom:")) {
	          var fname = this.word(/[\w$]/);
	          return customFunctions[fname] || function () {
	            return infer.ANull;
	          };
	        } else {
	          return this.fromWord("!" + arg + this.word(/[\w$<>\.!]/));
	        }
	      }
	      var t = this.parseType();
	      return function () {
	        return t;
	      };
	    },
	    extendRetType: function (base) {
	      var propName = this.word(/[\w<>$!]/) || this.error();
	      if (propName == "!ret") return function (self, args) {
	        var lhs = base(self, args);
	        if (lhs.retval) return lhs.retval;
	        var rv = new infer.AVal();
	        lhs.propagate(new infer.IsCallee(infer.ANull, [], null, rv));
	        return rv;
	      };
	      return function (self, args) {
	        return base(self, args).getProp(propName);
	      };
	    },
	    parseRetType: function () {
	      var tp = this.parseBaseRetType();
	      while (this.eat(".")) tp = this.extendRetType(tp);
	      return tp;
	    }
	  };

	  function parseType(spec, name, base, forceNew) {
	    var type = new TypeParser(spec, null, base, forceNew).parseType(name, true);
	    if (/^fn\(/.test(spec)) for (var i = 0; i < type.args.length; ++i) (function (i) {
	      var arg = type.args[i];
	      if (arg instanceof infer.Fn && arg.args && arg.args.length) addEffect(type, function (_self, fArgs) {
	        var fArg = fArgs[i];
	        if (fArg) fArg.propagate(new infer.IsCallee(infer.cx().topScope, arg.args, null, infer.ANull));
	      });
	    })(i);
	    return type;
	  }

	  function addEffect(fn, handler, replaceRet) {
	    var oldCmp = fn.computeRet,
	        rv = fn.retval;
	    fn.computeRet = function (self, args, argNodes) {
	      var handled = handler(self, args, argNodes);
	      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;
	      return replaceRet ? handled : old;
	    };
	  }

	  var parseEffect = exports.parseEffect = function (effect, fn) {
	    var m;
	    if (effect.indexOf("propagate ") == 0) {
	      var p = new TypeParser(effect, 10);
	      var getOrigin = p.parseRetType();
	      if (!p.eat(" ")) p.error();
	      var getTarget = p.parseRetType();
	      addEffect(fn, function (self, args) {
	        getOrigin(self, args).propagate(getTarget(self, args));
	      });
	    } else if (effect.indexOf("call ") == 0) {
	      var andRet = effect.indexOf("and return ", 5) == 5;
	      var p = new TypeParser(effect, andRet ? 16 : 5);
	      var getCallee = p.parseRetType(),
	          getSelf = null,
	          getArgs = [];
	      if (p.eat(" this=")) getSelf = p.parseRetType();
	      while (p.eat(" ")) getArgs.push(p.parseRetType());
	      addEffect(fn, function (self, args) {
	        var callee = getCallee(self, args);
	        var slf = getSelf ? getSelf(self, args) : infer.ANull,
	            as = [];
	        for (var i = 0; i < getArgs.length; ++i) as.push(getArgs[i](self, args));
	        var result = andRet ? new infer.AVal() : infer.ANull;
	        callee.propagate(new infer.IsCallee(slf, as, null, result));
	        return result;
	      }, andRet);
	    } else if (m = effect.match(/^custom (\S+)\s*(.*)/)) {
	      var customFunc = customFunctions[m[1]];
	      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);
	    } else if (effect.indexOf("copy ") == 0) {
	      var p = new TypeParser(effect, 5);
	      var getFrom = p.parseRetType();
	      p.eat(" ");
	      var getTo = p.parseRetType();
	      addEffect(fn, function (self, args) {
	        var from = getFrom(self, args),
	            to = getTo(self, args);
	        from.forAllProps(function (prop, val, local) {
	          if (local && prop != "<i>") to.propagate(new infer.PropHasSubset(prop, val));
	        });
	      });
	    } else {
	      throw new Error("Unknown effect type: " + effect);
	    }
	  };

	  var currentTopScope;

	  var parsePath = exports.parsePath = function (path) {
	    var cx = infer.cx(),
	        cached = cx.paths[path],
	        origPath = path;
	    if (cached != null) return cached;
	    cx.paths[path] = infer.ANull;

	    var base = currentTopScope || cx.topScope;

	    if (cx.localDefs) for (var name in cx.localDefs) {
	      if (path.indexOf(name) == 0) {
	        if (path == name) return cx.paths[path] = cx.localDefs[path];
	        if (path.charAt(name.length) == ".") {
	          base = cx.localDefs[name];
	          path = path.slice(name.length + 1);
	          break;
	        }
	      }
	    }

	    var parts = path.split(".");
	    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {
	      var prop = parts[i];
	      if (prop.charAt(0) == "!") {
	        if (prop == "!proto") {
	          base = base instanceof infer.Obj && base.proto || infer.ANull;
	        } else {
	          var fn = base.getFunctionType();
	          if (!fn) {
	            base = infer.ANull;
	          } else if (prop == "!ret") {
	            base = fn.retval && fn.retval.getType(false) || infer.ANull;
	          } else {
	            var arg = fn.args && fn.args[Number(prop.slice(1))];
	            base = arg && arg.getType(false) || infer.ANull;
	          }
	        }
	      } else if (base instanceof infer.Obj) {
	        var propVal = prop == "prototype" && base instanceof infer.Fn ? base.getProp(prop) : base.props[prop];
	        if (!propVal || propVal.isEmpty()) base = infer.ANull;else base = propVal.types[0];
	      }
	    }
	    // Uncomment this to get feedback on your poorly written .json files
	    // if (base == infer.ANull) console.error("bad path: " + origPath + " (" + cx.curOrigin + ")");
	    cx.paths[origPath] = base == infer.ANull ? null : base;
	    return base;
	  };

	  function emptyObj(ctor) {
	    var empty = Object.create(ctor.prototype);
	    empty.props = Object.create(null);
	    empty.isShell = true;
	    return empty;
	  }

	  function isSimpleAnnotation(spec) {
	    if (!spec["!type"] || /^(fn\(|\[)/.test(spec["!type"])) return false;
	    for (var prop in spec) if (prop != "!type" && prop != "!doc" && prop != "!url" && prop != "!span" && prop != "!data") return false;
	    return true;
	  }

	  function passOne(base, spec, path) {
	    if (!base) {
	      var tp = spec["!type"];
	      if (tp) {
	        if (/^fn\(/.test(tp)) base = emptyObj(infer.Fn);else if (tp.charAt(0) == "[") base = emptyObj(infer.Arr);else throw new Error("Invalid !type spec: " + tp);
	      } else if (spec["!stdProto"]) {
	        base = infer.cx().protos[spec["!stdProto"]];
	      } else {
	        base = emptyObj(infer.Obj);
	      }
	      base.name = path;
	    }

	    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
	      var inner = spec[name];
	      if (typeof inner == "string" || isSimpleAnnotation(inner)) continue;
	      var prop = base.defProp(name);
	      passOne(prop.getType(false), inner, path ? path + "." + name : name).propagate(prop);
	    }
	    return base;
	  }

	  function passTwo(base, spec, path) {
	    if (base.isShell) {
	      delete base.isShell;
	      var tp = spec["!type"];
	      if (tp) {
	        parseType(tp, path, base);
	      } else {
	        var proto = spec["!proto"] && parseType(spec["!proto"]);
	        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);
	      }
	    }

	    var effects = spec["!effects"];
	    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i) parseEffect(effects[i], base);
	    copyInfo(spec, base);

	    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
	      var inner = spec[name],
	          known = base.defProp(name),
	          innerPath = path ? path + "." + name : name;
	      var type = known.getType(false);
	      if (typeof inner == "string") {
	        if (type) continue;
	        parseType(inner, innerPath).propagate(known);
	      } else {
	        if (!isSimpleAnnotation(inner)) {
	          passTwo(type, inner, innerPath);
	        } else if (!type) {
	          parseType(inner["!type"], innerPath, null, true).propagate(known);
	          type = known.getType(false);
	          if (type instanceof infer.Obj) copyInfo(inner, type);
	        } else continue;
	        if (inner["!doc"]) known.doc = inner["!doc"];
	        if (inner["!url"]) known.url = inner["!url"];
	        if (inner["!span"]) known.span = inner["!span"];
	      }
	    }
	  }

	  function copyInfo(spec, type) {
	    if (spec["!doc"]) type.doc = spec["!doc"];
	    if (spec["!url"]) type.url = spec["!url"];
	    if (spec["!span"]) type.span = spec["!span"];
	    if (spec["!data"]) type.metaData = spec["!data"];
	  }

	  function runPasses(type, arg) {
	    var parent = infer.cx().parent,
	        pass = parent && parent.passes && parent.passes[type];
	    if (pass) for (var i = 0; i < pass.length; i++) pass[i](arg);
	  }

	  function doLoadEnvironment(data, scope) {
	    var cx = infer.cx();

	    infer.addOrigin(cx.curOrigin = data["!name"] || "env#" + cx.origins.length);
	    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);

	    runPasses("preLoadDef", data);

	    passOne(scope, data);

	    var def = data["!define"];
	    if (def) {
	      for (var name in def) {
	        var spec = def[name];
	        cx.localDefs[name] = typeof spec == "string" ? parsePath(spec) : passOne(null, spec, name);
	      }
	      for (var name in def) {
	        var spec = def[name];
	        if (typeof spec != "string") passTwo(cx.localDefs[name], def[name], name);
	      }
	    }

	    passTwo(scope, data);

	    runPasses("postLoadDef", data);

	    cx.curOrigin = cx.localDefs = null;
	  }

	  exports.load = function (data, scope) {
	    if (!scope) scope = infer.cx().topScope;
	    var oldScope = currentTopScope;
	    currentTopScope = scope;
	    try {
	      doLoadEnvironment(data, scope);
	    } finally {
	      currentTopScope = oldScope;
	    }
	  };

	  // Used to register custom logic for more involved effect or type
	  // computation.
	  var customFunctions = Object.create(null);
	  infer.registerFunction = function (name, f) {
	    customFunctions[name] = f;
	  };

	  var IsCreated = infer.constraint("created, target, spec", {
	    addType: function (tp) {
	      if (tp instanceof infer.Obj && this.created++ < 5) {
	        var derived = new infer.Obj(tp),
	            spec = this.spec;
	        if (spec instanceof infer.AVal) spec = spec.getType(false);
	        if (spec instanceof infer.Obj) for (var prop in spec.props) {
	          var cur = spec.props[prop].types[0];
	          var p = derived.defProp(prop);
	          if (cur && cur instanceof infer.Obj && cur.props.value) {
	            var vtp = cur.props.value.getType(false);
	            if (vtp) p.addType(vtp);
	          }
	        }
	        this.target.addType(derived);
	      }
	    }
	  });

	  infer.registerFunction("Object_create", function (_self, args, argNodes) {
	    if (argNodes && argNodes.length && argNodes[0].type == "Literal" && argNodes[0].value == null) return new infer.Obj();

	    var result = new infer.AVal();
	    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));
	    return result;
	  });

	  var IsBound = infer.constraint("self, args, target", {
	    addType: function (tp) {
	      if (!(tp instanceof infer.Fn)) return;
	      this.target.addType(new infer.Fn(tp.name, tp.self, tp.args.slice(this.args.length), tp.argNames.slice(this.args.length), tp.retval));
	      this.self.propagate(tp.self);
	      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i) this.args[i].propagate(tp.args[i]);
	    }
	  });

	  infer.registerFunction("Function_bind", function (self, args) {
	    if (!args.length) return infer.ANull;
	    var result = new infer.AVal();
	    self.propagate(new IsBound(args[0], args.slice(1), result));
	    return result;
	  });

	  infer.registerFunction("Array_ctor", function (_self, args) {
	    var arr = new infer.Arr();
	    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {
	      var content = arr.getProp("<i>");
	      for (var i = 0; i < args.length; ++i) args[i].propagate(content);
	    }
	    return arr;
	  });

	  return exports;
	});

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	(function (mod) {
	  if (true) // CommonJS
	    return mod(exports);
	  if (true) // AMD
	    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  mod((self.tern || (self.tern = {})).signal = {}); // Plain browser env
	})(function (exports) {
	  function on(type, f) {
	    var handlers = this._handlers || (this._handlers = Object.create(null));
	    (handlers[type] || (handlers[type] = [])).push(f);
	  }
	  function off(type, f) {
	    var arr = this._handlers && this._handlers[type];
	    if (arr) for (var i = 0; i < arr.length; ++i) if (arr[i] == f) {
	      arr.splice(i, 1);break;
	    }
	  }
	  function signal(type, a1, a2, a3, a4) {
	    var arr = this._handlers && this._handlers[type];
	    if (arr) for (var i = 0; i < arr.length; ++i) arr[i].call(this, a1, a2, a3, a4);
	  }

	  exports.mixin = function (obj) {
	    obj.on = on;obj.off = off;obj.signal = signal;
	    return obj;
	  };
	});

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	// AST walker module for Mozilla Parser API compatible trees

	(function (mod) {
	  if (true) return mod(exports); // CommonJS
	  if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	  mod((this.acorn || (this.acorn = {})).walk = {}); // Plain browser env
	})(function (exports) {
	  "use strict"

	  // A simple walk is one where you simply specify callbacks to be
	  // called on specific nodes. The last two arguments are optional. A
	  // simple use would be
	  //
	  //     walk.simple(myTree, {
	  //         Expression: function(node) { ... }
	  //     });
	  //
	  // to do something with all expressions. All Parser API node types
	  // can be used to identify node types, as well as Expression,
	  // Statement, and ScopeBody, which denote categories of nodes.
	  //
	  // The base argument can be used to pass a custom (recursive)
	  // walker, and state can be used to give this walked an initial
	  // state.
	  ;
	  exports.simple = function (node, visitors, base, state) {
	    if (!base) base = exports.base;
	    function c(node, st, override) {
	      var type = override || node.type,
	          found = visitors[type];
	      base[type](node, st, c);
	      if (found) found(node, st);
	    }
	    c(node, state);
	  };

	  // An ancestor walk builds up an array of ancestor nodes (including
	  // the current node) and passes them to the callback as the state parameter.
	  exports.ancestor = function (node, visitors, base, state) {
	    if (!base) base = exports.base;
	    if (!state) state = [];
	    function c(node, st, override) {
	      var type = override || node.type,
	          found = visitors[type];
	      if (node != st[st.length - 1]) {
	        st = st.slice();
	        st.push(node);
	      }
	      base[type](node, st, c);
	      if (found) found(node, st);
	    }
	    c(node, state);
	  };

	  // A recursive walk is one where your functions override the default
	  // walkers. They can modify and replace the state parameter that's
	  // threaded through the walk, and can opt how and whether to walk
	  // their child nodes (by calling their third argument on these
	  // nodes).
	  exports.recursive = function (node, state, funcs, base) {
	    var visitor = funcs ? exports.make(funcs, base) : base;
	    function c(node, st, override) {
	      visitor[override || node.type](node, st, c);
	    }
	    c(node, state);
	  };

	  function makeTest(test) {
	    if (typeof test == "string") return function (type) {
	      return type == test;
	    };else if (!test) return function () {
	      return true;
	    };else return test;
	  }

	  function Found(node, state) {
	    this.node = node;this.state = state;
	  }

	  // Find a node with a given start, end, and type (all are optional,
	  // null can be used as wildcard). Returns a {node, state} object, or
	  // undefined when it doesn't find a matching node.
	  exports.findNodeAt = function (node, start, end, test, base, state) {
	    test = makeTest(test);
	    try {
	      if (!base) base = exports.base;
	      var c = function (node, st, override) {
	        var type = override || node.type;
	        if ((start == null || node.start <= start) && (end == null || node.end >= end)) base[type](node, st, c);
	        if (test(type, node) && (start == null || node.start == start) && (end == null || node.end == end)) throw new Found(node, st);
	      };
	      c(node, state);
	    } catch (e) {
	      if (e instanceof Found) return e;
	      throw e;
	    }
	  };

	  // Find the innermost node of a given type that contains the given
	  // position. Interface similar to findNodeAt.
	  exports.findNodeAround = function (node, pos, test, base, state) {
	    test = makeTest(test);
	    try {
	      if (!base) base = exports.base;
	      var c = function (node, st, override) {
	        var type = override || node.type;
	        if (node.start > pos || node.end < pos) return;
	        base[type](node, st, c);
	        if (test(type, node)) throw new Found(node, st);
	      };
	      c(node, state);
	    } catch (e) {
	      if (e instanceof Found) return e;
	      throw e;
	    }
	  };

	  // Find the outermost matching node after a given position.
	  exports.findNodeAfter = function (node, pos, test, base, state) {
	    test = makeTest(test);
	    try {
	      if (!base) base = exports.base;
	      var c = function (node, st, override) {
	        if (node.end < pos) return;
	        var type = override || node.type;
	        if (node.start >= pos && test(type, node)) throw new Found(node, st);
	        base[type](node, st, c);
	      };
	      c(node, state);
	    } catch (e) {
	      if (e instanceof Found) return e;
	      throw e;
	    }
	  };

	  // Find the outermost matching node before a given position.
	  exports.findNodeBefore = function (node, pos, test, base, state) {
	    test = makeTest(test);
	    if (!base) base = exports.base;
	    var max;
	    var c = function (node, st, override) {
	      if (node.start > pos) return;
	      var type = override || node.type;
	      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) max = new Found(node, st);
	      base[type](node, st, c);
	    };
	    c(node, state);
	    return max;
	  };

	  // Used to create a custom walker. Will fill in all missing node
	  // type properties with the defaults.
	  exports.make = function (funcs, base) {
	    if (!base) base = exports.base;
	    var visitor = {};
	    for (var type in base) visitor[type] = base[type];
	    for (var type in funcs) visitor[type] = funcs[type];
	    return visitor;
	  };

	  function skipThrough(node, st, c) {
	    c(node, st);
	  }
	  function ignore(_node, _st, _c) {}

	  // Node walkers.

	  var base = exports.base = {};
	  base.Program = base.BlockStatement = function (node, st, c) {
	    for (var i = 0; i < node.body.length; ++i) c(node.body[i], st, "Statement");
	  };
	  base.Statement = skipThrough;
	  base.EmptyStatement = ignore;
	  base.ExpressionStatement = function (node, st, c) {
	    c(node.expression, st, "Expression");
	  };
	  base.IfStatement = function (node, st, c) {
	    c(node.test, st, "Expression");
	    c(node.consequent, st, "Statement");
	    if (node.alternate) c(node.alternate, st, "Statement");
	  };
	  base.LabeledStatement = function (node, st, c) {
	    c(node.body, st, "Statement");
	  };
	  base.BreakStatement = base.ContinueStatement = ignore;
	  base.WithStatement = function (node, st, c) {
	    c(node.object, st, "Expression");
	    c(node.body, st, "Statement");
	  };
	  base.SwitchStatement = function (node, st, c) {
	    c(node.discriminant, st, "Expression");
	    for (var i = 0; i < node.cases.length; ++i) {
	      var cs = node.cases[i];
	      if (cs.test) c(cs.test, st, "Expression");
	      for (var j = 0; j < cs.consequent.length; ++j) c(cs.consequent[j], st, "Statement");
	    }
	  };
	  base.ReturnStatement = base.YieldExpression = function (node, st, c) {
	    if (node.argument) c(node.argument, st, "Expression");
	  };
	  base.ThrowStatement = base.SpreadElement = function (node, st, c) {
	    c(node.argument, st, "Expression");
	  };
	  base.TryStatement = function (node, st, c) {
	    c(node.block, st, "Statement");
	    if (node.handler) c(node.handler.body, st, "ScopeBody");
	    if (node.finalizer) c(node.finalizer, st, "Statement");
	  };
	  base.WhileStatement = function (node, st, c) {
	    c(node.test, st, "Expression");
	    c(node.body, st, "Statement");
	  };
	  base.DoWhileStatement = base.WhileStatement;
	  base.ForStatement = function (node, st, c) {
	    if (node.init) c(node.init, st, "ForInit");
	    if (node.test) c(node.test, st, "Expression");
	    if (node.update) c(node.update, st, "Expression");
	    c(node.body, st, "Statement");
	  };
	  base.ForInStatement = base.ForOfStatement = function (node, st, c) {
	    c(node.left, st, "ForInit");
	    c(node.right, st, "Expression");
	    c(node.body, st, "Statement");
	  };
	  base.ForInit = function (node, st, c) {
	    if (node.type == "VariableDeclaration") c(node, st);else c(node, st, "Expression");
	  };
	  base.DebuggerStatement = ignore;

	  base.FunctionDeclaration = function (node, st, c) {
	    c(node, st, "Function");
	  };
	  base.VariableDeclaration = function (node, st, c) {
	    for (var i = 0; i < node.declarations.length; ++i) {
	      var decl = node.declarations[i];
	      if (decl.init) c(decl.init, st, "Expression");
	    }
	  };

	  base.Function = function (node, st, c) {
	    c(node.body, st, "ScopeBody");
	  };
	  base.ScopeBody = function (node, st, c) {
	    c(node, st, "Statement");
	  };

	  base.Expression = skipThrough;
	  base.ThisExpression = ignore;
	  base.ArrayExpression = function (node, st, c) {
	    for (var i = 0; i < node.elements.length; ++i) {
	      var elt = node.elements[i];
	      if (elt) c(elt, st, "Expression");
	    }
	  };
	  base.ObjectExpression = function (node, st, c) {
	    for (var i = 0; i < node.properties.length; ++i) c(node.properties[i], st);
	  };
	  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
	  base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {
	    for (var i = 0; i < node.expressions.length; ++i) c(node.expressions[i], st, "Expression");
	  };
	  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
	    c(node.argument, st, "Expression");
	  };
	  base.BinaryExpression = base.AssignmentExpression = base.LogicalExpression = function (node, st, c) {
	    c(node.left, st, "Expression");
	    c(node.right, st, "Expression");
	  };
	  base.ConditionalExpression = function (node, st, c) {
	    c(node.test, st, "Expression");
	    c(node.consequent, st, "Expression");
	    c(node.alternate, st, "Expression");
	  };
	  base.NewExpression = base.CallExpression = function (node, st, c) {
	    c(node.callee, st, "Expression");
	    if (node.arguments) for (var i = 0; i < node.arguments.length; ++i) c(node.arguments[i], st, "Expression");
	  };
	  base.MemberExpression = function (node, st, c) {
	    c(node.object, st, "Expression");
	    if (node.computed) c(node.property, st, "Expression");
	  };
	  base.Identifier = base.Literal = base.ExportDeclaration = base.ImportDeclaration = ignore;

	  base.TaggedTemplateExpression = function (node, st, c) {
	    c(node.tag, st, "Expression");
	    c(node.quasi, st);
	  };
	  base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
	    if (node.superClass) c(node.superClass, st, "Expression");
	    for (var i = 0; i < node.body.body.length; i++) c(node.body.body[i], st);
	  };
	  base.MethodDefinition = base.Property = function (node, st, c) {
	    if (node.computed) c(node.key, st, "Expression");
	    c(node.value, st, "Expression");
	  };
	  base.ComprehensionExpression = function (node, st, c) {
	    for (var i = 0; i < node.blocks.length; i++) c(node.blocks[i].right, st, "Expression");
	    c(node.body, st, "Expression");
	  };

	  // NOTE: the stuff below is deprecated, and will be removed when 1.0 is released

	  // A custom walker that keeps track of the scope chain and the
	  // variables defined in it.
	  function makeScope(prev, isCatch) {
	    return { vars: Object.create(null), prev: prev, isCatch: isCatch };
	  }
	  function normalScope(scope) {
	    while (scope.isCatch) scope = scope.prev;
	    return scope;
	  }
	  exports.scopeVisitor = exports.make({
	    Function: function (node, scope, c) {
	      var inner = makeScope(scope);
	      for (var i = 0; i < node.params.length; ++i) inner.vars[node.params[i].name] = { type: "argument", node: node.params[i] };
	      if (node.id) {
	        var decl = node.type == "FunctionDeclaration";
	        (decl ? normalScope(scope) : inner).vars[node.id.name] = { type: decl ? "function" : "function name", node: node.id };
	      }
	      c(node.body, inner, "ScopeBody");
	    },
	    TryStatement: function (node, scope, c) {
	      c(node.block, scope, "Statement");
	      if (node.handler) {
	        var inner = makeScope(scope, true);
	        inner.vars[node.handler.param.name] = { type: "catch clause", node: node.handler.param };
	        c(node.handler.body, inner, "ScopeBody");
	      }
	      if (node.finalizer) c(node.finalizer, scope, "Statement");
	    },
	    VariableDeclaration: function (node, scope, c) {
	      var target = normalScope(scope);
	      for (var i = 0; i < node.declarations.length; ++i) {
	        var decl = node.declarations[i];
	        target.vars[decl.id.name] = { type: "var", node: decl.id };
	        if (decl.init) c(decl.init, scope, "Expression");
	      }
	    }
	  });
	});

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;
	const Ci = _require.Ci;

	const promise = __webpack_require__(6);

	var _require2 = __webpack_require__(55);

	const Spectrum = _require2.Spectrum;

	var _require3 = __webpack_require__(56);

	const CubicBezierWidget = _require3.CubicBezierWidget;

	var _require4 = __webpack_require__(58);

	const MdnDocsWidget = _require4.MdnDocsWidget;

	var _require5 = __webpack_require__(59);

	const CSSFilterEditorWidget = _require5.CSSFilterEditorWidget;

	const EventEmitter = __webpack_require__(7);

	var _require6 = __webpack_require__(63);

	const colorUtils = _require6.colorUtils;

	const Heritage = __webpack_require__(64);

	var _require7 = __webpack_require__(65);

	const Eyedropper = _require7.Eyedropper;

	const Editor = __webpack_require__(36);

	const beautify = __webpack_require__(66);

	var _require8 = __webpack_require__(9);

	const Services = _require8.Services;

	var _require9 = __webpack_require__(15);

	const XPCOMUtils = _require9.XPCOMUtils;

	var _require10 = __webpack_require__(60);

	const setNamedTimeout = _require10.setNamedTimeout;
	const clearNamedTimeout = _require10.clearNamedTimeout;

	var _require11 = __webpack_require__(70);

	const VariablesView = _require11.VariablesView;
	const escapeHTML = _require11.escapeHTML;

	var _require12 = __webpack_require__(85);

	const VariablesViewController = _require12.VariablesViewController;
	const StackFrameUtils = _require12.StackFrameUtils;

	var _require13 = __webpack_require__(38);

	const Task = _require13.Task;

	const XHTML_NS = "http://www.w3.org/1999/xhtml";
	const SPECTRUM_FRAME = "chrome://devtools/content/shared/widgets/spectrum-frame.xhtml";
	const CUBIC_BEZIER_FRAME = "chrome://devtools/content/shared/widgets/cubic-bezier-frame.xhtml";
	const MDN_DOCS_FRAME = "chrome://devtools/content/shared/widgets/mdn-docs-frame.xhtml";
	const FILTER_FRAME = "chrome://devtools/content/shared/widgets/filter-frame.xhtml";
	const ESCAPE_KEYCODE = Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE;
	const RETURN_KEYCODE = Ci.nsIDOMKeyEvent.DOM_VK_RETURN;
	const POPUP_EVENTS = ["shown", "hidden", "showing", "hiding"];

	/**
	 * Tooltip widget.
	 *
	 * This widget is intended at any tool that may need to show rich content in the
	 * form of floating panels.
	 * A common use case is image previewing in the CSS rule view, but more complex
	 * use cases may include color pickers, object inspection, etc...
	 *
	 * Tooltips are based on XUL (namely XUL arrow-type <panel>s), and therefore
	 * need a XUL Document to live in.
	 * This is pretty much the only requirement they have on their environment.
	 *
	 * The way to use a tooltip is simply by instantiating a tooltip yourself and
	 * attaching some content in it, or using one of the ready-made content types.
	 *
	 * A convenient `startTogglingOnHover` method may avoid having to register event
	 * handlers yourself if the tooltip has to be shown when hovering over a
	 * specific element or group of elements (which is usually the most common case)
	 */

	/**
	 * Container used for dealing with optional parameters.
	 *
	 * @param {Object} defaults
	 *        An object with all default options {p1: v1, p2: v2, ...}
	 * @param {Object} options
	 *        The actual values.
	 */
	function OptionsStore(defaults, options) {
	  this.defaults = defaults || {};
	  this.options = options || {};
	}

	OptionsStore.prototype = {
	  /**
	   * Get the value for a given option name.
	   * @return {Object} Returns the value for that option, coming either for the
	   *         actual values that have been set in the constructor, or from the
	   *         defaults if that options was not specified.
	   */
	  get: function (name) {
	    if (typeof this.options[name] !== "undefined") {
	      return this.options[name];
	    }
	    return this.defaults[name];
	  }
	};

	/**
	 * The low level structure of a tooltip is a XUL element (a <panel>).
	 */
	var PanelFactory = {
	  /**
	   * Get a new XUL panel instance.
	   * @param {XULDocument} doc
	   *        The XUL document to put that panel into
	   * @param {OptionsStore} options
	   *        An options store to get some configuration from
	   */
	  get: function (doc, options) {
	    // Create the tooltip
	    let panel = doc.createElement("panel");
	    panel.setAttribute("hidden", true);
	    panel.setAttribute("ignorekeys", true);
	    panel.setAttribute("animate", false);

	    panel.setAttribute("consumeoutsideclicks", options.get("consumeOutsideClick"));
	    panel.setAttribute("noautofocus", options.get("noAutoFocus"));
	    panel.setAttribute("type", "arrow");
	    panel.setAttribute("level", "top");

	    panel.setAttribute("class", "devtools-tooltip theme-tooltip-panel");
	    doc.querySelector("body").appendChild(panel);

	    return panel;
	  }
	};

	/**
	 * Tooltip class.
	 *
	 * Basic usage:
	 *   let t = new Tooltip(xulDoc);
	 *   t.content = someXulContent;
	 *   t.show();
	 *   t.hide();
	 *   t.destroy();
	 *
	 * Better usage:
	 *   let t = new Tooltip(xulDoc);
	 *   t.startTogglingOnHover(container, target => {
	 *     if (<condition based on target>) {
	 *       t.setImageContent("http://image.png");
	 *       return true;
	 *     }
	 *   });
	 *   t.destroy();
	 *
	 * @param {XULDocument} doc
	 *        The XUL document hosting this tooltip
	 * @param {Object} options
	 *        Optional options that give options to consumers:
	 *        - consumeOutsideClick {Boolean} Wether the first click outside of the
	 *        tooltip should close the tooltip and be consumed or not.
	 *        Defaults to false.
	 *        - closeOnKeys {Array} An array of key codes that should close the
	 *        tooltip. Defaults to [27] (escape key).
	 *        - closeOnEvents [{emitter: {Object}, event: {String},
	 *                          useCapture: {Boolean}}]
	 *        Provide an optional list of emitter objects and event names here to
	 *        trigger the closing of the tooltip when these events are fired by the
	 *        emitters. The emitter objects should either implement
	 *        on/off(event, cb) or addEventListener/removeEventListener(event, cb).
	 *        Defaults to [].
	 *        For instance, the following would close the tooltip whenever the
	 *        toolbox selects a new tool and when a DOM node gets scrolled:
	 *        new Tooltip(doc, {
	 *          closeOnEvents: [
	 *            {emitter: toolbox, event: "select"},
	 *            {emitter: myContainer, event: "scroll", useCapture: true}
	 *          ]
	 *        });
	 *        - noAutoFocus {Boolean} Should the focus automatically go to the panel
	 *        when it opens. Defaults to true.
	 *
	 * Fires these events:
	 * - showing : just before the tooltip shows
	 * - shown : when the tooltip is shown
	 * - hiding : just before the tooltip closes
	 * - hidden : when the tooltip gets hidden
	 * - keypress : when any key gets pressed, with keyCode
	 */
	function Tooltip(doc, options) {
	  var _this = this;

	  EventEmitter.decorate(this);

	  this.doc = doc;
	  this.options = new OptionsStore({
	    consumeOutsideClick: false,
	    closeOnKeys: [ESCAPE_KEYCODE],
	    noAutoFocus: true,
	    closeOnEvents: []
	  }, options);
	  this.panel = PanelFactory.get(doc, this.options);

	  // Used for namedTimeouts in the mouseover handling
	  this.uid = "tooltip-" + Date.now();

	  // Emit show/hide events when the panel does.
	  for (let eventName of POPUP_EVENTS) {
	    this["_onPopup" + eventName] = (function (name) {
	      return function (e) {
	        if (e.target === _this.panel) {
	          _this.emit(name);
	        }
	      };
	    })(eventName);
	    this.panel.addEventListener("popup" + eventName, this["_onPopup" + eventName], false);
	  }

	  // Listen to keypress events to close the tooltip if configured to do so
	  let win = this.doc.querySelector("body");
	  this._onKeyPress = function (event) {
	    if (_this.panel.hidden) {
	      return;
	    }

	    _this.emit("keypress", event.keyCode);
	    if (_this.options.get("closeOnKeys").indexOf(event.keyCode) !== -1 && _this.isShown()) {
	      event.stopPropagation();
	      _this.hide();
	    }
	  };
	  win.addEventListener("keypress", this._onKeyPress, false);

	  // Listen to custom emitters' events to close the tooltip
	  this.hide = this.hide.bind(this);
	  let closeOnEvents = this.options.get("closeOnEvents");
	  for (let _ref of closeOnEvents) {
	    let emitter = _ref.emitter;
	    let event = _ref.event;
	    let useCapture = _ref.useCapture;

	    for (let add of ["addEventListener", "on"]) {
	      if (add in emitter) {
	        emitter[add](event, this.hide, useCapture);
	        break;
	      }
	    }
	  }
	}

	module.exports.Tooltip = Tooltip;

	Tooltip.prototype = {
	  defaultPosition: "before_start",
	  // px
	  defaultOffsetX: 0,
	  // px
	  defaultOffsetY: 0,
	  // px
	  defaultShowDelay: 50,

	  /**
	   * Show the tooltip. It might be wise to append some content first if you
	   * don't want the tooltip to be empty. You may access the content of the
	   * tooltip by setting a XUL node to t.content.
	   * @param {node} anchor
	   *        Which node should the tooltip be shown on
	   * @param {string} position [optional]
	   *        Optional tooltip position. Defaults to before_start
	   *        https://developer.mozilla.org/en-US/docs/XUL/PopupGuide/Positioning
	   * @param {number} x, y [optional]
	   *        The left and top offset coordinates, in pixels.
	   */
	  show: function (anchor, position = this.defaultPosition, x = this.defaultOffsetX, y = this.defaultOffsetY) {
	    this.panel.hidden = false;
	    this.panel.openPopup(anchor, position, x, y);
	  },

	  /**
	   * Hide the tooltip
	   */
	  hide: function () {
	    this.panel.hidden = true;
	    // this.panel.hidePopup();
	  },

	  isShown: function () {
	    return this.panel && this.panel.state !== "closed" && this.panel.state !== "hiding";
	  },

	  setSize: function (width, height) {
	    this.panel.sizeTo(width, height);
	  },

	  /**
	   * Empty the tooltip's content
	   */
	  empty: function () {
	    while (this.panel.hasChildNodes()) {
	      this.panel.removeChild(this.panel.firstChild);
	    }
	  },

	  /**
	   * Gets this panel's visibility state.
	   * @return boolean
	   */
	  isHidden: function () {
	    return this.panel.state == "closed" || this.panel.state == "hiding";
	  },

	  /**
	   * Gets if this panel has any child nodes.
	   * @return boolean
	   */
	  isEmpty: function () {
	    return !this.panel.hasChildNodes();
	  },

	  /**
	   * Get rid of references and event listeners
	   */
	  destroy: function () {
	    this.hide();

	    for (let eventName of POPUP_EVENTS) {
	      this.panel.removeEventListener("popup" + eventName, this["_onPopup" + eventName], false);
	    }

	    let win = this.doc.querySelector("body");
	    win.removeEventListener("keypress", this._onKeyPress, false);

	    let closeOnEvents = this.options.get("closeOnEvents");
	    for (let _ref2 of closeOnEvents) {
	      let emitter = _ref2.emitter;
	      let event = _ref2.event;
	      let useCapture = _ref2.useCapture;

	      for (let remove of ["removeEventListener", "off"]) {
	        if (remove in emitter) {
	          emitter[remove](event, this.hide, useCapture);
	          break;
	        }
	      }
	    }

	    this.content = null;

	    if (this._basedNode) {
	      this.stopTogglingOnHover();
	    }

	    this.doc = null;

	    this.panel.remove();
	    this.panel = null;
	  },

	  /**
	   * Show/hide the tooltip when the mouse hovers over particular nodes.
	   *
	   * 2 Ways to make this work:
	   * - Provide a single node to attach the tooltip to, as the baseNode, and
	   *   omit the second targetNodeCb argument
	   * - Provide a baseNode that is the container of possibly numerous children
	   *   elements that may receive a tooltip. In this case, provide the second
	   *   targetNodeCb argument to decide wether or not a child should receive
	   *   a tooltip.
	   *
	   * This works by tracking mouse movements on a base container node (baseNode)
	   * and showing the tooltip when the mouse stops moving. The targetNodeCb
	   * callback is used to know whether or not the particular element being
	   * hovered over should indeed receive the tooltip. If you don't provide it
	   * it's equivalent to a function that always returns true.
	   *
	   * Note that if you call this function a second time, it will itself call
	   * stopTogglingOnHover before adding mouse tracking listeners again.
	   *
	   * @param {node} baseNode
	   *        The container for all target nodes
	   * @param {Function} targetNodeCb
	   *        A function that accepts a node argument and returns true or false
	   *        (or a promise that resolves or rejects) to signify if the tooltip
	   *        should be shown on that node or not.
	   *        If the promise rejects, it must reject `false` as value.
	   *        Any other value is going to be logged as unexpected error.
	   *        Additionally, the function receives a second argument which is the
	   *        tooltip instance itself, to be used to add/modify the content of the
	   *        tooltip if needed. If omitted, the tooltip will be shown everytime.
	   * @param {Number} showDelay
	   *        An optional delay that will be observed before showing the tooltip.
	   *        Defaults to this.defaultShowDelay.
	   */
	  startTogglingOnHover: function (baseNode, targetNodeCb, showDelay = this.defaultShowDelay) {
	    if (this._basedNode) {
	      this.stopTogglingOnHover();
	    }
	    if (!baseNode) {
	      // Calling tool is in the process of being destroyed.
	      return;
	    }

	    this._basedNode = baseNode;
	    this._showDelay = showDelay;
	    this._targetNodeCb = targetNodeCb || function () {
	      return true;
	    };

	    this._onBaseNodeMouseMove = this._onBaseNodeMouseMove.bind(this);
	    this._onBaseNodeMouseLeave = this._onBaseNodeMouseLeave.bind(this);

	    baseNode.addEventListener("mousemove", this._onBaseNodeMouseMove, false);
	    baseNode.addEventListener("mouseleave", this._onBaseNodeMouseLeave, false);
	  },

	  /**
	   * If the startTogglingOnHover function has been used previously, and you want
	   * to get rid of this behavior, then call this function to remove the mouse
	   * movement tracking
	   */
	  stopTogglingOnHover: function () {
	    clearNamedTimeout(this.uid);

	    if (!this._basedNode) {
	      return;
	    }

	    this._basedNode.removeEventListener("mousemove", this._onBaseNodeMouseMove, false);
	    this._basedNode.removeEventListener("mouseleave", this._onBaseNodeMouseLeave, false);

	    this._basedNode = null;
	    this._targetNodeCb = null;
	    this._lastHovered = null;
	  },

	  _onBaseNodeMouseMove: function (event) {
	    var _this2 = this;

	    if (event.target !== this._lastHovered) {
	      this.hide();
	      this._lastHovered = event.target;
	      setNamedTimeout(this.uid, this._showDelay, function () {
	        _this2.isValidHoverTarget(event.target).then(function (target) {
	          _this2.show(target);
	        }, function (reason) {
	          if (reason === false) {
	            // isValidHoverTarget rejects with false if the tooltip should
	            // not be shown. This can be safely ignored.
	            return;
	          }
	          // Report everything else. Reason might be error that should not be
	          // hidden.
	          console.error("isValidHoverTarget rejected with an unexpected reason:");
	          console.error(reason);
	        });
	      });
	    }
	  },

	  /**
	   * Is the given target DOMNode a valid node for toggling the tooltip on hover.
	   * This delegates to the user-defined _targetNodeCb callback.
	   * @return a promise that resolves or rejects depending if the tooltip should
	   * be shown or not. If it resolves, it does to the actual anchor to be used
	   */
	  isValidHoverTarget: function (target) {
	    // Execute the user-defined callback which should return either true/false
	    // or a promise that resolves or rejects
	    let res = this._targetNodeCb(target, this);

	    // The callback can additionally return a DOMNode to replace the anchor of
	    // the tooltip when shown
	    if (res && res.then) {
	      return res.then(function (arg) {
	        return arg instanceof Ci.nsIDOMNode ? arg : target;
	      });
	    }
	    let newTarget = res instanceof Ci.nsIDOMNode ? res : target;
	    return res ? promise.resolve(newTarget) : promise.reject(false);
	  },

	  _onBaseNodeMouseLeave: function () {
	    clearNamedTimeout(this.uid);
	    this._lastHovered = null;
	    this.hide();
	  },

	  /**
	   * Set the content of this tooltip. Will first empty the tooltip and then
	   * append the new content element.
	   * Consider using one of the set<type>Content() functions instead.
	   * @param {node} content
	   *        A node that can be appended in the tooltip XUL element
	   */
	  set content(content) {
	    if (this.content == content) {
	      return;
	    }

	    this.empty();
	    this.panel.removeAttribute("clamped-dimensions");
	    this.panel.removeAttribute("clamped-dimensions-no-min-height");
	    this.panel.removeAttribute("clamped-dimensions-no-max-or-min-height");
	    this.panel.removeAttribute("wide");

	    if (content) {
	      this.panel.appendChild(content);
	    }
	  },

	  get content() {
	    return this.panel.firstChild;
	  },

	  /**
	   * Sets some text as the content of this tooltip.
	   *
	   * @param {array} messages
	   *        A list of text messages.
	   * @param {string} messagesClass [optional]
	   *        A style class for the text messages.
	   * @param {string} containerClass [optional]
	   *        A style class for the text messages container.
	   * @param {boolean} isAlertTooltip [optional]
	   *        Pass true to add an alert image for your tooltip.
	   */
	  setTextContent: function ({
	    messages,
	    messagesClass,
	    containerClass,
	    isAlertTooltip
	  }, extraButtons = []) {
	    messagesClass = messagesClass || "default-tooltip-simple-text-colors";
	    containerClass = containerClass || "default-tooltip-simple-text-colors";

	    let vbox = this.doc.createElement("vbox");
	    vbox.className = "devtools-tooltip-simple-text-container " + containerClass;
	    vbox.setAttribute("flex", "1");

	    for (let text of messages) {
	      let description = this.doc.createElement("description");
	      description.setAttribute("flex", "1");
	      description.className = "devtools-tooltip-simple-text " + messagesClass;
	      description.textContent = text;
	      vbox.appendChild(description);
	    }

	    for (let _ref3 of extraButtons) {
	      let label = _ref3.label;
	      let className = _ref3.className;
	      let command = _ref3.command;

	      let button = this.doc.createElement("button");
	      button.className = className;
	      button.setAttribute("label", label);
	      button.addEventListener("command", command);
	      vbox.appendChild(button);
	    }

	    if (isAlertTooltip) {
	      let hbox = this.doc.createElement("hbox");
	      hbox.setAttribute("align", "start");

	      let alertImg = this.doc.createElement("image");
	      alertImg.className = "devtools-tooltip-alert-icon";
	      hbox.appendChild(alertImg);
	      hbox.appendChild(vbox);
	      this.content = hbox;
	    } else {
	      this.content = vbox;
	    }
	  },

	  /**
	   * Sets some event listener info as the content of this tooltip.
	   *
	   * @param {Object} (destructuring assignment)
	   *          @0 {array} eventListenerInfos
	   *             A list of event listeners.
	   *          @1 {toolbox} toolbox
	   *             Toolbox used to select debugger panel.
	   */
	  setEventContent: function ({ eventListenerInfos, toolbox }) {
	    new EventTooltip(this, eventListenerInfos, toolbox);
	  },

	  /**
	   * Fill the tooltip with a variables view, inspecting an object via its
	   * corresponding object actor, as specified in the remote debugging protocol.
	   *
	   * @param {object} objectActor
	   *        The value grip for the object actor.
	   * @param {object} viewOptions [optional]
	   *        Options for the variables view visualization.
	   * @param {object} controllerOptions [optional]
	   *        Options for the variables view controller.
	   * @param {object} relayEvents [optional]
	   *        A collection of events to listen on the variables view widget.
	   *        For example, { fetched: () => ... }
	   * @param {boolean} reuseCachedWidget [optional]
	   *        Pass false to instantiate a brand new widget for this variable.
	   *        Otherwise, if a variable was previously inspected, its widget
	   *        will be reused.
	   * @param {Toolbox} toolbox [optional]
	   *        Pass the instance of the current toolbox if you want the variables
	   *        view widget to allow highlighting and selection of DOM nodes
	   */
	  setVariableContent: function (objectActor, viewOptions = {}, controllerOptions = {}, relayEvents = {}, extraButtons = [], toolbox = null) {
	    let vbox = this.doc.createElement("vbox");
	    vbox.className = "devtools-tooltip-variables-view-box";
	    vbox.setAttribute("flex", "1");

	    let innerbox = this.doc.createElement("vbox");
	    innerbox.className = "devtools-tooltip-variables-view-innerbox";
	    innerbox.setAttribute("flex", "1");
	    vbox.appendChild(innerbox);

	    for (let _ref4 of extraButtons) {
	      let label = _ref4.label;
	      let className = _ref4.className;
	      let command = _ref4.command;

	      let button = this.doc.createElement("button");
	      button.className = className;
	      button.setAttribute("label", label);
	      button.addEventListener("command", command);
	      vbox.appendChild(button);
	    }

	    let widget = new VariablesView(innerbox, viewOptions);

	    // If a toolbox was provided, link it to the vview
	    if (toolbox) {
	      widget.toolbox = toolbox;
	    }

	    // Analyzing state history isn't useful with transient object inspectors.
	    widget.commitHierarchy = function () {};

	    for (let e in relayEvents) widget.on(e, relayEvents[e]);
	    VariablesViewController.attach(widget, controllerOptions);

	    // Some of the view options are allowed to change between uses.
	    widget.searchPlaceholder = viewOptions.searchPlaceholder;
	    widget.searchEnabled = viewOptions.searchEnabled;

	    // Use the object actor's grip to display it as a variable in the widget.
	    // The controller options are allowed to change between uses.
	    widget.controller.setSingleVariable({ objectActor: objectActor }, controllerOptions);

	    this.content = vbox;
	    this.panel.setAttribute("clamped-dimensions", "");
	  },

	  /**
	   * Uses the provided inspectorFront's getImageDataFromURL method to resolve
	   * the relative URL on the server-side, in the page context, and then sets the
	   * tooltip content with the resulting image just like |setImageContent| does.
	   * @return a promise that resolves when the image is shown in the tooltip or
	   * resolves when the broken image tooltip content is ready, but never rejects.
	   */
	  setRelativeImageContent: Task.async(function* (imageUrl, inspectorFront, maxDim) {
	    if (imageUrl.startsWith("data:")) {
	      // If the imageUrl already is a data-url, save ourselves a round-trip
	      this.setImageContent(imageUrl, { maxDim: maxDim });
	    } else if (inspectorFront) {
	      try {
	        var _ref5 = yield inspectorFront.getImageDataFromURL(imageUrl, maxDim);

	        let data = _ref5.data;
	        let size = _ref5.size;

	        size.maxDim = maxDim;
	        let str = yield data.string();
	        this.setImageContent(str, size);
	      } catch (e) {
	        this.setBrokenImageContent();
	      }
	    }
	  }),

	  /**
	   * Fill the tooltip with a message explaining the the image is missing
	   */
	  setBrokenImageContent: function () {
	    this.setTextContent({
	      messages: [l10n.strings.GetStringFromName("previewTooltip.image.brokenImage")]
	    });
	  },

	  /**
	   * Fill the tooltip with an image and add the image dimension at the bottom.
	   *
	   * Only use this for absolute URLs that can be queried from the devtools
	   * client-side. For relative URLs, use |setRelativeImageContent|.
	   *
	   * @param {string} imageUrl
	   *        The url to load the image from
	   * @param {Object} options
	   *        The following options are supported:
	   *        - resized : whether or not the image identified by imageUrl has been
	   *        resized before this function was called.
	   *        - naturalWidth/naturalHeight : the original size of the image before
	   *        it was resized, if if was resized before this function was called.
	   *        If not provided, will be measured on the loaded image.
	   *        - maxDim : if the image should be resized before being shown, pass
	   *        a number here.
	   *        - hideDimensionLabel : if the dimension label should be appended
	   *        after the image.
	   */
	  setImageContent: function (imageUrl, options = {}) {
	    var _this3 = this;

	    if (!imageUrl) {
	      return;
	    }

	    // Main container
	    let vbox = this.doc.createElement("vbox");
	    vbox.setAttribute("align", "center");

	    // Display the image
	    let image = this.doc.createElement("image");
	    image.setAttribute("src", imageUrl);
	    if (options.maxDim) {
	      image.style.maxWidth = options.maxDim + "px";
	      image.style.maxHeight = options.maxDim + "px";
	    }
	    vbox.appendChild(image);

	    if (!options.hideDimensionLabel) {
	      let label = this.doc.createElement("label");
	      label.classList.add("devtools-tooltip-caption");
	      label.classList.add("theme-comment");

	      if (options.naturalWidth && options.naturalHeight) {
	        label.textContent = this._getImageDimensionLabel(options.naturalWidth, options.naturalHeight);
	      } else {
	        // If no dimensions were provided, load the image to get them
	        label.textContent = l10n.strings.GetStringFromName("previewTooltip.image.brokenImage");
	        let imgObj = new this.doc.defaultView.Image();
	        imgObj.src = imageUrl;
	        imgObj.onload = function () {
	          imgObj.onload = null;
	          label.textContent = _this3._getImageDimensionLabel(imgObj.naturalWidth, imgObj.naturalHeight);
	        };
	      }

	      vbox.appendChild(label);
	    }

	    this.content = vbox;
	  },

	  _getImageDimensionLabel: function (w, h) {
	    return w + " \u00D7 " + h;
	  },

	  /**
	   * Load a document into an iframe, and set the iframe
	   * to be the tooltip's content.
	   *
	   * Used by tooltips that want to load their interface
	   * into an iframe from a URL.
	   *
	   * @param {string} width
	   *        Width of the iframe.
	   * @param {string} height
	   *        Height of the iframe.
	   * @param {string} url
	   *        URL of the document to load into the iframe.
	   *
	   * @return {promise} A promise which is resolved with
	   * the iframe.
	   *
	   * This function creates an iframe, loads the specified document
	   * into it, sets the tooltip's content to the iframe, and returns
	   * a promise.
	   *
	   * When the document is loaded, the function gets the content window
	   * and resolves the promise with the content window.
	   */
	  setIFrameContent: function ({ width, height }, url) {
	    let def = promise.defer();

	    // Create an iframe
	    let iframe = this.doc.createElementNS(XHTML_NS, "iframe");
	    iframe.setAttribute("transparent", true);
	    iframe.setAttribute("width", width);
	    iframe.setAttribute("height", height);
	    iframe.setAttribute("flex", "1");
	    iframe.setAttribute("class", "devtools-tooltip-iframe");

	    // Wait for the load to initialize the widget
	    function onLoad() {
	      iframe.removeEventListener("load", onLoad, true);
	      def.resolve(iframe);
	    }
	    iframe.addEventListener("load", onLoad, true);

	    // load the document from url into the iframe
	    iframe.setAttribute("src", url);

	    // Put the iframe in the tooltip
	    this.content = iframe;

	    return def.promise;
	  },

	  /**
	   * Fill the tooltip with a new instance of the spectrum color picker widget
	   * initialized with the given color, and return a promise that resolves to
	   * the instance of spectrum
	   */
	  setColorPickerContent: function (color) {
	    let dimensions = { width: "210", height: "216" };
	    let panel = this.panel;
	    return this.setIFrameContent(dimensions, SPECTRUM_FRAME).then(onLoaded);

	    function onLoaded(iframe) {
	      let win = iframe.contentWindow.wrappedJSObject;
	      let def = promise.defer();
	      let container = win.document.getElementById("spectrum");
	      let spectrum = new Spectrum(container, color);

	      function finalizeSpectrum() {
	        spectrum.show();
	        def.resolve(spectrum);
	      }

	      // Finalize spectrum's init when the tooltip becomes visible
	      if (panel.state == "open") {
	        finalizeSpectrum();
	      } else {
	        panel.addEventListener("popupshown", function shown() {
	          panel.removeEventListener("popupshown", shown, true);
	          finalizeSpectrum();
	        }, true);
	      }
	      return def.promise;
	    }
	  },

	  /**
	   * Fill the tooltip with a new instance of the cubic-bezier widget
	   * initialized with the given value, and return a promise that resolves to
	   * the instance of the widget
	   */
	  setCubicBezierContent: function (bezier) {
	    let dimensions = { width: "500", height: "360" };
	    let panel = this.panel;
	    return this.setIFrameContent(dimensions, CUBIC_BEZIER_FRAME).then(onLoaded);

	    function onLoaded(iframe) {
	      let win = iframe.contentWindow.wrappedJSObject;
	      let def = promise.defer();
	      let container = win.document.getElementById("container");
	      let widget = new CubicBezierWidget(container, bezier);

	      // Resolve to the widget instance whenever the popup becomes visible
	      if (panel.state == "open") {
	        def.resolve(widget);
	      } else {
	        panel.addEventListener("popupshown", function shown() {
	          panel.removeEventListener("popupshown", shown, true);
	          def.resolve(widget);
	        }, true);
	      }
	      return def.promise;
	    }
	  },

	  /**
	   * Fill the tooltip with a new instance of the CSSFilterEditorWidget
	   * widget initialized with the given filter value, and return a promise
	   * that resolves to the instance of the widget when ready.
	   */
	  setFilterContent: function (filter) {
	    let dimensions = { width: "500", height: "200" };
	    let panel = this.panel;

	    return this.setIFrameContent(dimensions, FILTER_FRAME).then(onLoaded);

	    function onLoaded(iframe) {
	      let win = iframe.contentWindow.wrappedJSObject;
	      let doc = win.document.documentElement;
	      let def = promise.defer();
	      let container = win.document.getElementById("container");
	      let widget = new CSSFilterEditorWidget(container, filter);

	      // Resolve to the widget instance whenever the popup becomes visible
	      if (panel.state === "open") {
	        def.resolve(widget);
	      } else {
	        panel.addEventListener("popupshown", function shown() {
	          panel.removeEventListener("popupshown", shown, true);
	          def.resolve(widget);
	        }, true);
	      }
	      return def.promise;
	    }
	  },

	  /**
	   * Set the content of the tooltip to display a font family preview.
	   * This is based on Lea Verou's Dablet.
	   * See https://github.com/LeaVerou/dabblet
	   * for more info.
	   * @param {String} font The font family value.
	   * @param {object} nodeFront
	   *        The NodeActor that will used to retrieve the dataURL for the font
	   *        family tooltip contents.
	   * @return A promise that resolves when the font tooltip content is ready, or
	   *         rejects if no font is provided
	   */
	  setFontFamilyContent: Task.async(function* (font, nodeFront) {
	    if (!font || !nodeFront) {
	      throw new Error("Missing font");
	    }

	    if (typeof nodeFront.getFontFamilyDataURL === "function") {
	      font = font.replace(/"/g, "'");
	      font = font.replace("!important", "");
	      font = font.trim();

	      let fillStyle = Services.prefs.getCharPref("devtools.theme") === "light" ? "black" : "white";

	      var _ref6 = yield nodeFront.getFontFamilyDataURL(font, fillStyle);

	      let data = _ref6.data;
	      let size = _ref6.size;

	      let str = yield data.string();
	      this.setImageContent(str, { hideDimensionLabel: true, maxDim: size });
	    }
	  }),

	  /**
	   * Set the content of this tooltip to the MDN docs widget.
	   *
	   * This is called when the tooltip is first constructed.
	   *
	   * @return {promise} A promise which is resolved with an MdnDocsWidget.
	   *
	   * It loads the tooltip's structure from a separate XHTML file
	   * into an iframe. When the iframe is loaded it constructs
	   * an MdnDocsWidget and passes that into resolve.
	   *
	   * The caller can use the MdnDocsWidget to update the tooltip's
	   * UI with new content each time the tooltip is shown.
	   */
	  setMdnDocsContent: function () {
	    let dimensions = { width: "410", height: "300" };
	    return this.setIFrameContent(dimensions, MDN_DOCS_FRAME).then(onLoaded);

	    function onLoaded(iframe) {
	      let win = iframe.contentWindow.wrappedJSObject;
	      // create an MdnDocsWidget, initializing it with the content document
	      let widget = new MdnDocsWidget(win.document);
	      return widget;
	    }
	  }
	};

	/**
	 * Base class for all (color, gradient, ...)-swatch based value editors inside
	 * tooltips
	 *
	 * @param {XULDocument} doc
	 */
	function SwatchBasedEditorTooltip(doc) {
	  var _this4 = this;

	  // Creating a tooltip instance
	  // This one will consume outside clicks as it makes more sense to let the user
	  // close the tooltip by clicking out
	  // It will also close on <escape> and <enter>
	  this.tooltip = new Tooltip(doc, {
	    consumeOutsideClick: true,
	    closeOnKeys: [ESCAPE_KEYCODE, RETURN_KEYCODE],
	    noAutoFocus: false
	  });

	  // By default, swatch-based editor tooltips revert value change on <esc> and
	  // commit value change on <enter>
	  this._onTooltipKeypress = function (event, code) {
	    if (code === ESCAPE_KEYCODE) {
	      _this4.revert();
	    } else if (code === RETURN_KEYCODE) {
	      _this4.commit();
	    }
	  };
	  this.tooltip.on("keypress", this._onTooltipKeypress);

	  // All target swatches are kept in a map, indexed by swatch DOM elements
	  this.swatches = new Map();

	  // When a swatch is clicked, and for as long as the tooltip is shown, the
	  // activeSwatch property will hold the reference to the swatch DOM element
	  // that was clicked
	  this.activeSwatch = null;

	  this._onSwatchClick = this._onSwatchClick.bind(this);
	}

	SwatchBasedEditorTooltip.prototype = {
	  show: function () {
	    var _this5 = this;

	    if (this.activeSwatch) {
	      this.tooltip.show(this.activeSwatch, "topcenter bottomleft");

	      // When the tooltip is closed by clicking outside the panel we want to
	      // commit any changes. Because the "hidden" event destroys the tooltip we
	      // need to do this before the tooltip is destroyed (in the "hiding"
	      // event).
	      this.tooltip.once("hiding", function () {
	        if (!_this5._reverted && !_this5.eyedropperOpen) {
	          _this5.commit();
	        }
	        _this5._reverted = false;
	      });

	      // Once the tooltip is hidden we need to clean up any remaining objects.
	      this.tooltip.once("hidden", function () {
	        if (!_this5.eyedropperOpen) {
	          _this5.activeSwatch = null;
	        }
	      });
	    }
	  },

	  hide: function () {
	    this.tooltip.hide();
	  },

	  /**
	   * Add a new swatch DOM element to the list of swatch elements this editor
	   * tooltip knows about. That means from now on, clicking on that swatch will
	   * toggle the editor.
	   *
	   * @param {node} swatchEl
	   *        The element to add
	   * @param {object} callbacks
	   *        Callbacks that will be executed when the editor wants to preview a
	   *        value change, or revert a change, or commit a change.
	   *        - onShow: will be called when one of the swatch tooltip is shown
	   *        - onPreview: will be called when one of the sub-classes calls
	   *        preview
	   *        - onRevert: will be called when the user ESCapes out of the tooltip
	   *        - onCommit: will be called when the user presses ENTER or clicks
	   *        outside the tooltip.
	   */
	  addSwatch: function (swatchEl, callbacks = {}) {
	    if (!callbacks.onShow) {
	      callbacks.onShow = function () {};
	    }
	    if (!callbacks.onPreview) {
	      callbacks.onPreview = function () {};
	    }
	    if (!callbacks.onRevert) {
	      callbacks.onRevert = function () {};
	    }
	    if (!callbacks.onCommit) {
	      callbacks.onCommit = function () {};
	    }

	    this.swatches.set(swatchEl, {
	      callbacks: callbacks
	    });
	    swatchEl.addEventListener("click", this._onSwatchClick, false);
	  },

	  removeSwatch: function (swatchEl) {
	    if (this.swatches.has(swatchEl)) {
	      if (this.activeSwatch === swatchEl) {
	        this.hide();
	        this.activeSwatch = null;
	      }
	      swatchEl.removeEventListener("click", this._onSwatchClick, false);
	      this.swatches.delete(swatchEl);
	    }
	  },

	  _onSwatchClick: function (event) {
	    let swatch = this.swatches.get(event.target);

	    if (event.shiftKey) {
	      event.stopPropagation();
	      return;
	    }
	    if (swatch) {
	      this.activeSwatch = event.target;
	      this.show();
	      swatch.callbacks.onShow();
	      event.stopPropagation();
	    }
	  },

	  /**
	   * Not called by this parent class, needs to be taken care of by sub-classes
	   */
	  preview: function (value) {
	    if (this.activeSwatch) {
	      let swatch = this.swatches.get(this.activeSwatch);
	      swatch.callbacks.onPreview(value);
	    }
	  },

	  /**
	   * This parent class only calls this on <esc> keypress
	   */
	  revert: function () {
	    if (this.activeSwatch) {
	      this._reverted = true;
	      let swatch = this.swatches.get(this.activeSwatch);
	      this.tooltip.once("hiding", function () {
	        swatch.callbacks.onRevert();
	      });
	    }
	  },

	  /**
	   * This parent class only calls this on <enter> keypress
	   */
	  commit: function () {
	    if (this.activeSwatch) {
	      let swatch = this.swatches.get(this.activeSwatch);
	      swatch.callbacks.onCommit();
	    }
	  },

	  destroy: function () {
	    this.swatches.clear();
	    this.activeSwatch = null;
	    this.tooltip.off("keypress", this._onTooltipKeypress);
	    this.tooltip.destroy();
	  }
	};

	/**
	 * The swatch color picker tooltip class is a specific class meant to be used
	 * along with output-parser's generated color swatches.
	 * It extends the parent SwatchBasedEditorTooltip class.
	 * It just wraps a standard Tooltip and sets its content with an instance of a
	 * color picker.
	 *
	 * @param {XULDocument} doc
	 */
	function SwatchColorPickerTooltip(doc) {
	  SwatchBasedEditorTooltip.call(this, doc);

	  // Creating a spectrum instance. this.spectrum will always be a promise that
	  // resolves to the spectrum instance
	  this.spectrum = this.tooltip.setColorPickerContent([0, 0, 0, 1]);
	  this._onSpectrumColorChange = this._onSpectrumColorChange.bind(this);
	  this._openEyeDropper = this._openEyeDropper.bind(this);
	}

	module.exports.SwatchColorPickerTooltip = SwatchColorPickerTooltip;

	SwatchColorPickerTooltip.prototype = Heritage.extend(SwatchBasedEditorTooltip.prototype, {
	  /**
	   * Overriding the SwatchBasedEditorTooltip.show function to set spectrum's
	   * color.
	   */
	  show: function () {
	    var _this6 = this;

	    // Call then parent class' show function
	    SwatchBasedEditorTooltip.prototype.show.call(this);
	    // Then set spectrum's color and listen to color changes to preview them
	    if (this.activeSwatch) {
	      this.currentSwatchColor = this.activeSwatch.nextSibling;
	      this._originalColor = this.currentSwatchColor.textContent;
	      let color = this.activeSwatch.style.backgroundColor;
	      this.spectrum.then(function (spectrum) {
	        spectrum.off("changed", _this6._onSpectrumColorChange);
	        spectrum.rgb = _this6._colorToRgba(color);
	        spectrum.on("changed", _this6._onSpectrumColorChange);
	        spectrum.updateUI();
	      });
	    }

	    let tooltipDoc = this.tooltip.content.contentDocument;
	    let eyeButton = tooltipDoc.querySelector("#eyedropper-button");
	    eyeButton.addEventListener("click", this._openEyeDropper);
	  },

	  _onSpectrumColorChange: function (event, rgba, cssColor) {
	    this._selectColor(cssColor);
	  },

	  _selectColor: function (color) {
	    if (this.activeSwatch) {
	      this.activeSwatch.style.backgroundColor = color;
	      this.activeSwatch.parentNode.dataset.color = color;

	      color = this._toDefaultType(color);
	      this.currentSwatchColor.textContent = color;
	      this.preview(color);

	      if (this.eyedropperOpen) {
	        this.commit();
	      }
	    }
	  },

	  _openEyeDropper: function () {
	    var _this7 = this;

	    let chromeWindow = this.tooltip.doc.defaultView.top;
	    let windowType = chromeWindow.document.documentElement.getAttribute("windowtype");
	    let toolboxWindow;
	    if (windowType != "navigator:browser") {
	      // this means the toolbox is in a seperate window. We need to make
	      // sure we'll be inspecting the browser window instead
	      toolboxWindow = chromeWindow;
	      chromeWindow = Services.wm.getMostRecentWindow("navigator:browser");
	      chromeWindow.focus();
	    }
	    let dropper = new Eyedropper(chromeWindow, { copyOnSelect: false,
	      context: "picker" });

	    dropper.once("select", function (event, color) {
	      if (toolboxWindow) {
	        toolboxWindow.focus();
	      }
	      _this7._selectColor(color);
	    });

	    dropper.once("destroy", function () {
	      _this7.eyedropperOpen = false;
	      _this7.activeSwatch = null;
	    });

	    dropper.open();
	    this.eyedropperOpen = true;

	    // close the colorpicker tooltip so that only the eyedropper is open.
	    this.hide();

	    this.tooltip.emit("eyedropper-opened", dropper);
	  },

	  _colorToRgba: function (color) {
	    color = new colorUtils.CssColor(color);
	    let rgba = color._getRGBATuple();
	    return [rgba.r, rgba.g, rgba.b, rgba.a];
	  },

	  _toDefaultType: function (color) {
	    let colorObj = new colorUtils.CssColor(color);
	    colorObj.setAuthoredUnitFromColor(this._originalColor);
	    return colorObj.toString();
	  },

	  destroy: function () {
	    var _this8 = this;

	    SwatchBasedEditorTooltip.prototype.destroy.call(this);
	    this.currentSwatchColor = null;
	    this.spectrum.then(function (spectrum) {
	      spectrum.off("changed", _this8._onSpectrumColorChange);
	      spectrum.destroy();
	    });
	  }
	});

	function EventTooltip(tooltip, eventListenerInfos, toolbox) {
	  this._tooltip = tooltip;
	  this._eventListenerInfos = eventListenerInfos;
	  this._toolbox = toolbox;
	  this._tooltip.eventEditors = new WeakMap();

	  this._headerClicked = this._headerClicked.bind(this);
	  this._debugClicked = this._debugClicked.bind(this);
	  this.destroy = this.destroy.bind(this);

	  this._init();
	}

	EventTooltip.prototype = {
	  _init: function () {
	    var _this9 = this;

	    let config = {
	      mode: Editor.modes.js,
	      lineNumbers: false,
	      lineWrapping: false,
	      readOnly: true,
	      styleActiveLine: true,
	      extraKeys: {},
	      theme: "mozilla markup-view"
	    };

	    let doc = this._tooltip.doc;
	    let container = doc.createElement("vbox");
	    container.setAttribute("id", "devtools-tooltip-events-container");

	    for (let listener of this._eventListenerInfos) {
	      let phase = listener.capturing ? "Capturing" : "Bubbling";
	      let level = listener.DOM0 ? "DOM0" : "DOM2";

	      // Header
	      let header = doc.createElement("hbox");
	      header.className = "event-header devtools-toolbar";
	      container.appendChild(header);

	      if (!listener.hide.debugger) {
	        let debuggerIcon = doc.createElement("image");
	        debuggerIcon.className = "event-tooltip-debugger-icon";
	        debuggerIcon.setAttribute("src", "chrome://devtools/skin/images/tool-debugger.svg");
	        let openInDebugger = l10n.strings.GetStringFromName("eventsTooltip.openInDebugger");
	        debuggerIcon.setAttribute("tooltiptext", openInDebugger);
	        header.appendChild(debuggerIcon);
	      }

	      if (!listener.hide.type) {
	        let eventTypeLabel = doc.createElement("label");
	        eventTypeLabel.className = "event-tooltip-event-type";
	        eventTypeLabel.setAttribute("value", listener.type);
	        eventTypeLabel.setAttribute("tooltiptext", listener.type);
	        header.appendChild(eventTypeLabel);
	      }

	      if (!listener.hide.filename) {
	        let filename = doc.createElement("label");
	        filename.className = "event-tooltip-filename devtools-monospace";
	        filename.setAttribute("value", listener.origin);
	        filename.setAttribute("tooltiptext", listener.origin);
	        filename.setAttribute("crop", "left");
	        header.appendChild(filename);
	      }

	      let attributesContainer = doc.createElement("hbox");
	      attributesContainer.setAttribute("class", "event-tooltip-attributes-container");
	      header.appendChild(attributesContainer);

	      if (!listener.hide.capturing) {
	        let attributesBox = doc.createElement("box");
	        attributesBox.setAttribute("class", "event-tooltip-attributes-box");
	        attributesContainer.appendChild(attributesBox);

	        let capturing = doc.createElement("label");
	        capturing.className = "event-tooltip-attributes";
	        capturing.setAttribute("value", phase);
	        capturing.setAttribute("tooltiptext", phase);
	        attributesBox.appendChild(capturing);
	      }

	      if (listener.tags) {
	        for (let tag of listener.tags.split(",")) {
	          let attributesBox = doc.createElement("box");
	          attributesBox.setAttribute("class", "event-tooltip-attributes-box");
	          attributesContainer.appendChild(attributesBox);

	          let tagBox = doc.createElement("label");
	          tagBox.className = "event-tooltip-attributes";
	          tagBox.setAttribute("value", tag);
	          tagBox.setAttribute("tooltiptext", tag);
	          attributesBox.appendChild(tagBox);
	        }
	      }

	      if (!listener.hide.dom0) {
	        let attributesBox = doc.createElement("box");
	        attributesBox.setAttribute("class", "event-tooltip-attributes-box");
	        attributesContainer.appendChild(attributesBox);

	        let dom0 = doc.createElement("label");
	        dom0.className = "event-tooltip-attributes";
	        dom0.setAttribute("value", level);
	        dom0.setAttribute("tooltiptext", level);
	        attributesBox.appendChild(dom0);
	      }

	      // Content
	      let content = doc.createElement("box");
	      let editor = new Editor(config);
	      this._tooltip.eventEditors.set(content, {
	        editor: editor,
	        handler: listener.handler,
	        searchString: listener.searchString,
	        uri: listener.origin,
	        dom0: listener.DOM0,
	        appended: false
	      });

	      content.className = "event-tooltip-content-box";
	      container.appendChild(content);

	      this._addContentListeners(header);
	    }

	    this._tooltip.content = container;
	    this._tooltip.panel.setAttribute("clamped-dimensions-no-max-or-min-height", "");
	    this._tooltip.panel.setAttribute("wide", "");

	    this._tooltip.panel.addEventListener("popuphiding", function () {
	      _this9.destroy(container);
	    }, false);
	  },

	  _addContentListeners: function (header) {
	    header.addEventListener("click", this._headerClicked);
	  },

	  _headerClicked: function (event) {
	    var _this10 = this;

	    if (event.target.classList.contains("event-tooltip-debugger-icon")) {
	      this._debugClicked(event);
	      event.stopPropagation();
	      return;
	    }

	    let doc = this._tooltip.doc;
	    let header = event.currentTarget;
	    let content = header.nextElementSibling;

	    if (content.hasAttribute("open")) {
	      content.removeAttribute("open");
	    } else {
	      let contentNodes = doc.querySelectorAll(".event-tooltip-content-box");

	      for (let node of contentNodes) {
	        if (node !== content) {
	          node.removeAttribute("open");
	        }
	      }

	      content.setAttribute("open", "");

	      let eventEditors = this._tooltip.eventEditors.get(content);

	      if (eventEditors.appended) {
	        return;
	      }

	      let editor = eventEditors.editor;
	      let handler = eventEditors.handler;

	      let iframe = doc.createElement("iframe");
	      iframe.setAttribute("style", "width:100%;");

	      editor.appendTo(content, iframe).then(function () {
	        let tidied = beautify.js(handler, { indent_size: 2 });

	        editor.setText(tidied);

	        eventEditors.appended = true;

	        let container = header.parentElement.getBoundingClientRect();
	        if (header.getBoundingClientRect().top < container.top) {
	          header.scrollIntoView(true);
	        } else if (content.getBoundingClientRect().bottom > container.bottom) {
	          content.scrollIntoView(false);
	        }

	        _this10._tooltip.emit("event-tooltip-ready");
	      });
	    }
	  },

	  _debugClicked: function (event) {
	    let header = event.currentTarget;
	    let content = header.nextElementSibling;

	    var _tooltip$eventEditors = this._tooltip.eventEditors.get(content);

	    let uri = _tooltip$eventEditors.uri;
	    let searchString = _tooltip$eventEditors.searchString;
	    let dom0 = _tooltip$eventEditors.dom0;

	    if (uri && uri !== "?") {
	      // Save a copy of toolbox as it will be set to null when we hide the
	      // tooltip.
	      let toolbox = this._toolbox;

	      this._tooltip.hide();

	      uri = uri.replace(/"/g, "");

	      let showSource = function ({ DebuggerView }) {
	        let matches = uri.match(/(.*):(\d+$)/);
	        let line = 1;

	        if (matches) {
	          uri = matches[1];
	          line = matches[2];
	        }

	        let item = DebuggerView.Sources.getItemForAttachment(function (a) {
	          return a.source.url === uri;
	        });
	        if (item) {
	          let actor = item.attachment.source.actor;
	          DebuggerView.setEditorLocation(actor, line, { noDebug: true }).then(function () {
	            if (dom0) {
	              let text = DebuggerView.editor.getText();
	              let index = text.indexOf(searchString);
	              let lastIndex = text.lastIndexOf(searchString);

	              // To avoid confusion we only search for DOM0 event handlers when
	              // there is only one possible match in the file.
	              if (index !== -1 && index === lastIndex) {
	                text = text.substr(0, index);
	                let newlineMatches = text.match(/\n/g);

	                if (newlineMatches) {
	                  DebuggerView.editor.setCursor({
	                    line: newlineMatches.length
	                  });
	                }
	              }
	            }
	          });
	        }
	      };

	      let debuggerAlreadyOpen = toolbox.getPanel("jsdebugger");
	      toolbox.selectTool("jsdebugger").then(function ({ panelWin: dbg }) {
	        if (debuggerAlreadyOpen) {
	          showSource(dbg);
	        } else {
	          dbg.once(dbg.EVENTS.SOURCES_ADDED, function () {
	            return showSource(dbg);
	          });
	        }
	      });
	    }
	  },

	  destroy: function (container) {
	    if (this._tooltip) {
	      this._tooltip.panel.removeEventListener("popuphiding", this.destroy, false);

	      let boxes = container.querySelectorAll(".event-tooltip-content-box");

	      for (let box of boxes) {
	        var _tooltip$eventEditors2 = this._tooltip.eventEditors.get(box);

	        let editor = _tooltip$eventEditors2.editor;

	        editor.destroy();
	      }

	      this._tooltip.eventEditors.clear();
	      this._tooltip.eventEditors = null;
	    }

	    let headerNodes = container.querySelectorAll(".event-header");

	    for (let node of headerNodes) {
	      node.removeEventListener("click", this._headerClicked);
	    }

	    let sourceNodes = container.querySelectorAll(".event-tooltip-debugger-icon");
	    for (let node of sourceNodes) {
	      node.removeEventListener("click", this._debugClicked);
	    }

	    this._eventListenerInfos = this._toolbox = this._tooltip = null;
	  }
	};

	/**
	 * The swatch cubic-bezier tooltip class is a specific class meant to be used
	 * along with rule-view's generated cubic-bezier swatches.
	 * It extends the parent SwatchBasedEditorTooltip class.
	 * It just wraps a standard Tooltip and sets its content with an instance of a
	 * CubicBezierWidget.
	 *
	 * @param {XULDocument} doc
	 */
	function SwatchCubicBezierTooltip(doc) {
	  SwatchBasedEditorTooltip.call(this, doc);

	  // Creating a cubic-bezier instance.
	  // this.widget will always be a promise that resolves to the widget instance
	  this.widget = this.tooltip.setCubicBezierContent([0, 0, 1, 1]);
	  this._onUpdate = this._onUpdate.bind(this);
	}

	module.exports.SwatchCubicBezierTooltip = SwatchCubicBezierTooltip;

	SwatchCubicBezierTooltip.prototype = Heritage.extend(SwatchBasedEditorTooltip.prototype, {
	  /**
	   * Overriding the SwatchBasedEditorTooltip.show function to set the cubic
	   * bezier curve in the widget
	   */
	  show: function () {
	    var _this11 = this;

	    // Call the parent class' show function
	    SwatchBasedEditorTooltip.prototype.show.call(this);
	    // Then set the curve and listen to changes to preview them
	    if (this.activeSwatch) {
	      this.currentBezierValue = this.activeSwatch.nextSibling;
	      this.widget.then(function (widget) {
	        widget.off("updated", _this11._onUpdate);
	        widget.cssCubicBezierValue = _this11.currentBezierValue.textContent;
	        widget.on("updated", _this11._onUpdate);
	      });
	    }
	  },

	  _onUpdate: function (event, bezier) {
	    if (!this.activeSwatch) {
	      return;
	    }

	    this.currentBezierValue.textContent = bezier + "";
	    this.preview(bezier + "");
	  },

	  destroy: function () {
	    var _this12 = this;

	    SwatchBasedEditorTooltip.prototype.destroy.call(this);
	    this.currentBezierValue = null;
	    this.widget.then(function (widget) {
	      widget.off("updated", _this12._onUpdate);
	      widget.destroy();
	    });
	  }
	});

	/**
	 * Tooltip for displaying docs for CSS properties from MDN.
	 *
	 * @param {XULDocument} doc
	 */
	function CssDocsTooltip(doc) {
	  this.tooltip = new Tooltip(doc, {
	    consumeOutsideClick: true,
	    closeOnKeys: [ESCAPE_KEYCODE, RETURN_KEYCODE],
	    noAutoFocus: false
	  });
	  this.widget = this.tooltip.setMdnDocsContent();
	}

	module.exports.CssDocsTooltip = CssDocsTooltip;

	CssDocsTooltip.prototype = {
	  /**
	   * Load CSS docs for the given property,
	   * then display the tooltip.
	   */
	  show: function (anchor, propertyName) {
	    function loadCssDocs(widget) {
	      return widget.loadCssDocs(propertyName);
	    }

	    this.widget.then(loadCssDocs);
	    this.tooltip.show(anchor, "topcenter bottomleft");
	  },

	  hide: function () {
	    this.tooltip.hide();
	  },

	  destroy: function () {
	    this.tooltip.destroy();
	  }
	};

	/**
	 * The swatch-based css filter tooltip class is a specific class meant to be
	 * used along with rule-view's generated css filter swatches.
	 * It extends the parent SwatchBasedEditorTooltip class.
	 * It just wraps a standard Tooltip and sets its content with an instance of a
	 * CSSFilterEditorWidget.
	 *
	 * @param {XULDocument} doc
	 */
	function SwatchFilterTooltip(doc) {
	  SwatchBasedEditorTooltip.call(this, doc);

	  // Creating a filter editor instance.
	  // this.widget will always be a promise that resolves to the widget instance
	  this.widget = this.tooltip.setFilterContent("none");
	  this._onUpdate = this._onUpdate.bind(this);
	}

	exports.SwatchFilterTooltip = SwatchFilterTooltip;

	SwatchFilterTooltip.prototype = Heritage.extend(SwatchBasedEditorTooltip.prototype, {
	  show: function () {
	    var _this13 = this;

	    // Call the parent class' show function
	    SwatchBasedEditorTooltip.prototype.show.call(this);
	    // Then set the filter value and listen to changes to preview them
	    if (this.activeSwatch) {
	      this.currentFilterValue = this.activeSwatch.nextSibling;
	      this.widget.then(function (widget) {
	        widget.off("updated", _this13._onUpdate);
	        widget.on("updated", _this13._onUpdate);
	        widget.setCssValue(_this13.currentFilterValue.textContent);
	        widget.render();
	      });
	    }
	  },

	  _onUpdate: function (event, filters) {
	    if (!this.activeSwatch) {
	      return;
	    }

	    // Remove the old children and reparse the property value to
	    // recompute them.
	    while (this.currentFilterValue.firstChild) {
	      this.currentFilterValue.firstChild.remove();
	    }
	    let node = this._parser.parseCssProperty("filter", filters, this._options);
	    this.currentFilterValue.appendChild(node);

	    this.preview();
	  },

	  destroy: function () {
	    var _this14 = this;

	    SwatchBasedEditorTooltip.prototype.destroy.call(this);
	    this.currentFilterValue = null;
	    this.widget.then(function (widget) {
	      widget.off("updated", _this14._onUpdate);
	      widget.destroy();
	    });
	  },

	  /**
	   * Like SwatchBasedEditorTooltip.addSwatch, but accepts a parser object
	   * to use when previewing the updated property value.
	   *
	   * @param {node} swatchEl
	   *        @see SwatchBasedEditorTooltip.addSwatch
	   * @param {object} callbacks
	   *        @see SwatchBasedEditorTooltip.addSwatch
	   * @param {object} parser
	   *        A parser object; @see OutputParser object
	   * @param {object} options
	   *        options to pass to the output parser, with
	   *          the option |filterSwatch| set.
	   */
	  addSwatch: function (swatchEl, callbacks, parser, options) {
	    SwatchBasedEditorTooltip.prototype.addSwatch.call(this, swatchEl, callbacks);
	    this._parser = parser;
	    this._options = options;
	  }
	});

	/**
	 * L10N utility class
	 */
	function L10N() {}
	L10N.prototype = {};

	var l10n = new L10N();

	loader.lazyGetter(L10N.prototype, "strings", function () {
	  return Services.strings.createBundle("chrome://devtools/locale/inspector.properties");
	});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const EventEmitter = __webpack_require__(7);

	/**
	 * Spectrum creates a color picker widget in any container you give it.
	 *
	 * Simple usage example:
	 *
	 * const {Spectrum} = require("devtools/client/shared/widgets/Spectrum");
	 * let s = new Spectrum(containerElement, [255, 126, 255, 1]);
	 * s.on("changed", (event, rgba, color) => {
	 *   console.log("rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + rgba[3] + ")");
	 * });
	 * s.show();
	 * s.destroy();
	 *
	 * Note that the color picker is hidden by default and you need to call show to
	 * make it appear. This 2 stages initialization helps in cases you are creating
	 * the color picker in a parent element that hasn't been appended anywhere yet
	 * or that is hidden. Calling show() when the parent element is appended and
	 * visible will allow spectrum to correctly initialize its various parts.
	 *
	 * Fires the following events:
	 * - changed : When the user changes the current color
	 */
	function Spectrum(parentEl, rgb) {
	  EventEmitter.decorate(this);

	  this.element = parentEl.ownerDocument.createElement('div');
	  this.parentEl = parentEl;

	  this.element.className = "spectrum-container";
	  this.element.innerHTML = ["<div class='spectrum-top'>", "<div class='spectrum-fill'></div>", "<div class='spectrum-top-inner'>", "<div class='spectrum-color spectrum-box'>", "<div class='spectrum-sat'>", "<div class='spectrum-val'>", "<div class='spectrum-dragger'></div>", "</div>", "</div>", "</div>", "<div class='spectrum-hue spectrum-box'>", "<div class='spectrum-slider spectrum-slider-control'></div>", "</div>", "</div>", "</div>", "<div class='spectrum-alpha spectrum-checker spectrum-box'>", "<div class='spectrum-alpha-inner'>", "<div class='spectrum-alpha-handle spectrum-slider-control'></div>", "</div>", "</div>"].join("");

	  this.onElementClick = this.onElementClick.bind(this);
	  this.element.addEventListener("click", this.onElementClick, false);

	  this.parentEl.appendChild(this.element);

	  this.slider = this.element.querySelector(".spectrum-hue");
	  this.slideHelper = this.element.querySelector(".spectrum-slider");
	  Spectrum.draggable(this.slider, this.onSliderMove.bind(this));

	  this.dragger = this.element.querySelector(".spectrum-color");
	  this.dragHelper = this.element.querySelector(".spectrum-dragger");
	  Spectrum.draggable(this.dragger, this.onDraggerMove.bind(this));

	  this.alphaSlider = this.element.querySelector(".spectrum-alpha");
	  this.alphaSliderInner = this.element.querySelector(".spectrum-alpha-inner");
	  this.alphaSliderHelper = this.element.querySelector(".spectrum-alpha-handle");
	  Spectrum.draggable(this.alphaSliderInner, this.onAlphaSliderMove.bind(this));

	  if (rgb) {
	    this.rgb = rgb;
	    this.updateUI();
	  }
	}

	module.exports.Spectrum = Spectrum;

	Spectrum.hsvToRgb = function (h, s, v, a) {
	  let r, g, b;

	  let i = Math.floor(h * 6);
	  let f = h * 6 - i;
	  let p = v * (1 - s);
	  let q = v * (1 - f * s);
	  let t = v * (1 - (1 - f) * s);

	  switch (i % 6) {
	    case 0:
	      r = v, g = t, b = p;break;
	    case 1:
	      r = q, g = v, b = p;break;
	    case 2:
	      r = p, g = v, b = t;break;
	    case 3:
	      r = p, g = q, b = v;break;
	    case 4:
	      r = t, g = p, b = v;break;
	    case 5:
	      r = v, g = p, b = q;break;
	  }

	  return [r * 255, g * 255, b * 255, a];
	};

	Spectrum.rgbToHsv = function (r, g, b, a) {
	  r = r / 255;
	  g = g / 255;
	  b = b / 255;

	  let max = Math.max(r, g, b),
	      min = Math.min(r, g, b);
	  let h,
	      s,
	      v = max;

	  let d = max - min;
	  s = max == 0 ? 0 : d / max;

	  if (max == min) {
	    h = 0; // achromatic
	  } else {
	      switch (max) {
	        case r:
	          h = (g - b) / d + (g < b ? 6 : 0);break;
	        case g:
	          h = (b - r) / d + 2;break;
	        case b:
	          h = (r - g) / d + 4;break;
	      }
	      h /= 6;
	    }
	  return [h, s, v, a];
	};

	Spectrum.getOffset = function (el) {
	  let curleft = 0,
	      curtop = 0;
	  if (el.offsetParent) {
	    while (el) {
	      curleft += el.offsetLeft;
	      curtop += el.offsetTop;
	      el = el.offsetParent;
	    }
	  }
	  return {
	    left: curleft,
	    top: curtop
	  };
	};

	Spectrum.draggable = function (element, onmove, onstart, onstop) {
	  onmove = onmove || function () {};
	  onstart = onstart || function () {};
	  onstop = onstop || function () {};

	  let doc = element.ownerDocument;
	  let dragging = false;
	  let offset = {};
	  let maxHeight = 0;
	  let maxWidth = 0;

	  function prevent(e) {
	    e.stopPropagation();
	    e.preventDefault();
	  }

	  function move(e) {
	    if (dragging) {
	      if (e.buttons === 0) {
	        // The button is no longer pressed but we did not get a mouseup event.
	        return stop();
	      }
	      let pageX = e.pageX;
	      let pageY = e.pageY;

	      let dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
	      let dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));

	      onmove.apply(element, [dragX, dragY]);
	    }
	  }

	  function start(e) {
	    let rightclick = e.which === 3;

	    if (!rightclick && !dragging) {
	      if (onstart.apply(element, arguments) !== false) {
	        dragging = true;
	        maxHeight = element.offsetHeight;
	        maxWidth = element.offsetWidth;

	        offset = Spectrum.getOffset(element);

	        move(e);

	        doc.addEventListener("selectstart", prevent, false);
	        doc.addEventListener("dragstart", prevent, false);
	        doc.addEventListener("mousemove", move, false);
	        doc.addEventListener("mouseup", stop, false);

	        prevent(e);
	      }
	    }
	  }

	  function stop() {
	    if (dragging) {
	      doc.removeEventListener("selectstart", prevent, false);
	      doc.removeEventListener("dragstart", prevent, false);
	      doc.removeEventListener("mousemove", move, false);
	      doc.removeEventListener("mouseup", stop, false);
	      onstop.apply(element, arguments);
	    }
	    dragging = false;
	  }

	  element.addEventListener("mousedown", start, false);
	};

	Spectrum.prototype = {
	  set rgb(color) {
	    this.hsv = Spectrum.rgbToHsv(color[0], color[1], color[2], color[3]);
	  },

	  get rgb() {
	    let rgb = Spectrum.hsvToRgb(this.hsv[0], this.hsv[1], this.hsv[2], this.hsv[3]);
	    return [Math.round(rgb[0]), Math.round(rgb[1]), Math.round(rgb[2]), Math.round(rgb[3] * 100) / 100];
	  },

	  get rgbNoSatVal() {
	    let rgb = Spectrum.hsvToRgb(this.hsv[0], 1, 1);
	    return [Math.round(rgb[0]), Math.round(rgb[1]), Math.round(rgb[2]), rgb[3]];
	  },

	  get rgbCssString() {
	    let rgb = this.rgb;
	    return "rgba(" + rgb[0] + ", " + rgb[1] + ", " + rgb[2] + ", " + rgb[3] + ")";
	  },

	  show: function () {
	    this.element.classList.add('spectrum-show');

	    this.slideHeight = this.slider.offsetHeight;
	    this.dragWidth = this.dragger.offsetWidth;
	    this.dragHeight = this.dragger.offsetHeight;
	    this.dragHelperHeight = this.dragHelper.offsetHeight;
	    this.slideHelperHeight = this.slideHelper.offsetHeight;
	    this.alphaSliderWidth = this.alphaSliderInner.offsetWidth;
	    this.alphaSliderHelperWidth = this.alphaSliderHelper.offsetWidth;

	    this.updateUI();
	  },

	  onElementClick: function (e) {
	    e.stopPropagation();
	  },

	  onSliderMove: function (dragX, dragY) {
	    this.hsv[0] = dragY / this.slideHeight;
	    this.updateUI();
	    this.onChange();
	  },

	  onDraggerMove: function (dragX, dragY) {
	    this.hsv[1] = dragX / this.dragWidth;
	    this.hsv[2] = (this.dragHeight - dragY) / this.dragHeight;
	    this.updateUI();
	    this.onChange();
	  },

	  onAlphaSliderMove: function (dragX, dragY) {
	    this.hsv[3] = dragX / this.alphaSliderWidth;
	    this.updateUI();
	    this.onChange();
	  },

	  onChange: function () {
	    this.emit("changed", this.rgb, this.rgbCssString);
	  },

	  updateHelperLocations: function () {
	    // If the UI hasn't been shown yet then none of the dimensions will be correct
	    if (!this.element.classList.contains('spectrum-show')) return;

	    let h = this.hsv[0];
	    let s = this.hsv[1];
	    let v = this.hsv[2];

	    // Placing the color dragger
	    let dragX = s * this.dragWidth;
	    let dragY = this.dragHeight - v * this.dragHeight;
	    let helperDim = this.dragHelperHeight / 2;

	    dragX = Math.max(-helperDim, Math.min(this.dragWidth - helperDim, dragX - helperDim));
	    dragY = Math.max(-helperDim, Math.min(this.dragHeight - helperDim, dragY - helperDim));

	    this.dragHelper.style.top = dragY + "px";
	    this.dragHelper.style.left = dragX + "px";

	    // Placing the hue slider
	    let slideY = h * this.slideHeight - this.slideHelperHeight / 2;
	    this.slideHelper.style.top = slideY + "px";

	    // Placing the alpha slider
	    let alphaSliderX = this.hsv[3] * this.alphaSliderWidth - this.alphaSliderHelperWidth / 2;
	    this.alphaSliderHelper.style.left = alphaSliderX + "px";
	  },

	  updateUI: function () {
	    this.updateHelperLocations();

	    let rgb = this.rgb;
	    let rgbNoSatVal = this.rgbNoSatVal;

	    let flatColor = "rgb(" + rgbNoSatVal[0] + ", " + rgbNoSatVal[1] + ", " + rgbNoSatVal[2] + ")";
	    let fullColor = "rgba(" + rgb[0] + ", " + rgb[1] + ", " + rgb[2] + ", " + rgb[3] + ")";

	    this.dragger.style.backgroundColor = flatColor;

	    var rgbNoAlpha = "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
	    var rgbAlpha0 = "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ", 0)";
	    var alphaGradient = "linear-gradient(to right, " + rgbAlpha0 + ", " + rgbNoAlpha + ")";
	    this.alphaSliderInner.style.background = alphaGradient;
	  },

	  destroy: function () {
	    this.element.removeEventListener("click", this.onElementClick, false);

	    this.parentEl.removeChild(this.element);

	    this.slider = null;
	    this.dragger = null;
	    this.alphaSlider = this.alphaSliderInner = this.alphaSliderHelper = null;
	    this.parentEl = null;
	    this.element = null;
	  }
	};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013 Lea Verou. All rights reserved.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a
	 * copy of this software and associated documentation files (the "Software"),
	 * to deal in the Software without restriction, including without limitation
	 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
	 * and/or sell copies of the Software, and to permit persons to whom the
	 * Software is furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	 * DEALINGS IN THE SOFTWARE.
	 */

	// Based on www.cubic-bezier.com by Lea Verou
	// See https://github.com/LeaVerou/cubic-bezier

	"use strict";

	const EventEmitter = __webpack_require__(7);

	var _require = __webpack_require__(57);

	const PREDEFINED = _require.PREDEFINED;
	const PRESETS = _require.PRESETS;
	const DEFAULT_PRESET_CATEGORY = _require.DEFAULT_PRESET_CATEGORY;

	var _require2 = __webpack_require__(1);

	const Cc = _require2.Cc;
	const Ci = _require2.Ci;
	// loader.lazyGetter(this, "DOMUtils", () => {
	//   return Cc("@mozilla.org/inspector/dom-utils;1").getService(Ci.inIDOMUtils);
	// });

	/**
	 * CubicBezier data structure helper
	 * Accepts an array of coordinates and exposes a few useful getters
	 * @param {Array} coordinates i.e. [.42, 0, .58, 1]
	 */

	function CubicBezier(coordinates) {
	  if (!coordinates) {
	    throw new Error("No offsets were defined");
	  }

	  this.coordinates = coordinates.map(function (n) {
	    return +n;
	  });

	  for (let i = 4; i--;) {
	    let xy = this.coordinates[i];
	    if (isNaN(xy) || !(i % 2) && (xy < 0 || xy > 1)) {
	      throw new Error(`Wrong coordinate at ${ i }(${ xy })`);
	    }
	  }

	  this.coordinates.toString = function () {
	    return this.map(function (n) {
	      return (Math.round(n * 100) / 100 + "").replace(/^0\./, ".");
	    }) + "";
	  };
	}

	exports.CubicBezier = CubicBezier;

	CubicBezier.prototype = {
	  get P1() {
	    return this.coordinates.slice(0, 2);
	  },

	  get P2() {
	    return this.coordinates.slice(2);
	  },

	  toString: function () {
	    var _this = this;

	    // Check first if current coords are one of css predefined functions
	    let predefName = Object.keys(PREDEFINED).find(function (key) {
	      return coordsAreEqual(PREDEFINED[key], _this.coordinates);
	    });

	    return predefName || "cubic-bezier(" + this.coordinates + ")";
	  }
	};

	/**
	 * Bezier curve canvas plotting class
	 * @param {DOMNode} canvas
	 * @param {CubicBezier} bezier
	 * @param {Array} padding Amount of horizontal,vertical padding around the graph
	 */
	function BezierCanvas(canvas, bezier, padding) {
	  this.canvas = canvas;
	  this.bezier = bezier;
	  this.padding = getPadding(padding);

	  // Convert to a cartesian coordinate system with axes from 0 to 1
	  this.ctx = this.canvas.getContext("2d");
	  let p = this.padding;

	  this.ctx.scale(canvas.width * (1 - p[1] - p[3]), -canvas.height * (1 - p[0] - p[2]));
	  this.ctx.translate(p[3] / (1 - p[1] - p[3]), -1 - p[0] / (1 - p[0] - p[2]));
	}

	exports.BezierCanvas = BezierCanvas;

	BezierCanvas.prototype = {
	  /**
	   * Get P1 and P2 current top/left offsets so they can be positioned
	   * @return {Array} Returns an array of 2 {top:String,left:String} objects
	   */
	  get offsets() {
	    let p = this.padding,
	        w = this.canvas.width,
	        h = this.canvas.height;

	    return [{
	      left: w * (this.bezier.coordinates[0] * (1 - p[3] - p[1]) - p[3]) + "px",
	      top: h * (1 - this.bezier.coordinates[1] * (1 - p[0] - p[2]) - p[0]) + "px"
	    }, {
	      left: w * (this.bezier.coordinates[2] * (1 - p[3] - p[1]) - p[3]) + "px",
	      top: h * (1 - this.bezier.coordinates[3] * (1 - p[0] - p[2]) - p[0]) + "px"
	    }];
	  },

	  /**
	   * Convert an element's left/top offsets into coordinates
	   */
	  offsetsToCoordinates: function (element) {
	    let p = this.padding,
	        w = this.canvas.width,
	        h = this.canvas.height;

	    // Convert padding percentage to actual padding
	    p = p.map(function (a, i) {
	      return a * (i % 2 ? w : h);
	    });

	    return [(parseFloat(element.style.left) - p[3]) / (w + p[1] + p[3]), (h - parseFloat(element.style.top) - p[2]) / (h - p[0] - p[2])];
	  },

	  /**
	   * Draw the cubic bezier curve for the current coordinates
	   */
	  plot: function (settings = {}) {
	    let xy = this.bezier.coordinates;

	    let defaultSettings = {
	      handleColor: "#666",
	      handleThickness: .008,
	      bezierColor: "#4C9ED9",
	      bezierThickness: .015,
	      drawHandles: true
	    };

	    for (let setting in settings) {
	      defaultSettings[setting] = settings[setting];
	    }

	    // Clear the canvas –making sure to clear the
	    // whole area by resetting the transform first.
	    this.ctx.save();
	    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
	    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
	    this.ctx.restore();

	    if (defaultSettings.drawHandles) {
	      // Draw control handles
	      this.ctx.beginPath();
	      this.ctx.fillStyle = defaultSettings.handleColor;
	      this.ctx.lineWidth = defaultSettings.handleThickness;
	      this.ctx.strokeStyle = defaultSettings.handleColor;

	      this.ctx.moveTo(0, 0);
	      this.ctx.lineTo(xy[0], xy[1]);
	      this.ctx.moveTo(1, 1);
	      this.ctx.lineTo(xy[2], xy[3]);

	      this.ctx.stroke();
	      this.ctx.closePath();

	      let circle = function (ctx, cx, cy, r) {
	        ctx.beginPath();
	        ctx.arc(cx, cy, r, 0, 2 * Math.PI, !1);
	        ctx.closePath();
	      };

	      circle(this.ctx, xy[0], xy[1], 1.5 * defaultSettings.handleThickness);
	      this.ctx.fill();
	      circle(this.ctx, xy[2], xy[3], 1.5 * defaultSettings.handleThickness);
	      this.ctx.fill();
	    }

	    // Draw bezier curve
	    this.ctx.beginPath();
	    this.ctx.lineWidth = defaultSettings.bezierThickness;
	    this.ctx.strokeStyle = defaultSettings.bezierColor;
	    this.ctx.moveTo(0, 0);
	    this.ctx.bezierCurveTo(xy[0], xy[1], xy[2], xy[3], 1, 1);
	    this.ctx.stroke();
	    this.ctx.closePath();
	  }
	};

	/**
	 * Cubic-bezier widget. Uses the BezierCanvas class to draw the curve and
	 * adds the control points and user interaction
	 * @param {DOMNode} parent The container where the graph should be created
	 * @param {Array} coordinates Coordinates of the curve to be drawn
	 *
	 * Emits "updated" events whenever the curve is changed. Along with the event is
	 * sent a CubicBezier object
	 */
	function CubicBezierWidget(parent, coordinates = PRESETS["ease-in"]["ease-in-sine"]) {
	  EventEmitter.decorate(this);

	  this.parent = parent;

	  var _initMarkup = this._initMarkup();

	  let curve = _initMarkup.curve;
	  let p1 = _initMarkup.p1;
	  let p2 = _initMarkup.p2;

	  this.curveBoundingBox = curve.getBoundingClientRect();
	  this.curve = curve;
	  this.p1 = p1;
	  this.p2 = p2;

	  // Create and plot the bezier curve
	  this.bezierCanvas = new BezierCanvas(this.curve, new CubicBezier(coordinates), [0.30, 0]);
	  this.bezierCanvas.plot();

	  // Place the control points
	  let offsets = this.bezierCanvas.offsets;
	  this.p1.style.left = offsets[0].left;
	  this.p1.style.top = offsets[0].top;
	  this.p2.style.left = offsets[1].left;
	  this.p2.style.top = offsets[1].top;

	  this._onPointMouseDown = this._onPointMouseDown.bind(this);
	  this._onPointKeyDown = this._onPointKeyDown.bind(this);
	  this._onCurveClick = this._onCurveClick.bind(this);
	  this._onNewCoordinates = this._onNewCoordinates.bind(this);

	  // Add preset preview menu
	  this.presets = new CubicBezierPresetWidget(parent);

	  // Add the timing function previewer
	  this.timingPreview = new TimingFunctionPreviewWidget(parent);

	  this._initEvents();
	}

	exports.CubicBezierWidget = CubicBezierWidget;

	CubicBezierWidget.prototype = {
	  _initMarkup: function () {
	    let doc = this.parent.ownerDocument;

	    let wrap = doc.createElement("div");
	    wrap.className = "display-wrap";

	    let plane = doc.createElement("div");
	    plane.className = "coordinate-plane";

	    let p1 = doc.createElement("button");
	    p1.className = "control-point";
	    p1.id = "P1";
	    plane.appendChild(p1);

	    let p2 = doc.createElement("button");
	    p2.className = "control-point";
	    p2.id = "P2";
	    plane.appendChild(p2);

	    let curve = doc.createElement("canvas");
	    curve.setAttribute("width", 150);
	    curve.setAttribute("height", 370);
	    curve.id = "curve";

	    plane.appendChild(curve);
	    wrap.appendChild(plane);

	    this.parent.appendChild(wrap);

	    return {
	      p1: p1,
	      p2: p2,
	      curve: curve
	    };
	  },

	  _removeMarkup: function () {
	    this.parent.ownerDocument.querySelector(".display-wrap").remove();
	  },

	  _initEvents: function () {
	    this.p1.addEventListener("mousedown", this._onPointMouseDown);
	    this.p2.addEventListener("mousedown", this._onPointMouseDown);

	    this.p1.addEventListener("keydown", this._onPointKeyDown);
	    this.p2.addEventListener("keydown", this._onPointKeyDown);

	    this.curve.addEventListener("click", this._onCurveClick);

	    this.presets.on("new-coordinates", this._onNewCoordinates);
	  },

	  _removeEvents: function () {
	    this.p1.removeEventListener("mousedown", this._onPointMouseDown);
	    this.p2.removeEventListener("mousedown", this._onPointMouseDown);

	    this.p1.removeEventListener("keydown", this._onPointKeyDown);
	    this.p2.removeEventListener("keydown", this._onPointKeyDown);

	    this.curve.removeEventListener("click", this._onCurveClick);

	    this.presets.off("new-coordinates", this._onNewCoordinates);
	  },

	  _onPointMouseDown: function (event) {
	    // Updating the boundingbox in case it has changed
	    this.curveBoundingBox = this.curve.getBoundingClientRect();

	    let point = event.target;
	    let doc = point.ownerDocument;
	    let self = this;

	    doc.onmousemove = function drag(e) {
	      let x = e.pageX;
	      let y = e.pageY;
	      let left = self.curveBoundingBox.left;
	      let top = self.curveBoundingBox.top;

	      if (x === 0 && y == 0) {
	        return;
	      }

	      // Constrain x
	      x = Math.min(Math.max(left, x), left + self.curveBoundingBox.width);

	      point.style.left = x - left + "px";
	      point.style.top = y - top + "px";

	      self._updateFromPoints();
	    };

	    doc.onmouseup = function () {
	      point.focus();
	      doc.onmousemove = doc.onmouseup = null;
	    };
	  },

	  _onPointKeyDown: function (event) {
	    let point = event.target;
	    let code = event.keyCode;

	    if (code >= 37 && code <= 40) {
	      event.preventDefault();

	      // Arrow keys pressed
	      let left = parseInt(point.style.left, 10);
	      let top = parseInt(point.style.top, 10);
	      let offset = 3 * (event.shiftKey ? 10 : 1);

	      switch (code) {
	        case 37:
	          point.style.left = left - offset + "px";break;
	        case 38:
	          point.style.top = top - offset + "px";break;
	        case 39:
	          point.style.left = left + offset + "px";break;
	        case 40:
	          point.style.top = top + offset + "px";break;
	      }

	      this._updateFromPoints();
	    }
	  },

	  _onCurveClick: function (event) {
	    this.curveBoundingBox = this.curve.getBoundingClientRect();

	    let left = this.curveBoundingBox.left;
	    let top = this.curveBoundingBox.top;
	    let x = event.pageX - left;
	    let y = event.pageY - top;

	    // Find which point is closer
	    let distP1 = distance(x, y, parseInt(this.p1.style.left, 10), parseInt(this.p1.style.top, 10));
	    let distP2 = distance(x, y, parseInt(this.p2.style.left, 10), parseInt(this.p2.style.top, 10));

	    let point = distP1 < distP2 ? this.p1 : this.p2;
	    point.style.left = x + "px";
	    point.style.top = y + "px";

	    this._updateFromPoints();
	  },

	  _onNewCoordinates: function (event, coordinates) {
	    this.coordinates = coordinates;
	  },

	  /**
	   * Get the current point coordinates and redraw the curve to match
	   */
	  _updateFromPoints: function () {
	    // Get the new coordinates from the point's offsets
	    let coordinates = this.bezierCanvas.offsetsToCoordinates(this.p1);
	    coordinates = coordinates.concat(this.bezierCanvas.offsetsToCoordinates(this.p2));

	    this.presets.refreshMenu(coordinates);
	    this._redraw(coordinates);
	  },

	  /**
	   * Redraw the curve
	   * @param {Array} coordinates The array of control point coordinates
	   */
	  _redraw: function (coordinates) {
	    // Provide a new CubicBezier to the canvas and plot the curve
	    this.bezierCanvas.bezier = new CubicBezier(coordinates);
	    this.bezierCanvas.plot();
	    this.emit("updated", this.bezierCanvas.bezier);

	    this.timingPreview.preview(this.bezierCanvas.bezier + "");
	  },

	  /**
	   * Set new coordinates for the control points and redraw the curve
	   * @param {Array} coordinates
	   */
	  set coordinates(coordinates) {
	    this._redraw(coordinates);

	    // Move the points
	    let offsets = this.bezierCanvas.offsets;
	    this.p1.style.left = offsets[0].left;
	    this.p1.style.top = offsets[0].top;
	    this.p2.style.left = offsets[1].left;
	    this.p2.style.top = offsets[1].top;
	  },

	  /**
	   * Set new coordinates for the control point and redraw the curve
	   * @param {String} value A string value. E.g. "linear",
	   * "cubic-bezier(0,0,1,1)"
	   */
	  set cssCubicBezierValue(value) {
	    if (!value) {
	      return;
	    }

	    value = value.trim();

	    // Try with one of the predefined values
	    let coordinates = parseTimingFunction(value);

	    this.presets.refreshMenu(coordinates);
	    this.coordinates = coordinates;
	  },

	  destroy: function () {
	    this._removeEvents();
	    this._removeMarkup();

	    this.timingPreview.destroy();
	    this.presets.destroy();

	    this.curve = this.p1 = this.p2 = null;
	  }
	};

	/**
	 * CubicBezierPreset widget.
	 * Builds a menu of presets from CubicBezierPresets
	 * @param {DOMNode} parent The container where the preset panel should be
	 * created
	 *
	 * Emits "new-coordinate" event along with the coordinates
	 * whenever a preset is selected.
	 */
	function CubicBezierPresetWidget(parent) {
	  this.parent = parent;

	  var _initMarkup2 = this._initMarkup();

	  let presetPane = _initMarkup2.presetPane;
	  let presets = _initMarkup2.presets;
	  let categories = _initMarkup2.categories;

	  this.presetPane = presetPane;
	  this.presets = presets;
	  this.categories = categories;

	  this._activeCategory = null;
	  this._activePresetList = null;
	  this._activePreset = null;

	  this._onCategoryClick = this._onCategoryClick.bind(this);
	  this._onPresetClick = this._onPresetClick.bind(this);

	  EventEmitter.decorate(this);
	  this._initEvents();
	}

	exports.CubicBezierPresetWidget = CubicBezierPresetWidget;

	CubicBezierPresetWidget.prototype = {
	  /*
	   * Constructs a list of all preset categories and a list
	   * of presets for each category.
	   *
	   * High level markup:
	   *  div .preset-pane
	   *    div .preset-categories
	   *      div .category
	   *      div .category
	   *      ...
	   *    div .preset-container
	   *      div .presetList
	   *        div .preset
	   *        ...
	   *      div .presetList
	   *        div .preset
	   *        ...
	   */
	  _initMarkup: function () {
	    var _this2 = this;

	    let doc = this.parent.ownerDocument;

	    let presetPane = doc.createElement("div");
	    presetPane.className = "preset-pane";

	    let categoryList = doc.createElement("div");
	    categoryList.id = "preset-categories";

	    let presetContainer = doc.createElement("div");
	    presetContainer.id = "preset-container";

	    Object.keys(PRESETS).forEach(function (categoryLabel) {
	      let category = _this2._createCategory(categoryLabel);
	      categoryList.appendChild(category);

	      let presetList = _this2._createPresetList(categoryLabel);
	      presetContainer.appendChild(presetList);
	    });

	    presetPane.appendChild(categoryList);
	    presetPane.appendChild(presetContainer);

	    this.parent.appendChild(presetPane);

	    let allCategories = presetPane.querySelectorAll(".category");
	    let allPresets = presetPane.querySelectorAll(".preset");

	    return {
	      presetPane: presetPane,
	      presets: allPresets,
	      categories: allCategories
	    };
	  },

	  _createCategory: function (categoryLabel) {
	    let doc = this.parent.ownerDocument;

	    let category = doc.createElement("div");
	    category.id = categoryLabel;
	    category.classList.add("category");

	    let categoryDisplayLabel = this._normalizeCategoryLabel(categoryLabel);
	    category.textContent = categoryDisplayLabel;
	    category.setAttribute("title", categoryDisplayLabel);

	    return category;
	  },

	  _normalizeCategoryLabel: function (categoryLabel) {
	    return categoryLabel.replace("/-/g", " ");
	  },

	  _createPresetList: function (categoryLabel) {
	    var _this3 = this;

	    let doc = this.parent.ownerDocument;

	    let presetList = doc.createElement("div");
	    presetList.id = "preset-category-" + categoryLabel;
	    presetList.classList.add("preset-list");

	    Object.keys(PRESETS[categoryLabel]).forEach(function (presetLabel) {
	      let preset = _this3._createPreset(categoryLabel, presetLabel);
	      presetList.appendChild(preset);
	    });

	    return presetList;
	  },

	  _createPreset: function (categoryLabel, presetLabel) {
	    let doc = this.parent.ownerDocument;

	    let preset = doc.createElement("div");
	    preset.classList.add("preset");
	    preset.id = presetLabel;
	    preset.coordinates = PRESETS[categoryLabel][presetLabel];
	    // Create preset preview
	    let curve = doc.createElement("canvas");
	    let bezier = new CubicBezier(preset.coordinates);
	    curve.setAttribute("height", 50);
	    curve.setAttribute("width", 50);
	    preset.bezierCanvas = new BezierCanvas(curve, bezier, [0.15, 0]);
	    preset.bezierCanvas.plot({
	      drawHandles: false,
	      bezierThickness: 0.025
	    });
	    preset.appendChild(curve);

	    // Create preset label
	    let presetLabelElem = doc.createElement("p");
	    let presetDisplayLabel = this._normalizePresetLabel(categoryLabel, presetLabel);
	    presetLabelElem.textContent = presetDisplayLabel;
	    preset.appendChild(presetLabelElem);
	    preset.setAttribute("title", presetDisplayLabel);

	    return preset;
	  },

	  _normalizePresetLabel: function (categoryLabel, presetLabel) {
	    return presetLabel.replace(categoryLabel + "-", "").replace("/-/g", " ");
	  },

	  _initEvents: function () {
	    for (let category of this.categories) {
	      category.addEventListener("click", this._onCategoryClick);
	    }

	    for (let preset of this.presets) {
	      preset.addEventListener("click", this._onPresetClick);
	    }
	  },

	  _removeEvents: function () {
	    for (let category of this.categories) {
	      category.removeEventListener("click", this._onCategoryClick);
	    }

	    for (let preset of this.presets) {
	      preset.removeEventListener("click", this._onPresetClick);
	    }
	  },

	  _onPresetClick: function (event) {
	    this.emit("new-coordinates", event.currentTarget.coordinates);
	    this.activePreset = event.currentTarget;
	  },

	  _onCategoryClick: function (event) {
	    this.activeCategory = event.target;
	  },

	  _setActivePresetList: function (presetListId) {
	    let presetList = this.presetPane.querySelector("#" + presetListId);
	    swapClassName("active-preset-list", this._activePresetList, presetList);
	    this._activePresetList = presetList;
	  },

	  set activeCategory(category) {
	    swapClassName("active-category", this._activeCategory, category);
	    this._activeCategory = category;
	    this._setActivePresetList("preset-category-" + category.id);
	  },

	  get activeCategory() {
	    return this._activeCategory;
	  },

	  set activePreset(preset) {
	    swapClassName("active-preset", this._activePreset, preset);
	    this._activePreset = preset;
	  },

	  get activePreset() {
	    return this._activePreset;
	  },

	  /**
	   * Called by CubicBezierWidget onload and when
	   * the curve is modified via the canvas.
	   * Attempts to match the new user setting with an
	   * existing preset.
	   * @param {Array} coordinates new coords [i, j, k, l]
	   */
	  refreshMenu: function (coordinates) {
	    var _this4 = this;

	    // If we cannot find a matching preset, keep
	    // menu on last known preset category.
	    let category = this._activeCategory;

	    // If we cannot find a matching preset
	    // deselect any selected preset.
	    let preset = null;

	    // If a category has never been viewed before
	    // show the default category.
	    if (!category) {
	      category = this.parent.querySelector("#" + DEFAULT_PRESET_CATEGORY);
	    }

	    // If the new coordinates do match a preset,
	    // set its category and preset button as active.
	    Object.keys(PRESETS).forEach(function (categoryLabel) {
	      Object.keys(PRESETS[categoryLabel]).forEach(function (presetLabel) {
	        if (coordsAreEqual(PRESETS[categoryLabel][presetLabel], coordinates)) {
	          category = _this4.parent.querySelector("#" + categoryLabel);
	          preset = _this4.parent.querySelector("#" + presetLabel);
	        }
	      });
	    });

	    this.activeCategory = category;
	    this.activePreset = preset;
	  },

	  destroy: function () {
	    this._removeEvents();
	    this.parent.querySelector(".preset-pane").remove();
	  }
	};

	/**
	 * The TimingFunctionPreviewWidget animates a dot on a scale with a given
	 * timing-function
	 * @param {DOMNode} parent The container where this widget should go
	 */
	function TimingFunctionPreviewWidget(parent) {
	  this.previousValue = null;
	  this.autoRestartAnimation = null;

	  this.parent = parent;
	  this._initMarkup();
	}

	TimingFunctionPreviewWidget.prototype = {
	  PREVIEW_DURATION: 1000,

	  _initMarkup: function () {
	    let doc = this.parent.ownerDocument;

	    let container = doc.createElement("div");
	    container.className = "timing-function-preview";

	    this.dot = doc.createElement("div");
	    this.dot.className = "dot";
	    container.appendChild(this.dot);

	    let scale = doc.createElement("div");
	    scale.className = "scale";
	    container.appendChild(scale);

	    this.parent.appendChild(container);
	  },

	  destroy: function () {
	    clearTimeout(this.autoRestartAnimation);
	    this.parent.querySelector(".timing-function-preview").remove();
	    this.parent = this.dot = null;
	  },

	  /**
	   * Preview a new timing function. The current preview will only be stopped if
	   * the supplied function value is different from the previous one. If the
	   * supplied function is invalid, the preview will stop.
	   * @param {String} value
	   */
	  preview: function (value) {
	    // Don't restart the preview animation if the value is the same
	    if (value === this.previousValue) {
	      return false;
	    }

	    clearTimeout(this.autoRestartAnimation);

	    if (parseTimingFunction(value)) {
	      this.dot.style.animationTimingFunction = value;
	      this.restartAnimation();
	    }

	    this.previousValue = value;
	  },

	  /**
	   * Re-start the preview animation from the beginning
	   */
	  restartAnimation: function () {
	    // Reset the animation duration in case it was changed
	    this.dot.style.animationDuration = this.PREVIEW_DURATION * 2 + "ms";

	    // Just toggling the class won't do it unless there's a sync reflow
	    this.dot.classList.remove("animate");
	    let w = this.dot.offsetWidth;
	    this.dot.classList.add("animate");

	    // Restart it again after a while
	    this.autoRestartAnimation = setTimeout(this.restartAnimation.bind(this), this.PREVIEW_DURATION * 2);
	  }
	};

	// Helpers

	function getPadding(padding) {
	  let p = typeof padding === "number" ? [padding] : padding;

	  if (p.length === 1) {
	    p[1] = p[0];
	  }

	  if (p.length === 2) {
	    p[2] = p[0];
	  }

	  if (p.length === 3) {
	    p[3] = p[1];
	  }

	  return p;
	}

	function distance(x1, y1, x2, y2) {
	  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	}

	/**
	 * Parse a string to see whether it is a valid timing function.
	 * If it is, return the coordinates as an array.
	 * Otherwise, return undefined.
	 * @param {String} value
	 * @return {Array} of coordinates, or undefined
	 */
	function parseTimingFunction(value) {
	  if (value in PREDEFINED) {
	    return PREDEFINED[value];
	  }

	  let tokenStream = DOMUtils.getCSSLexer(value);
	  let getNextToken = function () {
	    while (true) {
	      let token = tokenStream.nextToken();
	      if (!token || token.tokenType !== "whitespace" && token.tokenType !== "comment") {
	        return token;
	      }
	    }
	  };

	  let token = getNextToken();
	  if (token.tokenType !== "function" || token.text !== "cubic-bezier") {
	    return undefined;
	  }

	  let result = [];
	  for (let i = 0; i < 4; ++i) {
	    token = getNextToken();
	    if (!token || token.tokenType !== "number") {
	      return undefined;
	    }
	    result.push(token.number);

	    token = getNextToken();
	    if (!token || token.tokenType !== "symbol" || token.text !== (i == 3 ? ")" : ",")) {
	      return undefined;
	    }
	  }

	  return result;
	}

	// This is exported for testing.
	exports._parseTimingFunction = parseTimingFunction;

	/**
	 * Removes a class from a node and adds it to another.
	 * @param {String} className the class to swap
	 * @param {DOMNode} from the node to remove the class from
	 * @param {DOMNode} to the node to add the class to
	 */
	function swapClassName(className, from, to) {
	  if (from !== null) {
	    from.classList.remove(className);
	  }

	  if (to !== null) {
	    to.classList.add(className);
	  }
	}

	/**
	 * Compares two arrays of coordinates [i, j, k, l]
	 * @param {Array} c1 first coordinate array to compare
	 * @param {Array} c2 second coordinate array to compare
	 * @return {Boolean}
	 */
	function coordsAreEqual(c1, c2) {
	  return c1.reduce(function (prev, curr, index) {
	    return prev && curr === c2[index];
	  }, true);
	}

/***/ },
/* 57 */
/***/ function(module, exports) {

	/**
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 */

	// Set of preset definitions for use with CubicBezierWidget
	// Credit: http://easings.net

	"use strict";

	const PREDEFINED = {
	  "ease": [0.25, 0.1, 0.25, 1],
	  "linear": [0, 0, 1, 1],
	  "ease-in": [0.42, 0, 1, 1],
	  "ease-out": [0, 0, 0.58, 1],
	  "ease-in-out": [0.42, 0, 0.58, 1]
	};

	const PRESETS = {
	  "ease-in": {
	    "ease-in-linear": [0, 0, 1, 1],
	    "ease-in-ease-in": [0.42, 0, 1, 1],
	    "ease-in-sine": [0.47, 0, 0.74, 0.71],
	    "ease-in-quadratic": [0.55, 0.09, 0.68, 0.53],
	    "ease-in-cubic": [0.55, 0.06, 0.68, 0.19],
	    "ease-in-quartic": [0.9, 0.03, 0.69, 0.22],
	    "ease-in-quintic": [0.76, 0.05, 0.86, 0.06],
	    "ease-in-exponential": [0.95, 0.05, 0.8, 0.04],
	    "ease-in-circular": [0.6, 0.04, 0.98, 0.34],
	    "ease-in-backward": [0.6, -0.28, 0.74, 0.05]
	  },
	  "ease-out": {
	    "ease-out-linear": [0, 0, 1, 1],
	    "ease-out-ease-out": [0, 0, 0.58, 1],
	    "ease-out-sine": [0.39, 0.58, 0.57, 1],
	    "ease-out-quadratic": [0.25, 0.46, 0.45, 0.94],
	    "ease-out-cubic": [0.22, 0.61, 0.36, 1],
	    "ease-out-quartic": [0.17, 0.84, 0.44, 1],
	    "ease-out-quintic": [0.23, 1, 0.32, 1],
	    "ease-out-exponential": [0.19, 1, 0.22, 1],
	    "ease-out-circular": [0.08, 0.82, 0.17, 1],
	    "ease-out-backward": [0.18, 0.89, 0.32, 1.28]
	  },
	  "ease-in-out": {
	    "ease-in-out-linear": [0, 0, 1, 1],
	    "ease-in-out-ease": [0.25, 0.1, 0.25, 1],
	    "ease-in-out-ease-in-out": [0.42, 0, 0.58, 1],
	    "ease-in-out-sine": [0.45, 0.05, 0.55, 0.95],
	    "ease-in-out-quadratic": [0.46, 0.03, 0.52, 0.96],
	    "ease-in-out-cubic": [0.65, 0.05, 0.36, 1],
	    "ease-in-out-quartic": [0.77, 0, 0.18, 1],
	    "ease-in-out-quintic": [0.86, 0, 0.07, 1],
	    "ease-in-out-exponential": [1, 0, 0, 1],
	    "ease-in-out-circular": [0.79, 0.14, 0.15, 0.86],
	    "ease-in-out-backward": [0.68, -0.55, 0.27, 1.55]
	  }
	};

	const DEFAULT_PRESET_CATEGORY = Object.keys(PRESETS)[0];

	exports.PRESETS = PRESETS;
	exports.PREDEFINED = PREDEFINED;
	exports.DEFAULT_PRESET_CATEGORY = DEFAULT_PRESET_CATEGORY;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * This file contains functions to retrieve docs content from
	 * MDN (developer.mozilla.org) for particular items, and to display
	 * the content in a tooltip.
	 *
	 * At the moment it only supports fetching content for CSS properties,
	 * but it might support other types of content in the future
	 * (Web APIs, for example).
	 *
	 * It's split into two parts:
	 *
	 * - functions like getCssDocs that just fetch content from MDN,
	 * without any constraints on what to do with the content. If you
	 * want to embed the content in some custom way, use this.
	 *
	 * - the MdnDocsWidget class, that manages and updates a tooltip
	 * document whose content is taken from MDN. If you want to embed
	 * the content in a tooltip, use this in conjunction with Tooltip.js.
	 */

	"use strict";

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Cu = _require.Cu;
	const Ci = _require.Ci;

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	const Promise = __webpack_require__(6);
	const DOMUtils = Cc("@mozilla.org/inspector/dom-utils;1").getService(Ci.inIDOMUtils);

	// Parameters for the XHR request
	// see https://developer.mozilla.org/en-US/docs/MDN/Kuma/API#Document_parameters
	const XHR_PARAMS = "?raw&macros";
	// URL for the XHR request
	var XHR_CSS_URL = "https://developer.mozilla.org/en-US/docs/Web/CSS/";

	// Parameters for the link to MDN in the tooltip, so
	// so we know which MDN visits come from this feature
	const PAGE_LINK_PARAMS = "?utm_source=mozilla&utm_medium=firefox-inspector&utm_campaign=default";
	// URL for the page link omits locale, so a locale-specific page will be loaded
	var PAGE_LINK_URL = "https://developer.mozilla.org/docs/Web/CSS/";

	const BROWSER_WINDOW = 'navigator:browser';

	const PROPERTY_NAME_COLOR = "theme-fg-color5";
	const PROPERTY_VALUE_COLOR = "theme-fg-color1";
	const COMMENT_COLOR = "theme-comment";

	/**
	 * Turns a string containing a series of CSS declarations into
	 * a series of DOM nodes, with classes applied to provide syntax
	 * highlighting.
	 *
	 * It uses the CSS tokenizer to generate a stream of CSS tokens.
	 * https://mxr.mozilla.org/mozilla-central/source/dom/webidl/CSSLexer.webidl
	 * lists all the token types.
	 *
	 * - "whitespace", "comment", and "symbol" tokens are appended as TEXT nodes,
	 * and will inherit the default style for text.
	 *
	 * - "ident" tokens that we think are property names are considered to be
	 * a property name, and are appended as SPAN nodes with a distinct color class.
	 *
	 * - "ident" nodes which we do not think are property names, and nodes
	 * of all other types ("number", "url", "percentage", ...) are considered
	 * to be part of a property value, and are appended as SPAN nodes with
	 * a different color class.
	 *
	 * @param {Document} doc
	 * Used to create nodes.
	 *
	 * @param {String} syntaxText
	 * The CSS input. This is assumed to consist of a series of
	 * CSS declarations, with trailing semicolons.
	 *
	 * @param {DOM node} syntaxSection
	 * This is the parent for the output nodes. Generated nodes
	 * are appended to this as children.
	 */
	function appendSyntaxHighlightedCSS(cssText, parentElement) {
	  let doc = parentElement.ownerDocument;
	  let identClass = PROPERTY_NAME_COLOR;
	  let lexer = DOMUtils.getCSSLexer(cssText);

	  /**
	   * Create a SPAN node with the given text content and class.
	   */
	  function createStyledNode(textContent, className) {
	    let newNode = doc.createElement("span");
	    newNode.classList.add(className);
	    newNode.textContent = textContent;
	    return newNode;
	  }

	  /**
	   * If the symbol is ":", we will expect the next
	   * "ident" token to be part of a property value.
	   *
	   * If the symbol is ";", we will expect the next
	   * "ident" token to be a property name.
	   */
	  function updateIdentClass(tokenText) {
	    if (tokenText === ":") {
	      identClass = PROPERTY_VALUE_COLOR;
	    } else {
	      if (tokenText === ";") {
	        identClass = PROPERTY_NAME_COLOR;
	      }
	    }
	  }

	  /**
	   * Create the appropriate node for this token type.
	   *
	   * If this token is a symbol, also update our expectations
	   * for what the next "ident" token represents.
	   */
	  function tokenToNode(token, tokenText) {
	    switch (token.tokenType) {
	      case "ident":
	        return createStyledNode(tokenText, identClass);
	      case "symbol":
	        updateIdentClass(tokenText);
	        return doc.createTextNode(tokenText);
	      case "whitespace":
	        return doc.createTextNode(tokenText);
	      case "comment":
	        return createStyledNode(tokenText, COMMENT_COLOR);
	      default:
	        return createStyledNode(tokenText, PROPERTY_VALUE_COLOR);
	    }
	  }

	  let token = lexer.nextToken();
	  while (token) {
	    let tokenText = cssText.slice(token.startOffset, token.endOffset);
	    let newNode = tokenToNode(token, tokenText);
	    parentElement.appendChild(newNode);
	    token = lexer.nextToken();
	  }
	}

	exports.appendSyntaxHighlightedCSS = appendSyntaxHighlightedCSS;

	/**
	 * Fetch an MDN page.
	 *
	 * @param {string} pageUrl
	 * URL of the page to fetch.
	 *
	 * @return {promise}
	 * The promise is resolved with the page as an XML document.
	 *
	 * The promise is rejected with an error message if
	 * we could not load the page.
	 */
	function getMdnPage(pageUrl) {
	  let deferred = Promise.defer();

	  let xhr = Cc("@mozilla.org/xmlextras/xmlhttprequest;1").createInstance(Ci.nsIXMLHttpRequest);

	  xhr.addEventListener("load", onLoaded, false);
	  xhr.addEventListener("error", onError, false);

	  xhr.open("GET", pageUrl);
	  xhr.responseType = "document";
	  xhr.send();

	  function onLoaded(e) {
	    if (xhr.status != 200) {
	      deferred.reject({ page: pageUrl, status: xhr.status });
	    } else {
	      deferred.resolve(xhr.responseXML);
	    }
	  }

	  function onError(e) {
	    deferred.reject({ page: pageUrl, status: xhr.status });
	  }

	  return deferred.promise;
	}

	/**
	 * Gets some docs for the given CSS property.
	 * Loads an MDN page for the property and gets some
	 * information about the property.
	 *
	 * @param {string} cssProperty
	 * The property for which we want docs.
	 *
	 * @return {promise}
	 * The promise is resolved with an object containing:
	 * - summary: a short summary of the property
	 * - syntax: some example syntax
	 *
	 * The promise is rejected with an error message if
	 * we could not load the page.
	 */
	function getCssDocs(cssProperty) {

	  let deferred = Promise.defer();
	  let pageUrl = XHR_CSS_URL + cssProperty + XHR_PARAMS;

	  getMdnPage(pageUrl).then(parseDocsFromResponse, handleRejection);

	  function parseDocsFromResponse(responseDocument) {
	    let theDocs = {};
	    theDocs.summary = getSummary(responseDocument);
	    theDocs.syntax = getSyntax(responseDocument);
	    if (theDocs.summary || theDocs.syntax) {
	      deferred.resolve(theDocs);
	    } else {
	      deferred.reject("Couldn't find the docs in the page.");
	    }
	  }

	  function handleRejection(e) {
	    deferred.reject(e.status);
	  }

	  return deferred.promise;
	}

	exports.getCssDocs = getCssDocs;

	/**
	 * The MdnDocsWidget is used by tooltip code that needs to display docs
	 * from MDN in a tooltip. The tooltip code loads a document that contains the
	 * basic structure of a docs tooltip (loaded from mdn-docs-frame.xhtml),
	 * and passes this document into the widget's constructor.
	 *
	 * In the constructor, the widget does some general setup that's not
	 * dependent on the particular item we need docs for.
	 *
	 * After that, when the tooltip code needs to display docs for an item, it
	 * asks the widget to retrieve the docs and update the document with them.
	 *
	 * @param {Document} tooltipDocument
	 * A DOM document. The widget expects the document to have a particular
	 * structure.
	 */
	function MdnDocsWidget(tooltipDocument) {

	  // fetch all the bits of the document that we will manipulate later
	  this.elements = {
	    heading: tooltipDocument.getElementById("property-name"),
	    summary: tooltipDocument.getElementById("summary"),
	    syntax: tooltipDocument.getElementById("syntax"),
	    info: tooltipDocument.getElementById("property-info"),
	    linkToMdn: tooltipDocument.getElementById("visit-mdn-page")
	  };

	  this.doc = tooltipDocument;

	  // get the localized string for the link text
	  this.elements.linkToMdn.textContent = l10n.strings.GetStringFromName("docsTooltip.visitMDN");

	  // listen for clicks and open in the browser window instead
	  let browserWindow = Services.wm.getMostRecentWindow(BROWSER_WINDOW);
	  this.elements.linkToMdn.addEventListener("click", function (e) {
	    e.stopPropagation();
	    e.preventDefault();
	    let link = e.target.href;
	    browserWindow.gBrowser.addTab(link);
	  });
	}

	exports.MdnDocsWidget = MdnDocsWidget;

	MdnDocsWidget.prototype = {
	  /**
	   * This is called just before the tooltip is displayed, and is
	   * passed the CSS property for which we want to display help.
	   *
	   * Its job is to make sure the document contains the docs
	   * content for that CSS property.
	   *
	   * First, it initializes the document, setting the things it can
	   * set synchronously, resetting the things it needs to get
	   * asynchronously, and making sure the throbber is throbbing.
	   *
	   * Then it tries to get the content asynchronously, updating
	   * the document with the content or with an error message.
	   *
	   * It returns immediately, so the caller can display the tooltip
	   * without waiting for the asynch operation to complete.
	   *
	   * @param {string} propertyName
	   * The name of the CSS property for which we need to display help.
	   */
	  loadCssDocs: function (propertyName) {

	    /**
	     * Do all the setup we can do synchronously, and get the document in
	     * a state where it can be displayed while we are waiting for the
	     * MDN docs content to be retrieved.
	     */
	    function initializeDocument(propertyName) {

	      // set property name heading
	      elements.heading.textContent = propertyName;

	      // set link target
	      elements.linkToMdn.setAttribute("href", PAGE_LINK_URL + propertyName + PAGE_LINK_PARAMS);

	      // clear docs summary and syntax
	      elements.summary.textContent = "";
	      while (elements.syntax.firstChild) {
	        elements.syntax.firstChild.remove();
	      }

	      // reset the scroll position
	      elements.info.scrollTop = 0;
	      elements.info.scrollLeft = 0;

	      // show the throbber
	      elements.info.classList.add("devtools-throbber");
	    }

	    /**
	     * This is called if we successfully got the docs content.
	     * Finishes setting up the tooltip content, and disables the throbber.
	     */
	    function finalizeDocument({ summary, syntax }) {
	      // set docs summary and syntax
	      elements.summary.textContent = summary;
	      appendSyntaxHighlightedCSS(syntax, elements.syntax);

	      // hide the throbber
	      elements.info.classList.remove("devtools-throbber");

	      deferred.resolve(this);
	    }

	    /**
	     * This is called if we failed to get the docs content.
	     * Sets the content to contain an error message, and disables the throbber.
	     */
	    function gotError(error) {
	      // show error message
	      elements.summary.textContent = l10n.strings.GetStringFromName("docsTooltip.loadDocsError");

	      // hide the throbber
	      elements.info.classList.remove("devtools-throbber");

	      // although gotError is called when there's an error, we have handled
	      // the error, so call resolve not reject.
	      deferred.resolve(this);
	    }

	    let deferred = Promise.defer();
	    let elements = this.elements;
	    let doc = this.doc;

	    initializeDocument(propertyName);
	    getCssDocs(propertyName).then(finalizeDocument, gotError);

	    return deferred.promise;
	  },

	  destroy: function () {
	    this.elements = null;
	    this.doc = null;
	  }
	};

	/**
	 * L10N utility class
	 */
	function L10N() {}
	L10N.prototype = {};

	var l10n = new L10N();

	loader.lazyGetter(L10N.prototype, "strings", function () {
	  return Services.strings.createBundle("chrome://devtools/locale/inspector.properties");
	});

	/**
	 * Test whether a node is all whitespace.
	 *
	 * @return {boolean}
	 * True if the node all whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
	  return !/[^\t\n\r ]/.test(node.textContent);
	}

	/**
	 * Test whether a node is a comment or whitespace node.
	 *
	 * @return {boolean}
	 * True if the node is a comment node or is all whitespace, otherwise false.
	 */
	function isIgnorable(node) {
	  return node.nodeType == 8 || // A comment node
	  node.nodeType == 3 && isAllWhitespace(node); // text node, all ws
	}

	/**
	 * Get the next node, skipping comments and whitespace.
	 *
	 * @return {node}
	 * The next sibling node that is not a comment or whitespace, or null if
	 * there isn't one.
	 */
	function nodeAfter(sib) {
	  while (sib = sib.nextSibling) {
	    if (!isIgnorable(sib)) return sib;
	  }
	  return null;
	}

	/**
	 * Test whether the argument `node` is a node whose tag is `tagName`.
	 *
	 * @param {node} node
	 * The code to test. May be null.
	 *
	 * @param {string} tagName
	 * The tag name to test against.
	 *
	 * @return {boolean}
	 * True if the node is not null and has the tag name `tagName`,
	 * otherwise false.
	 */
	function hasTagName(node, tagName) {
	  return node && node.tagName && node.tagName.toLowerCase() == tagName.toLowerCase();
	}

	/**
	 * Given an MDN page, get the "summary" portion.
	 *
	 * This is the textContent of the first non-whitespace
	 * element in the #Summary section of the document.
	 *
	 * It's expected to be a <P> element.
	 *
	 * @param {Document} mdnDocument
	 * The document in which to look for the "summary" section.
	 *
	 * @return {string}
	 * The summary section as a string, or null if it could not be found.
	 */
	function getSummary(mdnDocument) {
	  let summary = mdnDocument.getElementById("Summary");
	  if (!hasTagName(summary, "H2")) {
	    return null;
	  }

	  let firstParagraph = nodeAfter(summary);
	  if (!hasTagName(firstParagraph, "P")) {
	    return null;
	  }

	  return firstParagraph.textContent;
	}

	/**
	 * Given an MDN page, get the "syntax" portion.
	 *
	 * First we get the #Syntax section of the document. The syntax
	 * section we want is somewhere inside there.
	 *
	 * If the page is in the old structure, then the *first two*
	 * non-whitespace elements in the #Syntax section will be <PRE>
	 * nodes, and the second of these will be the syntax section.
	 *
	 * If the page is in the new structure, then the only the *first*
	 * non-whitespace element in the #Syntax section will be a <PRE>
	 * node, and it will be the syntax section.
	 *
	 * @param {Document} mdnDocument
	 * The document in which to look for the "syntax" section.
	 *
	 * @return {string}
	 * The syntax section as a string, or null if it could not be found.
	 */
	function getSyntax(mdnDocument) {

	  let syntax = mdnDocument.getElementById("Syntax");
	  if (!hasTagName(syntax, "H2")) {
	    return null;
	  }

	  let firstParagraph = nodeAfter(syntax);
	  if (!hasTagName(firstParagraph, "PRE")) {
	    return null;
	  }

	  let secondParagraph = nodeAfter(firstParagraph);
	  if (hasTagName(secondParagraph, "PRE")) {
	    return secondParagraph.textContent;
	  } else {
	    return firstParagraph.textContent;
	  }
	}

	/**
	 * Use a different URL for CSS docs pages. Used only for testing.
	 *
	 * @param {string} baseUrl
	 * The baseURL to use.
	 */
	function setBaseCssDocsUrl(baseUrl) {
	  PAGE_LINK_URL = baseUrl;
	  XHR_CSS_URL = baseUrl;
	}

	exports.setBaseCssDocsUrl = setBaseCssDocsUrl;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict"

	/**
	  * This is a CSS Filter Editor widget used
	  * for Rule View's filter swatches
	  */

	;

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	const EventEmitter = __webpack_require__(7);

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;
	const Cc = _require.Cc;
	const Ci = _require.Ci;

	var _require2 = __webpack_require__(60);

	const ViewHelpers = _require2.ViewHelpers;

	const L10N = new ViewHelpers.L10N(__webpack_require__(61));

	var _require3 = __webpack_require__(43);

	const cssTokenizer = _require3.cssTokenizer;

	loader.lazyGetter(this, "asyncStorage", function () {
	  return __webpack_require__(62);
	});

	// loader.lazyGetter(this, "DOMUtils", () => {
	//   return Cc("@mozilla.org/inspector/dom-utils;1").getService(Ci.inIDOMUtils);
	// });

	const DEFAULT_FILTER_TYPE = "length";
	const UNIT_MAPPING = {
	  percentage: "%",
	  length: "px",
	  angle: "deg",
	  string: ""
	};

	const FAST_VALUE_MULTIPLIER = 10;
	const SLOW_VALUE_MULTIPLIER = 0.1;
	const DEFAULT_VALUE_MULTIPLIER = 1;

	const LIST_PADDING = 7;
	const LIST_ITEM_HEIGHT = 32;

	const filterList = [{
	  "name": "blur",
	  "range": [0, Infinity],
	  "type": "length"
	}, {
	  "name": "brightness",
	  "range": [0, Infinity],
	  "type": "percentage"
	}, {
	  "name": "contrast",
	  "range": [0, Infinity],
	  "type": "percentage"
	}, {
	  "name": "drop-shadow",
	  "placeholder": L10N.getStr("dropShadowPlaceholder"),
	  "type": "string"
	}, {
	  "name": "grayscale",
	  "range": [0, 100],
	  "type": "percentage"
	}, {
	  "name": "hue-rotate",
	  "range": [0, 360],
	  "type": "angle"
	}, {
	  "name": "invert",
	  "range": [0, 100],
	  "type": "percentage"
	}, {
	  "name": "opacity",
	  "range": [0, 100],
	  "type": "percentage"
	}, {
	  "name": "saturate",
	  "range": [0, Infinity],
	  "type": "percentage"
	}, {
	  "name": "sepia",
	  "range": [0, 100],
	  "type": "percentage"
	}, {
	  "name": "url",
	  "placeholder": "example.svg#c1",
	  "type": "string"
	}];

	// Valid values that shouldn't be parsed for filters.
	const SPECIAL_VALUES = new Set(["none", "unset", "initial", "inherit"]);

	/**
	 * A CSS Filter editor widget used to add/remove/modify
	 * filters.
	 *
	 * Normally, it takes a CSS filter value as input, parses it
	 * and creates the required elements / bindings.
	 *
	 * You can, however, use add/remove/update methods manually.
	 * See each method's comments for more details
	 *
	 * @param {nsIDOMNode} el
	 *        The widget container.
	 * @param {String} value
	 *        CSS filter value
	 */
	function CSSFilterEditorWidget(el, value = "") {
	  this.doc = el.ownerDocument;
	  this.win = this.doc.ownerGlobal;
	  this.el = el;

	  this._addButtonClick = this._addButtonClick.bind(this);
	  this._removeButtonClick = this._removeButtonClick.bind(this);
	  this._mouseMove = this._mouseMove.bind(this);
	  this._mouseUp = this._mouseUp.bind(this);
	  this._mouseDown = this._mouseDown.bind(this);
	  this._keyDown = this._keyDown.bind(this);
	  this._input = this._input.bind(this);
	  this._presetClick = this._presetClick.bind(this);
	  this._savePreset = this._savePreset.bind(this);
	  this._togglePresets = this._togglePresets.bind(this);

	  // Passed to asyncStorage, requires binding
	  this.renderPresets = this.renderPresets.bind(this);

	  this._initMarkup();
	  this._buildFilterItemMarkup();
	  this._buildPresetItemMarkup();
	  this._addEventListeners();

	  EventEmitter.decorate(this);

	  this.filters = [];
	  this.setCssValue(value);
	  this.renderPresets();
	}

	exports.CSSFilterEditorWidget = CSSFilterEditorWidget;

	CSSFilterEditorWidget.prototype = {
	  _initMarkup: function () {
	    this.filtersList = this.el.querySelector("#filters");
	    this.presetsList = this.el.querySelector("#presets");
	    this.togglePresets = this.el.querySelector("#toggle-presets");
	    this.filterSelect = this.el.querySelector("select");
	    this.addPresetButton = this.el.querySelector(".presets-list .add");
	    this.addPresetInput = this.el.querySelector(".presets-list .footer input");

	    this.el.querySelector(".presets-list input").value = "";

	    this._populateFilterSelect();
	  },

	  _destroyMarkup: function () {
	    this._filterItemMarkup.remove();
	    this.el.remove();
	    this.el = this.filtersList = this._filterItemMarkup = null;
	    this.presetsList = this.togglePresets = this.filterSelect = null;
	    this.addPresetButton = null;
	  },

	  destroy: function () {
	    this._removeEventListeners();
	    this._destroyMarkup();
	  },

	  /**
	    * Creates <option> elements for each filter definition
	    * in filterList
	    */
	  _populateFilterSelect: function () {
	    var _this = this;

	    let select = this.filterSelect;
	    filterList.forEach(function (filter) {
	      let option = _this.doc.createElement("option");
	      option.innerHTML = option.value = filter.name;
	      select.appendChild(option);
	    });
	  },

	  /**
	    * Creates a template for filter elements which is cloned and used in render
	    */
	  _buildFilterItemMarkup: function () {
	    let base = this.doc.createElement("div");
	    base.className = "filter";

	    let name = this.doc.createElement("div");
	    name.className = "filter-name";

	    let value = this.doc.createElement("div");
	    value.className = "filter-value";

	    let drag = this.doc.createElement("i");
	    drag.title = L10N.getStr("dragHandleTooltipText");

	    let label = this.doc.createElement("label");

	    name.appendChild(drag);
	    name.appendChild(label);

	    let unitPreview = this.doc.createElement("span");
	    let input = this.doc.createElement("input");
	    input.classList.add("devtools-textinput");

	    value.appendChild(input);
	    value.appendChild(unitPreview);

	    let removeButton = this.doc.createElement("button");
	    removeButton.className = "remove-button";

	    base.appendChild(name);
	    base.appendChild(value);
	    base.appendChild(removeButton);

	    this._filterItemMarkup = base;
	  },

	  _buildPresetItemMarkup: function () {
	    let base = this.doc.createElement("div");
	    base.classList.add("preset");

	    let name = this.doc.createElement("label");
	    base.appendChild(name);

	    let value = this.doc.createElement("span");
	    base.appendChild(value);

	    let removeButton = this.doc.createElement("button");
	    removeButton.classList.add("remove-button");

	    base.appendChild(removeButton);

	    this._presetItemMarkup = base;
	  },

	  _addEventListeners: function () {
	    this.addButton = this.el.querySelector("#add-filter");
	    this.addButton.addEventListener("click", this._addButtonClick);
	    this.filtersList.addEventListener("click", this._removeButtonClick);
	    this.filtersList.addEventListener("mousedown", this._mouseDown);
	    this.filtersList.addEventListener("keydown", this._keyDown);

	    this.presetsList.addEventListener("click", this._presetClick);
	    this.togglePresets.addEventListener("click", this._togglePresets);
	    this.addPresetButton.addEventListener("click", this._savePreset);

	    // These events are event delegators for
	    // drag-drop re-ordering and label-dragging
	    this.win.addEventListener("mousemove", this._mouseMove);
	    this.win.addEventListener("mouseup", this._mouseUp);

	    // Used to workaround float-precision problems
	    this.filtersList.addEventListener("input", this._input);
	  },

	  _removeEventListeners: function () {
	    this.addButton.removeEventListener("click", this._addButtonClick);
	    this.filtersList.removeEventListener("click", this._removeButtonClick);
	    this.filtersList.removeEventListener("mousedown", this._mouseDown);
	    this.filtersList.removeEventListener("keydown", this._keyDown);

	    this.presetsList.removeEventListener("click", this._presetClick);
	    this.togglePresets.removeEventListener("click", this._togglePresets);
	    this.addPresetButton.removeEventListener("click", this._savePreset);

	    // These events are used for drag drop re-ordering
	    this.win.removeEventListener("mousemove", this._mouseMove);
	    this.win.removeEventListener("mouseup", this._mouseUp);

	    // Used to workaround float-precision problems
	    this.filtersList.removeEventListener("input", this._input);
	  },

	  _getFilterElementIndex: function (el) {
	    return [...this.filtersList.children].indexOf(el);
	  },

	  _keyDown: function (e) {
	    if (e.target.tagName.toLowerCase() !== "input" || e.keyCode !== 40 && e.keyCode !== 38) {
	      return;
	    }
	    let input = e.target;

	    const direction = e.keyCode === 40 ? -1 : 1;

	    let multiplier = DEFAULT_VALUE_MULTIPLIER;
	    if (e.altKey) {
	      multiplier = SLOW_VALUE_MULTIPLIER;
	    } else if (e.shiftKey) {
	      multiplier = FAST_VALUE_MULTIPLIER;
	    }

	    const filterEl = e.target.closest(".filter");
	    const index = this._getFilterElementIndex(filterEl);
	    const filter = this.filters[index];

	    // Filters that have units are number-type filters. For them,
	    // the value can be incremented/decremented simply.
	    // For other types of filters (e.g. drop-shadow) we need to check
	    // if the keypress happened close to a number first.
	    if (filter.unit) {
	      let startValue = parseFloat(e.target.value);
	      let value = startValue + direction * multiplier;

	      var _definition$range = _slicedToArray(this._definition(filter.name).range, 2);

	      const min = _definition$range[0];
	      const max = _definition$range[1];

	      if (value < min) {
	        value = min;
	      } else if (value > max) {
	        value = max;
	      }

	      input.value = fixFloat(value);

	      this.updateValueAt(index, value);
	    } else {
	      let selectionStart = input.selectionStart;
	      let num = getNeighbourNumber(input.value, selectionStart);
	      if (!num) {
	        return;
	      }

	      let start = num.start;
	      let end = num.end;
	      let value = num.value;

	      let split = input.value.split("");
	      let computed = fixFloat(value + direction * multiplier);
	      let dotIndex = computed.indexOf(".0");
	      if (dotIndex > -1) {
	        computed = computed.slice(0, -2);

	        selectionStart = selectionStart > start + dotIndex ? start + dotIndex : selectionStart;
	      }
	      split.splice(start, end - start, computed);

	      value = split.join("");
	      input.value = value;
	      this.updateValueAt(index, value);
	      input.setSelectionRange(selectionStart, selectionStart);
	    }
	    e.preventDefault();
	  },

	  _input: function (e) {
	    let filterEl = e.target.closest(".filter");
	    let index = this._getFilterElementIndex(filterEl);
	    let filter = this.filters[index];
	    let def = this._definition(filter.name);

	    if (def.type !== "string") {
	      e.target.value = fixFloat(e.target.value);
	    }
	    this.updateValueAt(index, e.target.value);
	  },

	  _mouseDown: function (e) {
	    let filterEl = e.target.closest(".filter");

	    // re-ordering drag handle
	    if (e.target.tagName.toLowerCase() === "i") {
	      this.isReorderingFilter = true;
	      filterEl.startingY = e.pageY;
	      filterEl.classList.add("dragging");

	      this.el.classList.add("dragging");
	      // label-dragging
	    } else if (e.target.classList.contains("devtools-draglabel")) {
	        let label = e.target;
	        let input = filterEl.querySelector("input");
	        let index = this._getFilterElementIndex(filterEl);

	        this._dragging = {
	          index, label, input,
	          startX: e.pageX
	        };

	        this.isDraggingLabel = true;
	      }
	  },

	  _addButtonClick: function () {
	    const select = this.filterSelect;
	    if (!select.value) {
	      return;
	    }

	    const key = select.value;
	    this.add(key, null);

	    this.render();
	  },

	  _removeButtonClick: function (e) {
	    const isRemoveButton = e.target.classList.contains("remove-button");
	    if (!isRemoveButton) {
	      return;
	    }

	    let filterEl = e.target.closest(".filter");
	    let index = this._getFilterElementIndex(filterEl);
	    this.removeAt(index);
	  },

	  _mouseMove: function (e) {
	    if (this.isReorderingFilter) {
	      this._dragFilterElement(e);
	    } else if (this.isDraggingLabel) {
	      this._dragLabel(e);
	    }
	  },

	  _dragFilterElement: function (e) {
	    const rect = this.filtersList.getBoundingClientRect();
	    let top = e.pageY - LIST_PADDING;
	    let bottom = e.pageY + LIST_PADDING;
	    // don't allow dragging over top/bottom of list
	    if (top < rect.top || bottom > rect.bottom) {
	      return;
	    }

	    const filterEl = this.filtersList.querySelector(".dragging");

	    const delta = e.pageY - filterEl.startingY;
	    filterEl.style.top = delta + "px";

	    // change is the number of _steps_ taken from initial position
	    // i.e. how many elements we have passed
	    let change = delta / LIST_ITEM_HEIGHT;
	    if (change > 0) {
	      change = Math.floor(change);
	    } else if (change < 0) {
	      change = Math.ceil(change);
	    }

	    const children = this.filtersList.children;
	    const index = [...children].indexOf(filterEl);
	    const destination = index + change;

	    // If we're moving out, or there's no change at all, stop and return
	    if (destination >= children.length || destination < 0 || change === 0) {
	      return;
	    }

	    // Re-order filter objects
	    swapArrayIndices(this.filters, index, destination);

	    // Re-order the dragging element in markup
	    const target = change > 0 ? children[destination + 1] : children[destination];
	    if (target) {
	      this.filtersList.insertBefore(filterEl, target);
	    } else {
	      this.filtersList.appendChild(filterEl);
	    }

	    filterEl.removeAttribute("style");

	    const currentPosition = change * LIST_ITEM_HEIGHT;
	    filterEl.startingY = e.pageY + currentPosition - delta;
	  },

	  _dragLabel: function (e) {
	    let dragging = this._dragging;

	    let input = dragging.input;

	    let multiplier = DEFAULT_VALUE_MULTIPLIER;

	    if (e.altKey) {
	      multiplier = SLOW_VALUE_MULTIPLIER;
	    } else if (e.shiftKey) {
	      multiplier = FAST_VALUE_MULTIPLIER;
	    }

	    dragging.lastX = e.pageX;
	    const delta = e.pageX - dragging.startX;
	    const startValue = parseFloat(input.value);
	    let value = startValue + delta * multiplier;

	    const filter = this.filters[dragging.index];

	    var _definition$range2 = _slicedToArray(this._definition(filter.name).range, 2);

	    const min = _definition$range2[0];
	    const max = _definition$range2[1];

	    if (value < min) {
	      value = min;
	    } else if (value > max) {
	      value = max;
	    }

	    input.value = fixFloat(value);

	    dragging.startX = e.pageX;

	    this.updateValueAt(dragging.index, value);
	  },

	  _mouseUp: function () {
	    // Label-dragging is disabled on mouseup
	    this._dragging = null;
	    this.isDraggingLabel = false;

	    // Filter drag/drop needs more cleaning
	    if (!this.isReorderingFilter) {
	      return;
	    }
	    let filterEl = this.filtersList.querySelector(".dragging");

	    this.isReorderingFilter = false;
	    filterEl.classList.remove("dragging");
	    this.el.classList.remove("dragging");
	    filterEl.removeAttribute("style");

	    this.emit("updated", this.getCssValue());
	    this.render();
	  },

	  _presetClick: function (e) {
	    var _this2 = this;

	    let el = e.target;
	    let preset = el.closest(".preset");
	    if (!preset) {
	      return;
	    }

	    let id = +preset.dataset.id;

	    this.getPresets().then(function (presets) {
	      if (el.classList.contains("remove-button")) {
	        // If the click happened on the remove button.
	        presets.splice(id, 1);
	        _this2.setPresets(presets).then(_this2.renderPresets, Cu.reportError);
	      } else {
	        // Or if the click happened on a preset.
	        let p = presets[id];

	        _this2.setCssValue(p.value);
	        _this2.addPresetInput.value = p.name;
	      }
	    }, Cu.reportError);
	  },

	  _togglePresets: function () {
	    this.el.classList.toggle("show-presets");
	    this.emit("render");
	  },

	  _savePreset: function (e) {
	    var _this3 = this;

	    e.preventDefault();

	    let name = this.addPresetInput.value;
	    let value = this.getCssValue();

	    if (!name || !value || SPECIAL_VALUES.has(value)) {
	      this.emit("preset-save-error");
	      return;
	    }

	    this.getPresets().then(function (presets) {
	      let index = presets.findIndex(function (preset) {
	        return preset.name === name;
	      });

	      if (index > -1) {
	        presets[index].value = value;
	      } else {
	        presets.push({ name, value });
	      }

	      _this3.setPresets(presets).then(_this3.renderPresets, Cu.reportError);
	    }, Cu.reportError);
	  },

	  /**
	   * Clears the list and renders filters, binding required events.
	   * There are some delegated events bound in _addEventListeners method
	   */
	  render: function () {
	    if (!this.filters.length) {
	      this.filtersList.innerHTML = `<p> ${ L10N.getStr("emptyFilterList") } <br />
	                                 ${ L10N.getStr("addUsingList") } </p>`;
	      this.emit("render");
	      return;
	    }

	    this.filtersList.innerHTML = "";

	    let base = this._filterItemMarkup;

	    for (let filter of this.filters) {
	      const def = this._definition(filter.name);

	      let el = base.cloneNode(true);

	      var _el$children = _slicedToArray(el.children, 2);

	      let name = _el$children[0];
	      let value = _el$children[1];

	      let label = name.children[1];

	      var _value$children = _slicedToArray(value.children, 2);

	      let input = _value$children[0];
	      let unitPreview = _value$children[1];

	      let min, max;
	      if (def.range) {
	        var _def$range = _slicedToArray(def.range, 2);

	        min = _def$range[0];
	        max = _def$range[1];
	      }

	      label.textContent = filter.name;
	      input.value = filter.value;

	      switch (def.type) {
	        case "percentage":
	        case "angle":
	        case "length":
	          input.type = "number";
	          input.min = min;
	          if (max !== Infinity) {
	            input.max = max;
	          }
	          input.step = "0.1";
	          break;
	        case "string":
	          input.type = "text";
	          input.placeholder = def.placeholder;
	          break;
	      }

	      // use photoshop-style label-dragging
	      // and show filters' unit next to their <input>
	      if (def.type !== "string") {
	        unitPreview.textContent = filter.unit;

	        label.classList.add("devtools-draglabel");
	        label.title = L10N.getStr("labelDragTooltipText");
	      } else {
	        // string-type filters have no unit
	        unitPreview.remove();
	      }

	      this.filtersList.appendChild(el);
	    }

	    let lastInput = this.filtersList.querySelector(`.filter:last-of-type input`);
	    if (lastInput) {
	      lastInput.focus();
	      // move cursor to end of input
	      const end = lastInput.value.length;
	      lastInput.setSelectionRange(end, end);
	    }

	    this.emit("render");
	  },

	  renderPresets: function () {
	    var _this4 = this;

	    this.getPresets().then(function (presets) {
	      if (!presets || !presets.length) {
	        _this4.presetsList.innerHTML = `<p>${ L10N.getStr("emptyPresetList") }</p>`;
	        _this4.emit("render");
	        return;
	      }
	      let base = _this4._presetItemMarkup;

	      _this4.presetsList.innerHTML = "";

	      for (let _ref of presets.entries()) {
	        var _ref2 = _slicedToArray(_ref, 2);

	        let index = _ref2[0];
	        let preset = _ref2[1];

	        let el = base.cloneNode(true);

	        var _el$children2 = _slicedToArray(el.children, 2);

	        let label = _el$children2[0];
	        let span = _el$children2[1];

	        el.dataset.id = index;

	        label.textContent = preset.name;
	        span.textContent = preset.value;

	        _this4.presetsList.appendChild(el);
	      }

	      _this4.emit("render");
	    });
	  },

	  /**
	    * returns definition of a filter as defined in filterList
	    *
	    * @param {String} name
	    *        filter name (e.g. blur)
	    * @return {Object}
	    *        filter's definition
	    */
	  _definition: function (name) {
	    name = name.toLowerCase();
	    return filterList.find(function (a) {
	      return a.name === name;
	    });
	  },

	  /**
	    * Parses the CSS value specified, updating widget's filters
	    *
	    * @param {String} cssValue
	    *        css value to be parsed
	    */
	  setCssValue: function (cssValue) {
	    if (!cssValue) {
	      throw new Error("Missing CSS filter value in setCssValue");
	    }

	    this.filters = [];

	    if (SPECIAL_VALUES.has(cssValue)) {
	      this._specialValue = cssValue;
	      this.emit("updated", this.getCssValue());
	      this.render();
	      return;
	    }

	    for (let _ref3 of tokenizeFilterValue(cssValue)) {
	      let name = _ref3.name;
	      let value = _ref3.value;
	      let quote = _ref3.quote;

	      // If the specified value is invalid, replace it with the
	      // default.
	      if (name !== "url") {
	        if (!DOMUtils.cssPropertyIsValid("filter", name + "(" + value + ")")) {
	          value = null;
	        }
	      }

	      this.add(name, value, quote);
	    }

	    this.emit("updated", this.getCssValue());
	    this.render();
	  },

	  /**
	    * Creates a new [name] filter record with value
	    *
	    * @param {String} name
	    *        filter name (e.g. blur)
	    * @param {String} value
	    *        value of the filter (e.g. 30px, 20%)
	    *        If this is |null|, then a default value may be supplied.
	    * @param {String} quote
	    *        For a url filter, the quoting style.  This can be a
	    *        single quote, a double quote, or empty.
	    * @return {Number}
	    *        The index of the new filter in the current list of filters
	    */
	  add: function (name, value, quote) {
	    const def = this._definition(name);
	    if (!def) {
	      return false;
	    }

	    if (value === null) {
	      // UNIT_MAPPING[string] is an empty string (falsy), so
	      // using || doesn't work here
	      const unitLabel = typeof UNIT_MAPPING[def.type] === "undefined" ? UNIT_MAPPING[DEFAULT_FILTER_TYPE] : UNIT_MAPPING[def.type];

	      // string-type filters have no default value but a placeholder instead
	      if (!unitLabel) {
	        value = "";
	      } else {
	        value = def.range[0] + unitLabel;
	      }

	      if (name === "url") {
	        // Default quote.
	        quote = "\"";
	      }
	    }

	    let unit = def.type === "string" ? "" : (/[a-zA-Z%]+/.exec(value) || [])[0];

	    if (def.type !== "string") {
	      value = parseFloat(value);

	      // You can omit percentage values' and use a value between 0..1
	      if (def.type === "percentage" && !unit) {
	        value = value * 100;
	        unit = "%";
	      }

	      var _def$range2 = _slicedToArray(def.range, 2);

	      const min = _def$range2[0];
	      const max = _def$range2[1];

	      if (value < min) {
	        value = min;
	      } else if (value > max) {
	        value = max;
	      }
	    }

	    const index = this.filters.push({ value, unit, name, quote }) - 1;
	    this.emit("updated", this.getCssValue());

	    return index;
	  },

	  /**
	    * returns value + unit of the specified filter
	    *
	    * @param {Number} index
	    *        filter index
	    * @return {String}
	    *        css value of filter
	    */
	  getValueAt: function (index) {
	    let filter = this.filters[index];
	    if (!filter) {
	      return null;
	    }

	    // Just return the value+unit for non-url functions.
	    if (filter.name !== "url") {
	      return filter.value + filter.unit;
	    }

	    // url values need to be quoted and escaped.
	    if (filter.quote === "'") {
	      return "'" + filter.value.replace(/\'/g, "\\'") + "'";
	    } else if (filter.quote === "\"") {
	      return "\"" + filter.value.replace(/\"/g, "\\\"") + "\"";
	    }

	    // Unquoted.  This approach might change the original input -- for
	    // example the original might be over-quoted.  But, this is
	    // correct and probably good enough.
	    return filter.value.replace(/[ \t(){};]/g, "\\$&");
	  },

	  removeAt: function (index) {
	    if (!this.filters[index]) {
	      return null;
	    }

	    this.filters.splice(index, 1);
	    this.emit("updated", this.getCssValue());
	    this.render();
	  },

	  /**
	    * Generates CSS filter value for filters of the widget
	    *
	    * @return {String}
	    *        css value of filters
	    */
	  getCssValue: function () {
	    var _this5 = this;

	    return this.filters.map(function (filter, i) {
	      return `${ filter.name }(${ _this5.getValueAt(i) })`;
	    }).join(" ") || this._specialValue || "none";
	  },

	  /**
	    * Updates specified filter's value
	    *
	    * @param {Number} index
	    *        The index of the filter in the current list of filters
	    * @param {number/string} value
	    *        value to set, string for string-typed filters
	    *        number for the rest (unit automatically determined)
	    */
	  updateValueAt: function (index, value) {
	    let filter = this.filters[index];
	    if (!filter) {
	      return;
	    }

	    const def = this._definition(filter.name);

	    if (def.type !== "string") {
	      var _def$range3 = _slicedToArray(def.range, 2);

	      const min = _def$range3[0];
	      const max = _def$range3[1];

	      if (value < min) {
	        value = min;
	      } else if (value > max) {
	        value = max;
	      }
	    }

	    filter.value = filter.unit ? fixFloat(value, true) : value;

	    this.emit("updated", this.getCssValue());
	  },

	  getPresets: function () {
	    return asyncStorage.getItem("cssFilterPresets").then(function (presets) {
	      if (!presets) {
	        return [];
	      }

	      return presets;
	    }, Cu.reportError);
	  },

	  setPresets: function (presets) {
	    return asyncStorage.setItem("cssFilterPresets", presets).catch(Cu.reportError);
	  }
	};

	// Fixes JavaScript's float precision
	function fixFloat(a, number) {
	  let fixed = parseFloat(a).toFixed(1);
	  return number ? parseFloat(fixed) : fixed;
	}

	/**
	 * Used to swap two filters' indexes
	 * after drag/drop re-ordering
	 *
	 * @param {Array} array
	 *        the array to swap elements of
	 * @param {Number} a
	 *        index of first element
	 * @param {Number} b
	 *        index of second element
	 */
	function swapArrayIndices(array, a, b) {
	  array[a] = array.splice(b, 1, array[a])[0];
	}

	/**
	 * Tokenizes a CSS Filter value and returns an array of {name, value} pairs.
	 *
	 * @param {String} css CSS Filter value to be parsed
	 * @return {Array} An array of {name, value} pairs
	 */
	function tokenizeFilterValue(css) {
	  let filters = [];
	  let depth = 0;

	  if (SPECIAL_VALUES.has(css)) {
	    return filters;
	  }

	  let state = "initial";
	  let name;
	  let contents;
	  for (let token of cssTokenizer(css)) {
	    switch (state) {
	      case "initial":
	        if (token.tokenType === "function") {
	          name = token.text;
	          contents = "";
	          state = "function";
	          depth = 1;
	        } else if (token.tokenType === "url" || token.tokenType === "bad_url") {
	          // Extract the quoting style from the url.
	          let originalText = css.substring(token.startOffset, token.endOffset);

	          var _$exec = /^url\([ \t\r\n\f]*(["']?)/i.exec(originalText);

	          var _$exec2 = _slicedToArray(_$exec, 2);

	          let quote = _$exec2[1];

	          filters.push({ name: "url", value: token.text.trim(), quote: quote });
	          // Leave state as "initial" because the URL token includes
	          // the trailing close paren.
	        }
	        break;

	      case "function":
	        if (token.tokenType === "symbol" && token.text === ")") {
	          --depth;
	          if (depth === 0) {
	            filters.push({ name: name, value: contents.trim() });
	            state = "initial";
	            break;
	          }
	        }
	        contents += css.substring(token.startOffset, token.endOffset);
	        if (token.tokenType === "function" || token.tokenType === "symbol" && token.text === "(") {
	          ++depth;
	        }
	        break;
	    }
	  }

	  return filters;
	}

	/**
	  * Finds neighbour number characters of an index in a string
	  * the numbers may be floats (containing dots)
	  * It's assumed that the value given to this function is a valid number
	  *
	  * @param {String} string
	  *        The string containing numbers
	  * @param {Number} index
	  *        The index to look for neighbours for
	  * @return {Object}
	  *         returns null if no number is found
	  *         value: The number found
	  *         start: The number's starting index
	  *         end: The number's ending index
	  */
	function getNeighbourNumber(string, index) {
	  if (!/\d/.test(string)) {
	    return null;
	  }

	  let left = /-?[0-9.]*$/.exec(string.slice(0, index));
	  let right = /-?[0-9.]*/.exec(string.slice(index));

	  left = left ? left[0] : "";
	  right = right ? right[0] : "";

	  if (!right && !left) {
	    return null;
	  }

	  return {
	    value: fixFloat(left + right, true),
	    start: index - left.length,
	    end: index + right.length
	  };
	}

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	const Ci = __webpack_require__(1);

	const PANE_APPEARANCE_DELAY = 50;
	const PAGE_SIZE_ITEM_COUNT_RATIO = 5;
	const WIDGET_FOCUSABLE_NODES = new Set(["vbox", "hbox"]);

	var _require = __webpack_require__(9);

	const Services = _require.Services;

	var _require2 = __webpack_require__(15);

	const XPCOMUtils = _require2.XPCOMUtils;

	const DevToolsUtils = __webpack_require__(19);
	const EventEmitter = __webpack_require__(7);

	/**
	 * Inheritance helpers from the addon SDK's core/heritage.
	 * Remove these when all devtools are loadered.
	 */
	var Heritage = {
	  /**
	   * @see extend in sdk/core/heritage.
	   */
	  extend: function (aPrototype, aProperties = {}) {
	    return Object.create(aPrototype, this.getOwnPropertyDescriptors(aProperties));
	  },

	  /**
	   * @see getOwnPropertyDescriptors in sdk/core/heritage.
	   */
	  getOwnPropertyDescriptors: function (aObject) {
	    return Object.getOwnPropertyNames(aObject).reduce(function (aDescriptor, aName) {
	      aDescriptor[aName] = Object.getOwnPropertyDescriptor(aObject, aName);
	      return aDescriptor;
	    }, {});
	  }
	};

	/**
	 * Helper for draining a rapid succession of events and invoking a callback
	 * once everything settles down.
	 *
	 * @param string aId
	 *        A string identifier for the named timeout.
	 * @param number aWait
	 *        The amount of milliseconds to wait after no more events are fired.
	 * @param function aCallback
	 *        Invoked when no more events are fired after the specified time.
	 */
	var setNamedTimeout = function setNamedTimeout(aId, aWait, aCallback) {
	  clearNamedTimeout(aId);

	  namedTimeoutsStore.set(aId, setTimeout(function () {
	    return namedTimeoutsStore.delete(aId) && aCallback();
	  }, aWait));
	};

	/**
	 * Clears a named timeout.
	 * @see setNamedTimeout
	 *
	 * @param string aId
	 *        A string identifier for the named timeout.
	 */
	var clearNamedTimeout = function clearNamedTimeout(aId) {
	  if (!namedTimeoutsStore) {
	    return;
	  }
	  clearTimeout(namedTimeoutsStore.get(aId));
	  namedTimeoutsStore.delete(aId);
	};

	/**
	 * Same as `setNamedTimeout`, but invokes the callback only if the provided
	 * predicate function returns true. Otherwise, the timeout is re-triggered.
	 *
	 * @param string aId
	 *        A string identifier for the conditional timeout.
	 * @param number aWait
	 *        The amount of milliseconds to wait after no more events are fired.
	 * @param function aPredicate
	 *        The predicate function used to determine whether the timeout restarts.
	 * @param function aCallback
	 *        Invoked when no more events are fired after the specified time, and
	 *        the provided predicate function returns true.
	 */
	var setConditionalTimeout = function setConditionalTimeout(aId, aWait, aPredicate, aCallback) {
	  setNamedTimeout(aId, aWait, function maybeCallback() {
	    if (aPredicate()) {
	      aCallback();
	      return;
	    }
	    setConditionalTimeout(aId, aWait, aPredicate, aCallback);
	  });
	};

	/**
	 * Clears a conditional timeout.
	 * @see setConditionalTimeout
	 *
	 * @param string aId
	 *        A string identifier for the conditional timeout.
	 */
	var clearConditionalTimeout = function clearConditionalTimeout(aId) {
	  clearNamedTimeout(aId);
	};

	var namedTimeoutsStore = new Map();

	/**
	 * Helpers for creating and messaging between UI components.
	 */
	var ViewHelpers = {
	  /**
	   * Convenience method, dispatching a custom event.
	   *
	   * @param nsIDOMNode aTarget
	   *        A custom target element to dispatch the event from.
	   * @param string aType
	   *        The name of the event.
	   * @param any aDetail
	   *        The data passed when initializing the event.
	   * @return boolean
	   *         True if the event was cancelled or a registered handler
	   *         called preventDefault.
	   */
	  dispatchEvent: function (aTarget, aType, aDetail) {
	    if (!(aTarget instanceof Ci.nsIDOMNode)) {
	      return true; // Event cancelled.
	    }
	    let document = aTarget.ownerDocument || aTarget;
	    let dispatcher = aTarget.ownerDocument ? aTarget : document.documentElement;

	    let event = document.createEvent("CustomEvent");
	    event.initCustomEvent(aType, true, true, aDetail);
	    return dispatcher.dispatchEvent(event);
	  },

	  /**
	   * Helper delegating some of the DOM attribute methods of a node to a widget.
	   *
	   * @param object aWidget
	   *        The widget to assign the methods to.
	   * @param nsIDOMNode aNode
	   *        A node to delegate the methods to.
	   */
	  delegateWidgetAttributeMethods: function (aWidget, aNode) {
	    aWidget.getAttribute = aWidget.getAttribute || aNode.getAttribute.bind(aNode);
	    aWidget.setAttribute = aWidget.setAttribute || aNode.setAttribute.bind(aNode);
	    aWidget.removeAttribute = aWidget.removeAttribute || aNode.removeAttribute.bind(aNode);
	  },

	  /**
	   * Helper delegating some of the DOM event methods of a node to a widget.
	   *
	   * @param object aWidget
	   *        The widget to assign the methods to.
	   * @param nsIDOMNode aNode
	   *        A node to delegate the methods to.
	   */
	  delegateWidgetEventMethods: function (aWidget, aNode) {
	    aWidget.addEventListener = aWidget.addEventListener || aNode.addEventListener.bind(aNode);
	    aWidget.removeEventListener = aWidget.removeEventListener || aNode.removeEventListener.bind(aNode);
	  },

	  /**
	   * Checks if the specified object looks like it's been decorated by an
	   * event emitter.
	   *
	   * @return boolean
	   *         True if it looks, walks and quacks like an event emitter.
	   */
	  isEventEmitter: function (aObject) {
	    return aObject && aObject.on && aObject.off && aObject.once && aObject.emit;
	  },

	  /**
	   * Checks if the specified object is an instance of a DOM node.
	   *
	   * @return boolean
	   *         True if it's a node, false otherwise.
	   */
	  isNode: function (aObject) {
	    return aObject instanceof Ci.nsIDOMNode || aObject instanceof Ci.nsIDOMElement || aObject instanceof Ci.nsIDOMDocumentFragment;
	  },

	  /**
	   * Prevents event propagation when navigation keys are pressed.
	   *
	   * @param Event e
	   *        The event to be prevented.
	   */
	  preventScrolling: function (e) {
	    switch (e.keyCode) {
	      case e.DOM_VK_UP:
	      case e.DOM_VK_DOWN:
	      case e.DOM_VK_LEFT:
	      case e.DOM_VK_RIGHT:
	      case e.DOM_VK_PAGE_UP:
	      case e.DOM_VK_PAGE_DOWN:
	      case e.DOM_VK_HOME:
	      case e.DOM_VK_END:
	        e.preventDefault();
	        e.stopPropagation();
	    }
	  },

	  /**
	   * Sets a side pane hidden or visible.
	   *
	   * @param object aFlags
	   *        An object containing some of the following properties:
	   *        - visible: true if the pane should be shown, false to hide
	   *        - animated: true to display an animation on toggle
	   *        - delayed: true to wait a few cycles before toggle
	   *        - callback: a function to invoke when the toggle finishes
	   * @param nsIDOMNode aPane
	   *        The element representing the pane to toggle.
	   */
	  togglePane: function (aFlags, aPane) {
	    // Make sure a pane is actually available first.
	    if (!aPane) {
	      return;
	    }

	    // Hiding is always handled via margins, not the hidden attribute.
	    aPane.removeAttribute("hidden");

	    // Add a class to the pane to handle min-widths, margins and animations.
	    if (!aPane.classList.contains("generic-toggled-side-pane")) {
	      aPane.classList.add("generic-toggled-side-pane");
	    }

	    // Avoid useless toggles.
	    if (aFlags.visible == !aPane.hasAttribute("pane-collapsed")) {
	      if (aFlags.callback) aFlags.callback();
	      return;
	    }

	    // The "animated" attributes enables animated toggles (slide in-out).
	    if (aFlags.animated) {
	      aPane.setAttribute("animated", "");
	    } else {
	      aPane.removeAttribute("animated");
	    }

	    // Computes and sets the pane margins in order to hide or show it.
	    let doToggle = function () {
	      if (aFlags.visible) {
	        aPane.style.marginLeft = "0";
	        aPane.style.marginRight = "0";
	        aPane.removeAttribute("pane-collapsed");
	      } else {
	        let margin = ~ ~aPane.getAttribute("width") + 1;
	        aPane.style.marginLeft = -margin + "px";
	        aPane.style.marginRight = -margin + "px";
	        aPane.setAttribute("pane-collapsed", "");
	      }

	      // Invoke the callback when the transition ended.
	      if (aFlags.animated) {
	        aPane.addEventListener("transitionend", function onEvent() {
	          aPane.removeEventListener("transitionend", onEvent, false);
	          if (aFlags.callback) aFlags.callback();
	        }, false);
	      }
	      // Invoke the callback immediately since there's no transition.
	      else {
	          if (aFlags.callback) aFlags.callback();
	        }
	    };

	    // Sometimes it's useful delaying the toggle a few ticks to ensure
	    // a smoother slide in-out animation.
	    if (aFlags.delayed) {
	      aPane.ownerDocument.defaultView.setTimeout(doToggle, PANE_APPEARANCE_DELAY);
	    } else {
	      doToggle();
	    }
	  }
	};

	/**
	 * Localization convenience methods.
	 *
	 * @param string aStringBundleName
	 *        The desired string bundle's name.
	 */
	ViewHelpers.L10N = function (aStringBundleName) {
	  this.stringBundle = Services.strings.createBundle(aStringBundleName);
	  this.ellipsis = "…"; // Should be l10n'd
	};

	ViewHelpers.L10N.prototype = {
	  stringBundle: null,
	  /**
	   * L10N shortcut function.
	   *
	   * @param string aName
	   * @return string
	   */
	  getStr: function (aName) {
	    return this.stringBundle.GetStringFromName(aName);
	  },

	  /**
	   * L10N shortcut function.
	   *
	   * @param string aName
	   * @param array aArgs
	   * @return string
	   */
	  getFormatStr: function (aName, ...aArgs) {
	    return this.stringBundle.formatStringFromName(aName, aArgs, aArgs.length);
	  },

	  /**
	   * L10N shortcut function for numeric arguments that need to be formatted.
	   * All numeric arguments will be fixed to 2 decimals and given a localized
	   * decimal separator. Other arguments will be left alone.
	   *
	   * @param string aName
	   * @param array aArgs
	   * @return string
	   */
	  getFormatStrWithNumbers: function (aName, ...aArgs) {
	    var _this = this;

	    let newArgs = aArgs.map(function (x) {
	      return typeof x == "number" ? _this.numberWithDecimals(x, 2) : x;
	    });
	    return this.stringBundle.formatStringFromName(aName, newArgs, newArgs.length);
	  },

	  /**
	   * Converts a number to a locale-aware string format and keeps a certain
	   * number of decimals.
	   *
	   * @param number aNumber
	   *        The number to convert.
	   * @param number aDecimals [optional]
	   *        Total decimals to keep.
	   * @return string
	   *         The localized number as a string.
	   */
	  numberWithDecimals: function (aNumber, aDecimals = 0) {
	    // If this is an integer, don't do anything special.
	    if (aNumber == (aNumber | 0)) {
	      return aNumber;
	    }
	    if (isNaN(aNumber) || aNumber == null) {
	      return "0";
	    }
	    let localized = aNumber.toLocaleString(); // localize

	    // If no grouping or decimal separators are available, bail out, because
	    // padding with zeros at the end of the string won't make sense anymore.
	    if (!localized.match(/[^\d]/)) {
	      return localized;
	    }

	    return aNumber.toLocaleString(undefined, {
	      maximumFractionDigits: aDecimals,
	      minimumFractionDigits: aDecimals
	    });
	  }
	};

	/**
	 * A helper for having the same interface as ViewHelpers.L10N, but for
	 * more than one file. Useful for abstracting l10n string locations.
	 */
	ViewHelpers.MultiL10N = function (aStringBundleNames) {
	  var _this2 = this;

	  let l10ns = aStringBundleNames.map(function (bundle) {
	    return new ViewHelpers.L10N(bundle);
	  });
	  let proto = ViewHelpers.L10N.prototype;

	  Object.getOwnPropertyNames(proto).map(function (name) {
	    return {
	      name: name,
	      desc: Object.getOwnPropertyDescriptor(proto, name)
	    };
	  }).filter(function (property) {
	    return property.desc.value instanceof Function;
	  }).forEach(function (method) {
	    _this2[method.name] = function (...args) {
	      for (let l10n of l10ns) {
	        try {
	          return method.desc.value.apply(l10n, args);
	        } catch (e) {}
	      }
	    };
	  });
	};

	/**
	 * Shortcuts for lazily accessing and setting various preferences.
	 * Usage:
	 *   let prefs = new ViewHelpers.Prefs("root.path.to.branch", {
	 *     myIntPref: ["Int", "leaf.path.to.my-int-pref"],
	 *     myCharPref: ["Char", "leaf.path.to.my-char-pref"],
	 *     myJsonPref: ["Json", "leaf.path.to.my-json-pref"],
	 *     myFloatPref: ["Float", "leaf.path.to.my-float-pref"]
	 *     ...
	 *   });
	 *
	 * Get/set:
	 *   prefs.myCharPref = "foo";
	 *   let aux = prefs.myCharPref;
	 *
	 * Observe:
	 *   prefs.registerObserver();
	 *   prefs.on("pref-changed", (prefName, prefValue) => {
	 *     ...
	 *   });
	 *
	 * @param string aPrefsRoot
	 *        The root path to the required preferences branch.
	 * @param object aPrefsBlueprint
	 *        An object containing { accessorName: [prefType, prefName] } keys.
	 * @param object aOptions
	 *        Additional options for this constructor. Currently supported:
	 *          - monitorChanges: true to update the stored values if they changed
	 *                            when somebody edits about:config or the prefs
	 *                            change somewhere else.
	 */
	ViewHelpers.Prefs = function (aPrefsRoot = "", aPrefsBlueprint = {}, aOptions = {}) {
	  EventEmitter.decorate(this);

	  this._cache = new Map();
	  let self = this;

	  for (let _ref of Iterator(aPrefsBlueprint)) {
	    var _ref2 = _slicedToArray(_ref, 2);

	    let accessorName = _ref2[0];

	    var _ref2$ = _slicedToArray(_ref2[1], 2);

	    let prefType = _ref2$[0];
	    let prefName = _ref2$[1];

	    this._map(accessorName, prefType, aPrefsRoot, prefName);
	  }

	  let observer = {
	    register: function () {
	      this.branch = Services.prefs.getBranch(aPrefsRoot + ".");
	      this.branch.addObserver("", this, false);
	    },
	    unregister: function () {
	      this.branch.removeObserver("", this);
	    },
	    observe: function (_, __, aPrefName) {
	      // If this particular pref isn't handled by the blueprint object,
	      // even though it's in the specified branch, ignore it.
	      let accessor = self._accessor(aPrefsBlueprint, aPrefName);
	      if (!(accessor in self)) {
	        return;
	      }
	      self._cache.delete(aPrefName);
	      self.emit("pref-changed", accessor, self[accessor]);
	    }
	  };

	  this.registerObserver = function () {
	    return observer.register();
	  };
	  this.unregisterObserver = function () {
	    return observer.unregister();
	  };

	  if (aOptions.monitorChanges) {
	    this.registerObserver();
	  }
	};

	ViewHelpers.Prefs.prototype = {
	  /**
	   * Helper method for getting a pref value.
	   *
	   * @param string aType
	   * @param string aPrefsRoot
	   * @param string aPrefName
	   * @return any
	   */
	  _get: function (aType, aPrefsRoot, aPrefName) {
	    let cachedPref = this._cache.get(aPrefName);
	    if (cachedPref !== undefined) {
	      return cachedPref;
	    }
	    let value = Services.prefs["get" + aType + "Pref"]([aPrefsRoot, aPrefName].join("."));
	    this._cache.set(aPrefName, value);
	    return value;
	  },

	  /**
	   * Helper method for setting a pref value.
	   *
	   * @param string aType
	   * @param string aPrefsRoot
	   * @param string aPrefName
	   * @param any aValue
	   */
	  _set: function (aType, aPrefsRoot, aPrefName, aValue) {
	    Services.prefs["set" + aType + "Pref"]([aPrefsRoot, aPrefName].join("."), aValue);
	    this._cache.set(aPrefName, aValue);
	  },

	  /**
	   * Maps a property name to a pref, defining lazy getters and setters.
	   * Supported types are "Bool", "Char", "Int", "Float" (sugar around "Char" type and casting),
	   * and "Json" (which is basically just sugar for "Char" using the standard JSON serializer).
	   *
	   * @param string aAccessorName
	   * @param string aType
	   * @param string aPrefsRoot
	   * @param string aPrefName
	   * @param array aSerializer
	   */
	  _map: function (aAccessorName, aType, aPrefsRoot, aPrefName, aSerializer = { in: function (e) {
	      return e;
	    }, out: function (e) {
	      return e;
	    } }) {
	    var _this3 = this;

	    if (aPrefName in this) {
	      throw new Error(`Can't use ${ aPrefName } because it's already a property.`);
	    }
	    if (aType == "Json") {
	      this._map(aAccessorName, "Char", aPrefsRoot, aPrefName, { in: JSON.parse, out: JSON.stringify });
	      return;
	    }
	    if (aType == "Float") {
	      this._map(aAccessorName, "Char", aPrefsRoot, aPrefName, { in: Number.parseFloat, out: function (n) {
	          return n + "";
	        } });
	      return;
	    }

	    Object.defineProperty(this, aAccessorName, {
	      get: function () {
	        return aSerializer.in(_this3._get(aType, aPrefsRoot, aPrefName));
	      },
	      set: function (e) {
	        return _this3._set(aType, aPrefsRoot, aPrefName, aSerializer.out(e));
	      }
	    });
	  },

	  /**
	   * Finds the accessor in this object for the provided property name,
	   * based on the blueprint object used in the constructor.
	   */
	  _accessor: function (aPrefsBlueprint, aPrefName) {
	    for (let _ref3 of Iterator(aPrefsBlueprint)) {
	      var _ref4 = _slicedToArray(_ref3, 2);

	      let accessorName = _ref4[0];

	      var _ref4$ = _slicedToArray(_ref4[1], 2);

	      let prefName = _ref4$[1];

	      if (prefName == aPrefName) {
	        return accessorName;
	      }
	    }
	    return null;
	  }
	};

	/**
	 * A generic Item is used to describe children present in a Widget.
	 *
	 * This is basically a very thin wrapper around an nsIDOMNode, with a few
	 * characteristics, like a `value` and an `attachment`.
	 *
	 * The characteristics are optional, and their meaning is entirely up to you.
	 * - The `value` should be a string, passed as an argument.
	 * - The `attachment` is any kind of primitive or object, passed as an argument.
	 *
	 * Iterable via "for (let childItem of parentItem) { }".
	 *
	 * @param object aOwnerView
	 *        The owner view creating this item.
	 * @param nsIDOMNode aElement
	 *        A prebuilt node to be wrapped.
	 * @param string aValue
	 *        A string identifying the node.
	 * @param any aAttachment
	 *        Some attached primitive/object.
	 */
	function Item(aOwnerView, aElement, aValue, aAttachment) {
	  this.ownerView = aOwnerView;
	  this.attachment = aAttachment;
	  this._value = aValue + "";
	  this._prebuiltNode = aElement;
	};

	Item.prototype = {
	  get value() {
	    return this._value;
	  },
	  get target() {
	    return this._target;
	  },
	  get prebuiltNode() {
	    return this._prebuiltNode;
	  },

	  /**
	   * Immediately appends a child item to this item.
	   *
	   * @param nsIDOMNode aElement
	   *        An nsIDOMNode representing the child element to append.
	   * @param object aOptions [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attachment: some attached primitive/object for the item
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function invoked when the child item is removed
	   * @return Item
	   *         The item associated with the displayed element.
	   */
	  append: function (aElement, aOptions = {}) {
	    let item = new Item(this, aElement, "", aOptions.attachment);

	    // Entangle the item with the newly inserted child node.
	    // Make sure this is done with the value returned by appendChild(),
	    // to avoid storing a potential DocumentFragment.
	    this._entangleItem(item, this._target.appendChild(aElement));

	    // Handle any additional options after entangling the item.
	    if (aOptions.attributes) {
	      aOptions.attributes.forEach(function (e) {
	        return item._target.setAttribute(e[0], e[1]);
	      });
	    }
	    if (aOptions.finalize) {
	      item.finalize = aOptions.finalize;
	    }

	    // Return the item associated with the displayed element.
	    return item;
	  },

	  /**
	   * Immediately removes the specified child item from this item.
	   *
	   * @param Item aItem
	   *        The item associated with the element to remove.
	   */
	  remove: function (aItem) {
	    if (!aItem) {
	      return;
	    }
	    this._target.removeChild(aItem._target);
	    this._untangleItem(aItem);
	  },

	  /**
	   * Entangles an item (model) with a displayed node element (view).
	   *
	   * @param Item aItem
	   *        The item describing a target element.
	   * @param nsIDOMNode aElement
	   *        The element displaying the item.
	   */
	  _entangleItem: function (aItem, aElement) {
	    this._itemsByElement.set(aElement, aItem);
	    aItem._target = aElement;
	  },

	  /**
	   * Untangles an item (model) from a displayed node element (view).
	   *
	   * @param Item aItem
	   *        The item describing a target element.
	   */
	  _untangleItem: function (aItem) {
	    if (aItem.finalize) {
	      aItem.finalize(aItem);
	    }
	    for (let childItem of aItem) {
	      aItem.remove(childItem);
	    }

	    this._unlinkItem(aItem);
	    aItem._target = null;
	  },

	  /**
	   * Deletes an item from the its parent's storage maps.
	   *
	   * @param Item aItem
	   *        The item describing a target element.
	   */
	  _unlinkItem: function (aItem) {
	    this._itemsByElement.delete(aItem._target);
	  },

	  /**
	   * Returns a string representing the object.
	   * Avoid using `toString` to avoid accidental JSONification.
	   * @return string
	   */
	  stringify: function () {
	    return JSON.stringify({
	      value: this._value,
	      target: this._target + "",
	      prebuiltNode: this._prebuiltNode + "",
	      attachment: this.attachment
	    }, null, 2);
	  },

	  _value: "",
	  _target: null,
	  _prebuiltNode: null,
	  finalize: null,
	  attachment: null
	};

	// Creating maps thousands of times for widgets with a large number of children
	// fills up a lot of memory. Make sure these are instantiated only if needed.
	DevToolsUtils.defineLazyPrototypeGetter(Item.prototype, "_itemsByElement", function () {
	  return new Map();
	});

	/**
	 * Some generic Widget methods handling Item instances.
	 * Iterable via "for (let childItem of wrappedView) { }".
	 *
	 * Usage:
	 *   function MyView() {
	 *     this.widget = new MyWidget(document.querySelector(".my-node"));
	 *   }
	 *
	 *   MyView.prototype = Heritage.extend(WidgetMethods, {
	 *     myMethod: function() {},
	 *     ...
	 *   });
	 *
	 * See https://gist.github.com/victorporof/5749386 for more details.
	 * The devtools/shared/widgets/SimpleListWidget.js is an implementation example.
	 *
	 * Language:
	 *   - An "item" is an instance of an Item.
	 *   - An "element" or "node" is a nsIDOMNode.
	 *
	 * The supplied widget can be any object implementing the following methods:
	 *   - function:nsIDOMNode insertItemAt(aIndex:number, aNode:nsIDOMNode, aValue:string)
	 *   - function:nsIDOMNode getItemAtIndex(aIndex:number)
	 *   - function removeChild(aChild:nsIDOMNode)
	 *   - function removeAllItems()
	 *   - get:nsIDOMNode selectedItem()
	 *   - set selectedItem(aChild:nsIDOMNode)
	 *   - function getAttribute(aName:string)
	 *   - function setAttribute(aName:string, aValue:string)
	 *   - function removeAttribute(aName:string)
	 *   - function addEventListener(aName:string, aCallback:function, aBubbleFlag:boolean)
	 *   - function removeEventListener(aName:string, aCallback:function, aBubbleFlag:boolean)
	 *
	 * Optional methods that can be implemented by the widget:
	 *   - function ensureElementIsVisible(aChild:nsIDOMNode)
	 *
	 * Optional attributes that may be handled (when calling get/set/removeAttribute):
	 *   - "emptyText": label temporarily added when there are no items present
	 *   - "headerText": label permanently added as a header
	 *
	 * For automagical keyboard and mouse accessibility, the widget should be an
	 * event emitter with the following events:
	 *   - "keyPress" -> (aName:string, aEvent:KeyboardEvent)
	 *   - "mousePress" -> (aName:string, aEvent:MouseEvent)
	 */
	var WidgetMethods = {
	  /**
	   * Sets the element node or widget associated with this container.
	   * @param nsIDOMNode | object aWidget
	   */
	  set widget(aWidget) {
	    this._widget = aWidget;

	    // Can't use a WeakMap for _itemsByValue because keys are strings, and
	    // can't use one for _itemsByElement either, since it needs to be iterable.
	    XPCOMUtils.defineLazyGetter(this, "_itemsByValue", function () {
	      return new Map();
	    });
	    XPCOMUtils.defineLazyGetter(this, "_itemsByElement", function () {
	      return new Map();
	    });
	    XPCOMUtils.defineLazyGetter(this, "_stagedItems", function () {
	      return [];
	    });

	    // Handle internal events emitted by the widget if necessary.
	    if (ViewHelpers.isEventEmitter(aWidget)) {
	      aWidget.on("keyPress", this._onWidgetKeyPress.bind(this));
	      aWidget.on("mousePress", this._onWidgetMousePress.bind(this));
	    }
	  },

	  /**
	   * Gets the element node or widget associated with this container.
	   * @return nsIDOMNode | object
	   */
	  get widget() {
	    return this._widget;
	  },

	  /**
	   * Prepares an item to be added to this container. This allows, for example,
	   * for a large number of items to be batched up before being sorted & added.
	   *
	   * If the "staged" flag is *not* set to true, the item will be immediately
	   * inserted at the correct position in this container, so that all the items
	   * still remain sorted. This can (possibly) be much slower than batching up
	   * multiple items.
	   *
	   * By default, this container assumes that all the items should be displayed
	   * sorted by their value. This can be overridden with the "index" flag,
	   * specifying on which position should an item be appended. The "staged" and
	   * "index" flags are mutually exclusive, meaning that all staged items
	   * will always be appended.
	   *
	   * @param nsIDOMNode aElement
	   *        A prebuilt node to be wrapped.
	   * @param string aValue
	   *        A string identifying the node.
	   * @param object aOptions [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attachment: some attached primitive/object for the item
	   *          - staged: true to stage the item to be appended later
	   *          - index: specifies on which position should the item be appended
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function invoked when the item is removed
	   * @return Item
	   *         The item associated with the displayed element if an unstaged push,
	   *         undefined if the item was staged for a later commit.
	   */
	  push: function ([aElement, aValue], aOptions = {}) {
	    let item = new Item(this, aElement, aValue, aOptions.attachment);

	    // Batch the item to be added later.
	    if (aOptions.staged) {
	      // An ulterior commit operation will ignore any specified index, so
	      // no reason to keep it around.
	      aOptions.index = undefined;
	      return void this._stagedItems.push({ item: item, options: aOptions });
	    }
	    // Find the target position in this container and insert the item there.
	    if (!("index" in aOptions)) {
	      return this._insertItemAt(this._findExpectedIndexFor(item), item, aOptions);
	    }
	    // Insert the item at the specified index. If negative or out of bounds,
	    // the item will be simply appended.
	    return this._insertItemAt(aOptions.index, item, aOptions);
	  },

	  /**
	   * Flushes all the prepared items into this container.
	   * Any specified index on the items will be ignored. Everything is appended.
	   *
	   * @param object aOptions [optional]
	   *        Additional options or flags supported by this operation:
	   *          - sorted: true to sort all the items before adding them
	   */
	  commit: function (aOptions = {}) {
	    var _this4 = this;

	    let stagedItems = this._stagedItems;

	    // Sort the items before adding them to this container, if preferred.
	    if (aOptions.sorted) {
	      stagedItems.sort(function (a, b) {
	        return _this4._currentSortPredicate(a.item, b.item);
	      });
	    }
	    // Append the prepared items to this container.
	    for (let _ref5 of stagedItems) {
	      let item = _ref5.item;
	      let options = _ref5.options;

	      this._insertItemAt(-1, item, options);
	    }
	    // Recreate the temporary items list for ulterior pushes.
	    this._stagedItems.length = 0;
	  },

	  /**
	   * Immediately removes the specified item from this container.
	   *
	   * @param Item aItem
	   *        The item associated with the element to remove.
	   */
	  remove: function (aItem) {
	    if (!aItem) {
	      return;
	    }
	    this._widget.removeChild(aItem._target);
	    this._untangleItem(aItem);

	    if (!this._itemsByElement.size) {
	      this._preferredValue = this.selectedValue;
	      this._widget.selectedItem = null;
	      this._widget.setAttribute("emptyText", this._emptyText);
	    }
	  },

	  /**
	   * Removes the item at the specified index from this container.
	   *
	   * @param number aIndex
	   *        The index of the item to remove.
	   */
	  removeAt: function (aIndex) {
	    this.remove(this.getItemAtIndex(aIndex));
	  },

	  /**
	   * Removes the items in this container based on a predicate.
	   */
	  removeForPredicate: function (aPredicate) {
	    let item;
	    while (item = this.getItemForPredicate(aPredicate)) {
	      this.remove(item);
	    }
	  },

	  /**
	   * Removes all items from this container.
	   */
	  empty: function () {
	    this._preferredValue = this.selectedValue;
	    this._widget.selectedItem = null;
	    this._widget.removeAllItems();
	    this._widget.setAttribute("emptyText", this._emptyText);

	    for (let _ref6 of this._itemsByElement) {
	      var _ref7 = _slicedToArray(_ref6, 2);

	      let item = _ref7[1];

	      this._untangleItem(item);
	    }

	    this._itemsByValue.clear();
	    this._itemsByElement.clear();
	    this._stagedItems.length = 0;
	  },

	  /**
	   * Ensures the specified item is visible in this container.
	   *
	   * @param Item aItem
	   *        The item to bring into view.
	   */
	  ensureItemIsVisible: function (aItem) {
	    this._widget.ensureElementIsVisible(aItem._target);
	  },

	  /**
	   * Ensures the item at the specified index is visible in this container.
	   *
	   * @param number aIndex
	   *        The index of the item to bring into view.
	   */
	  ensureIndexIsVisible: function (aIndex) {
	    this.ensureItemIsVisible(this.getItemAtIndex(aIndex));
	  },

	  /**
	   * Sugar for ensuring the selected item is visible in this container.
	   */
	  ensureSelectedItemIsVisible: function () {
	    this.ensureItemIsVisible(this.selectedItem);
	  },

	  /**
	   * If supported by the widget, the label string temporarily added to this
	   * container when there are no child items present.
	   */
	  set emptyText(aValue) {
	    this._emptyText = aValue;

	    // Apply the emptyText attribute right now if there are no child items.
	    if (!this._itemsByElement.size) {
	      this._widget.setAttribute("emptyText", aValue);
	    }
	  },

	  /**
	   * If supported by the widget, the label string permanently added to this
	   * container as a header.
	   * @param string aValue
	   */
	  set headerText(aValue) {
	    this._headerText = aValue;
	    this._widget.setAttribute("headerText", aValue);
	  },

	  /**
	   * Toggles all the items in this container hidden or visible.
	   *
	   * This does not change the default filtering predicate, so newly inserted
	   * items will always be visible. Use WidgetMethods.filterContents if you care.
	   *
	   * @param boolean aVisibleFlag
	   *        Specifies the intended visibility.
	   */
	  toggleContents: function (aVisibleFlag) {
	    for (let _ref8 of this._itemsByElement) {
	      var _ref9 = _slicedToArray(_ref8, 2);

	      let element = _ref9[0];
	      let item = _ref9[1];

	      element.hidden = !aVisibleFlag;
	    }
	  },

	  /**
	   * Toggles all items in this container hidden or visible based on a predicate.
	   *
	   * @param function aPredicate [optional]
	   *        Items are toggled according to the return value of this function,
	   *        which will become the new default filtering predicate in this container.
	   *        If unspecified, all items will be toggled visible.
	   */
	  filterContents: function (aPredicate = this._currentFilterPredicate) {
	    this._currentFilterPredicate = aPredicate;

	    for (let _ref10 of this._itemsByElement) {
	      var _ref11 = _slicedToArray(_ref10, 2);

	      let element = _ref11[0];
	      let item = _ref11[1];

	      element.hidden = !aPredicate(item);
	    }
	  },

	  /**
	   * Sorts all the items in this container based on a predicate.
	   *
	   * @param function aPredicate [optional]
	   *        Items are sorted according to the return value of the function,
	   *        which will become the new default sorting predicate in this container.
	   *        If unspecified, all items will be sorted by their value.
	   */
	  sortContents: function (aPredicate = this._currentSortPredicate) {
	    let sortedItems = this.items.sort(this._currentSortPredicate = aPredicate);

	    for (let i = 0, len = sortedItems.length; i < len; i++) {
	      this.swapItems(this.getItemAtIndex(i), sortedItems[i]);
	    }
	  },

	  /**
	   * Visually swaps two items in this container.
	   *
	   * @param Item aFirst
	   *        The first item to be swapped.
	   * @param Item aSecond
	   *        The second item to be swapped.
	   */
	  swapItems: function (aFirst, aSecond) {
	    if (aFirst == aSecond) {
	      // We're just dandy, thank you.
	      return;
	    }
	    let firstPrebuiltTarget = aFirst._prebuiltNode;
	    let firstTarget = aFirst._target;
	    let secondPrebuiltTarget = aSecond._prebuiltNode;
	    let secondTarget = aSecond._target;

	    // If the two items were constructed with prebuilt nodes as DocumentFragments,
	    // then those DocumentFragments are now empty and need to be reassembled.

	    if (firstPrebuiltTarget instanceof Ci.nsIDOMDocumentFragment) {
	      for (let node of firstTarget.childNodes) {
	        firstPrebuiltTarget.appendChild(node.cloneNode(true));
	      }
	    }
	    if (secondPrebuiltTarget instanceof Ci.nsIDOMDocumentFragment) {
	      for (let node of secondTarget.childNodes) {
	        secondPrebuiltTarget.appendChild(node.cloneNode(true));
	      }
	    }

	    // 1. Get the indices of the two items to swap.
	    let i = this._indexOfElement(firstTarget);
	    let j = this._indexOfElement(secondTarget);

	    // 2. Remeber the selection index, to reselect an item, if necessary.
	    let selectedTarget = this._widget.selectedItem;
	    let selectedIndex = -1;
	    if (selectedTarget == firstTarget) {
	      selectedIndex = i;
	    } else if (selectedTarget == secondTarget) {
	      selectedIndex = j;
	    }

	    // 3. Silently nuke both items, nobody needs to know about this.
	    this._widget.removeChild(firstTarget);
	    this._widget.removeChild(secondTarget);
	    this._unlinkItem(aFirst);
	    this._unlinkItem(aSecond);

	    // 4. Add the items again, but reversing their indices.
	    this._insertItemAt.apply(this, i < j ? [i, aSecond] : [j, aFirst]);
	    this._insertItemAt.apply(this, i < j ? [j, aFirst] : [i, aSecond]);

	    // 5. Restore the previous selection, if necessary.
	    if (selectedIndex == i) {
	      this._widget.selectedItem = aFirst._target;
	    } else if (selectedIndex == j) {
	      this._widget.selectedItem = aSecond._target;
	    }

	    // 6. Let the outside world know that these two items were swapped.
	    ViewHelpers.dispatchEvent(aFirst.target, "swap", [aSecond, aFirst]);
	  },

	  /**
	   * Visually swaps two items in this container at specific indices.
	   *
	   * @param number aFirst
	   *        The index of the first item to be swapped.
	   * @param number aSecond
	   *        The index of the second item to be swapped.
	   */
	  swapItemsAtIndices: function (aFirst, aSecond) {
	    this.swapItems(this.getItemAtIndex(aFirst), this.getItemAtIndex(aSecond));
	  },

	  /**
	   * Checks whether an item with the specified value is among the elements
	   * shown in this container.
	   *
	   * @param string aValue
	   *        The item's value.
	   * @return boolean
	   *         True if the value is known, false otherwise.
	   */
	  containsValue: function (aValue) {
	    return this._itemsByValue.has(aValue) || this._stagedItems.some(function ({ item }) {
	      return item._value == aValue;
	    });
	  },

	  /**
	   * Gets the "preferred value". This is the latest selected item's value,
	   * remembered just before emptying this container.
	   * @return string
	   */
	  get preferredValue() {
	    return this._preferredValue;
	  },

	  /**
	   * Retrieves the item associated with the selected element.
	   * @return Item | null
	   */
	  get selectedItem() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement);
	    }
	    return null;
	  },

	  /**
	   * Retrieves the selected element's index in this container.
	   * @return number
	   */
	  get selectedIndex() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._indexOfElement(selectedElement);
	    }
	    return -1;
	  },

	  /**
	   * Retrieves the value of the selected element.
	   * @return string
	   */
	  get selectedValue() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement)._value;
	    }
	    return "";
	  },

	  /**
	   * Retrieves the attachment of the selected element.
	   * @return object | null
	   */
	  get selectedAttachment() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement).attachment;
	    }
	    return null;
	  },

	  /**
	   * Selects the element with the entangled item in this container.
	   * @param Item | function aItem
	   */
	  set selectedItem(aItem) {
	    // A predicate is allowed to select a specific item.
	    // If no item is matched, then the current selection is removed.
	    if (typeof aItem == "function") {
	      aItem = this.getItemForPredicate(aItem);
	    }

	    // A falsy item is allowed to invalidate the current selection.
	    let targetElement = aItem ? aItem._target : null;
	    let prevElement = this._widget.selectedItem;

	    // Make sure the selected item's target element is focused and visible.
	    if (this.autoFocusOnSelection && targetElement) {
	      targetElement.focus();
	    }
	    if (this.maintainSelectionVisible && targetElement) {
	      // Some methods are optional. See the WidgetMethods object documentation
	      // for a comprehensive list.
	      if ("ensureElementIsVisible" in this._widget) {
	        this._widget.ensureElementIsVisible(targetElement);
	      }
	    }

	    // Prevent selecting the same item again and avoid dispatching
	    // a redundant selection event, so return early.
	    if (targetElement != prevElement) {
	      this._widget.selectedItem = targetElement;
	      let dispTarget = targetElement || prevElement;
	      let dispName = this.suppressSelectionEvents ? "suppressed-select" : "select";
	      ViewHelpers.dispatchEvent(dispTarget, dispName, aItem);
	    }
	  },

	  /**
	   * Selects the element at the specified index in this container.
	   * @param number aIndex
	   */
	  set selectedIndex(aIndex) {
	    let targetElement = this._widget.getItemAtIndex(aIndex);
	    if (targetElement) {
	      this.selectedItem = this._itemsByElement.get(targetElement);
	      return;
	    }
	    this.selectedItem = null;
	  },

	  /**
	   * Selects the element with the specified value in this container.
	   * @param string aValue
	   */
	  set selectedValue(aValue) {
	    this.selectedItem = this._itemsByValue.get(aValue);
	  },

	  /**
	   * Deselects and re-selects an item in this container.
	   *
	   * Useful when you want a "select" event to be emitted, even though
	   * the specified item was already selected.
	   *
	   * @param Item | function aItem
	   * @see `set selectedItem`
	   */
	  forceSelect: function (aItem) {
	    this.selectedItem = null;
	    this.selectedItem = aItem;
	  },

	  /**
	   * Specifies if this container should try to keep the selected item visible.
	   * (For example, when new items are added the selection is brought into view).
	   */
	  maintainSelectionVisible: true,

	  /**
	   * Specifies if "select" events dispatched from the elements in this container
	   * when their respective items are selected should be suppressed or not.
	   *
	   * If this flag is set to true, then consumers of this container won't
	   * be normally notified when items are selected.
	   */
	  suppressSelectionEvents: false,

	  /**
	   * Focus this container the first time an element is inserted?
	   *
	   * If this flag is set to true, then when the first item is inserted in
	   * this container (and thus it's the only item available), its corresponding
	   * target element is focused as well.
	   */
	  autoFocusOnFirstItem: true,

	  /**
	   * Focus on selection?
	   *
	   * If this flag is set to true, then whenever an item is selected in
	   * this container (e.g. via the selectedIndex or selectedItem setters),
	   * its corresponding target element is focused as well.
	   *
	   * You can disable this flag, for example, to maintain a certain node
	   * focused but visually indicate a different selection in this container.
	   */
	  autoFocusOnSelection: true,

	  /**
	   * Focus on input (e.g. mouse click)?
	   *
	   * If this flag is set to true, then whenever an item receives user input in
	   * this container, its corresponding target element is focused as well.
	   */
	  autoFocusOnInput: true,

	  /**
	   * When focusing on input, allow right clicks?
	   * @see WidgetMethods.autoFocusOnInput
	   */
	  allowFocusOnRightClick: false,

	  /**
	   * The number of elements in this container to jump when Page Up or Page Down
	   * keys are pressed. If falsy, then the page size will be based on the
	   * number of visible items in the container.
	   */
	  pageSize: 0,

	  /**
	   * Focuses the first visible item in this container.
	   */
	  focusFirstVisibleItem: function () {
	    this.focusItemAtDelta(-this.itemCount);
	  },

	  /**
	   * Focuses the last visible item in this container.
	   */
	  focusLastVisibleItem: function () {
	    this.focusItemAtDelta(+this.itemCount);
	  },

	  /**
	   * Focuses the next item in this container.
	   */
	  focusNextItem: function () {
	    this.focusItemAtDelta(+1);
	  },

	  /**
	   * Focuses the previous item in this container.
	   */
	  focusPrevItem: function () {
	    this.focusItemAtDelta(-1);
	  },

	  /**
	   * Focuses another item in this container based on the index distance
	   * from the currently focused item.
	   *
	   * @param number aDelta
	   *        A scalar specifying by how many items should the selection change.
	   */
	  focusItemAtDelta: function (aDelta) {
	    // Make sure the currently selected item is also focused, so that the
	    // command dispatcher mechanism has a relative node to work with.
	    // If there's no selection, just select an item at a corresponding index
	    // (e.g. the first item in this container if aDelta <= 1).
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      selectedElement.focus();
	    } else {
	      this.selectedIndex = Math.max(0, aDelta - 1);
	      return;
	    }

	    let direction = aDelta > 0 ? "advanceFocus" : "rewindFocus";
	    let distance = Math.abs(Math[aDelta > 0 ? "ceil" : "floor"](aDelta));
	    while (distance--) {
	      if (!this._focusChange(direction)) {
	        break; // Out of bounds.
	      }
	    }

	    // Synchronize the selected item as being the currently focused element.
	    this.selectedItem = this.getItemForElement(this._focusedElement);
	  },

	  /**
	   * Focuses the next or previous item in this container.
	   *
	   * @param string aDirection
	   *        Either "advanceFocus" or "rewindFocus".
	   * @return boolean
	   *         False if the focus went out of bounds and the first or last item
	   *         in this container was focused instead.
	   */
	  _focusChange: function (aDirection) {
	    let commandDispatcher = this._commandDispatcher;
	    let prevFocusedElement = commandDispatcher.focusedElement;
	    let currFocusedElement;

	    do {
	      commandDispatcher.suppressFocusScroll = true;
	      commandDispatcher[aDirection]();
	      currFocusedElement = commandDispatcher.focusedElement;

	      // Make sure the newly focused item is a part of this container. If the
	      // focus goes out of bounds, revert the previously focused item.
	      if (!this.getItemForElement(currFocusedElement)) {
	        prevFocusedElement.focus();
	        return false;
	      }
	    } while (!WIDGET_FOCUSABLE_NODES.has(currFocusedElement.tagName));

	    // Focus remained within bounds.
	    return true;
	  },

	  /**
	   * Gets the command dispatcher instance associated with this container's DOM.
	   * If there are no items displayed in this container, null is returned.
	   * @return nsIDOMXULCommandDispatcher | null
	   */
	  get _commandDispatcher() {
	    if (this._cachedCommandDispatcher) {
	      return this._cachedCommandDispatcher;
	    }
	    let someElement = this._widget.getItemAtIndex(0);
	    if (someElement) {
	      let commandDispatcher = someElement.ownerDocument.commandDispatcher;
	      return this._cachedCommandDispatcher = commandDispatcher;
	    }
	    return null;
	  },

	  /**
	   * Gets the currently focused element in this container.
	   *
	   * @return nsIDOMNode
	   *         The focused element, or null if nothing is found.
	   */
	  get _focusedElement() {
	    let commandDispatcher = this._commandDispatcher;
	    if (commandDispatcher) {
	      return commandDispatcher.focusedElement;
	    }
	    return null;
	  },

	  /**
	   * Gets the item in the container having the specified index.
	   *
	   * @param number aIndex
	   *        The index used to identify the element.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemAtIndex: function (aIndex) {
	    return this.getItemForElement(this._widget.getItemAtIndex(aIndex));
	  },

	  /**
	   * Gets the item in the container having the specified value.
	   *
	   * @param string aValue
	   *        The value used to identify the element.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemByValue: function (aValue) {
	    return this._itemsByValue.get(aValue);
	  },

	  /**
	   * Gets the item in the container associated with the specified element.
	   *
	   * @param nsIDOMNode aElement
	   *        The element used to identify the item.
	   * @param object aFlags [optional]
	   *        Additional options for showing the source. Supported options:
	   *          - noSiblings: if siblings shouldn't be taken into consideration
	   *                        when searching for the associated item.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemForElement: function (aElement, aFlags = {}) {
	    while (aElement) {
	      let item = this._itemsByElement.get(aElement);

	      // Also search the siblings if allowed.
	      if (!aFlags.noSiblings) {
	        item = item || this._itemsByElement.get(aElement.nextElementSibling) || this._itemsByElement.get(aElement.previousElementSibling);
	      }
	      if (item) {
	        return item;
	      }
	      aElement = aElement.parentNode;
	    }
	    return null;
	  },

	  /**
	   * Gets a visible item in this container validating a specified predicate.
	   *
	   * @param function aPredicate
	   *        The first item which validates this predicate is returned
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemForPredicate: function (aPredicate, aOwner = this) {
	    // Recursively check the items in this widget for a predicate match.
	    for (let _ref12 of aOwner._itemsByElement) {
	      var _ref13 = _slicedToArray(_ref12, 2);

	      let element = _ref13[0];
	      let item = _ref13[1];

	      let match;
	      if (aPredicate(item) && !element.hidden) {
	        match = item;
	      } else {
	        match = this.getItemForPredicate(aPredicate, item);
	      }
	      if (match) {
	        return match;
	      }
	    }
	    // Also check the staged items. No need to do this recursively since
	    // they're not even appended to the view yet.
	    for (let _ref14 of this._stagedItems) {
	      let item = _ref14.item;

	      if (aPredicate(item)) {
	        return item;
	      }
	    }
	    return null;
	  },

	  /**
	   * Shortcut function for getItemForPredicate which works on item attachments.
	   * @see getItemForPredicate
	   */
	  getItemForAttachment: function (aPredicate, aOwner = this) {
	    return this.getItemForPredicate(function (e) {
	      return aPredicate(e.attachment);
	    });
	  },

	  /**
	   * Finds the index of an item in the container.
	   *
	   * @param Item aItem
	   *        The item get the index for.
	   * @return number
	   *         The index of the matched item, or -1 if nothing is found.
	   */
	  indexOfItem: function (aItem) {
	    return this._indexOfElement(aItem._target);
	  },

	  /**
	   * Finds the index of an element in the container.
	   *
	   * @param nsIDOMNode aElement
	   *        The element get the index for.
	   * @return number
	   *         The index of the matched element, or -1 if nothing is found.
	   */
	  _indexOfElement: function (aElement) {
	    for (let i = 0; i < this._itemsByElement.size; i++) {
	      if (this._widget.getItemAtIndex(i) == aElement) {
	        return i;
	      }
	    }
	    return -1;
	  },

	  /**
	   * Gets the total number of items in this container.
	   * @return number
	   */
	  get itemCount() {
	    return this._itemsByElement.size;
	  },

	  /**
	   * Returns a list of items in this container, in the displayed order.
	   * @return array
	   */
	  get items() {
	    let store = [];
	    let itemCount = this.itemCount;
	    for (let i = 0; i < itemCount; i++) {
	      store.push(this.getItemAtIndex(i));
	    }
	    return store;
	  },

	  /**
	   * Returns a list of values in this container, in the displayed order.
	   * @return array
	   */
	  get values() {
	    return this.items.map(function (e) {
	      return e._value;
	    });
	  },

	  /**
	   * Returns a list of attachments in this container, in the displayed order.
	   * @return array
	   */
	  get attachments() {
	    return this.items.map(function (e) {
	      return e.attachment;
	    });
	  },

	  /**
	   * Returns a list of all the visible (non-hidden) items in this container,
	   * in the displayed order
	   * @return array
	   */
	  get visibleItems() {
	    return this.items.filter(function (e) {
	      return !e._target.hidden;
	    });
	  },

	  /**
	   * Checks if an item is unique in this container. If an item's value is an
	   * empty string, "undefined" or "null", it is considered unique.
	   *
	   * @param Item aItem
	   *        The item for which to verify uniqueness.
	   * @return boolean
	   *         True if the item is unique, false otherwise.
	   */
	  isUnique: function (aItem) {
	    let value = aItem._value;
	    if (value == "" || value == "undefined" || value == "null") {
	      return true;
	    }
	    return !this._itemsByValue.has(value);
	  },

	  /**
	   * Checks if an item is eligible for this container. By default, this checks
	   * whether an item is unique and has a prebuilt target node.
	   *
	   * @param Item aItem
	   *        The item for which to verify eligibility.
	   * @return boolean
	   *         True if the item is eligible, false otherwise.
	   */
	  isEligible: function (aItem) {
	    return this.isUnique(aItem) && aItem._prebuiltNode;
	  },

	  /**
	   * Finds the expected item index in this container based on the default
	   * sort predicate.
	   *
	   * @param Item aItem
	   *        The item for which to get the expected index.
	   * @return number
	   *         The expected item index.
	   */
	  _findExpectedIndexFor: function (aItem) {
	    let itemCount = this.itemCount;
	    for (let i = 0; i < itemCount; i++) {
	      if (this._currentSortPredicate(this.getItemAtIndex(i), aItem) > 0) {
	        return i;
	      }
	    }
	    return itemCount;
	  },

	  /**
	   * Immediately inserts an item in this container at the specified index.
	   *
	   * @param number aIndex
	   *        The position in the container intended for this item.
	   * @param Item aItem
	   *        The item describing a target element.
	   * @param object aOptions [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function when the item is untangled (removed)
	   * @return Item
	   *         The item associated with the displayed element, null if rejected.
	   */
	  _insertItemAt: function (aIndex, aItem, aOptions = {}) {
	    if (!this.isEligible(aItem)) {
	      return null;
	    }

	    // Entangle the item with the newly inserted node.
	    // Make sure this is done with the value returned by insertItemAt(),
	    // to avoid storing a potential DocumentFragment.
	    let node = aItem._prebuiltNode;
	    let attachment = aItem.attachment;
	    this._entangleItem(aItem, this._widget.insertItemAt(aIndex, node, attachment));

	    // Handle any additional options after entangling the item.
	    if (!this._currentFilterPredicate(aItem)) {
	      aItem._target.hidden = true;
	    }
	    if (this.autoFocusOnFirstItem && this._itemsByElement.size == 1) {
	      aItem._target.focus();
	    }
	    if (aOptions.attributes) {
	      aOptions.attributes.forEach(function (e) {
	        return aItem._target.setAttribute(e[0], e[1]);
	      });
	    }
	    if (aOptions.finalize) {
	      aItem.finalize = aOptions.finalize;
	    }

	    // Hide the empty text if the selection wasn't lost.
	    this._widget.removeAttribute("emptyText");

	    // Return the item associated with the displayed element.
	    return aItem;
	  },

	  /**
	   * Entangles an item (model) with a displayed node element (view).
	   *
	   * @param Item aItem
	   *        The item describing a target element.
	   * @param nsIDOMNode aElement
	   *        The element displaying the item.
	   */
	  _entangleItem: function (aItem, aElement) {
	    this._itemsByValue.set(aItem._value, aItem);
	    this._itemsByElement.set(aElement, aItem);
	    aItem._target = aElement;
	  },

	  /**
	   * Untangles an item (model) from a displayed node element (view).
	   *
	   * @param Item aItem
	   *        The item describing a target element.
	   */
	  _untangleItem: function (aItem) {
	    if (aItem.finalize) {
	      aItem.finalize(aItem);
	    }
	    for (let childItem of aItem) {
	      aItem.remove(childItem);
	    }

	    this._unlinkItem(aItem);
	    aItem._target = null;
	  },

	  /**
	   * Deletes an item from the its parent's storage maps.
	   *
	   * @param Item aItem
	   *        The item describing a target element.
	   */
	  _unlinkItem: function (aItem) {
	    this._itemsByValue.delete(aItem._value);
	    this._itemsByElement.delete(aItem._target);
	  },

	  /**
	   * The keyPress event listener for this container.
	   * @param string aName
	   * @param KeyboardEvent aEvent
	   */
	  _onWidgetKeyPress: function (aName, aEvent) {
	    // Prevent scrolling when pressing navigation keys.
	    ViewHelpers.preventScrolling(aEvent);

	    switch (aEvent.keyCode) {
	      case aEvent.DOM_VK_UP:
	      case aEvent.DOM_VK_LEFT:
	        this.focusPrevItem();
	        return;
	      case aEvent.DOM_VK_DOWN:
	      case aEvent.DOM_VK_RIGHT:
	        this.focusNextItem();
	        return;
	      case aEvent.DOM_VK_PAGE_UP:
	        this.focusItemAtDelta(-(this.pageSize || this.itemCount / PAGE_SIZE_ITEM_COUNT_RATIO));
	        return;
	      case aEvent.DOM_VK_PAGE_DOWN:
	        this.focusItemAtDelta(+(this.pageSize || this.itemCount / PAGE_SIZE_ITEM_COUNT_RATIO));
	        return;
	      case aEvent.DOM_VK_HOME:
	        this.focusFirstVisibleItem();
	        return;
	      case aEvent.DOM_VK_END:
	        this.focusLastVisibleItem();
	        return;
	    }
	  },

	  /**
	   * The mousePress event listener for this container.
	   * @param string aName
	   * @param MouseEvent aEvent
	   */
	  _onWidgetMousePress: function (aName, aEvent) {
	    if (aEvent.button != 0 && !this.allowFocusOnRightClick) {
	      // Only allow left-click to trigger this event.
	      return;
	    }

	    let item = this.getItemForElement(aEvent.target);
	    if (item) {
	      // The container is not empty and we clicked on an actual item.
	      this.selectedItem = item;
	      // Make sure the current event's target element is also focused.
	      this.autoFocusOnInput && item._target.focus();
	    }
	  },

	  /**
	   * The predicate used when filtering items. By default, all items in this
	   * view are visible.
	   *
	   * @param Item aItem
	   *        The item passing through the filter.
	   * @return boolean
	   *         True if the item should be visible, false otherwise.
	   */
	  _currentFilterPredicate: function (aItem) {
	    return true;
	  },

	  /**
	   * The predicate used when sorting items. By default, items in this view
	   * are sorted by their label.
	   *
	   * @param Item aFirst
	   *        The first item used in the comparison.
	   * @param Item aSecond
	   *        The second item used in the comparison.
	   * @return number
	   *         -1 to sort aFirst to a lower index than aSecond
	   *          0 to leave aFirst and aSecond unchanged with respect to each other
	   *          1 to sort aSecond to a lower index than aFirst
	   */
	  _currentSortPredicate: function (aFirst, aSecond) {
	    return +(aFirst._value.toLowerCase() > aSecond._value.toLowerCase());
	  },

	  /**
	   * Call a method on this widget named `aMethodName`. Any further arguments are
	   * passed on to the method. Returns the result of the method call.
	   *
	   * @param String aMethodName
	   *        The name of the method you want to call.
	   * @param aArgs
	   *        Optional. Any arguments you want to pass through to the method.
	   */
	  callMethod: function (aMethodName, ...aArgs) {
	    return this._widget[aMethodName].apply(this._widget, aArgs);
	  },

	  _widget: null,
	  _emptyText: "",
	  _headerText: "",
	  _preferredValue: "",
	  _cachedCommandDispatcher: null
	};

	/**
	 * A generator-iterator over all the items in this container.
	 */
	Item.prototype[Symbol.iterator] = WidgetMethods[Symbol.iterator] = function* () {
	  yield* this._itemsByElement.values();
	};

	exports.Heritage = Heritage;
	exports.ViewHelpers = ViewHelpers;
	exports.WidgetMethods = WidgetMethods;
	exports.setNamedTimeout = setNamedTimeout;
	exports.clearNamedTimeout = clearNamedTimeout;
	exports.setConditionalTimeout = setConditionalTimeout;
	exports.clearConditionalTimeout = clearConditionalTimeout;

/***/ },
/* 61 */
/***/ function(module, exports) {

	module.exports = {
	  "emptyFilterList": "No filter specified",
	  "emptyPresetList": "You don't have any saved presets. You can store filter presets by choosing a name and saving them. Presets are quickly accessible and you can re-use them with ease.",
	  "addUsingList": "Add a filter using the list below",
	  "dropShadowPlaceholder": "x y radius color",
	  "dragHandleTooltipText": "Drag up or down to re-order filter",
	  "labelDragTooltipText": "Drag left or right to decrease or increase the value"
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 *
	 * Adapted from https://github.com/mozilla-b2g/gaia/blob/f09993563fb5fec4393eb71816ce76cb00463190/shared/js/async_storage.js
	 * (converted to use Promises instead of callbacks).
	 *
	 * This file defines an asynchronous version of the localStorage API, backed by
	 * an IndexedDB database.  It creates a global asyncStorage object that has
	 * methods like the localStorage object.
	 *
	 * To store a value use setItem:
	 *
	 *   asyncStorage.setItem("key", "value");
	 *
	 * This returns a promise in case you want confirmation that the value has been stored.
	 *
	 *  asyncStorage.setItem("key", "newvalue").then(function() {
	 *    console.log("new value stored");
	 *  });
	 *
	 * To read a value, call getItem(), but note that you must wait for a promise
	 * resolution for the value to be retrieved.
	 *
	 *  asyncStorage.getItem("key").then(function(value) {
	 *    console.log("The value of key is:", value);
	 *  });
	 *
	 * Note that unlike localStorage, asyncStorage does not allow you to store and
	 * retrieve values by setting and querying properties directly. You cannot just
	 * write asyncStorage.key; you have to explicitly call setItem() or getItem().
	 *
	 * removeItem(), clear(), length(), and key() are like the same-named methods of
	 * localStorage, and all return a promise.
	 *
	 * The asynchronous nature of getItem() makes it tricky to retrieve multiple
	 * values. But unlike localStorage, asyncStorage does not require the values you
	 * store to be strings.  So if you need to save multiple values and want to
	 * retrieve them together, in a single asynchronous operation, just group the
	 * values into a single object. The properties of this object may not include
	 * DOM elements, but they may include things like Blobs and typed arrays.
	 *
	 */

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;
	const Cr = _require.Cr;
	var _open = { open: function () {} };
	const indexedDB = _open.indexedDB; // require("sdk/indexed-db");

	const Promise = __webpack_require__(6);

	module.exports = (function () {
	  "use strict";

	  var DBNAME = "devtools-async-storage";
	  var DBVERSION = 1;
	  var STORENAME = "keyvaluepairs";
	  var db = null;

	  function withStore(type, onsuccess, onerror) {
	    if (db) {
	      var transaction = db.transaction(STORENAME, type);
	      var store = transaction.objectStore(STORENAME);
	      onsuccess(store);
	    } else {
	      var openreq = indexedDB.open(DBNAME, DBVERSION);
	      openreq.onerror = function withStoreOnError() {
	        onerror();
	      };
	      openreq.onupgradeneeded = function withStoreOnUpgradeNeeded() {
	        // First time setup: create an empty object store
	        openreq.result.createObjectStore(STORENAME);
	      };
	      openreq.onsuccess = function withStoreOnSuccess() {
	        db = openreq.result;
	        var transaction = db.transaction(STORENAME, type);
	        var store = transaction.objectStore(STORENAME);
	        onsuccess(store);
	      };
	    }
	  }

	  function getItem(key) {
	    return new Promise(function (resolve, reject) {
	      var req;
	      withStore("readonly", function (store) {
	        store.transaction.oncomplete = function onComplete() {
	          var value = req.result;
	          if (value === undefined) {
	            value = null;
	          }
	          resolve(value);
	        };
	        req = store.get(key);
	        req.onerror = function getItemOnError() {
	          reject("Error in asyncStorage.getItem(): ", req.error.name);
	        };
	      }, reject);
	    });
	  }

	  function setItem(key, value) {
	    return new Promise(function (resolve, reject) {
	      withStore("readwrite", function (store) {
	        store.transaction.oncomplete = resolve;
	        var req = store.put(value, key);
	        req.onerror = function setItemOnError() {
	          reject("Error in asyncStorage.setItem(): ", req.error.name);
	        };
	      }, reject);
	    });
	  }

	  function removeItem(key) {
	    return new Promise(function (resolve, reject) {
	      withStore("readwrite", function (store) {
	        store.transaction.oncomplete = resolve;
	        var req = store.delete(key);
	        req.onerror = function removeItemOnError() {
	          reject("Error in asyncStorage.removeItem(): ", req.error.name);
	        };
	      }, reject);
	    });
	  }

	  function clear() {
	    return new Promise(function (resolve, reject) {
	      withStore("readwrite", function (store) {
	        store.transaction.oncomplete = resolve;
	        var req = store.clear();
	        req.onerror = function clearOnError() {
	          reject("Error in asyncStorage.clear(): ", req.error.name);
	        };
	      }, reject);
	    });
	  }

	  function length() {
	    return new Promise(function (resolve, reject) {
	      var req;
	      withStore("readonly", function (store) {
	        store.transaction.oncomplete = function onComplete() {
	          resolve(req.result);
	        };
	        req = store.count();
	        req.onerror = function lengthOnError() {
	          reject("Error in asyncStorage.length(): ", req.error.name);
	        };
	      }, reject);
	    });
	  }

	  function key(n) {
	    return new Promise(function (resolve, reject) {
	      if (n < 0) {
	        resolve(null);
	        return;
	      }

	      var req;
	      withStore("readonly", function (store) {
	        store.transaction.oncomplete = function onComplete() {
	          var cursor = req.result;
	          resolve(cursor ? cursor.key : null);
	        };
	        var advanced = false;
	        req = store.openCursor();
	        req.onsuccess = function keyOnSuccess() {
	          var cursor = req.result;
	          if (!cursor) {
	            // this means there weren"t enough keys
	            return;
	          }
	          if (n === 0 || advanced) {
	            // Either 1) we have the first key, return it if that's what they
	            // wanted, or 2) we"ve got the nth key.
	            return;
	          }

	          // Otherwise, ask the cursor to skip ahead n records
	          advanced = true;
	          cursor.advance(n);
	        };
	        req.onerror = function keyOnError() {
	          reject("Error in asyncStorage.key(): ", req.error.name);
	        };
	      }, reject);
	    });
	  }

	  return {
	    getItem: getItem,
	    setItem: setItem,
	    removeItem: removeItem,
	    clear: clear,
	    length: length,
	    key: key
	  };
	})();

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	const COLOR_UNIT_PREF = "devtools.defaultColorUnit";

	const SPECIALVALUES = new Set(["currentcolor", "initial", "inherit", "transparent", "unset"]);

	/**
	 * This module is used to convert between various color types.
	 *
	 * Usage:
	 *   let {colorUtils} = require("devtools/shared/css-color");
	 *   let color = new colorUtils.CssColor("red");
	 *
	 *   color.authored === "red"
	 *   color.hasAlpha === false
	 *   color.valid === true
	 *   color.transparent === false // transparent has a special status.
	 *   color.name === "red"        // returns hex or rgba when no name available.
	 *   color.hex === "#f00"        // returns shortHex when available else returns
	 *                                  longHex. If alpha channel is present then we
	 *                                  return this.rgba.
	 *   color.longHex === "#ff0000" // If alpha channel is present then we return
	 *                                  this.rgba.
	 *   color.rgb === "rgb(255, 0, 0)" // If alpha channel is present then we return
	 *                                     this.rgba.
	 *   color.rgba === "rgba(255, 0, 0, 1)"
	 *   color.hsl === "hsl(0, 100%, 50%)"
	 *   color.hsla === "hsla(0, 100%, 50%, 1)" // If alpha channel is present
	 *                                             then we return this.rgba.
	 *
	 *   color.toString() === "#f00"; // Outputs the color type determined in the
	 *                                   COLOR_UNIT_PREF constant (above).
	 *   // Color objects can be reused
	 *   color.newColor("green") === "#0f0"; // true
	 *
	 *   Valid values for COLOR_UNIT_PREF are contained in CssColor.COLORUNIT.
	 */

	function CssColor(colorValue) {
	  this.newColor(colorValue);
	}

	module.exports.colorUtils = {
	  CssColor: CssColor,
	  rgbToHsl: rgbToHsl,
	  setAlpha: setAlpha,
	  classifyColor: classifyColor
	};

	/**
	 * Values used in COLOR_UNIT_PREF
	 */
	CssColor.COLORUNIT = {
	  "authored": "authored",
	  "hex": "hex",
	  "name": "name",
	  "rgb": "rgb",
	  "hsl": "hsl"
	};

	CssColor.prototype = {
	  _colorUnit: null,
	  _colorUnitUppercase: false,

	  // The value as-authored.
	  authored: null,
	  // A lower-cased copy of |authored|.
	  lowerCased: null,

	  get colorUnit() {
	    if (this._colorUnit === null) {
	      let defaultUnit = Services.prefs.getCharPref(COLOR_UNIT_PREF);
	      this._colorUnit = CssColor.COLORUNIT[defaultUnit];
	      this._colorUnitUppercase = this.authored === this.authored.toUpperCase();
	    }
	    return this._colorUnit;
	  },

	  set colorUnit(unit) {
	    this._colorUnit = unit;
	  },

	  /**
	   * If the current color unit pref is "authored", then set the
	   * default color unit from the given color.  Otherwise, leave the
	   * color unit untouched.
	   *
	   * @param {String} color The color to use
	   */
	  setAuthoredUnitFromColor: function (color) {
	    if (Services.prefs.getCharPref(COLOR_UNIT_PREF) === CssColor.COLORUNIT.authored) {
	      this._colorUnit = classifyColor(color);
	      this._colorUnitUppercase = color === color.toUpperCase();
	    }
	  },

	  get hasAlpha() {
	    if (!this.valid) {
	      return false;
	    }
	    return this._getRGBATuple().a !== 1;
	  },

	  get valid() {
	    return DOMUtils.isValidCSSColor(this.authored);
	  },

	  /**
	   * Return true for all transparent values e.g. rgba(0, 0, 0, 0).
	   */
	  get transparent() {
	    try {
	      let tuple = this._getRGBATuple();
	      return !(tuple.r || tuple.g || tuple.b || tuple.a);
	    } catch (e) {
	      return false;
	    }
	  },

	  get specialValue() {
	    return SPECIALVALUES.has(this.lowerCased) ? this.authored : null;
	  },

	  get name() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    try {
	      let tuple = this._getRGBATuple();

	      if (tuple.a !== 1) {
	        return this.rgb;
	      }
	      let r = tuple.r;
	      let g = tuple.g;
	      let b = tuple.b;

	      return DOMUtils.rgbToColorName(r, g, b);
	    } catch (e) {
	      return this.hex;
	    }
	  },

	  get hex() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.hasAlpha) {
	      return this.rgba;
	    }

	    let hex = this.longHex;
	    if (hex.charAt(1) == hex.charAt(2) && hex.charAt(3) == hex.charAt(4) && hex.charAt(5) == hex.charAt(6)) {
	      hex = "#" + hex.charAt(1) + hex.charAt(3) + hex.charAt(5);
	    }
	    return hex;
	  },

	  get longHex() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.hasAlpha) {
	      return this.rgba;
	    }

	    let tuple = this._getRGBATuple();
	    return "#" + ((1 << 24) + (tuple.r << 16) + (tuple.g << 8) + (tuple.b << 0)).toString(16).substr(-6);
	  },

	  get rgb() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (!this.hasAlpha) {
	      if (this.lowerCased.startsWith("rgb(")) {
	        // The color is valid and begins with rgb(.
	        return this.authored;
	      }
	      let tuple = this._getRGBATuple();
	      return "rgb(" + tuple.r + ", " + tuple.g + ", " + tuple.b + ")";
	    }
	    return this.rgba;
	  },

	  get rgba() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.lowerCased.startsWith("rgba(")) {
	      // The color is valid and begins with rgba(.
	      return this.authored;
	    }
	    let components = this._getRGBATuple();
	    return "rgba(" + components.r + ", " + components.g + ", " + components.b + ", " + components.a + ")";
	  },

	  get hsl() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.lowerCased.startsWith("hsl(")) {
	      // The color is valid and begins with hsl(.
	      return this.authored;
	    }
	    if (this.hasAlpha) {
	      return this.hsla;
	    }
	    return this._hsl();
	  },

	  get hsla() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.lowerCased.startsWith("hsla(")) {
	      // The color is valid and begins with hsla(.
	      return this.authored;
	    }
	    if (this.hasAlpha) {
	      let a = this._getRGBATuple().a;
	      return this._hsl(a);
	    }
	    return this._hsl(1);
	  },

	  /**
	   * Check whether the current color value is in the special list e.g.
	   * transparent or invalid.
	   *
	   * @return {String|Boolean}
	   *         - If the current color is a special value e.g. "transparent" then
	   *           return the color.
	   *         - If the color is invalid return an empty string.
	   *         - If the color is a regular color e.g. #F06 so we return false
	   *           to indicate that the color is neither invalid or special.
	   */
	  _getInvalidOrSpecialValue: function () {
	    if (this.specialValue) {
	      return this.specialValue;
	    }
	    if (!this.valid) {
	      return "";
	    }
	    return false;
	  },

	  /**
	   * Change color
	   *
	   * @param  {String} color
	   *         Any valid color string
	   */
	  newColor: function (color) {
	    // Store a lower-cased version of the color to help with format
	    // testing.  The original text is kept as well so it can be
	    // returned when needed.
	    this.lowerCased = color.toLowerCase();
	    this.authored = color;
	    return this;
	  },

	  nextColorUnit: function () {
	    // Reorder the formats array to have the current format at the
	    // front so we can cycle through.
	    let formats = ["authored", "hex", "hsl", "rgb", "name"];
	    let putOnEnd = formats.splice(0, formats.indexOf(this.colorUnit));
	    formats = formats.concat(putOnEnd);
	    let currentDisplayedColor = this[formats[0]];

	    for (let format of formats) {
	      if (this[format].toLowerCase() !== currentDisplayedColor.toLowerCase()) {
	        this.colorUnit = CssColor.COLORUNIT[format];
	        break;
	      }
	    }

	    return this.toString();
	  },

	  /**
	   * Return a string representing a color of type defined in COLOR_UNIT_PREF.
	   */
	  toString: function () {
	    let color;

	    switch (this.colorUnit) {
	      case CssColor.COLORUNIT.authored:
	        color = this.authored;
	        break;
	      case CssColor.COLORUNIT.hex:
	        color = this.hex;
	        break;
	      case CssColor.COLORUNIT.hsl:
	        color = this.hsl;
	        break;
	      case CssColor.COLORUNIT.name:
	        color = this.name;
	        break;
	      case CssColor.COLORUNIT.rgb:
	        color = this.rgb;
	        break;
	      default:
	        color = this.rgb;
	    }

	    if (this._colorUnitUppercase && this.colorUnit != CssColor.COLORUNIT.authored) {
	      color = color.toUpperCase();
	    }

	    return color;
	  },

	  /**
	   * Returns a RGBA 4-Tuple representation of a color or transparent as
	   * appropriate.
	   */
	  _getRGBATuple: function () {
	    let tuple = DOMUtils.colorToRGBA(this.authored);

	    tuple.a = parseFloat(tuple.a.toFixed(1));

	    return tuple;
	  },

	  _hsl: function (maybeAlpha) {
	    if (this.lowerCased.startsWith("hsl(") && maybeAlpha === undefined) {
	      // We can use it as-is.
	      return this.authored;
	    }

	    var _getRGBATuple = this._getRGBATuple();

	    let r = _getRGBATuple.r;
	    let g = _getRGBATuple.g;
	    let b = _getRGBATuple.b;

	    var _rgbToHsl = rgbToHsl([r, g, b]);

	    var _rgbToHsl2 = _slicedToArray(_rgbToHsl, 3);

	    let h = _rgbToHsl2[0];
	    let s = _rgbToHsl2[1];
	    let l = _rgbToHsl2[2];

	    if (maybeAlpha !== undefined) {
	      return "hsla(" + h + ", " + s + "%, " + l + "%, " + maybeAlpha + ")";
	    } else {
	      return "hsl(" + h + ", " + s + "%, " + l + "%)";
	    }
	  },

	  /**
	   * This method allows comparison of CssColor objects using ===.
	   */
	  valueOf: function () {
	    return this.rgba;
	  }
	};

	/**
	 * Convert rgb value to hsl
	 *
	 * @param {array} rgb
	 *         Array of rgb values
	 * @return {array}
	 *         Array of hsl values.
	 */
	function rgbToHsl([r, g, b]) {
	  r = r / 255;
	  g = g / 255;
	  b = b / 255;

	  let max = Math.max(r, g, b);
	  let min = Math.min(r, g, b);
	  let h;
	  let s;
	  let l = (max + min) / 2;

	  if (max == min) {
	    h = s = 0;
	  } else {
	    let d = max - min;
	    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

	    switch (max) {
	      case r:
	        h = (g - b) / d % 6;
	        break;
	      case g:
	        h = (b - r) / d + 2;
	        break;
	      case b:
	        h = (r - g) / d + 4;
	        break;
	    }
	    h *= 60;
	    if (h < 0) {
	      h += 360;
	    }
	  }

	  return [Math.round(h), Math.round(s * 100), Math.round(l * 100)];
	}

	/**
	 * Takes a color value of any type (hex, hsl, hsla, rgb, rgba)
	 * and an alpha value to generate an rgba string with the correct
	 * alpha value.
	 *
	 * @param  {String} colorValue
	 *         Color in the form of hex, hsl, hsla, rgb, rgba.
	 * @param  {Number} alpha
	 *         Alpha value for the color, between 0 and 1.
	 * @return {String}
	 *         Converted color with `alpha` value in rgba form.
	 */
	function setAlpha(colorValue, alpha) {
	  let color = new CssColor(colorValue);

	  // Throw if the color supplied is not valid.
	  if (!color.valid) {
	    throw new Error("Invalid color.");
	  }

	  // If an invalid alpha valid, just set to 1.
	  if (!(alpha >= 0 && alpha <= 1)) {
	    alpha = 1;
	  }

	  var _color$_getRGBATuple = color._getRGBATuple();

	  let r = _color$_getRGBATuple.r;
	  let g = _color$_getRGBATuple.g;
	  let b = _color$_getRGBATuple.b;

	  return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
	}

	/**
	 * Given a color, classify its type as one of the possible color
	 * units, as known by |CssColor.colorUnit|.
	 *
	 * @param  {String} value
	 *         The color, in any form accepted by CSS.
	 * @return {String}
	 *         The color classification, one of "rgb", "hsl", "hex", or "name".
	 */
	function classifyColor(value) {
	  value = value.toLowerCase();
	  if (value.startsWith("rgb(") || value.startsWith("rgba(")) {
	    return CssColor.COLORUNIT.rgb;
	  } else if (value.startsWith("hsl(") || value.startsWith("hsla(")) {
	    return CssColor.COLORUNIT.hsl;
	  } else if (/^#[0-9a-f]+$/.exec(value)) {
	    return CssColor.COLORUNIT.hex;
	  }
	  return CssColor.COLORUNIT.name;
	}

	// loader.lazyGetter(this, "DOMUtils", function () {
	//   return Cc("@mozilla.org/inspector/dom-utils;1").getService(Ci.inIDOMUtils);
	// });

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	'use strict';

	module.metadata = {
	  "stability": "unstable"
	};

	var getPrototypeOf = Object.getPrototypeOf;
	var getNames = function (x) {
	  return [...Object.getOwnPropertyNames(x), ...Object.getOwnPropertySymbols(x)];
	};
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var create = Object.create;
	var freeze = Object.freeze;
	var unbind = Function.call.bind(Function.bind, Function.call);

	// This shortcut makes sure that we do perform desired operations, even if
	// associated methods have being overridden on the used object.
	var owns = unbind(Object.prototype.hasOwnProperty);
	var apply = unbind(Function.prototype.apply);
	var slice = Array.slice || unbind(Array.prototype.slice);
	var reduce = Array.reduce || unbind(Array.prototype.reduce);
	var map = Array.map || unbind(Array.prototype.map);
	var concat = Array.concat || unbind(Array.prototype.concat);

	// Utility function to get own properties descriptor map.
	function getOwnPropertyDescriptors(object) {
	  return reduce(getNames(object), function (descriptor, name) {
	    descriptor[name] = getOwnPropertyDescriptor(object, name);
	    return descriptor;
	  }, {});
	}

	function isDataProperty(property) {
	  var value = property.value;
	  var type = typeof property.value;
	  return "value" in property && (type !== "object" || value === null) && type !== "function";
	}

	function getDataProperties(object) {
	  var properties = getOwnPropertyDescriptors(object);
	  return getNames(properties).reduce(function (result, name) {
	    var property = properties[name];
	    if (isDataProperty(property)) {
	      result[name] = {
	        value: property.value,
	        writable: true,
	        configurable: true,
	        enumerable: false
	      };
	    }
	    return result;
	  }, {});
	}

	/**
	 * Takes `source` object as an argument and returns identical object
	 * with the difference that all own properties will be non-enumerable
	 */
	function obscure(source) {
	  var descriptor = reduce(getNames(source), function (descriptor, name) {
	    var property = getOwnPropertyDescriptor(source, name);
	    property.enumerable = false;
	    descriptor[name] = property;
	    return descriptor;
	  }, {});
	  return create(getPrototypeOf(source), descriptor);
	}
	exports.obscure = obscure;

	/**
	 * Takes arbitrary number of source objects and returns fresh one, that
	 * inherits from the same prototype as a first argument and implements all
	 * own properties of all argument objects. If two or more argument objects
	 * have own properties with the same name, the property is overridden, with
	 * precedence from right to left, implying, that properties of the object on
	 * the left are overridden by a same named property of the object on the right.
	 */
	var mix = function (source) {
	  var descriptor = reduce(slice(arguments), function (descriptor, source) {
	    return reduce(getNames(source), function (descriptor, name) {
	      descriptor[name] = getOwnPropertyDescriptor(source, name);
	      return descriptor;
	    }, descriptor);
	  }, {});

	  return create(getPrototypeOf(source), descriptor);
	};
	exports.mix = mix;

	/**
	 * Returns a frozen object with that inherits from the given `prototype` and
	 * implements all own properties of the given `properties` object.
	 */
	function extend(prototype, properties) {
	  return create(prototype, getOwnPropertyDescriptors(properties));
	}
	exports.extend = extend;

	/**
	 * Returns a constructor function with a proper `prototype` setup. Returned
	 * constructor's `prototype` inherits from a given `options.extends` or
	 * `Class.prototype` if omitted and implements all the properties of the
	 * given `option`. If `options.implemens` array is passed, it's elements
	 * will be mixed into prototype as well. Also, `options.extends` can be
	 * a function or a prototype. If function than it's prototype is used as
	 * an ancestor of the prototype, if it's an object that it's used directly.
	 * Also `options.implements` may contain functions or objects, in case of
	 * functions their prototypes are used for mixing.
	 */
	var Class = new (function () {
	  function prototypeOf(input) {
	    return typeof input === 'function' ? input.prototype : input;
	  }
	  var none = freeze([]);

	  return function Class(options) {
	    // Create descriptor with normalized `options.extends` and
	    // `options.implements`.
	    var descriptor = {
	      // Normalize extends property of `options.extends` to a prototype object
	      // in case it's constructor. If property is missing that fallback to
	      // `Type.prototype`.
	      extends: owns(options, 'extends') ? prototypeOf(options.extends) : Class.prototype,
	      // Normalize `options.implements` to make sure that it's array of
	      // prototype objects instead of constructor functions.
	      implements: owns(options, 'implements') ? freeze(map(options.implements, prototypeOf)) : none
	    };

	    // Create array of property descriptors who's properties will be defined
	    // on the resulting prototype. Note: Using reflection `concat` instead of
	    // method as it may be overridden.
	    var descriptors = concat(descriptor.implements, options, descriptor, {
	      constructor: constructor
	    });

	    // Note: we use reflection `apply` in the constructor instead of method
	    // call since later may be overridden.
	    function constructor() {
	      var instance = create(prototype, attributes);
	      if (initialize) apply(initialize, instance, arguments);
	      return instance;
	    }
	    // Create `prototype` that inherits from given ancestor passed as
	    // `options.extends`, falling back to `Type.prototype`, implementing all
	    // properties of given `options.implements` and `options` itself.
	    var prototype = extend(descriptor.extends, mix.apply(mix, descriptors));
	    var initialize = prototype.initialize;

	    // Combine ancestor attributes with prototype's attributes so that
	    // ancestors attributes also become initializeable.
	    var attributes = mix(descriptor.extends.constructor.attributes || {}, getDataProperties(prototype));

	    constructor.attributes = attributes;
	    Object.defineProperty(constructor, 'prototype', {
	      configurable: false,
	      writable: false,
	      value: prototype
	    });
	    return constructor;
	  };
	})();
	Class.prototype = extend(null, obscure({
	  constructor: function constructor() {
	    this.initialize.apply(this, arguments);
	    return this;
	  },
	  initialize: function initialize() {
	    // Do your initialization logic here
	  },
	  // Copy useful properties from `Object.prototype`.
	  toString: Object.prototype.toString,
	  toLocaleString: Object.prototype.toLocaleString,
	  toSource: Object.prototype.toSource,
	  valueOf: Object.prototype.valueOf,
	  isPrototypeOf: Object.prototype.isPrototypeOf
	}));
	exports.Class = freeze(Class);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	const rgbToHsl = __webpack_require__(63).colorUtils.rgbToHsl;

	const Telemetry = __webpack_require__(8);
	const EventEmitter = __webpack_require__(7);
	const promise = __webpack_require__(6);
	//const {setTimeout, clearTimeout} = require("devtools/sham/timer");

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	loader.lazyGetter(this, "clipboardHelper", function () {
	  return Cc("@mozilla.org/widget/clipboardhelper;1").getService(Ci.nsIClipboardHelper);
	});

	loader.lazyGetter(this, "ssService", function () {
	  return Cc("@mozilla.org/content/style-sheet-service;1").getService(Ci.nsIStyleSheetService);
	});

	loader.lazyGetter(this, "ioService", function () {
	  return Cc("@mozilla.org/network/io-service;1").getService(Ci.nsIIOService);
	});

	loader.lazyGetter(this, "DOMUtils", function () {
	  return Cc("@mozilla.org/inspector/dom-utils;1").getService(Ci.inIDOMUtils);
	});

	loader.lazyGetter(this, "XULRuntime", function () {
	  return Cc("@mozilla.org/xre/app-info;1").getService(Ci.nsIXULRuntime);
	});

	loader.lazyGetter(this, "l10n", function () {
	  return Services.strings.createBundle("chrome://devtools/locale/eyedropper.properties");
	});

	const EYEDROPPER_URL = "chrome://devtools/content/eyedropper/eyedropper.xul";
	const CROSSHAIRS_URL = "chrome://devtools/content/eyedropper/crosshairs.css";
	const NOCURSOR_URL = "chrome://devtools/content/eyedropper/nocursor.css";

	const ZOOM_PREF = "devtools.eyedropper.zoom";
	const FORMAT_PREF = "devtools.defaultColorUnit";

	const CANVAS_WIDTH = 96;
	const CANVAS_OFFSET = 3; // equals the border width of the canvas.
	const CLOSE_DELAY = 750;

	const HEX_BOX_WIDTH = CANVAS_WIDTH + CANVAS_OFFSET * 2;
	const HSL_BOX_WIDTH = 158;

	/**
	 * Manage instances of eyedroppers for windows. Registering here isn't
	 * necessary for creating an eyedropper, but can be used for testing.
	 */
	var EyedropperManager = {
	  _instances: new WeakMap(),

	  getInstance: function (chromeWindow) {
	    return this._instances.get(chromeWindow);
	  },

	  createInstance: function (chromeWindow, options) {
	    var _this = this;

	    let dropper = this.getInstance(chromeWindow);
	    if (dropper) {
	      return dropper;
	    }

	    dropper = new Eyedropper(chromeWindow, options);
	    this._instances.set(chromeWindow, dropper);

	    dropper.on("destroy", function () {
	      _this.deleteInstance(chromeWindow);
	    });

	    return dropper;
	  },

	  deleteInstance: function (chromeWindow) {
	    this._instances.delete(chromeWindow);
	  }
	};

	exports.EyedropperManager = EyedropperManager;

	/**
	 * Eyedropper widget. Once opened, shows zoomed area above current pixel and
	 * displays the color value of the center pixel. Clicking on the window will
	 * close the widget and fire a 'select' event. If 'copyOnSelect' is true, the color
	 * will also be copied to the clipboard.
	 *
	 * let eyedropper = new Eyedropper(window);
	 * eyedropper.open();
	 *
	 * eyedropper.once("select", (ev, color) => {
	 *   console.log(color);  // "rgb(20, 50, 230)"
	 * })
	 *
	 * @param {DOMWindow} chromeWindow
	 *        window to inspect
	 * @param {object} opts
	 *        optional options object, with 'copyOnSelect', 'context'
	 */
	function Eyedropper(chromeWindow, opts = { copyOnSelect: true, context: "other" }) {
	  this.copyOnSelect = opts.copyOnSelect;

	  this._onFirstMouseMove = this._onFirstMouseMove.bind(this);
	  this._onMouseMove = this._onMouseMove.bind(this);
	  this._onMouseDown = this._onMouseDown.bind(this);
	  this._onKeyDown = this._onKeyDown.bind(this);
	  this._onFrameLoaded = this._onFrameLoaded.bind(this);

	  this._chromeWindow = chromeWindow;
	  this._chromeDocument = chromeWindow.document;

	  this._OS = XULRuntime.OS;

	  this._dragging = true;
	  this.loaded = false;

	  this._mouseMoveCounter = 0;

	  this.format = Services.prefs.getCharPref(FORMAT_PREF); // color value format
	  this.zoom = Services.prefs.getIntPref(ZOOM_PREF); // zoom level - integer

	  this._zoomArea = {
	    x: 0, // the left coordinate of the center of the inspected region
	    y: 0, // the top coordinate of the center of the inspected region
	    width: CANVAS_WIDTH, // width of canvas to draw zoomed area onto
	    height: CANVAS_WIDTH // height of canvas
	  };

	  let mm = this._contentTab.linkedBrowser.messageManager;
	  mm.loadFrameScript("resource://devtools/client/eyedropper/eyedropper-child.js", true);

	  // record if this was opened via the picker or standalone
	  var telemetry = new Telemetry();
	  if (opts.context == "command") {
	    telemetry.toolOpened("eyedropper");
	  } else if (opts.context == "menu") {
	    telemetry.toolOpened("menueyedropper");
	  } else if (opts.context == "picker") {
	    telemetry.toolOpened("pickereyedropper");
	  }

	  EventEmitter.decorate(this);
	}

	exports.Eyedropper = Eyedropper;

	Eyedropper.prototype = {
	  /**
	   * Get the number of cells (blown-up pixels) per direction in the grid.
	   */
	  get cellsWide() {
	    // Canvas will render whole "pixels" (cells) only, and an even
	    // number at that. Round up to the nearest even number of pixels.
	    let cellsWide = Math.ceil(this._zoomArea.width / this.zoom);
	    cellsWide += cellsWide % 2;

	    return cellsWide;
	  },

	  /**
	   * Get the size of each cell (blown-up pixel) in the grid.
	   */
	  get cellSize() {
	    return this._zoomArea.width / this.cellsWide;
	  },

	  /**
	   * Get index of cell in the center of the grid.
	   */
	  get centerCell() {
	    return Math.floor(this.cellsWide / 2);
	  },

	  /**
	   * Get color of center cell in the grid.
	   */
	  get centerColor() {
	    let x = y = this.centerCell * this.cellSize + this.cellSize / 2;
	    let rgb = this._ctx.getImageData(x, y, 1, 1).data;
	    return rgb;
	  },

	  get _contentTab() {
	    return this._chromeWindow.gBrowser.selectedTab;
	  },

	  /**
	   * Fetch a screenshot of the content.
	   *
	   * @return {promise}
	   *         Promise that resolves with the screenshot as a dataURL
	   */
	  getContentScreenshot: function () {
	    let deferred = promise.defer();

	    let mm = this._contentTab.linkedBrowser.messageManager;
	    function onScreenshot(message) {
	      mm.removeMessageListener("Eyedropper:Screenshot", onScreenshot);
	      deferred.resolve(message.data);
	    }
	    mm.addMessageListener("Eyedropper:Screenshot", onScreenshot);
	    mm.sendAsyncMessage("Eyedropper:RequestContentScreenshot");

	    return deferred.promise;
	  },

	  /**
	   * Start the eyedropper. Add listeners for a mouse move in the window to
	   * show the eyedropper.
	   */
	  open: function () {
	    var _this2 = this;

	    if (this.isOpen) {
	      // the eyedropper is aready open, don't create another panel.
	      return promise.resolve();
	    }
	    let deferred = promise.defer();

	    this.isOpen = true;

	    this._showCrosshairs();

	    // Get screenshot of content so we can inspect colors
	    this.getContentScreenshot().then(function (dataURL) {
	      _this2._contentImage = new _this2._chromeWindow.Image();
	      _this2._contentImage.src = dataURL;

	      // Wait for screenshot to load
	      _this2._contentImage.onload = function () {
	        // Then start showing the eyedropper UI
	        _this2._chromeDocument.addEventListener("mousemove", _this2._onFirstMouseMove);
	        deferred.resolve();

	        _this2.isStarted = true;
	        _this2.emit("started");
	      };
	    });

	    return deferred.promise;
	  },

	  /**
	   * Called on the first mouse move over the window. Opens the eyedropper
	   * panel where the mouse is.
	   */
	  _onFirstMouseMove: function (event) {
	    this._chromeDocument.removeEventListener("mousemove", this._onFirstMouseMove);

	    this._panel = this._buildPanel();

	    let popupSet = this._chromeDocument.querySelector("#mainPopupSet");
	    popupSet.appendChild(this._panel);

	    var _getPanelCoordinates = this._getPanelCoordinates(event);

	    let panelX = _getPanelCoordinates.panelX;
	    let panelY = _getPanelCoordinates.panelY;

	    this._panel.openPopupAtScreen(panelX, panelY);

	    this._setCoordinates(event);

	    this._addListeners();

	    // hide cursor as we'll be showing the panel over the mouse instead.
	    this._hideCrosshairs();
	    this._hideCursor();
	  },

	  /**
	   * Whether the coordinates are over the content or chrome.
	   *
	   * @param {number} clientX
	   *        x-coordinate of mouse relative to browser window.
	   * @param {number} clientY
	   *        y-coordinate of mouse relative to browser window.
	   */
	  _isInContent: function (clientX, clientY) {
	    let box = this._contentTab.linkedBrowser.getBoundingClientRect();
	    if (clientX > box.left && clientX < box.right && clientY > box.top && clientY < box.bottom) {
	      return true;
	    }
	    return false;
	  },

	  /**
	   * Set the current coordinates to inspect from where a mousemove originated.
	   *
	   * @param {MouseEvent} event
	   *        Event for the mouse move.
	   */
	  _setCoordinates: function (event) {
	    let inContent = this._isInContent(event.clientX, event.clientY);
	    let win = this._chromeWindow;

	    // offset of mouse from browser window
	    let x = event.clientX;
	    let y = event.clientY;

	    if (inContent) {
	      // calculate the offset of the mouse from the content window
	      let box = this._contentTab.linkedBrowser.getBoundingClientRect();
	      x = x - box.left;
	      y = y - box.top;

	      this._zoomArea.contentWidth = box.width;
	      this._zoomArea.contentHeight = box.height;
	    }
	    this._zoomArea.inContent = inContent;

	    // don't let it inspect outside the browser window
	    x = Math.max(0, Math.min(x, win.outerWidth - 1));
	    y = Math.max(0, Math.min(y, win.outerHeight - 1));

	    this._zoomArea.x = x;
	    this._zoomArea.y = y;
	  },

	  /**
	   * Build and add a new eyedropper panel to the window.
	   *
	   * @return {Panel}
	   *         The XUL panel holding the eyedropper UI.
	   */
	  _buildPanel: function () {
	    let panel = this._chromeDocument.createElement("panel");
	    panel.setAttribute("noautofocus", true);
	    panel.setAttribute("noautohide", true);
	    panel.setAttribute("level", "floating");
	    panel.setAttribute("class", "devtools-eyedropper-panel");

	    let iframe = this._iframe = this._chromeDocument.createElement("iframe");
	    iframe.addEventListener("load", this._onFrameLoaded, true);
	    iframe.setAttribute("flex", "1");
	    iframe.setAttribute("transparent", "transparent");
	    iframe.setAttribute("allowTransparency", true);
	    iframe.setAttribute("class", "devtools-eyedropper-iframe");
	    iframe.setAttribute("src", EYEDROPPER_URL);
	    iframe.setAttribute("width", CANVAS_WIDTH);
	    iframe.setAttribute("height", CANVAS_WIDTH);

	    panel.appendChild(iframe);

	    return panel;
	  },

	  /**
	   * Event handler for the panel's iframe's load event. Emits
	   * a "load" event from this eyedropper object.
	   */
	  _onFrameLoaded: function () {
	    this._iframe.removeEventListener("load", this._onFrameLoaded, true);

	    this._iframeDocument = this._iframe.contentDocument;
	    this._colorPreview = this._iframeDocument.querySelector("#color-preview");
	    this._colorValue = this._iframeDocument.querySelector("#color-value");

	    // value box will be too long for hex values and too short for hsl
	    let valueBox = this._iframeDocument.querySelector("#color-value-box");
	    if (this.format == "hex") {
	      valueBox.style.width = HEX_BOX_WIDTH + "px";
	    } else if (this.format == "hsl") {
	      valueBox.style.width = HSL_BOX_WIDTH + "px";
	    }

	    this._canvas = this._iframeDocument.querySelector("#canvas");
	    this._ctx = this._canvas.getContext("2d");

	    // so we preserve the clear pixel boundaries
	    this._ctx.mozImageSmoothingEnabled = false;

	    this._drawWindow();

	    this._addPanelListeners();
	    this._iframe.focus();

	    this.loaded = true;
	    this.emit("load");
	  },

	  /**
	   * Add key listeners to the panel.
	   */
	  _addPanelListeners: function () {
	    this._iframeDocument.addEventListener("keydown", this._onKeyDown);

	    let closeCmd = this._iframeDocument.getElementById("eyedropper-cmd-close");
	    closeCmd.addEventListener("command", this.destroy.bind(this), true);

	    let copyCmd = this._iframeDocument.getElementById("eyedropper-cmd-copy");
	    copyCmd.addEventListener("command", this.selectColor.bind(this), true);
	  },

	  /**
	   * Remove listeners from the panel.
	   */
	  _removePanelListeners: function () {
	    this._iframeDocument.removeEventListener("keydown", this._onKeyDown);
	  },

	  /**
	   * Add mouse event listeners to the document we're inspecting.
	   */
	  _addListeners: function () {
	    this._chromeDocument.addEventListener("mousemove", this._onMouseMove);
	    this._chromeDocument.addEventListener("mousedown", this._onMouseDown);
	  },

	  /**
	   * Remove mouse event listeners from the document we're inspecting.
	   */
	  _removeListeners: function () {
	    this._chromeDocument.removeEventListener("mousemove", this._onFirstMouseMove);
	    this._chromeDocument.removeEventListener("mousemove", this._onMouseMove);
	    this._chromeDocument.removeEventListener("mousedown", this._onMouseDown);
	  },

	  /**
	   * Hide the cursor.
	   */
	  _hideCursor: function () {
	    registerStyleSheet(NOCURSOR_URL);
	  },

	  /**
	   * Reset the cursor back to default.
	   */
	  _resetCursor: function () {
	    unregisterStyleSheet(NOCURSOR_URL);
	  },

	  /**
	   * Show a crosshairs as the mouse cursor
	   */
	  _showCrosshairs: function () {
	    registerStyleSheet(CROSSHAIRS_URL);
	  },

	  /**
	   * Reset cursor.
	   */
	  _hideCrosshairs: function () {
	    unregisterStyleSheet(CROSSHAIRS_URL);
	  },

	  /**
	   * Event handler for a mouse move over the page we're inspecting.
	   * Preview the area under the cursor, and move panel to be under the cursor.
	   *
	   * @param  {DOMEvent} event
	   *         MouseEvent for the mouse moving
	   */
	  _onMouseMove: function (event) {
	    if (!this._dragging || !this._panel || !this._canvas) {
	      return;
	    }

	    if (this._OS == "Linux" && ++this._mouseMoveCounter % 2 == 0) {
	      // skip every other mousemove to preserve performance.
	      return;
	    }

	    this._setCoordinates(event);
	    this._drawWindow();

	    var _getPanelCoordinates2 = this._getPanelCoordinates(event);

	    let panelX = _getPanelCoordinates2.panelX;
	    let panelY = _getPanelCoordinates2.panelY;

	    this._movePanel(panelX, panelY);
	  },

	  /**
	   * Get coordinates of where the eyedropper panel should go based on
	   * the current coordinates of the mouse cursor.
	   *
	   * @param {MouseEvent} event
	   *        object with properties 'screenX' and 'screenY'
	   *
	   * @return {object}
	  *          object with properties 'panelX', 'panelY'
	   */
	  _getPanelCoordinates: function ({ screenX, screenY }) {
	    let win = this._chromeWindow;
	    let offset = CANVAS_WIDTH / 2 + CANVAS_OFFSET;

	    let panelX = screenX - offset;
	    let windowX = win.screenX + (win.outerWidth - win.innerWidth);
	    let maxX = win.screenX + win.outerWidth - offset - 1;

	    let panelY = screenY - offset;
	    let windowY = win.screenY + (win.outerHeight - win.innerHeight);
	    let maxY = win.screenY + win.outerHeight - offset - 1;

	    // don't let the panel move outside the browser window
	    panelX = Math.max(windowX - offset, Math.min(panelX, maxX));
	    panelY = Math.max(windowY - offset, Math.min(panelY, maxY));

	    return { panelX: panelX, panelY: panelY };
	  },

	  /**
	   * Move the eyedropper panel to the given coordinates.
	   *
	   * @param  {number} screenX
	   *         left coordinate on the screen
	   * @param  {number} screenY
	   *         top coordinate
	   */
	  _movePanel: function (screenX, screenY) {
	    this._panelX = screenX;
	    this._panelY = screenY;

	    this._panel.moveTo(screenX, screenY);
	  },

	  /**
	   * Handler for the mouse down event on the inspected page. This means a
	   * click, so we'll select the color that's currently hovered.
	   *
	   * @param  {Event} event
	   *         DOM MouseEvent object
	   */
	  _onMouseDown: function (event) {
	    event.preventDefault();
	    event.stopPropagation();

	    this.selectColor();
	  },

	  /**
	   * Select the current color that's being previewed. Fire a
	   * "select" event with the color as an rgb string.
	   */
	  selectColor: function () {
	    if (this._isSelecting) {
	      return;
	    }
	    this._isSelecting = true;
	    this._dragging = false;

	    this.emit("select", this._colorValue.value);

	    if (this.copyOnSelect) {
	      this.copyColor(this.destroy.bind(this));
	    } else {
	      this.destroy();
	    }
	  },

	  /**
	   * Copy the currently inspected color to the clipboard.
	   *
	   * @param  {Function} callback
	   *         Callback to be called when the color is in the clipboard.
	   */
	  copyColor: function (callback) {
	    var _this3 = this;

	    clearTimeout(this._copyTimeout);

	    let color = this._colorValue.value;
	    clipboardHelper.copyString(color);

	    this._colorValue.classList.add("highlight");
	    this._colorValue.value = "✓ " + l10n.GetStringFromName("colorValue.copied");

	    this._copyTimeout = setTimeout(function () {
	      _this3._colorValue.classList.remove("highlight");
	      _this3._colorValue.value = color;

	      if (callback) {
	        callback();
	      }
	    }, CLOSE_DELAY);
	  },

	  /**
	   * Handler for the keydown event on the panel. Either copy the color
	   * or move the panel in a direction depending on the key pressed.
	   *
	   * @param  {Event} event
	   *         DOM KeyboardEvent object
	   */
	  _onKeyDown: function (event) {
	    if (event.metaKey && event.keyCode === event.DOM_VK_C) {
	      this.copyColor();
	      return;
	    }

	    let offsetX = 0;
	    let offsetY = 0;
	    let modifier = 1;

	    if (event.keyCode === event.DOM_VK_LEFT) {
	      offsetX = -1;
	    }
	    if (event.keyCode === event.DOM_VK_RIGHT) {
	      offsetX = 1;
	    }
	    if (event.keyCode === event.DOM_VK_UP) {
	      offsetY = -1;
	    }
	    if (event.keyCode === event.DOM_VK_DOWN) {
	      offsetY = 1;
	    }
	    if (event.shiftKey) {
	      modifier = 10;
	    }

	    offsetY *= modifier;
	    offsetX *= modifier;

	    if (offsetX !== 0 || offsetY !== 0) {
	      this._zoomArea.x += offsetX;
	      this._zoomArea.y += offsetY;

	      this._drawWindow();

	      this._movePanel(this._panelX + offsetX, this._panelY + offsetY);

	      event.preventDefault();
	    }
	  },

	  /**
	   * Draw the inspected area onto the canvas using the zoom level.
	   */
	  _drawWindow: function () {
	    var _zoomArea = this._zoomArea;
	    let width = _zoomArea.width;
	    let height = _zoomArea.height;
	    let x = _zoomArea.x;
	    let y = _zoomArea.y;
	    let inContent = _zoomArea.inContent;
	    let contentWidth = _zoomArea.contentWidth;
	    let contentHeight = _zoomArea.contentHeight;

	    let zoomedWidth = width / this.zoom;
	    let zoomedHeight = height / this.zoom;

	    let leftX = x - zoomedWidth / 2;
	    let topY = y - zoomedHeight / 2;

	    // draw the portion of the window we're inspecting
	    if (inContent) {
	      // draw from content source image "s" to destination rect "d"
	      let sx = leftX;
	      let sy = topY;
	      let sw = zoomedWidth;
	      let sh = zoomedHeight;
	      let dx = 0;
	      let dy = 0;

	      // we're at the content edge, so we have to crop the drawing
	      if (leftX < 0) {
	        sx = 0;
	        sw = zoomedWidth + leftX;
	        dx = -leftX;
	      } else if (leftX + zoomedWidth > contentWidth) {
	        sw = contentWidth - leftX;
	      }
	      if (topY < 0) {
	        sy = 0;
	        sh = zoomedHeight + topY;
	        dy = -topY;
	      } else if (topY + zoomedHeight > contentHeight) {
	        sh = contentHeight - topY;
	      }
	      let dw = sw;
	      let dh = sh;

	      // we don't want artifacts when we're inspecting the edges of content
	      if (leftX < 0 || topY < 0 || leftX + zoomedWidth > contentWidth || topY + zoomedHeight > contentHeight) {
	        this._ctx.fillStyle = "white";
	        this._ctx.fillRect(0, 0, width, height);
	      }

	      // draw from the screenshot to the eyedropper canvas
	      this._ctx.drawImage(this._contentImage, sx, sy, sw, sh, dx, dy, dw, dh);
	    } else {
	      // the mouse is over the chrome, so draw that instead of the content
	      this._ctx.drawWindow(this._chromeWindow, leftX, topY, zoomedWidth, zoomedHeight, "white");
	    }

	    // now scale it
	    this._ctx.drawImage(this._canvas, 0, 0, zoomedWidth, zoomedHeight, 0, 0, width, height);

	    let rgb = this.centerColor;
	    this._colorPreview.style.backgroundColor = toColorString(rgb, "rgb");
	    this._colorValue.value = toColorString(rgb, this.format);

	    if (this.zoom > 2) {
	      // grid at 2x is too busy
	      this._drawGrid();
	    }
	    this._drawCrosshair();
	  },

	  /**
	   * Draw a grid on the canvas representing pixel boundaries.
	   */
	  _drawGrid: function () {
	    var _zoomArea2 = this._zoomArea;
	    let width = _zoomArea2.width;
	    let height = _zoomArea2.height;

	    this._ctx.lineWidth = 1;
	    this._ctx.strokeStyle = "rgba(143, 143, 143, 0.2)";

	    for (let i = 0; i < width; i += this.cellSize) {
	      this._ctx.beginPath();
	      this._ctx.moveTo(i - .5, 0);
	      this._ctx.lineTo(i - .5, height);
	      this._ctx.stroke();

	      this._ctx.beginPath();
	      this._ctx.moveTo(0, i - .5);
	      this._ctx.lineTo(width, i - .5);
	      this._ctx.stroke();
	    }
	  },

	  /**
	   * Draw a box on the canvas to highlight the center cell.
	   */
	  _drawCrosshair: function () {
	    let x = y = this.centerCell * this.cellSize;

	    this._ctx.lineWidth = 1;
	    this._ctx.lineJoin = 'miter';
	    this._ctx.strokeStyle = "rgba(0, 0, 0, 1)";
	    this._ctx.strokeRect(x - 1.5, y - 1.5, this.cellSize + 2, this.cellSize + 2);

	    this._ctx.strokeStyle = "rgba(255, 255, 255, 1)";
	    this._ctx.strokeRect(x - 0.5, y - 0.5, this.cellSize, this.cellSize);
	  },

	  /**
	   * Destroy the eyedropper and clean up. Emits a "destroy" event.
	   */
	  destroy: function () {
	    this._resetCursor();
	    this._hideCrosshairs();

	    if (this._panel) {
	      this._panel.hidePopup();
	      this._panel.remove();
	      this._panel = null;
	    }
	    this._removePanelListeners();
	    this._removeListeners();

	    this.isStarted = false;
	    this.isOpen = false;
	    this._isSelecting = false;

	    this.emit("destroy");
	  }
	};

	/**
	 * Add a user style sheet that applies to all documents.
	 */
	function registerStyleSheet(url) {
	  var uri = ioService.newURI(url, null, null);
	  if (!ssService.sheetRegistered(uri, ssService.AGENT_SHEET)) {
	    ssService.loadAndRegisterSheet(uri, ssService.AGENT_SHEET);
	  }
	}

	/**
	 * Remove a user style sheet.
	 */
	function unregisterStyleSheet(url) {
	  var uri = ioService.newURI(url, null, null);
	  if (ssService.sheetRegistered(uri, ssService.AGENT_SHEET)) {
	    ssService.unregisterSheet(uri, ssService.AGENT_SHEET);
	  }
	}

	/**
	 * Get a formatted CSS color string from a color value.
	 *
	 * @param {array} rgb
	 *        Rgb values of a color to format
	 * @param {string} format
	 *        Format of string. One of "hex", "rgb", "hsl", "name"
	 *
	 * @return {string}
	 *        Formatted color value, e.g. "#FFF" or "hsl(20, 10%, 10%)"
	 */
	function toColorString(rgb, format) {
	  var _rgb = _slicedToArray(rgb, 3);

	  let r = _rgb[0];
	  let g = _rgb[1];
	  let b = _rgb[2];

	  switch (format) {
	    case "hex":
	      return hexString(rgb);
	    case "rgb":
	      return "rgb(" + r + ", " + g + ", " + b + ")";
	    case "hsl":
	      var _rgbToHsl = rgbToHsl(rgb);

	      var _rgbToHsl2 = _slicedToArray(_rgbToHsl, 3);

	      let h = _rgbToHsl2[0];
	      let s = _rgbToHsl2[1];
	      let l = _rgbToHsl2[2];

	      return "hsl(" + h + ", " + s + "%, " + l + "%)";
	    case "name":
	      let str;
	      try {
	        str = DOMUtils.rgbToColorName(r, g, b);
	      } catch (e) {
	        str = hexString(rgb);
	      }
	      return str;
	    default:
	      return hexString(rgb);
	  }
	}

	/**
	 * Produce a hex-formatted color string from rgb values.
	 *
	 * @param {array} rgb
	 *        Rgb values of color to stringify
	 *
	 * @return {string}
	 *        Hex formatted string for color, e.g. "#FFEE00"
	 */
	function hexString([r, g, b]) {
	  let val = (1 << 24) + (r << 16) + (g << 8) + (b << 0);
	  return "#" + val.toString(16).substr(-6).toUpperCase();
	}

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _require = __webpack_require__(67);

	var cssBeautify = _require.cssBeautify;

	var _require2 = __webpack_require__(68);

	var htmlBeautify = _require2.htmlBeautify;

	var _require3 = __webpack_require__(69);

	var jsBeautify = _require3.jsBeautify;

	exports.css = cssBeautify;
	exports.html = htmlBeautify;
	exports.js = jsBeautify;

/***/ },
/* 67 */
/***/ function(module, exports) {

	"use strict";

	/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.


	 CSS Beautifier
	---------------

	    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

	    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
	        http://jsbeautifier.org/

	    Usage:
	        css_beautify(source_text);
	        css_beautify(source_text, options);

	    The options are (default in brackets):
	        indent_size (4)                   — indentation size,
	        indent_char (space)               — character to indent with,
	        selector_separator_newline (true) - separate selectors with newline or
	                                            not (e.g. "a,\nbr" or "a, br")
	        end_with_newline (false)          - end with a newline

	    e.g

	    css_beautify(css_source_text, {
	      'indent_size': 1,
	      'indent_char': '\t',
	      'selector_separator': ' ',
	      'end_with_newline': false,
	    });
	*/

	// http://www.w3.org/TR/CSS21/syndata.html#tokenization
	// http://www.w3.org/TR/css3-syntax/

	(function () {
	    function css_beautify(source_text, options) {
	        options = options || {};
	        var indentSize = options.indent_size || 4;
	        var indentCharacter = options.indent_char || ' ';
	        var selectorSeparatorNewline = options.selector_separator_newline === undefined ? true : options.selector_separator_newline;
	        var endWithNewline = options.end_with_newline === undefined ? false : options.end_with_newline;

	        // compatibility
	        if (typeof indentSize === "string") {
	            indentSize = parseInt(indentSize, 10);
	        }

	        // tokenizer
	        var whiteRe = /^\s+$/;
	        var wordRe = /[\w$\-_]/;

	        var pos = -1,
	            ch;

	        function next() {
	            ch = source_text.charAt(++pos);
	            return ch;
	        }

	        function peek() {
	            return source_text.charAt(pos + 1);
	        }

	        function eatString(endChar) {
	            var start = pos;
	            while (next()) {
	                if (ch === "\\") {
	                    next();
	                    next();
	                } else if (ch === endChar) {
	                    break;
	                } else if (ch === "\n") {
	                    break;
	                }
	            }
	            return source_text.substring(start, pos + 1);
	        }

	        function eatWhitespace() {
	            var start = pos;
	            while (whiteRe.test(peek())) {
	                pos++;
	            }
	            return pos !== start;
	        }

	        function skipWhitespace() {
	            var start = pos;
	            do {} while (whiteRe.test(next()));
	            return pos !== start + 1;
	        }

	        function eatComment(singleLine) {
	            var start = pos;
	            next();
	            while (next()) {
	                if (ch === "*" && peek() === "/") {
	                    pos++;
	                    break;
	                } else if (singleLine && ch === "\n") {
	                    break;
	                }
	            }

	            return source_text.substring(start, pos + 1);
	        }

	        function lookBack(str) {
	            return source_text.substring(pos - str.length, pos).toLowerCase() === str;
	        }

	        function isCommentOnLine() {
	            var endOfLine = source_text.indexOf('\n', pos);
	            if (endOfLine === -1) {
	                return false;
	            }
	            var restOfLine = source_text.substring(pos, endOfLine);
	            return restOfLine.indexOf('//') !== -1;
	        }

	        // printer
	        var indentString = source_text.match(/^[\r\n]*[\t ]*/)[0];
	        var singleIndent = new Array(indentSize + 1).join(indentCharacter);
	        var indentLevel = 0;
	        var nestedLevel = 0;

	        function indent() {
	            indentLevel++;
	            indentString += singleIndent;
	        }

	        function outdent() {
	            indentLevel--;
	            indentString = indentString.slice(0, -indentSize);
	        }

	        var print = {};
	        print["{"] = function (ch) {
	            print.singleSpace();
	            output.push(ch);
	            print.newLine();
	        };
	        print["}"] = function (ch) {
	            print.newLine();
	            output.push(ch);
	            print.newLine();
	        };

	        print._lastCharWhitespace = function () {
	            return whiteRe.test(output[output.length - 1]);
	        };

	        print.newLine = function (keepWhitespace) {
	            if (!keepWhitespace) {
	                while (print._lastCharWhitespace()) {
	                    output.pop();
	                }
	            }

	            if (output.length) {
	                output.push('\n');
	            }
	            if (indentString) {
	                output.push(indentString);
	            }
	        };
	        print.singleSpace = function () {
	            if (output.length && !print._lastCharWhitespace()) {
	                output.push(' ');
	            }
	        };
	        var output = [];
	        if (indentString) {
	            output.push(indentString);
	        }
	        /*_____________________--------------------_____________________*/

	        var insideRule = false;
	        var enteringConditionalGroup = false;

	        while (true) {
	            var isAfterSpace = skipWhitespace();

	            if (!ch) {
	                break;
	            } else if (ch === '/' && peek() === '*') {
	                /* css comment */
	                print.newLine();
	                output.push(eatComment(), "\n", indentString);
	                var header = lookBack("");
	                if (header) {
	                    print.newLine();
	                }
	            } else if (ch === '/' && peek() === '/') {
	                // single line comment
	                output.push(eatComment(true), indentString);
	            } else if (ch === '@') {
	                // strip trailing space, if present, for hash property checks
	                var atRule = eatString(" ").replace(/ $/, '');

	                // pass along the space we found as a separate item
	                output.push(atRule, ch);

	                // might be a nesting at-rule
	                if (atRule in css_beautify.NESTED_AT_RULE) {
	                    nestedLevel += 1;
	                    if (atRule in css_beautify.CONDITIONAL_GROUP_RULE) {
	                        enteringConditionalGroup = true;
	                    }
	                }
	            } else if (ch === '{') {
	                eatWhitespace();
	                if (peek() === '}') {
	                    next();
	                    output.push(" {}");
	                } else {
	                    indent();
	                    print["{"](ch);
	                    // when entering conditional groups, only rulesets are allowed
	                    if (enteringConditionalGroup) {
	                        enteringConditionalGroup = false;
	                        insideRule = indentLevel > nestedLevel;
	                    } else {
	                        // otherwise, declarations are also allowed
	                        insideRule = indentLevel >= nestedLevel;
	                    }
	                }
	            } else if (ch === '}') {
	                outdent();
	                print["}"](ch);
	                insideRule = false;
	                if (nestedLevel) {
	                    nestedLevel--;
	                }
	            } else if (ch === ":") {
	                eatWhitespace();
	                if (insideRule || enteringConditionalGroup) {
	                    // 'property: value' delimiter
	                    // which could be in a conditional group query
	                    output.push(ch, " ");
	                } else {
	                    if (peek() === ":") {
	                        // pseudo-element
	                        next();
	                        output.push("::");
	                    } else {
	                        // pseudo-class
	                        output.push(ch);
	                    }
	                }
	            } else if (ch === '"' || ch === '\'') {
	                output.push(eatString(ch));
	            } else if (ch === ';') {
	                if (isCommentOnLine()) {
	                    var beforeComment = eatString('/');
	                    var comment = eatComment(true);
	                    output.push(beforeComment, comment.substring(1, comment.length - 1), '\n', indentString);
	                } else {
	                    output.push(ch, '\n', indentString);
	                }
	            } else if (ch === '(') {
	                // may be a url
	                if (lookBack("url")) {
	                    output.push(ch);
	                    eatWhitespace();
	                    if (next()) {
	                        if (ch !== ')' && ch !== '"' && ch !== '\'') {
	                            output.push(eatString(')'));
	                        } else {
	                            pos--;
	                        }
	                    }
	                } else {
	                    if (isAfterSpace) {
	                        print.singleSpace();
	                    }
	                    output.push(ch);
	                    eatWhitespace();
	                }
	            } else if (ch === ')') {
	                output.push(ch);
	            } else if (ch === ',') {
	                eatWhitespace();
	                output.push(ch);
	                if (!insideRule && selectorSeparatorNewline) {
	                    print.newLine();
	                } else {
	                    print.singleSpace();
	                }
	            } else if (ch === ']') {
	                output.push(ch);
	            } else if (ch === '[') {
	                if (isAfterSpace) {
	                    print.singleSpace();
	                }
	                output.push(ch);
	            } else if (ch === '=') {
	                // no whitespace before or after
	                eatWhitespace();
	                output.push(ch);
	            } else {
	                if (isAfterSpace) {
	                    print.singleSpace();
	                }

	                output.push(ch);
	            }
	        }

	        var sweetCode = output.join('').replace(/[\n ]+$/, '');

	        // establish end_with_newline
	        var should = endWithNewline;
	        var actually = /\n$/.test(sweetCode);
	        if (should && !actually) {
	            sweetCode += "\n";
	        } else if (!should && actually) {
	            sweetCode = sweetCode.slice(0, -1);
	        }

	        return sweetCode;
	    }

	    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
	    css_beautify.NESTED_AT_RULE = {
	        "@page": true,
	        "@font-face": true,
	        "@keyframes": true,
	        // also in CONDITIONAL_GROUP_RULE below
	        "@media": true,
	        "@supports": true,
	        "@document": true
	    };
	    css_beautify.CONDITIONAL_GROUP_RULE = {
	        "@media": true,
	        "@supports": true,
	        "@document": true
	    };

	    exports.cssBeautify = css_beautify;
	})();

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.


	 Style HTML
	---------------

	  Written by Nochum Sossonko, (nsossonko@hotmail.com)

	  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
	    http://jsbeautifier.org/

	  Usage:
	    style_html(html_source);

	    style_html(html_source, options);

	  The options are:
	    indent_inner_html (default false)  — indent <head> and <body> sections,
	    indent_size (default 4)          — indentation size,
	    indent_char (default space)      — character to indent with,
	    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
	    brace_style (default "collapse") - "collapse" | "expand" | "end-expand"
	            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.
	    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
	    indent_scripts (default normal)  - "keep"|"separate"|"normal"
	    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
	                                        Only works before elements, not inside tags or for text.
	    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
	    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}

	    e.g.

	    style_html(html_source, {
	      'indent_inner_html': false,
	      'indent_size': 2,
	      'indent_char': ' ',
	      'wrap_line_length': 78,
	      'brace_style': 'expand',
	      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u'],
	      'preserve_newlines': true,
	      'max_preserve_newlines': 5,
	      'indent_handlebars': false
	    });
	*/

	(function () {

	    function trim(s) {
	        return s.replace(/^\s+|\s+$/g, '');
	    }

	    function ltrim(s) {
	        return s.replace(/^\s+/g, '');
	    }

	    function style_html(html_source, options, js_beautify, css_beautify) {
	        //Wrapper function to invoke all the necessary constructors and deal with the output.

	        var multi_parser, indent_inner_html, indent_size, indent_character, wrap_line_length, brace_style, unformatted, preserve_newlines, max_preserve_newlines, indent_handlebars;

	        options = options || {};

	        // backwards compatibility to 1.3.4
	        if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) && options.max_char !== undefined && parseInt(options.max_char, 10) !== 0) {
	            options.wrap_line_length = options.max_char;
	        }

	        indent_inner_html = options.indent_inner_html === undefined ? false : options.indent_inner_html;
	        indent_size = options.indent_size === undefined ? 4 : parseInt(options.indent_size, 10);
	        indent_character = options.indent_char === undefined ? ' ' : options.indent_char;
	        brace_style = options.brace_style === undefined ? 'collapse' : options.brace_style;
	        wrap_line_length = parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);
	        unformatted = options.unformatted || ['a', 'span', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike', 'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	        preserve_newlines = options.preserve_newlines === undefined ? true : options.preserve_newlines;
	        max_preserve_newlines = preserve_newlines ? isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10) : 0;
	        indent_handlebars = options.indent_handlebars === undefined ? false : options.indent_handlebars;

	        function Parser() {

	            this.pos = 0; //Parser position
	            this.token = '';
	            this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
	            this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
	                parent: 'parent1',
	                parentcount: 1,
	                parent1: ''
	            };
	            this.tag_type = '';
	            this.token_text = this.last_token = this.last_text = this.token_type = '';
	            this.newlines = 0;
	            this.indent_content = indent_inner_html;

	            this.Utils = { //Uilities made available to the various functions
	                whitespace: "\n\r\t ".split(''),
	                single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?='.split(','), //all the single tags for HTML
	                extra_liners: 'head,body,/html'.split(','), //for tags that need a line of whitespace before them
	                in_array: function (what, arr) {
	                    for (var i = 0; i < arr.length; i++) {
	                        if (what === arr[i]) {
	                            return true;
	                        }
	                    }
	                    return false;
	                }
	            };

	            this.traverse_whitespace = function () {
	                var input_char = '';

	                input_char = this.input.charAt(this.pos);
	                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                    this.newlines = 0;
	                    while (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                        if (preserve_newlines && input_char === '\n' && this.newlines <= max_preserve_newlines) {
	                            this.newlines += 1;
	                        }

	                        this.pos++;
	                        input_char = this.input.charAt(this.pos);
	                    }
	                    return true;
	                }
	                return false;
	            };

	            this.get_content = function () {
	                //function to capture regular content between tags

	                var input_char = '',
	                    content = [],
	                    space = false; //if a space is needed

	                while (this.input.charAt(this.pos) !== '<') {
	                    if (this.pos >= this.input.length) {
	                        return content.length ? content.join('') : ['', 'TK_EOF'];
	                    }

	                    if (this.traverse_whitespace()) {
	                        if (content.length) {
	                            space = true;
	                        }
	                        continue; //don't want to insert unnecessary space
	                    }

	                    if (indent_handlebars) {
	                        // Handlebars parsing is complicated.
	                        // {{#foo}} and {{/foo}} are formatted tags.
	                        // {{something}} should get treated as content, except:
	                        // {{else}} specifically behaves like {{#if}} and {{/if}}
	                        var peek3 = this.input.substr(this.pos, 3);
	                        if (peek3 === '{{#' || peek3 === '{{/') {
	                            // These are tags and not content.
	                            break;
	                        } else if (this.input.substr(this.pos, 2) === '{{') {
	                            if (this.get_tag(true) === '{{else}}') {
	                                break;
	                            }
	                        }
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (space) {
	                        if (this.line_char_count >= this.wrap_line_length) {
	                            //insert a line when the wrap_line_length is reached
	                            this.print_newline(false, content);
	                            this.print_indentation(content);
	                        } else {
	                            this.line_char_count++;
	                            content.push(' ');
	                        }
	                        space = false;
	                    }
	                    this.line_char_count++;
	                    content.push(input_char); //letter at-a-time (or string) inserted to an array
	                }
	                return content.length ? content.join('') : '';
	            };

	            this.get_contents_to = function (name) {
	                //get the full content of a script or style to pass to js_beautify
	                if (this.pos === this.input.length) {
	                    return ['', 'TK_EOF'];
	                }
	                var input_char = '';
	                var content = '';
	                var reg_match = new RegExp('</' + name + '\\s*>', 'igm');
	                reg_match.lastIndex = this.pos;
	                var reg_array = reg_match.exec(this.input);
	                var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script
	                if (this.pos < end_script) {
	                    //get everything in between the script tags
	                    content = this.input.substring(this.pos, end_script);
	                    this.pos = end_script;
	                }
	                return content;
	            };

	            this.record_tag = function (tag) {
	                //function to record a tag and its parent in this.tags Object
	                if (this.tags[tag + 'count']) {
	                    //check for the existence of this tag type
	                    this.tags[tag + 'count']++;
	                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
	                } else {
	                        //otherwise initialize this tag type
	                        this.tags[tag + 'count'] = 1;
	                        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
	                    }
	                this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
	                this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
	            };

	            this.retrieve_tag = function (tag) {
	                //function to retrieve the opening tag to the corresponding closer
	                if (this.tags[tag + 'count']) {
	                    //if the openener is not in the Object we ignore it
	                    var temp_parent = this.tags.parent; //check to see if it's a closable tag.
	                    while (temp_parent) {
	                        //till we reach '' (the initial value);
	                        if (tag + this.tags[tag + 'count'] === temp_parent) {
	                            //if this is it use it
	                            break;
	                        }
	                        temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
	                    }
	                    if (temp_parent) {
	                        //if we caught something
	                        this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
	                        this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
	                    }
	                    delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
	                    delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
	                    if (this.tags[tag + 'count'] === 1) {
	                        delete this.tags[tag + 'count'];
	                    } else {
	                        this.tags[tag + 'count']--;
	                    }
	                }
	            };

	            this.indent_to_tag = function (tag) {
	                // Match the indentation level to the last use of this tag, but don't remove it.
	                if (!this.tags[tag + 'count']) {
	                    return;
	                }
	                var temp_parent = this.tags.parent;
	                while (temp_parent) {
	                    if (tag + this.tags[tag + 'count'] === temp_parent) {
	                        break;
	                    }
	                    temp_parent = this.tags[temp_parent + 'parent'];
	                }
	                if (temp_parent) {
	                    this.indent_level = this.tags[tag + this.tags[tag + 'count']];
	                }
	            };

	            this.get_tag = function (peek) {
	                //function to get a full tag and parse its type
	                var input_char = '',
	                    content = [],
	                    comment = '',
	                    space = false,
	                    tag_start,
	                    tag_end,
	                    tag_start_char,
	                    orig_pos = this.pos,
	                    orig_line_char_count = this.line_char_count;

	                peek = peek !== undefined ? peek : false;

	                do {
	                    if (this.pos >= this.input.length) {
	                        if (peek) {
	                            this.pos = orig_pos;
	                            this.line_char_count = orig_line_char_count;
	                        }
	                        return content.length ? content.join('') : ['', 'TK_EOF'];
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                        //don't want to insert unnecessary space
	                        space = true;
	                        continue;
	                    }

	                    if (input_char === "'" || input_char === '"') {
	                        input_char += this.get_unformatted(input_char);
	                        space = true;
	                    }

	                    if (input_char === '=') {
	                        //no space before =
	                        space = false;
	                    }

	                    if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {
	                        //no space after = or before >
	                        if (this.line_char_count >= this.wrap_line_length) {
	                            this.print_newline(false, content);
	                            this.print_indentation(content);
	                        } else {
	                            content.push(' ');
	                            this.line_char_count++;
	                        }
	                        space = false;
	                    }

	                    if (indent_handlebars && tag_start_char === '<') {
	                        // When inside an angle-bracket tag, put spaces around
	                        // handlebars not inside of strings.
	                        if (input_char + this.input.charAt(this.pos) === '{{') {
	                            input_char += this.get_unformatted('}}');
	                            if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {
	                                input_char = ' ' + input_char;
	                            }
	                            space = true;
	                        }
	                    }

	                    if (input_char === '<' && !tag_start_char) {
	                        tag_start = this.pos - 1;
	                        tag_start_char = '<';
	                    }

	                    if (indent_handlebars && !tag_start_char) {
	                        if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] == '{') {
	                            if (input_char === '#' || input_char === '/') {
	                                tag_start = this.pos - 3;
	                            } else {
	                                tag_start = this.pos - 2;
	                            }
	                            tag_start_char = '{';
	                        }
	                    }

	                    this.line_char_count++;
	                    content.push(input_char); //inserts character at-a-time (or string)

	                    if (content[1] && content[1] === '!') {
	                        //if we're in a comment, do something special
	                        // We treat all comments as literals, even more than preformatted tags
	                        // we just look for the appropriate close tag
	                        content = [this.get_comment(tag_start)];
	                        break;
	                    }

	                    if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {
	                        break;
	                    }
	                } while (input_char !== '>');

	                var tag_complete = content.join('');
	                var tag_index;
	                var tag_offset;

	                if (tag_complete.indexOf(' ') !== -1) {
	                    //if there's whitespace, thats where the tag name ends
	                    tag_index = tag_complete.indexOf(' ');
	                } else if (tag_complete[0] === '{') {
	                    tag_index = tag_complete.indexOf('}');
	                } else {
	                    //otherwise go with the tag ending
	                    tag_index = tag_complete.indexOf('>');
	                }
	                if (tag_complete[0] === '<' || !indent_handlebars) {
	                    tag_offset = 1;
	                } else {
	                    tag_offset = tag_complete[2] === '#' ? 3 : 2;
	                }
	                var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();
	                if (tag_complete.charAt(tag_complete.length - 2) === '/' || this.Utils.in_array(tag_check, this.Utils.single_token)) {
	                    //if this tag name is a single tag type (either in the list or has a closing /)
	                    if (!peek) {
	                        this.tag_type = 'SINGLE';
	                    }
	                } else if (indent_handlebars && tag_complete[0] === '{' && tag_check === 'else') {
	                    if (!peek) {
	                        this.indent_to_tag('if');
	                        this.tag_type = 'HANDLEBARS_ELSE';
	                        this.indent_content = true;
	                        this.traverse_whitespace();
	                    }
	                } else if (tag_check === 'script' && (tag_complete.search('type') === -1 || tag_complete.search('type') > -1 && tag_complete.search(/\b(text|application)\/(x-)?(javascript|ecmascript|jscript|livescript)/) > -1)) {
	                    if (!peek) {
	                        this.record_tag(tag_check);
	                        this.tag_type = 'SCRIPT';
	                    }
	                } else if (tag_check === 'style' && (tag_complete.search('type') === -1 || tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1)) {
	                    if (!peek) {
	                        this.record_tag(tag_check);
	                        this.tag_type = 'STYLE';
	                    }
	                } else if (this.is_unformatted(tag_check, unformatted)) {
	                    // do not reformat the "unformatted" tags
	                    comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function
	                    content.push(comment);
	                    // Preserve collapsed whitespace either before or after this tag.
	                    if (tag_start > 0 && this.Utils.in_array(this.input.charAt(tag_start - 1), this.Utils.whitespace)) {
	                        content.splice(0, 0, this.input.charAt(tag_start - 1));
	                    }
	                    tag_end = this.pos - 1;
	                    if (this.Utils.in_array(this.input.charAt(tag_end + 1), this.Utils.whitespace)) {
	                        content.push(this.input.charAt(tag_end + 1));
	                    }
	                    this.tag_type = 'SINGLE';
	                } else if (tag_check.charAt(0) === '!') {
	                    //peek for <! comment
	                    // for comments content is already correct.
	                    if (!peek) {
	                        this.tag_type = 'SINGLE';
	                        this.traverse_whitespace();
	                    }
	                } else if (!peek) {
	                    if (tag_check.charAt(0) === '/') {
	                        //this tag is a double tag so check for tag-ending
	                        this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
	                        this.tag_type = 'END';
	                        this.traverse_whitespace();
	                    } else {
	                        //otherwise it's a start-tag
	                        this.record_tag(tag_check); //push it on the tag stack
	                        if (tag_check.toLowerCase() !== 'html') {
	                            this.indent_content = true;
	                        }
	                        this.tag_type = 'START';

	                        // Allow preserving of newlines after a start tag
	                        this.traverse_whitespace();
	                    }
	                    if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) {
	                        //check if this double needs an extra line
	                        this.print_newline(false, this.output);
	                        if (this.output.length && this.output[this.output.length - 2] !== '\n') {
	                            this.print_newline(true, this.output);
	                        }
	                    }
	                }

	                if (peek) {
	                    this.pos = orig_pos;
	                    this.line_char_count = orig_line_char_count;
	                }

	                return content.join(''); //returns fully formatted tag
	            };

	            this.get_comment = function (start_pos) {
	                //function to return comment content in its entirety
	                // this is will have very poor perf, but will work for now.
	                var comment = '',
	                    delimiter = '>',
	                    matched = false;

	                this.pos = start_pos;
	                input_char = this.input.charAt(this.pos);
	                this.pos++;

	                while (this.pos <= this.input.length) {
	                    comment += input_char;

	                    // only need to check for the delimiter if the last chars match
	                    if (comment[comment.length - 1] === delimiter[delimiter.length - 1] && comment.indexOf(delimiter) !== -1) {
	                        break;
	                    }

	                    // only need to search for custom delimiter for the first few characters
	                    if (!matched && comment.length < 10) {
	                        if (comment.indexOf('<![if') === 0) {
	                            //peek for <![if conditional comment
	                            delimiter = '<![endif]>';
	                            matched = true;
	                        } else if (comment.indexOf('<![cdata[') === 0) {
	                            //if it's a <[cdata[ comment...
	                            delimiter = ']]>';
	                            matched = true;
	                        } else if (comment.indexOf('<![') === 0) {
	                            // some other ![ comment? ...
	                            delimiter = ']>';
	                            matched = true;
	                        } else if (comment.indexOf('<!--') === 0) {
	                            // <!-- comment ...
	                            delimiter = '-->';
	                            matched = true;
	                        }
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;
	                }

	                return comment;
	            };

	            this.get_unformatted = function (delimiter, orig_tag) {
	                //function to return unformatted content in its entirety

	                if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {
	                    return '';
	                }
	                var input_char = '';
	                var content = '';
	                var min_index = 0;
	                var space = true;
	                do {

	                    if (this.pos >= this.input.length) {
	                        return content;
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                        if (!space) {
	                            this.line_char_count--;
	                            continue;
	                        }
	                        if (input_char === '\n' || input_char === '\r') {
	                            content += '\n';
	                            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'
	                            for (var i=0; i<this.indent_level; i++) {
	                            content += this.indent_string;
	                            }
	                            space = false; //...and make sure other indentation is erased
	                            */
	                            this.line_char_count = 0;
	                            continue;
	                        }
	                    }
	                    content += input_char;
	                    this.line_char_count++;
	                    space = true;

	                    if (indent_handlebars && input_char === '{' && content.length && content[content.length - 2] === '{') {
	                        // Handlebars expressions in strings should also be unformatted.
	                        content += this.get_unformatted('}}');
	                        // These expressions are opaque.  Ignore delimiters found in them.
	                        min_index = content.length;
	                    }
	                } while (content.toLowerCase().indexOf(delimiter, min_index) === -1);
	                return content;
	            };

	            this.get_token = function () {
	                //initial handler for token-retrieval
	                var token;

	                if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') {
	                    //check if we need to format javascript
	                    var type = this.last_token.substr(7);
	                    token = this.get_contents_to(type);
	                    if (typeof token !== 'string') {
	                        return token;
	                    }
	                    return [token, 'TK_' + type];
	                }
	                if (this.current_mode === 'CONTENT') {
	                    token = this.get_content();
	                    if (typeof token !== 'string') {
	                        return token;
	                    } else {
	                        return [token, 'TK_CONTENT'];
	                    }
	                }

	                if (this.current_mode === 'TAG') {
	                    token = this.get_tag();
	                    if (typeof token !== 'string') {
	                        return token;
	                    } else {
	                        var tag_name_type = 'TK_TAG_' + this.tag_type;
	                        return [token, tag_name_type];
	                    }
	                }
	            };

	            this.get_full_indent = function (level) {
	                level = this.indent_level + level || 0;
	                if (level < 1) {
	                    return '';
	                }

	                return Array(level + 1).join(this.indent_string);
	            };

	            this.is_unformatted = function (tag_check, unformatted) {
	                //is this an HTML5 block-level link?
	                if (!this.Utils.in_array(tag_check, unformatted)) {
	                    return false;
	                }

	                if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {
	                    return true;
	                }

	                //at this point we have an  tag; is its first child something we want to remain
	                //unformatted?
	                var next_tag = this.get_tag(true /* peek. */);

	                // test next_tag to see if it is just html tag (no external content)
	                var tag = (next_tag || "").match(/^\s*<\s*\/?([a-z]*)\s*[^>]*>\s*$/);

	                // if next_tag comes back but is not an isolated tag, then
	                // let's treat the 'a' tag as having content
	                // and respect the unformatted option
	                if (!tag || this.Utils.in_array(tag, unformatted)) {
	                    return true;
	                } else {
	                    return false;
	                }
	            };

	            this.printer = function (js_source, indent_character, indent_size, wrap_line_length, brace_style) {
	                //handles input/output and some other printing functions

	                this.input = js_source || ''; //gets the input for the Parser
	                this.output = [];
	                this.indent_character = indent_character;
	                this.indent_string = '';
	                this.indent_size = indent_size;
	                this.brace_style = brace_style;
	                this.indent_level = 0;
	                this.wrap_line_length = wrap_line_length;
	                this.line_char_count = 0; //count to see if wrap_line_length was exceeded

	                for (var i = 0; i < this.indent_size; i++) {
	                    this.indent_string += this.indent_character;
	                }

	                this.print_newline = function (force, arr) {
	                    this.line_char_count = 0;
	                    if (!arr || !arr.length) {
	                        return;
	                    }
	                    if (force || arr[arr.length - 1] !== '\n') {
	                        //we might want the extra line
	                        arr.push('\n');
	                    }
	                };

	                this.print_indentation = function (arr) {
	                    for (var i = 0; i < this.indent_level; i++) {
	                        arr.push(this.indent_string);
	                        this.line_char_count += this.indent_string.length;
	                    }
	                };

	                this.print_token = function (text) {
	                    if (text || text !== '') {
	                        if (this.output.length && this.output[this.output.length - 1] === '\n') {
	                            this.print_indentation(this.output);
	                            text = ltrim(text);
	                        }
	                    }
	                    this.print_token_raw(text);
	                };

	                this.print_token_raw = function (text) {
	                    if (text && text !== '') {
	                        if (text.length > 1 && text[text.length - 1] === '\n') {
	                            // unformatted tags can grab newlines as their last character
	                            this.output.push(text.slice(0, -1));
	                            this.print_newline(false, this.output);
	                        } else {
	                            this.output.push(text);
	                        }
	                    }

	                    for (var n = 0; n < this.newlines; n++) {
	                        this.print_newline(n > 0, this.output);
	                    }
	                    this.newlines = 0;
	                };

	                this.indent = function () {
	                    this.indent_level++;
	                };

	                this.unindent = function () {
	                    if (this.indent_level > 0) {
	                        this.indent_level--;
	                    }
	                };
	            };
	            return this;
	        }

	        /*_____________________--------------------_____________________*/

	        multi_parser = new Parser(); //wrapping functions Parser
	        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values

	        while (true) {
	            var t = multi_parser.get_token();
	            multi_parser.token_text = t[0];
	            multi_parser.token_type = t[1];

	            if (multi_parser.token_type === 'TK_EOF') {
	                break;
	            }

	            switch (multi_parser.token_type) {
	                case 'TK_TAG_START':
	                    multi_parser.print_newline(false, multi_parser.output);
	                    multi_parser.print_token(multi_parser.token_text);
	                    if (multi_parser.indent_content) {
	                        multi_parser.indent();
	                        multi_parser.indent_content = false;
	                    }
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_STYLE':
	                case 'TK_TAG_SCRIPT':
	                    multi_parser.print_newline(false, multi_parser.output);
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_END':
	                    //Print new line only if the tag has no content and has child
	                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {
	                        var tag_name = multi_parser.token_text.match(/\w+/)[0];
	                        var tag_extracted_from_last_output = null;
	                        if (multi_parser.output.length) {
	                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\s*(\w+)/);
	                        }
	                        if (tag_extracted_from_last_output === null || tag_extracted_from_last_output[1] !== tag_name) {
	                            multi_parser.print_newline(false, multi_parser.output);
	                        }
	                    }
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_SINGLE':
	                    // Don't add a newline before elements that should remain unformatted.
	                    var tag_check = multi_parser.token_text.match(/^\s*<([a-z]+)/i);
	                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {
	                        multi_parser.print_newline(false, multi_parser.output);
	                    }
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_HANDLEBARS_ELSE':
	                    multi_parser.print_token(multi_parser.token_text);
	                    if (multi_parser.indent_content) {
	                        multi_parser.indent();
	                        multi_parser.indent_content = false;
	                    }
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_CONTENT':
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'TAG';
	                    break;
	                case 'TK_STYLE':
	                case 'TK_SCRIPT':
	                    if (multi_parser.token_text !== '') {
	                        multi_parser.print_newline(false, multi_parser.output);
	                        var text = multi_parser.token_text,
	                            _beautifier,
	                            script_indent_level = 1;
	                        if (multi_parser.token_type === 'TK_SCRIPT') {
	                            _beautifier = typeof js_beautify === 'function' && js_beautify;
	                        } else if (multi_parser.token_type === 'TK_STYLE') {
	                            _beautifier = typeof css_beautify === 'function' && css_beautify;
	                        }

	                        if (options.indent_scripts === "keep") {
	                            script_indent_level = 0;
	                        } else if (options.indent_scripts === "separate") {
	                            script_indent_level = -multi_parser.indent_level;
	                        }

	                        var indentation = multi_parser.get_full_indent(script_indent_level);
	                        if (_beautifier) {
	                            // call the Beautifier if avaliable
	                            text = _beautifier(text.replace(/^\s*/, indentation), options);
	                        } else {
	                            // simply indent the string otherwise
	                            var white = text.match(/^\s*/)[0];
	                            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
	                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);
	                            text = text.replace(/^\s*/, indentation).replace(/\r\n|\r|\n/g, '\n' + reindent).replace(/\s+$/, '');
	                        }
	                        if (text) {
	                            multi_parser.print_token_raw(indentation + trim(text));
	                            multi_parser.print_newline(false, multi_parser.output);
	                        }
	                    }
	                    multi_parser.current_mode = 'TAG';
	                    break;
	            }
	            multi_parser.last_token = multi_parser.token_type;
	            multi_parser.last_text = multi_parser.token_text;
	        }
	        return multi_parser.output.join('');
	    }

	    var beautify = __webpack_require__(66);

	    exports.htmlBeautify = function (html_source, options) {
	        return style_html(html_source, options, beautify.js, beautify.css);
	    };
	})();

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */

	"use strict";

	const acorn = __webpack_require__(49);

	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.

	 JS Beautifier
	---------------


	  Written by Einar Lielmanis, <einar@jsbeautifier.org>
	      http://jsbeautifier.org/

	  Originally converted to javascript by Vital, <vital76@gmail.com>
	  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
	  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


	  Usage:
	    js_beautify(js_source_text);
	    js_beautify(js_source_text, options);

	  The options are:
	    indent_size (default 4)          - indentation size,
	    indent_char (default space)      - character to indent with,
	    preserve_newlines (default true) - whether existing line breaks should be preserved,
	    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

	    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

	            jslint_happy       !jslint_happy
	            ---------------------------------
	            function ()        function()

	    brace_style (default "collapse") - "collapse" | "expand" | "end-expand"
	            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.

	    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

	    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

	    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
	          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
	                be preserved if it were present.

	    e.g

	    js_beautify(js_source_text, {
	      'indent_size': 1,
	      'indent_char': '\t'
	    });

	*/

	var js_beautify = function js_beautify(js_source_text, options) {
	    var beautifier = new Beautifier(js_source_text, options);
	    return beautifier.beautify();
	};

	exports.jsBeautify = js_beautify;

	function Beautifier(js_source_text, options) {
	    var input, output_lines;
	    var token_text, token_type, last_type, last_last_text, indent_string;
	    var flags, previous_flags, flag_store;
	    var whitespace, wordchar, punct, parser_pos, line_starters, reserved_words, digits;
	    var prefix;
	    var input_wanted_newline;
	    var output_space_before_token;
	    var input_length, n_newlines, whitespace_before_token;
	    var handlers, MODE, opt;
	    var preindent_string = '';

	    whitespace = "\n\r\t ".split('');
	    wordchar = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'.split('');
	    digits = '0123456789'.split('');

	    punct = '+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! ~ , : ? ^ ^= |= :: =>';
	    punct += ' <%= <% %> <?= <? ?>'; // try to be a good boy and try not to break the markup language identifiers
	    punct = punct.split(' ');

	    // words which should always start on new line.
	    line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,yield'.split(',');
	    reserved_words = line_starters.concat(['do', 'in', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof']);

	    MODE = {
	        BlockStatement: 'BlockStatement', // 'BLOCK'
	        Statement: 'Statement', // 'STATEMENT'
	        ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
	        ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
	        ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
	        Conditional: 'Conditional', //'(COND-EXPRESSION)',
	        Expression: 'Expression' //'(EXPRESSION)'
	    };

	    handlers = {
	        'TK_START_EXPR': handle_start_expr,
	        'TK_END_EXPR': handle_end_expr,
	        'TK_START_BLOCK': handle_start_block,
	        'TK_END_BLOCK': handle_end_block,
	        'TK_WORD': handle_word,
	        'TK_RESERVED': handle_word,
	        'TK_SEMICOLON': handle_semicolon,
	        'TK_STRING': handle_string,
	        'TK_EQUALS': handle_equals,
	        'TK_OPERATOR': handle_operator,
	        'TK_COMMA': handle_comma,
	        'TK_BLOCK_COMMENT': handle_block_comment,
	        'TK_INLINE_COMMENT': handle_inline_comment,
	        'TK_COMMENT': handle_comment,
	        'TK_DOT': handle_dot,
	        'TK_UNKNOWN': handle_unknown
	    };

	    function create_flags(flags_base, mode) {
	        var next_indent_level = 0;
	        if (flags_base) {
	            next_indent_level = flags_base.indentation_level;
	            if (!just_added_newline() && flags_base.line_indent_level > next_indent_level) {
	                next_indent_level = flags_base.line_indent_level;
	            }
	        }

	        var next_flags = {
	            mode: mode,
	            parent: flags_base,
	            last_text: flags_base ? flags_base.last_text : '', // last token text
	            last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
	            declaration_statement: false,
	            declaration_assignment: false,
	            in_html_comment: false,
	            multiline_frame: false,
	            if_block: false,
	            else_block: false,
	            do_block: false,
	            do_while: false,
	            in_case_statement: false, // switch(..){ INSIDE HERE }
	            in_case: false, // we're on the exact line with "case 0:"
	            case_body: false, // the indented case-action block
	            indentation_level: next_indent_level,
	            line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
	            start_line_index: output_lines.length,
	            had_comment: false,
	            ternary_depth: 0
	        };
	        return next_flags;
	    }

	    // Using object instead of string to allow for later expansion of info about each line

	    function create_output_line() {
	        return {
	            text: []
	        };
	    }

	    // Some interpreters have unexpected results with foo = baz || bar;
	    options = options ? options : {};
	    opt = {};

	    // compatibility
	    if (options.space_after_anon_function !== undefined && options.jslint_happy === undefined) {
	        options.jslint_happy = options.space_after_anon_function;
	    }
	    if (options.braces_on_own_line !== undefined) {
	        //graceful handling of deprecated option
	        opt.brace_style = options.braces_on_own_line ? "expand" : "collapse";
	    }
	    opt.brace_style = options.brace_style ? options.brace_style : opt.brace_style ? opt.brace_style : "collapse";

	    // graceful handling of deprecated option
	    if (opt.brace_style === "expand-strict") {
	        opt.brace_style = "expand";
	    }

	    opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
	    opt.indent_char = options.indent_char ? options.indent_char : ' ';
	    opt.preserve_newlines = options.preserve_newlines === undefined ? true : options.preserve_newlines;
	    opt.break_chained_methods = options.break_chained_methods === undefined ? false : options.break_chained_methods;
	    opt.max_preserve_newlines = options.max_preserve_newlines === undefined ? 0 : parseInt(options.max_preserve_newlines, 10);
	    opt.space_in_paren = options.space_in_paren === undefined ? false : options.space_in_paren;
	    opt.space_in_empty_paren = options.space_in_empty_paren === undefined ? false : options.space_in_empty_paren;
	    opt.jslint_happy = options.jslint_happy === undefined ? false : options.jslint_happy;
	    opt.keep_array_indentation = options.keep_array_indentation === undefined ? false : options.keep_array_indentation;
	    opt.space_before_conditional = options.space_before_conditional === undefined ? true : options.space_before_conditional;
	    opt.unescape_strings = options.unescape_strings === undefined ? false : options.unescape_strings;
	    opt.wrap_line_length = options.wrap_line_length === undefined ? 0 : parseInt(options.wrap_line_length, 10);
	    opt.e4x = options.e4x === undefined ? false : options.e4x;

	    if (options.indent_with_tabs) {
	        opt.indent_char = '\t';
	        opt.indent_size = 1;
	    }

	    //----------------------------------
	    indent_string = '';
	    while (opt.indent_size > 0) {
	        indent_string += opt.indent_char;
	        opt.indent_size -= 1;
	    }

	    while (js_source_text && (js_source_text.charAt(0) === ' ' || js_source_text.charAt(0) === '\t')) {
	        preindent_string += js_source_text.charAt(0);
	        js_source_text = js_source_text.substring(1);
	    }
	    input = js_source_text;
	    // cache the source's length.
	    input_length = js_source_text.length;

	    last_type = 'TK_START_BLOCK'; // last token type
	    last_last_text = ''; // pre-last token text
	    output_lines = [create_output_line()];
	    output_space_before_token = false;
	    whitespace_before_token = [];

	    // Stack of parsing/formatting states, including MODE.
	    // We tokenize, parse, and output in an almost purely a forward-only stream of token input
	    // and formatted output.  This makes the beautifier less accurate than full parsers
	    // but also far more tolerant of syntax errors.
	    //
	    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
	    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
	    // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
	    // most full parsers would die, but the beautifier gracefully falls back to
	    // MODE.BlockStatement and continues on.
	    flag_store = [];
	    set_mode(MODE.BlockStatement);

	    parser_pos = 0;

	    this.beautify = function () {
	        /*jshint onevar:true */
	        var t, i, keep_whitespace, sweet_code;

	        while (true) {
	            t = get_next_token();
	            token_text = t[0];
	            token_type = t[1];

	            if (token_type === 'TK_EOF') {
	                // Unwind any open statements
	                while (flags.mode === MODE.Statement) {
	                    restore_mode();
	                }
	                break;
	            }

	            keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);
	            input_wanted_newline = n_newlines > 0;

	            if (keep_whitespace) {
	                for (i = 0; i < n_newlines; i += 1) {
	                    print_newline(i > 0);
	                }
	            } else {
	                if (opt.max_preserve_newlines && n_newlines > opt.max_preserve_newlines) {
	                    n_newlines = opt.max_preserve_newlines;
	                }

	                if (opt.preserve_newlines) {
	                    if (n_newlines > 1) {
	                        print_newline();
	                        for (i = 1; i < n_newlines; i += 1) {
	                            print_newline(true);
	                        }
	                    }
	                }
	            }

	            handlers[token_type]();

	            // The cleanest handling of inline comments is to treat them as though they aren't there.
	            // Just continue formatting and the behavior should be logical.
	            // Also ignore unknown tokens.  Again, this should result in better behavior.
	            if (token_type !== 'TK_INLINE_COMMENT' && token_type !== 'TK_COMMENT' && token_type !== 'TK_BLOCK_COMMENT' && token_type !== 'TK_UNKNOWN') {
	                last_last_text = flags.last_text;
	                last_type = token_type;
	                flags.last_text = token_text;
	            }
	            flags.had_comment = token_type === 'TK_INLINE_COMMENT' || token_type === 'TK_COMMENT' || token_type === 'TK_BLOCK_COMMENT';
	        }

	        sweet_code = output_lines[0].text.join('');
	        for (var line_index = 1; line_index < output_lines.length; line_index++) {
	            sweet_code += '\n' + output_lines[line_index].text.join('');
	        }
	        sweet_code = sweet_code.replace(/[\r\n ]+$/, '');
	        return sweet_code;
	    };

	    function trim_output(eat_newlines) {
	        eat_newlines = eat_newlines === undefined ? false : eat_newlines;

	        if (output_lines.length) {
	            trim_output_line(output_lines[output_lines.length - 1], eat_newlines);

	            while (eat_newlines && output_lines.length > 1 && output_lines[output_lines.length - 1].text.length === 0) {
	                output_lines.pop();
	                trim_output_line(output_lines[output_lines.length - 1], eat_newlines);
	            }
	        }
	    }

	    function trim_output_line(line) {
	        while (line.text.length && (line.text[line.text.length - 1] === ' ' || line.text[line.text.length - 1] === indent_string || line.text[line.text.length - 1] === preindent_string)) {
	            line.text.pop();
	        }
	    }

	    function trim(s) {
	        return s.replace(/^\s+|\s+$/g, '');
	    }

	    // we could use just string.split, but
	    // IE doesn't like returning empty strings

	    function split_newlines(s) {
	        //return s.split(/\x0d\x0a|\x0a/);

	        s = s.replace(/\x0d/g, '');
	        var out = [],
	            idx = s.indexOf("\n");
	        while (idx !== -1) {
	            out.push(s.substring(0, idx));
	            s = s.substring(idx + 1);
	            idx = s.indexOf("\n");
	        }
	        if (s.length) {
	            out.push(s);
	        }
	        return out;
	    }

	    function just_added_newline() {
	        var line = output_lines[output_lines.length - 1];
	        return line.text.length === 0;
	    }

	    function just_added_blankline() {
	        if (just_added_newline()) {
	            if (output_lines.length === 1) {
	                return true; // start of the file and newline = blank
	            }

	            var line = output_lines[output_lines.length - 2];
	            return line.text.length === 0;
	        }
	        return false;
	    }

	    function allow_wrap_or_preserved_newline(force_linewrap) {
	        force_linewrap = force_linewrap === undefined ? false : force_linewrap;
	        if (opt.wrap_line_length && !force_linewrap) {
	            var line = output_lines[output_lines.length - 1];
	            var proposed_line_length = 0;
	            // never wrap the first token of a line.
	            if (line.text.length > 0) {
	                proposed_line_length = line.text.join('').length + token_text.length + (output_space_before_token ? 1 : 0);
	                if (proposed_line_length >= opt.wrap_line_length) {
	                    force_linewrap = true;
	                }
	            }
	        }
	        if ((opt.preserve_newlines && input_wanted_newline || force_linewrap) && !just_added_newline()) {
	            print_newline(false, true);
	        }
	    }

	    function print_newline(force_newline, preserve_statement_flags) {
	        output_space_before_token = false;

	        if (!preserve_statement_flags) {
	            if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
	                while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
	                    restore_mode();
	                }
	            }
	        }

	        if (output_lines.length === 1 && just_added_newline()) {
	            return; // no newline on start of file
	        }

	        if (force_newline || !just_added_newline()) {
	            flags.multiline_frame = true;
	            output_lines.push(create_output_line());
	        }
	    }

	    function print_token_line_indentation() {
	        if (just_added_newline()) {
	            var line = output_lines[output_lines.length - 1];
	            if (opt.keep_array_indentation && is_array(flags.mode) && input_wanted_newline) {
	                // prevent removing of this whitespace as redundant
	                line.text.push('');
	                for (var i = 0; i < whitespace_before_token.length; i += 1) {
	                    line.text.push(whitespace_before_token[i]);
	                }
	            } else {
	                if (preindent_string) {
	                    line.text.push(preindent_string);
	                }

	                print_indent_string(flags.indentation_level);
	            }
	        }
	    }

	    function print_indent_string(level) {
	        // Never indent your first output indent at the start of the file
	        if (output_lines.length > 1) {
	            var line = output_lines[output_lines.length - 1];

	            flags.line_indent_level = level;
	            for (var i = 0; i < level; i += 1) {
	                line.text.push(indent_string);
	            }
	        }
	    }

	    function print_token_space_before() {
	        var line = output_lines[output_lines.length - 1];
	        if (output_space_before_token && line.text.length) {
	            var last_output = line.text[line.text.length - 1];
	            if (last_output !== ' ' && last_output !== indent_string) {
	                // prevent occassional duplicate space
	                line.text.push(' ');
	            }
	        }
	    }

	    function print_token(printable_token) {
	        printable_token = printable_token || token_text;
	        print_token_line_indentation();
	        print_token_space_before();
	        output_space_before_token = false;
	        output_lines[output_lines.length - 1].text.push(printable_token);
	    }

	    function indent() {
	        flags.indentation_level += 1;
	    }

	    function deindent() {
	        if (flags.indentation_level > 0 && (!flags.parent || flags.indentation_level > flags.parent.indentation_level)) flags.indentation_level -= 1;
	    }

	    function remove_redundant_indentation(frame) {
	        // This implementation is effective but has some issues:
	        //     - less than great performance due to array splicing
	        //     - can cause line wrap to happen too soon due to indent removal
	        //           after wrap points are calculated
	        // These issues are minor compared to ugly indentation.

	        if (frame.multiline_frame) return;

	        // remove one indent from each line inside this section
	        var index = frame.start_line_index;
	        var splice_index = 0;
	        var line;

	        while (index < output_lines.length) {
	            line = output_lines[index];
	            index++;

	            // skip empty lines
	            if (line.text.length === 0) {
	                continue;
	            }

	            // skip the preindent string if present
	            if (preindent_string && line.text[0] === preindent_string) {
	                splice_index = 1;
	            } else {
	                splice_index = 0;
	            }

	            // remove one indent, if present
	            if (line.text[splice_index] === indent_string) {
	                line.text.splice(splice_index, 1);
	            }
	        }
	    }

	    function set_mode(mode) {
	        if (flags) {
	            flag_store.push(flags);
	            previous_flags = flags;
	        } else {
	            previous_flags = create_flags(null, mode);
	        }

	        flags = create_flags(previous_flags, mode);
	    }

	    function is_array(mode) {
	        return mode === MODE.ArrayLiteral;
	    }

	    function is_expression(mode) {
	        return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
	    }

	    function restore_mode() {
	        if (flag_store.length > 0) {
	            previous_flags = flags;
	            flags = flag_store.pop();
	            if (previous_flags.mode === MODE.Statement) {
	                remove_redundant_indentation(previous_flags);
	            }
	        }
	    }

	    function start_of_object_property() {
	        return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && flags.last_text === ':' && flags.ternary_depth === 0;
	    }

	    function start_of_statement() {
	        if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && token_type === 'TK_WORD' || last_type === 'TK_RESERVED' && flags.last_text === 'do' || last_type === 'TK_RESERVED' && flags.last_text === 'return' && !input_wanted_newline || last_type === 'TK_RESERVED' && flags.last_text === 'else' && !(token_type === 'TK_RESERVED' && token_text === 'if') || last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional) || last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement && !flags.in_case && !(token_text === '--' || token_text === '++') && token_type !== 'TK_WORD' && token_type !== 'TK_RESERVED' || flags.mode === MODE.ObjectLiteral && flags.last_text === ':' && flags.ternary_depth === 0) {

	            set_mode(MODE.Statement);
	            indent();

	            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && token_type === 'TK_WORD') {
	                flags.declaration_statement = true;
	            }

	            // Issue #276:
	            // If starting a new statement with [if, for, while, do], push to a new line.
	            // if (a) if (b) if(c) d(); else e(); else f();
	            if (!start_of_object_property()) {
	                allow_wrap_or_preserved_newline(token_type === 'TK_RESERVED' && in_array(token_text, ['do', 'for', 'if', 'while']));
	            }

	            return true;
	        }
	        return false;
	    }

	    function all_lines_start_with(lines, c) {
	        for (var i = 0; i < lines.length; i++) {
	            var line = trim(lines[i]);
	            if (line.charAt(0) !== c) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function each_line_matches_indent(lines, indent) {
	        var i = 0,
	            len = lines.length,
	            line;
	        for (; i < len; i++) {
	            line = lines[i];
	            // allow empty lines to pass through
	            if (line && line.indexOf(indent) !== 0) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function is_special_word(word) {
	        return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
	    }

	    function in_array(what, arr) {
	        for (var i = 0; i < arr.length; i += 1) {
	            if (arr[i] === what) {
	                return true;
	            }
	        }
	        return false;
	    }

	    function unescape_string(s) {
	        var esc = false,
	            out = '',
	            pos = 0,
	            s_hex = '',
	            escaped = 0,
	            c;

	        while (esc || pos < s.length) {

	            c = s.charAt(pos);
	            pos++;

	            if (esc) {
	                esc = false;
	                if (c === 'x') {
	                    // simple hex-escape \x24
	                    s_hex = s.substr(pos, 2);
	                    pos += 2;
	                } else if (c === 'u') {
	                    // unicode-escape, \u2134
	                    s_hex = s.substr(pos, 4);
	                    pos += 4;
	                } else {
	                    // some common escape, e.g \n
	                    out += '\\' + c;
	                    continue;
	                }
	                if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {
	                    // some weird escaping, bail out,
	                    // leaving whole string intact
	                    return s;
	                }

	                escaped = parseInt(s_hex, 16);

	                if (escaped >= 0x00 && escaped < 0x20) {
	                    // leave 0x00...0x1f escaped
	                    if (c === 'x') {
	                        out += '\\x' + s_hex;
	                    } else {
	                        out += '\\u' + s_hex;
	                    }
	                    continue;
	                } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
	                    // single-quote, apostrophe, backslash - escape these
	                    out += '\\' + String.fromCharCode(escaped);
	                } else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {
	                    // we bail out on \x7f..\xff,
	                    // leaving whole string escaped,
	                    // as it's probably completely binary
	                    return s;
	                } else {
	                    out += String.fromCharCode(escaped);
	                }
	            } else if (c === '\\') {
	                esc = true;
	            } else {
	                out += c;
	            }
	        }
	        return out;
	    }

	    function is_next(find) {
	        var local_pos = parser_pos;
	        var c = input.charAt(local_pos);
	        while (in_array(c, whitespace) && c !== find) {
	            local_pos++;
	            if (local_pos >= input_length) {
	                return false;
	            }
	            c = input.charAt(local_pos);
	        }
	        return c === find;
	    }

	    function get_next_token() {
	        var i, resulting_string;

	        n_newlines = 0;

	        if (parser_pos >= input_length) {
	            return ['', 'TK_EOF'];
	        }

	        input_wanted_newline = false;
	        whitespace_before_token = [];

	        var c = input.charAt(parser_pos);
	        parser_pos += 1;

	        while (in_array(c, whitespace)) {

	            if (c === '\n') {
	                n_newlines += 1;
	                whitespace_before_token = [];
	            } else if (n_newlines) {
	                if (c === indent_string) {
	                    whitespace_before_token.push(indent_string);
	                } else if (c !== '\r') {
	                    whitespace_before_token.push(' ');
	                }
	            }

	            if (parser_pos >= input_length) {
	                return ['', 'TK_EOF'];
	            }

	            c = input.charAt(parser_pos);
	            parser_pos += 1;
	        }

	        // NOTE: because beautifier doesn't fully parse, it doesn't use acorn.isIdentifierStart.
	        // It just treats all identifiers and numbers and such the same.
	        if (acorn.isIdentifierChar(input.charCodeAt(parser_pos - 1))) {
	            if (parser_pos < input_length) {
	                while (acorn.isIdentifierChar(input.charCodeAt(parser_pos))) {
	                    c += input.charAt(parser_pos);
	                    parser_pos += 1;
	                    if (parser_pos === input_length) {
	                        break;
	                    }
	                }
	            }

	            // small and surprisingly unugly hack for 1E-10 representation
	            if (parser_pos !== input_length && c.match(/^[0-9]+[Ee]$/) && (input.charAt(parser_pos) === '-' || input.charAt(parser_pos) === '+')) {

	                var sign = input.charAt(parser_pos);
	                parser_pos += 1;

	                var t = get_next_token();
	                c += sign + t[0];
	                return [c, 'TK_WORD'];
	            }

	            if (!(last_type === 'TK_DOT' || last_type === 'TK_RESERVED' && in_array(flags.last_text, ['set', 'get'])) && in_array(c, reserved_words)) {
	                if (c === 'in') {
	                    // hack for 'in' operator
	                    return [c, 'TK_OPERATOR'];
	                }
	                return [c, 'TK_RESERVED'];
	            }
	            return [c, 'TK_WORD'];
	        }

	        if (c === '(' || c === '[') {
	            return [c, 'TK_START_EXPR'];
	        }

	        if (c === ')' || c === ']') {
	            return [c, 'TK_END_EXPR'];
	        }

	        if (c === '{') {
	            return [c, 'TK_START_BLOCK'];
	        }

	        if (c === '}') {
	            return [c, 'TK_END_BLOCK'];
	        }

	        if (c === ';') {
	            return [c, 'TK_SEMICOLON'];
	        }

	        if (c === '/') {
	            var comment = '';
	            // peek for comment /* ... */
	            var inline_comment = true;
	            if (input.charAt(parser_pos) === '*') {
	                parser_pos += 1;
	                if (parser_pos < input_length) {
	                    while (parser_pos < input_length && !(input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/')) {
	                        c = input.charAt(parser_pos);
	                        comment += c;
	                        if (c === "\n" || c === "\r") {
	                            inline_comment = false;
	                        }
	                        parser_pos += 1;
	                        if (parser_pos >= input_length) {
	                            break;
	                        }
	                    }
	                }
	                parser_pos += 2;
	                if (inline_comment && n_newlines === 0) {
	                    return ['/*' + comment + '*/', 'TK_INLINE_COMMENT'];
	                } else {
	                    return ['/*' + comment + '*/', 'TK_BLOCK_COMMENT'];
	                }
	            }
	            // peek for comment // ...
	            if (input.charAt(parser_pos) === '/') {
	                comment = c;
	                while (input.charAt(parser_pos) !== '\r' && input.charAt(parser_pos) !== '\n') {
	                    comment += input.charAt(parser_pos);
	                    parser_pos += 1;
	                    if (parser_pos >= input_length) {
	                        break;
	                    }
	                }
	                return [comment, 'TK_COMMENT'];
	            }
	        }

	        if (c === '`' || c === "'" || c === '"' || // string
	        (c === '/' || // regexp
	        opt.e4x && c === "<" && input.slice(parser_pos - 1).match(/^<([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])\s*([-a-zA-Z:0-9_.]+=('[^']*'|"[^"]*"|{[^{}]*})\s*)*\/?\s*>/) // xml
	        ) && ( // regex and xml can only appear in specific locations during parsing
	        last_type === 'TK_RESERVED' && is_special_word(flags.last_text) || last_type === 'TK_END_EXPR' && in_array(previous_flags.mode, [MODE.Conditional, MODE.ForInitializer]) || in_array(last_type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK', 'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA']))) {

	            var sep = c,
	                esc = false,
	                has_char_escapes = false;

	            resulting_string = c;

	            if (parser_pos < input_length) {
	                if (sep === '/') {
	                    //
	                    // handle regexp
	                    //
	                    var in_char_class = false;
	                    while (esc || in_char_class || input.charAt(parser_pos) !== sep) {
	                        resulting_string += input.charAt(parser_pos);
	                        if (!esc) {
	                            esc = input.charAt(parser_pos) === '\\';
	                            if (input.charAt(parser_pos) === '[') {
	                                in_char_class = true;
	                            } else if (input.charAt(parser_pos) === ']') {
	                                in_char_class = false;
	                            }
	                        } else {
	                            esc = false;
	                        }
	                        parser_pos += 1;
	                        if (parser_pos >= input_length) {
	                            // incomplete string/rexp when end-of-file reached.
	                            // bail out with what had been received so far.
	                            return [resulting_string, 'TK_STRING'];
	                        }
	                    }
	                } else if (opt.e4x && sep === '<') {
	                    //
	                    // handle e4x xml literals
	                    //
	                    var xmlRegExp = /<(\/?)([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])\s*([-a-zA-Z:0-9_.]+=('[^']*'|"[^"]*"|{[^{}]*})\s*)*(\/?)\s*>/g;
	                    var xmlStr = input.slice(parser_pos - 1);
	                    var match = xmlRegExp.exec(xmlStr);
	                    if (match && match.index === 0) {
	                        var rootTag = match[2];
	                        var depth = 0;
	                        while (match) {
	                            var isEndTag = !!match[1];
	                            var tagName = match[2];
	                            var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === "![CDATA[";
	                            if (tagName === rootTag && !isSingletonTag) {
	                                if (isEndTag) {
	                                    --depth;
	                                } else {
	                                    ++depth;
	                                }
	                            }
	                            if (depth <= 0) {
	                                break;
	                            }
	                            match = xmlRegExp.exec(xmlStr);
	                        }
	                        var xmlLength = match ? match.index + match[0].length : xmlStr.length;
	                        parser_pos += xmlLength - 1;
	                        return [xmlStr.slice(0, xmlLength), "TK_STRING"];
	                    }
	                } else {
	                    //
	                    // handle string
	                    //
	                    while (esc || input.charAt(parser_pos) !== sep) {
	                        resulting_string += input.charAt(parser_pos);
	                        if (esc) {
	                            if (input.charAt(parser_pos) === 'x' || input.charAt(parser_pos) === 'u') {
	                                has_char_escapes = true;
	                            }
	                            esc = false;
	                        } else {
	                            esc = input.charAt(parser_pos) === '\\';
	                        }
	                        parser_pos += 1;
	                        if (parser_pos >= input_length) {
	                            // incomplete string/rexp when end-of-file reached.
	                            // bail out with what had been received so far.
	                            return [resulting_string, 'TK_STRING'];
	                        }
	                    }
	                }
	            }

	            parser_pos += 1;
	            resulting_string += sep;

	            if (has_char_escapes && opt.unescape_strings) {
	                resulting_string = unescape_string(resulting_string);
	            }

	            if (sep === '/') {
	                // regexps may have modifiers /regexp/MOD , so fetch those, too
	                while (parser_pos < input_length && in_array(input.charAt(parser_pos), wordchar)) {
	                    resulting_string += input.charAt(parser_pos);
	                    parser_pos += 1;
	                }
	            }
	            return [resulting_string, 'TK_STRING'];
	        }

	        if (c === '#') {

	            if (output_lines.length === 1 && output_lines[0].text.length === 0 && input.charAt(parser_pos) === '!') {
	                // shebang
	                resulting_string = c;
	                while (parser_pos < input_length && c !== '\n') {
	                    c = input.charAt(parser_pos);
	                    resulting_string += c;
	                    parser_pos += 1;
	                }
	                return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
	            }

	            // Spidermonkey-specific sharp variables for circular references
	            // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
	            // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
	            var sharp = '#';
	            if (parser_pos < input_length && in_array(input.charAt(parser_pos), digits)) {
	                do {
	                    c = input.charAt(parser_pos);
	                    sharp += c;
	                    parser_pos += 1;
	                } while (parser_pos < input_length && c !== '#' && c !== '=');
	                if (c === '#') {
	                    //
	                } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {
	                        sharp += '[]';
	                        parser_pos += 2;
	                    } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {
	                        sharp += '{}';
	                        parser_pos += 2;
	                    }
	                return [sharp, 'TK_WORD'];
	            }
	        }

	        if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {
	            parser_pos += 3;
	            c = '<!--';
	            while (input.charAt(parser_pos) !== '\n' && parser_pos < input_length) {
	                c += input.charAt(parser_pos);
	                parser_pos++;
	            }
	            flags.in_html_comment = true;
	            return [c, 'TK_COMMENT'];
	        }

	        if (c === '-' && flags.in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {
	            flags.in_html_comment = false;
	            parser_pos += 2;
	            return ['-->', 'TK_COMMENT'];
	        }

	        if (c === '.') {
	            return [c, 'TK_DOT'];
	        }

	        if (in_array(c, punct)) {
	            while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {
	                c += input.charAt(parser_pos);
	                parser_pos += 1;
	                if (parser_pos >= input_length) {
	                    break;
	                }
	            }

	            if (c === ',') {
	                return [c, 'TK_COMMA'];
	            } else if (c === '=') {
	                return [c, 'TK_EQUALS'];
	            } else {
	                return [c, 'TK_OPERATOR'];
	            }
	        }

	        return [c, 'TK_UNKNOWN'];
	    }

	    function handle_start_expr() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        var next_mode = MODE.Expression;
	        if (token_text === '[') {

	            if (last_type === 'TK_WORD' || flags.last_text === ')') {
	                // this is array index specifier, break immediately
	                // a[x], fn()[x]
	                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, line_starters)) {
	                    output_space_before_token = true;
	                }
	                set_mode(next_mode);
	                print_token();
	                indent();
	                if (opt.space_in_paren) {
	                    output_space_before_token = true;
	                }
	                return;
	            }

	            next_mode = MODE.ArrayLiteral;
	            if (is_array(flags.mode)) {
	                if (flags.last_text === '[' || flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}')) {
	                    // ], [ goes to new line
	                    // }, [ goes to new line
	                    if (!opt.keep_array_indentation) {
	                        print_newline();
	                    }
	                }
	            }
	        } else {
	            if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
	                next_mode = MODE.ForInitializer;
	            } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
	                next_mode = MODE.Conditional;
	            } else {
	                // next_mode = MODE.Expression;
	            }
	        }

	        if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
	            print_newline();
	        } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
	            // TODO: Consider whether forcing this is required.  Review failing tests when removed.
	            allow_wrap_or_preserved_newline(input_wanted_newline);
	            // do nothing on (( and )( and ][ and ]( and .(
	        } else if (!(last_type === 'TK_RESERVED' && token_text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
	                output_space_before_token = true;
	            } else if (last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof') || flags.last_text === '*' && last_last_text === 'function') {
	                // function() vs function ()
	                if (opt.jslint_happy) {
	                    output_space_before_token = true;
	                }
	            } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, line_starters) || flags.last_text === 'catch')) {
	                if (opt.space_before_conditional) {
	                    output_space_before_token = true;
	                }
	            }

	        // Support of this kind of newline preservation.
	        // a = (b &&
	        //     (c || d));
	        if (token_text === '(') {
	            if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	                if (!start_of_object_property()) {
	                    allow_wrap_or_preserved_newline();
	                }
	            }
	        }

	        set_mode(next_mode);
	        print_token();
	        if (opt.space_in_paren) {
	            output_space_before_token = true;
	        }

	        // In all cases, if we newline while inside an expression it should be indented.
	        indent();
	    }

	    function handle_end_expr() {
	        // statements inside expressions are not valid syntax, but...
	        // statements must all be closed when their container closes
	        while (flags.mode === MODE.Statement) {
	            restore_mode();
	        }

	        if (flags.multiline_frame) {
	            allow_wrap_or_preserved_newline(token_text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);
	        }

	        if (opt.space_in_paren) {
	            if (last_type === 'TK_START_EXPR' && !opt.space_in_empty_paren) {
	                // () [] no inner space in empty parens like these, ever, ref #320
	                trim_output();
	                output_space_before_token = false;
	            } else {
	                output_space_before_token = true;
	            }
	        }
	        if (token_text === ']' && opt.keep_array_indentation) {
	            print_token();
	            restore_mode();
	        } else {
	            restore_mode();
	            print_token();
	        }
	        remove_redundant_indentation(previous_flags);

	        // do {} while () // no statement required after
	        if (flags.do_while && previous_flags.mode === MODE.Conditional) {
	            previous_flags.mode = MODE.Expression;
	            flags.do_block = false;
	            flags.do_while = false;
	        }
	    }

	    function handle_start_block() {
	        set_mode(MODE.BlockStatement);

	        var empty_braces = is_next('}');
	        var empty_anonymous_function = empty_braces && flags.last_word === 'function' && last_type === 'TK_END_EXPR';

	        if (opt.brace_style === "expand") {
	            if (last_type !== 'TK_OPERATOR' && (empty_anonymous_function || last_type === 'TK_EQUALS' || last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else')) {
	                output_space_before_token = true;
	            } else {
	                print_newline(false, true);
	            }
	        } else {
	            // collapse
	            if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
	                if (last_type === 'TK_START_BLOCK') {
	                    print_newline();
	                } else {
	                    output_space_before_token = true;
	                }
	            } else {
	                // if TK_OPERATOR or TK_START_EXPR
	                if (is_array(previous_flags.mode) && flags.last_text === ',') {
	                    if (last_last_text === '}') {
	                        // }, { in array context
	                        output_space_before_token = true;
	                    } else {
	                        print_newline(); // [a, b, c, {
	                    }
	                }
	            }
	        }
	        print_token();
	        indent();
	    }

	    function handle_end_block() {
	        // statements must all be closed when their container closes
	        while (flags.mode === MODE.Statement) {
	            restore_mode();
	        }
	        var empty_braces = last_type === 'TK_START_BLOCK';

	        if (opt.brace_style === "expand") {
	            if (!empty_braces) {
	                print_newline();
	            }
	        } else {
	            // skip {}
	            if (!empty_braces) {
	                if (is_array(flags.mode) && opt.keep_array_indentation) {
	                    // we REALLY need a newline here, but newliner would skip that
	                    opt.keep_array_indentation = false;
	                    print_newline();
	                    opt.keep_array_indentation = true;
	                } else {
	                    print_newline();
	                }
	            }
	        }
	        restore_mode();
	        print_token();
	    }

	    function handle_word() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        } else if (input_wanted_newline && !is_expression(flags.mode) && (last_type !== 'TK_OPERATOR' || flags.last_text === '--' || flags.last_text === '++') && last_type !== 'TK_EQUALS' && (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {

	                print_newline();
	            }

	        if (flags.do_block && !flags.do_while) {
	            if (token_type === 'TK_RESERVED' && token_text === 'while') {
	                // do {} ## while ()
	                output_space_before_token = true;
	                print_token();
	                output_space_before_token = true;
	                flags.do_while = true;
	                return;
	            } else {
	                // do {} should always have while as the next word.
	                // if we don't see the expected while, recover
	                print_newline();
	                flags.do_block = false;
	            }
	        }

	        // if may be followed by else, or not
	        // Bare/inline ifs are tricky
	        // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
	        if (flags.if_block) {
	            if (!flags.else_block && token_type === 'TK_RESERVED' && token_text === 'else') {
	                flags.else_block = true;
	            } else {
	                while (flags.mode === MODE.Statement) {
	                    restore_mode();
	                }
	                flags.if_block = false;
	                flags.else_block = false;
	            }
	        }

	        if (token_type === 'TK_RESERVED' && (token_text === 'case' || token_text === 'default' && flags.in_case_statement)) {
	            print_newline();
	            if (flags.case_body || opt.jslint_happy) {
	                // switch cases following one another
	                deindent();
	                flags.case_body = false;
	            }
	            print_token();
	            flags.in_case = true;
	            flags.in_case_statement = true;
	            return;
	        }

	        if (token_type === 'TK_RESERVED' && token_text === 'function') {
	            if (in_array(flags.last_text, ['}', ';']) || just_added_newline() && !in_array(flags.last_text, ['{', ':', '=', ','])) {
	                // make sure there is a nice clean space of at least one blank line
	                // before a new function definition
	                if (!just_added_blankline() && !flags.had_comment) {
	                    print_newline();
	                    print_newline(true);
	                }
	            }
	            if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
	                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return'])) {
	                    output_space_before_token = true;
	                } else {
	                    print_newline();
	                }
	            } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
	                // foo = function
	                output_space_before_token = true;
	            } else if (is_expression(flags.mode)) {
	                // (function
	            } else {
	                    print_newline();
	                }
	        }

	        if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	            if (!start_of_object_property()) {
	                allow_wrap_or_preserved_newline();
	            }
	        }

	        if (token_type === 'TK_RESERVED' && token_text === 'function') {
	            print_token();
	            flags.last_word = token_text;
	            return;
	        }

	        prefix = 'NONE';

	        if (last_type === 'TK_END_BLOCK') {
	            if (!(token_type === 'TK_RESERVED' && in_array(token_text, ['else', 'catch', 'finally']))) {
	                prefix = 'NEWLINE';
	            } else {
	                if (opt.brace_style === "expand" || opt.brace_style === "end-expand") {
	                    prefix = 'NEWLINE';
	                } else {
	                    prefix = 'SPACE';
	                    output_space_before_token = true;
	                }
	            }
	        } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
	            // TODO: Should this be for STATEMENT as well?
	            prefix = 'NEWLINE';
	        } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
	            prefix = 'SPACE';
	        } else if (last_type === 'TK_STRING') {
	            prefix = 'NEWLINE';
	        } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' || flags.last_text === '*' && last_last_text === 'function') {
	            prefix = 'SPACE';
	        } else if (last_type === 'TK_START_BLOCK') {
	            prefix = 'NEWLINE';
	        } else if (last_type === 'TK_END_EXPR') {
	            output_space_before_token = true;
	            prefix = 'NEWLINE';
	        }

	        if (token_type === 'TK_RESERVED' && in_array(token_text, line_starters) && flags.last_text !== ')') {
	            if (flags.last_text === 'else') {
	                prefix = 'SPACE';
	            } else {
	                prefix = 'NEWLINE';
	            }
	        }

	        if (token_type === 'TK_RESERVED' && in_array(token_text, ['else', 'catch', 'finally'])) {
	            if (last_type !== 'TK_END_BLOCK' || opt.brace_style === "expand" || opt.brace_style === "end-expand") {
	                print_newline();
	            } else {
	                trim_output(true);
	                var line = output_lines[output_lines.length - 1];
	                // If we trimmed and there's something other than a close block before us
	                // put a newline back in.  Handles '} // comment' scenario.
	                if (line.text[line.text.length - 1] !== '}') {
	                    print_newline();
	                }
	                output_space_before_token = true;
	            }
	        } else if (prefix === 'NEWLINE') {
	            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	                // no newline between 'return nnn'
	                output_space_before_token = true;
	            } else if (last_type !== 'TK_END_EXPR') {
	                if ((last_type !== 'TK_START_EXPR' || !(token_type === 'TK_RESERVED' && in_array(token_text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
	                    // no need to force newline on 'var': for (var x = 0...)
	                    if (token_type === 'TK_RESERVED' && token_text === 'if' && flags.last_word === 'else' && flags.last_text !== '{') {
	                        // no newline for } else if {
	                        output_space_before_token = true;
	                    } else {
	                        print_newline();
	                    }
	                }
	            } else if (token_type === 'TK_RESERVED' && in_array(token_text, line_starters) && flags.last_text !== ')') {
	                print_newline();
	            }
	        } else if (is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
	            print_newline(); // }, in lists get a newline treatment
	        } else if (prefix === 'SPACE') {
	                output_space_before_token = true;
	            }
	        print_token();
	        flags.last_word = token_text;

	        if (token_type === 'TK_RESERVED' && token_text === 'do') {
	            flags.do_block = true;
	        }

	        if (token_type === 'TK_RESERVED' && token_text === 'if') {
	            flags.if_block = true;
	        }
	    }

	    function handle_semicolon() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	            // Semicolon can be the start (and end) of a statement
	            output_space_before_token = false;
	        }
	        while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
	            restore_mode();
	        }
	        print_token();
	        if (flags.mode === MODE.ObjectLiteral) {
	            // if we're in OBJECT mode and see a semicolon, its invalid syntax
	            // recover back to treating this as a BLOCK
	            flags.mode = MODE.BlockStatement;
	        }
	    }

	    function handle_string() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	            // One difference - strings want at least a space before
	            output_space_before_token = true;
	        } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
	            output_space_before_token = true;
	        } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	            if (!start_of_object_property()) {
	                allow_wrap_or_preserved_newline();
	            }
	        } else {
	            print_newline();
	        }
	        print_token();
	    }

	    function handle_equals() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        if (flags.declaration_statement) {
	            // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
	            flags.declaration_assignment = true;
	        }
	        output_space_before_token = true;
	        print_token();
	        output_space_before_token = true;
	    }

	    function handle_comma() {
	        if (flags.declaration_statement) {
	            if (is_expression(flags.parent.mode)) {
	                // do not break on comma, for(var a = 1, b = 2)
	                flags.declaration_assignment = false;
	            }

	            print_token();

	            if (flags.declaration_assignment) {
	                flags.declaration_assignment = false;
	                print_newline(false, true);
	            } else {
	                output_space_before_token = true;
	            }
	            return;
	        }

	        print_token();
	        if (flags.mode === MODE.ObjectLiteral || flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral) {
	            if (flags.mode === MODE.Statement) {
	                restore_mode();
	            }
	            print_newline();
	        } else {
	            // EXPR or DO_BLOCK
	            output_space_before_token = true;
	        }
	    }

	    function handle_operator() {
	        // Check if this is a BlockStatement that should be treated as a ObjectLiteral
	        if (token_text === ':' && flags.mode === MODE.BlockStatement && last_last_text === '{' && (last_type === 'TK_WORD' || last_type === 'TK_RESERVED')) {
	            flags.mode = MODE.ObjectLiteral;
	        }

	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        var space_before = true;
	        var space_after = true;
	        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	            // "return" had a special handling in TK_WORD. Now we need to return the favor
	            output_space_before_token = true;
	            print_token();
	            return;
	        }

	        // hack for actionscript's import .*;
	        if (token_text === '*' && last_type === 'TK_DOT' && !last_last_text.match(/^\d+$/)) {
	            print_token();
	            return;
	        }

	        if (token_text === ':' && flags.in_case) {
	            flags.case_body = true;
	            indent();
	            print_token();
	            print_newline();
	            flags.in_case = false;
	            return;
	        }

	        if (token_text === '::') {
	            // no spaces around exotic namespacing syntax operator
	            print_token();
	            return;
	        }

	        // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
	        // if there is a newline between -- or ++ and anything else we should preserve it.
	        if (input_wanted_newline && (token_text === '--' || token_text === '++')) {
	            print_newline();
	        }

	        // Allow line wrapping between operators
	        if (last_type === 'TK_OPERATOR') {
	            allow_wrap_or_preserved_newline();
	        }

	        if (in_array(token_text, ['--', '++', '!', '~']) || in_array(token_text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(flags.last_text, line_starters) || flags.last_text === ',')) {
	            // unary operators (and binary +/- pretending to be unary) special cases

	            space_before = false;
	            space_after = false;

	            if (flags.last_text === ';' && is_expression(flags.mode)) {
	                // for (;; ++i)
	                //        ^^^
	                space_before = true;
	            }

	            if (last_type === 'TK_RESERVED') {
	                space_before = true;
	            }

	            if ((flags.mode === MODE.BlockStatement || flags.mode === MODE.Statement) && (flags.last_text === '{' || flags.last_text === ';')) {
	                // { foo; --i }
	                // foo(); --bar;
	                print_newline();
	            }
	        } else if (token_text === ':') {
	            if (flags.ternary_depth === 0) {
	                if (flags.mode === MODE.BlockStatement) {
	                    flags.mode = MODE.ObjectLiteral;
	                }
	                space_before = false;
	            } else {
	                flags.ternary_depth -= 1;
	            }
	        } else if (token_text === '?') {
	            flags.ternary_depth += 1;
	        } else if (token_text === '*' && last_type === 'TK_RESERVED' && flags.last_text === 'function') {
	            space_before = false;
	            space_after = false;
	        }
	        output_space_before_token = output_space_before_token || space_before;
	        print_token();
	        output_space_before_token = space_after;
	    }

	    function handle_block_comment() {
	        var lines = split_newlines(token_text);
	        var j; // iterator for this case
	        var javadoc = false;
	        var starless = false;
	        var lastIndent = whitespace_before_token.join('');
	        var lastIndentLength = lastIndent.length;

	        // block comment starts with a new line
	        print_newline(false, true);
	        if (lines.length > 1) {
	            if (all_lines_start_with(lines.slice(1), '*')) {
	                javadoc = true;
	            } else if (each_line_matches_indent(lines.slice(1), lastIndent)) {
	                starless = true;
	            }
	        }

	        // first line always indented
	        print_token(lines[0]);
	        for (j = 1; j < lines.length; j++) {
	            print_newline(false, true);
	            if (javadoc) {
	                // javadoc: reformat and re-indent
	                print_token(' ' + trim(lines[j]));
	            } else if (starless && lines[j].length > lastIndentLength) {
	                // starless: re-indent non-empty content, avoiding trim
	                print_token(lines[j].substring(lastIndentLength));
	            } else {
	                // normal comments output raw
	                output_lines[output_lines.length - 1].text.push(lines[j]);
	            }
	        }

	        // for comments of more than one line, make sure there's a new line after
	        print_newline(false, true);
	    }

	    function handle_inline_comment() {
	        output_space_before_token = true;
	        print_token();
	        output_space_before_token = true;
	    }

	    function handle_comment() {
	        if (input_wanted_newline) {
	            print_newline(false, true);
	        } else {
	            trim_output(true);
	        }

	        output_space_before_token = true;
	        print_token();
	        print_newline(false, true);
	    }

	    function handle_dot() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	            output_space_before_token = true;
	        } else {
	            // allow preserved newlines before dots in general
	            // force newlines on dots after close paren when break_chained - for bar().baz()
	            allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
	        }

	        print_token();
	    }

	    function handle_unknown() {
	        print_token();

	        if (token_text[token_text.length - 1] === '\n') {
	            print_newline();
	        }
	    }
	}

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */ /* vim: set ft=javascript ts=2 et sw=2 tw=80: */ /* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */"use strict";var _slicedToArray=(function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n = (_s = _i.next()).done);_n = true) {_arr.push(_s.value);if(i && _arr.length === i)break;}}catch(err) {_d = true;_e = err;}finally {try{if(!_n && _i["return"])_i["return"]();}finally {if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else {throw new TypeError("Invalid attempt to destructure non-iterable instance");}};})();const Ci=Components.interfaces;const Cu=Components.utils;const LAZY_EMPTY_DELAY=150; // ms
	const LAZY_EXPAND_DELAY=50; // ms
	const SCROLL_PAGE_SIZE_DEFAULT=0;const PAGE_SIZE_SCROLL_HEIGHT_RATIO=100;const PAGE_SIZE_MAX_JUMPS=30;const SEARCH_ACTION_MAX_DELAY=300; // ms
	const ITEM_FLASH_DURATION=300; // ms
	var _require=__webpack_require__(9);const Services=_require.Services;var _require2=__webpack_require__(15);const XPCOMUtils=_require2.XPCOMUtils;var _require3=__webpack_require__(60);const Heritage=_require3.Heritage;const ViewHelpers=_require3.ViewHelpers;const WidgetMethods=_require3.WidgetMethods;const setNamedTimeout=_require3.setNamedTimeout;const clearNamedTimeout=_require3.clearNamedTimeout;const setConditionalTimeout=_require3.setConditionalTimeout;const clearConditionalTimeout=_require3.clearConditionalTimeout;const EventEmitter=__webpack_require__(7);var _require4=__webpack_require__(38);const Task=_require4.Task;const DevToolsUtils=__webpack_require__(19);const promise=__webpack_require__(6);const PluralForm=__webpack_require__(71);const clipboardHelper=__webpack_require__(31);Object.defineProperty(this,"WebConsoleUtils",{get:function(){return __webpack_require__(72).Utils;},configurable:true,enumerable:true});Object.defineProperty(this,"NetworkHelper",{get:function(){return __webpack_require__(24);},configurable:true,enumerable:true}); /**
	 * Debugger localization strings.
	 */const STR=Services.strings.createBundle(__webpack_require__(84)); /**
	 * A tree view for inspecting scopes, objects and properties.
	 * Iterable via "for (let [id, scope] of instance) { }".
	 * Requires the devtools common.css and debugger.css skin stylesheets.
	 *
	 * To allow replacing variable or property values in this view, provide an
	 * "eval" function property. To allow replacing variable or property names,
	 * provide a "switch" function. To handle deleting variables or properties,
	 * provide a "delete" function.
	 *
	 * @param nsIDOMNode aParentNode
	 *        The parent node to hold this view.
	 * @param object aFlags [optional]
	 *        An object contaning initialization options for this view.
	 *        e.g. { lazyEmpty: true, searchEnabled: true ... }
	 */var VariablesView=function VariablesView(aParentNode,aFlags = {}){this._store = []; // Can't use a Map because Scope names needn't be unique.
	this._itemsByElement = new WeakMap();this._prevHierarchy = new Map();this._currHierarchy = new Map();this._parent = aParentNode;this._parent.classList.add("variables-view-container");this._parent.classList.add("theme-body");this._appendEmptyNotice();this._onSearchboxInput = this._onSearchboxInput.bind(this);this._onSearchboxKeyPress = this._onSearchboxKeyPress.bind(this);this._onViewKeyPress = this._onViewKeyPress.bind(this);this._onViewKeyDown = this._onViewKeyDown.bind(this); // Create an internal scrollbox container.
	this._list = this.document.createElement("scrollbox");this._list.setAttribute("orient","vertical");this._list.addEventListener("keypress",this._onViewKeyPress,false);this._list.addEventListener("keydown",this._onViewKeyDown,false);this._parent.appendChild(this._list);for(let name in aFlags) {this[name] = aFlags[name];}EventEmitter.decorate(this);};VariablesView.prototype = { /**
	   * Helper setter for populating this container with a raw object.
	   *
	   * @param object aObject
	   *        The raw object to display. You can only provide this object
	   *        if you want the variables view to work in sync mode.
	   */set rawObject(aObject){this.empty();this.addScope().addItem("",{enumerable:true}).populate(aObject,{sorted:true});}, /**
	   * Adds a scope to contain any inspected variables.
	   *
	   * This new scope will be considered the parent of any other scope
	   * added afterwards.
	   *
	   * @param string aName
	   *        The scope's name (e.g. "Local", "Global" etc.).
	   * @return Scope
	   *         The newly created Scope instance.
	   */addScope:function(aName = ""){this._removeEmptyNotice();this._toggleSearchVisibility(true);let scope=new Scope(this,aName);this._store.push(scope);this._itemsByElement.set(scope._target,scope);this._currHierarchy.set(aName,scope);scope.header = !!aName;return scope;}, /**
	   * Removes all items from this container.
	   *
	   * @param number aTimeout [optional]
	   *        The number of milliseconds to delay the operation if
	   *        lazy emptying of this container is enabled.
	   */empty:function(aTimeout = this.lazyEmptyDelay){ // If there are no items in this container, emptying is useless.
	if(!this._store.length){return;}this._store.length = 0;this._itemsByElement.clear();this._prevHierarchy = this._currHierarchy;this._currHierarchy = new Map(); // Don't clear, this is just simple swapping.
	// Check if this empty operation may be executed lazily.
	if(this.lazyEmpty && aTimeout > 0){this._emptySoon(aTimeout);return;}while(this._list.hasChildNodes()) {this._list.firstChild.remove();}this._appendEmptyNotice();this._toggleSearchVisibility(false);}, /**
	   * Emptying this container and rebuilding it immediately afterwards would
	   * result in a brief redraw flicker, because the previously expanded nodes
	   * may get asynchronously re-expanded, after fetching the prototype and
	   * properties from a server.
	   *
	   * To avoid such behaviour, a normal container list is rebuild, but not
	   * immediately attached to the parent container. The old container list
	   * is kept around for a short period of time, hopefully accounting for the
	   * data fetching delay. In the meantime, any operations can be executed
	   * normally.
	   *
	   * @see VariablesView.empty
	   * @see VariablesView.commitHierarchy
	   */_emptySoon:function(aTimeout){var _this=this;let prevList=this._list;let currList=this._list = this.document.createElement("scrollbox");this.window.setTimeout(function(){prevList.removeEventListener("keypress",_this._onViewKeyPress,false);prevList.removeEventListener("keydown",_this._onViewKeyDown,false);currList.addEventListener("keypress",_this._onViewKeyPress,false);currList.addEventListener("keydown",_this._onViewKeyDown,false);currList.setAttribute("orient","vertical");_this._parent.removeChild(prevList);_this._parent.appendChild(currList);if(!_this._store.length){_this._appendEmptyNotice();_this._toggleSearchVisibility(false);}},aTimeout);}, /**
	   * Optional DevTools toolbox containing this VariablesView. Used to
	   * communicate with the inspector and highlighter.
	   */toolbox:null, /**
	   * The controller for this VariablesView, if it has one.
	   */controller:null, /**
	   * The amount of time (in milliseconds) it takes to empty this view lazily.
	   */lazyEmptyDelay:LAZY_EMPTY_DELAY, /**
	   * Specifies if this view may be emptied lazily.
	   * @see VariablesView.prototype.empty
	   */lazyEmpty:false, /**
	   * Specifies if nodes in this view may be searched lazily.
	   */lazySearch:true, /**
	   * The number of elements in this container to jump when Page Up or Page Down
	   * keys are pressed. If falsy, then the page size will be based on the
	   * container height.
	   */scrollPageSize:SCROLL_PAGE_SIZE_DEFAULT, /**
	   * Function called each time a variable or property's value is changed via
	   * user interaction. If null, then value changes are disabled.
	   *
	   * This property is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */eval:null, /**
	   * Function called each time a variable or property's name is changed via
	   * user interaction. If null, then name changes are disabled.
	   *
	   * This property is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */switch:null, /**
	   * Function called each time a variable or property is deleted via
	   * user interaction. If null, then deletions are disabled.
	   *
	   * This property is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */delete:null, /**
	   * Function called each time a property is added via user interaction. If
	   * null, then property additions are disabled.
	   *
	   * This property is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */new:null, /**
	   * Specifies if after an eval or switch operation, the variable or property
	   * which has been edited should be disabled.
	   */preventDisableOnChange:false, /**
	   * Specifies if, whenever a variable or property descriptor is available,
	   * configurable, enumerable, writable, frozen, sealed and extensible
	   * attributes should not affect presentation.
	   *
	   * This flag is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */preventDescriptorModifiers:false, /**
	   * The tooltip text shown on a variable or property's value if an |eval|
	   * function is provided, in order to change the variable or property's value.
	   *
	   * This flag is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */editableValueTooltip:STR.GetStringFromName("variablesEditableValueTooltip"), /**
	   * The tooltip text shown on a variable or property's name if a |switch|
	   * function is provided, in order to change the variable or property's name.
	   *
	   * This flag is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */editableNameTooltip:STR.GetStringFromName("variablesEditableNameTooltip"), /**
	   * The tooltip text shown on a variable or property's edit button if an
	   * |eval| function is provided and a getter/setter descriptor is present,
	   * in order to change the variable or property to a plain value.
	   *
	   * This flag is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */editButtonTooltip:STR.GetStringFromName("variablesEditButtonTooltip"), /**
	   * The tooltip text shown on a variable or property's value if that value is
	   * a DOMNode that can be highlighted and selected in the inspector.
	   *
	   * This flag is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */domNodeValueTooltip:STR.GetStringFromName("variablesDomNodeValueTooltip"), /**
	   * The tooltip text shown on a variable or property's delete button if a
	   * |delete| function is provided, in order to delete the variable or property.
	   *
	   * This flag is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */deleteButtonTooltip:STR.GetStringFromName("variablesCloseButtonTooltip"), /**
	   * Specifies the context menu attribute set on variables and properties.
	   *
	   * This flag is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */contextMenuId:"", /**
	   * The separator label between the variables or properties name and value.
	   *
	   * This flag is applied recursively onto each scope in this view and
	   * affects only the child nodes when they're created.
	   */separatorStr:STR.GetStringFromName("variablesSeparatorLabel"), /**
	   * Specifies if enumerable properties and variables should be displayed.
	   * These variables and properties are visible by default.
	   * @param boolean aFlag
	   */set enumVisible(aFlag){this._enumVisible = aFlag;for(let scope of this._store) {scope._enumVisible = aFlag;}}, /**
	   * Specifies if non-enumerable properties and variables should be displayed.
	   * These variables and properties are visible by default.
	   * @param boolean aFlag
	   */set nonEnumVisible(aFlag){this._nonEnumVisible = aFlag;for(let scope of this._store) {scope._nonEnumVisible = aFlag;}}, /**
	   * Specifies if only enumerable properties and variables should be displayed.
	   * Both types of these variables and properties are visible by default.
	   * @param boolean aFlag
	   */set onlyEnumVisible(aFlag){if(aFlag){this.enumVisible = true;this.nonEnumVisible = false;}else {this.enumVisible = true;this.nonEnumVisible = true;}}, /**
	   * Sets if the variable and property searching is enabled.
	   * @param boolean aFlag
	   */set searchEnabled(aFlag){aFlag?this._enableSearch():this._disableSearch();}, /**
	   * Gets if the variable and property searching is enabled.
	   * @return boolean
	   */get searchEnabled(){return !!this._searchboxContainer;}, /**
	   * Sets the text displayed for the searchbox in this container.
	   * @param string aValue
	   */set searchPlaceholder(aValue){if(this._searchboxNode){this._searchboxNode.setAttribute("placeholder",aValue);}this._searchboxPlaceholder = aValue;}, /**
	   * Gets the text displayed for the searchbox in this container.
	   * @return string
	   */get searchPlaceholder(){return this._searchboxPlaceholder;}, /**
	   * Enables variable and property searching in this view.
	   * Use the "searchEnabled" setter to enable searching.
	   */_enableSearch:function(){ // If searching was already enabled, no need to re-enable it again.
	if(this._searchboxContainer){return;}let document=this.document;let ownerNode=this._parent.parentNode;let container=this._searchboxContainer = document.createElement("hbox");container.className = "devtools-toolbar"; // Hide the variables searchbox container if there are no variables or
	// properties to display.
	container.hidden = !this._store.length;let searchbox=this._searchboxNode = document.createElement("textbox");searchbox.className = "variables-view-searchinput devtools-searchinput";searchbox.setAttribute("placeholder",this._searchboxPlaceholder);searchbox.setAttribute("type","search");searchbox.setAttribute("flex","1");searchbox.addEventListener("command",this._onSearchboxInput,false);searchbox.addEventListener("keypress",this._onSearchboxKeyPress,false);container.appendChild(searchbox);ownerNode.insertBefore(container,this._parent);}, /**
	   * Disables variable and property searching in this view.
	   * Use the "searchEnabled" setter to disable searching.
	   */_disableSearch:function(){ // If searching was already disabled, no need to re-disable it again.
	if(!this._searchboxContainer){return;}this._searchboxContainer.remove();this._searchboxNode.removeEventListener("command",this._onSearchboxInput,false);this._searchboxNode.removeEventListener("keypress",this._onSearchboxKeyPress,false);this._searchboxContainer = null;this._searchboxNode = null;}, /**
	   * Sets the variables searchbox container hidden or visible.
	   * It's hidden by default.
	   *
	   * @param boolean aVisibleFlag
	   *        Specifies the intended visibility.
	   */_toggleSearchVisibility:function(aVisibleFlag){ // If searching was already disabled, there's no need to hide it.
	if(!this._searchboxContainer){return;}this._searchboxContainer.hidden = !aVisibleFlag;}, /**
	   * Listener handling the searchbox input event.
	   */_onSearchboxInput:function(){this.scheduleSearch(this._searchboxNode.value);}, /**
	   * Listener handling the searchbox key press event.
	   */_onSearchboxKeyPress:function(e){switch(e.keyCode){case e.DOM_VK_RETURN:this._onSearchboxInput();return;case e.DOM_VK_ESCAPE:this._searchboxNode.value = "";this._onSearchboxInput();return;}}, /**
	   * Schedules searching for variables or properties matching the query.
	   *
	   * @param string aToken
	   *        The variable or property to search for.
	   * @param number aWait
	   *        The amount of milliseconds to wait until draining.
	   */scheduleSearch:function(aToken,aWait){var _this2=this; // Check if this search operation may not be executed lazily.
	if(!this.lazySearch){this._doSearch(aToken);return;} // The amount of time to wait for the requests to settle.
	let maxDelay=SEARCH_ACTION_MAX_DELAY;let delay=aWait === undefined?maxDelay / aToken.length:aWait; // Allow requests to settle down first.
	setNamedTimeout("vview-search",delay,function(){return _this2._doSearch(aToken);});}, /**
	   * Performs a case insensitive search for variables or properties matching
	   * the query, and hides non-matched items.
	   *
	   * If aToken is falsy, then all the scopes are unhidden and expanded,
	   * while the available variables and properties inside those scopes are
	   * just unhidden.
	   *
	   * @param string aToken
	   *        The variable or property to search for.
	   */_doSearch:function(aToken){if(this.controller && this.controller.supportsSearch()){ // Retrieve the main Scope in which we add attributes
	let scope=this._store[0]._store.get("");if(!aToken){ // Prune the view from old previous content
	// so that we delete the intermediate search results
	// we created in previous searches
	for(let property of scope._store.values()) {property.remove();}} // Retrieve new attributes eventually hidden in splits
	this.controller.performSearch(scope,aToken); // Filter already displayed attributes
	if(aToken){scope._performSearch(aToken.toLowerCase());}return;}for(let scope of this._store) {switch(aToken){case "":case null:case undefined:scope.expand();scope._performSearch("");break;default:scope._performSearch(aToken.toLowerCase());break;}}}, /**
	   * Find the first item in the tree of visible items in this container that
	   * matches the predicate. Searches in visual order (the order seen by the
	   * user). Descends into each scope to check the scope and its children.
	   *
	   * @param function aPredicate
	   *        A function that returns true when a match is found.
	   * @return Scope | Variable | Property
	   *         The first visible scope, variable or property, or null if nothing
	   *         is found.
	   */_findInVisibleItems:function(aPredicate){for(let scope of this._store) {let result=scope._findInVisibleItems(aPredicate);if(result){return result;}}return null;}, /**
	   * Find the last item in the tree of visible items in this container that
	   * matches the predicate. Searches in reverse visual order (opposite of the
	   * order seen by the user). Descends into each scope to check the scope and
	   * its children.
	   *
	   * @param function aPredicate
	   *        A function that returns true when a match is found.
	   * @return Scope | Variable | Property
	   *         The last visible scope, variable or property, or null if nothing
	   *         is found.
	   */_findInVisibleItemsReverse:function(aPredicate){for(let i=this._store.length - 1;i >= 0;i--) {let scope=this._store[i];let result=scope._findInVisibleItemsReverse(aPredicate);if(result){return result;}}return null;}, /**
	   * Gets the scope at the specified index.
	   *
	   * @param number aIndex
	   *        The scope's index.
	   * @return Scope
	   *         The scope if found, undefined if not.
	   */getScopeAtIndex:function(aIndex){return this._store[aIndex];}, /**
	   * Recursively searches this container for the scope, variable or property
	   * displayed by the specified node.
	   *
	   * @param nsIDOMNode aNode
	   *        The node to search for.
	   * @return Scope | Variable | Property
	   *         The matched scope, variable or property, or null if nothing is found.
	   */getItemForNode:function(aNode){return this._itemsByElement.get(aNode);}, /**
	   * Gets the scope owning a Variable or Property.
	   *
	   * @param Variable | Property
	   *        The variable or property to retrieven the owner scope for.
	   * @return Scope
	   *         The owner scope.
	   */getOwnerScopeForVariableOrProperty:function(aItem){if(!aItem){return null;} // If this is a Scope, return it.
	if(!(aItem instanceof Variable)){return aItem;} // If this is a Variable or Property, find its owner scope.
	if(aItem instanceof Variable && aItem.ownerView){return this.getOwnerScopeForVariableOrProperty(aItem.ownerView);}return null;}, /**
	   * Gets the parent scopes for a specified Variable or Property.
	   * The returned list will not include the owner scope.
	   *
	   * @param Variable | Property
	   *        The variable or property for which to find the parent scopes.
	   * @return array
	   *         A list of parent Scopes.
	   */getParentScopesForVariableOrProperty:function(aItem){let scope=this.getOwnerScopeForVariableOrProperty(aItem);return this._store.slice(0,Math.max(this._store.indexOf(scope),0));}, /**
	   * Gets the currently focused scope, variable or property in this view.
	   *
	   * @return Scope | Variable | Property
	   *         The focused scope, variable or property, or null if nothing is found.
	   */getFocusedItem:function(){let focused=this.document.commandDispatcher.focusedElement;return this.getItemForNode(focused);}, /**
	   * Focuses the first visible scope, variable, or property in this container.
	   */focusFirstVisibleItem:function(){let focusableItem=this._findInVisibleItems(function(item){return item.focusable;});if(focusableItem){this._focusItem(focusableItem);}this._parent.scrollTop = 0;this._parent.scrollLeft = 0;}, /**
	   * Focuses the last visible scope, variable, or property in this container.
	   */focusLastVisibleItem:function(){let focusableItem=this._findInVisibleItemsReverse(function(item){return item.focusable;});if(focusableItem){this._focusItem(focusableItem);}this._parent.scrollTop = this._parent.scrollHeight;this._parent.scrollLeft = 0;}, /**
	   * Focuses the next scope, variable or property in this view.
	   */focusNextItem:function(){this.focusItemAtDelta(+1);}, /**
	   * Focuses the previous scope, variable or property in this view.
	   */focusPrevItem:function(){this.focusItemAtDelta(-1);}, /**
	   * Focuses another scope, variable or property in this view, based on
	   * the index distance from the currently focused item.
	   *
	   * @param number aDelta
	   *        A scalar specifying by how many items should the selection change.
	   */focusItemAtDelta:function(aDelta){let direction=aDelta > 0?"advanceFocus":"rewindFocus";let distance=Math.abs(Math[aDelta > 0?"ceil":"floor"](aDelta));while(distance--) {if(!this._focusChange(direction)){break; // Out of bounds.
	}}}, /**
	   * Focuses the next or previous scope, variable or property in this view.
	   *
	   * @param string aDirection
	   *        Either "advanceFocus" or "rewindFocus".
	   * @return boolean
	   *         False if the focus went out of bounds and the first or last element
	   *         in this view was focused instead.
	   */_focusChange:function(aDirection){let commandDispatcher=this.document.commandDispatcher;let prevFocusedElement=commandDispatcher.focusedElement;let currFocusedItem=null;do {commandDispatcher.suppressFocusScroll = true;commandDispatcher[aDirection](); // Make sure the newly focused item is a part of this view.
	// If the focus goes out of bounds, revert the previously focused item.
	if(!(currFocusedItem = this.getFocusedItem())){prevFocusedElement.focus();return false;}}while(!currFocusedItem.focusable); // Focus remained within bounds.
	return true;}, /**
	   * Focuses a scope, variable or property and makes sure it's visible.
	   *
	   * @param aItem Scope | Variable | Property
	   *        The item to focus.
	   * @param boolean aCollapseFlag
	   *        True if the focused item should also be collapsed.
	   * @return boolean
	   *         True if the item was successfully focused.
	   */_focusItem:function(aItem,aCollapseFlag){if(!aItem.focusable){return false;}if(aCollapseFlag){aItem.collapse();}aItem._target.focus();this.boxObject.ensureElementIsVisible(aItem._arrow);return true;}, /**
	   * Listener handling a key press event on the view.
	   */_onViewKeyPress:function(e){let item=this.getFocusedItem(); // Prevent scrolling when pressing navigation keys.
	ViewHelpers.preventScrolling(e);switch(e.keyCode){case e.DOM_VK_UP: // Always rewind focus.
	this.focusPrevItem(true);return;case e.DOM_VK_DOWN: // Always advance focus.
	this.focusNextItem(true);return;case e.DOM_VK_LEFT: // Collapse scopes, variables and properties before rewinding focus.
	if(item._isExpanded && item._isArrowVisible){item.collapse();}else {this._focusItem(item.ownerView);}return;case e.DOM_VK_RIGHT: // Nothing to do here if this item never expands.
	if(!item._isArrowVisible){return;} // Expand scopes, variables and properties before advancing focus.
	if(!item._isExpanded){item.expand();}else {this.focusNextItem(true);}return;case e.DOM_VK_PAGE_UP: // Rewind a certain number of elements based on the container height.
	this.focusItemAtDelta(-(this.scrollPageSize || Math.min(Math.floor(this._list.scrollHeight / PAGE_SIZE_SCROLL_HEIGHT_RATIO),PAGE_SIZE_MAX_JUMPS)));return;case e.DOM_VK_PAGE_DOWN: // Advance a certain number of elements based on the container height.
	this.focusItemAtDelta(+(this.scrollPageSize || Math.min(Math.floor(this._list.scrollHeight / PAGE_SIZE_SCROLL_HEIGHT_RATIO),PAGE_SIZE_MAX_JUMPS)));return;case e.DOM_VK_HOME:this.focusFirstVisibleItem();return;case e.DOM_VK_END:this.focusLastVisibleItem();return;case e.DOM_VK_RETURN: // Start editing the value or name of the Variable or Property.
	if(item instanceof Variable){if(e.metaKey || e.altKey || e.shiftKey){item._activateNameInput();}else {item._activateValueInput();}}return;case e.DOM_VK_DELETE:case e.DOM_VK_BACK_SPACE: // Delete the Variable or Property if allowed.
	if(item instanceof Variable){item._onDelete(e);}return;case e.DOM_VK_INSERT:item._onAddProperty(e);return;}}, /**
	   * Listener handling a key down event on the view.
	   */_onViewKeyDown:function(e){if(e.keyCode == e.DOM_VK_C){ // Copy current selection to clipboard.
	if(e.ctrlKey || e.metaKey){let item=this.getFocusedItem();clipboardHelper.copy(item._nameString + item.separatorStr + item._valueString);}}}, /**
	   * Sets the text displayed in this container when there are no available items.
	   * @param string aValue
	   */set emptyText(aValue){if(this._emptyTextNode){this._emptyTextNode.setAttribute("value",aValue);}this._emptyTextValue = aValue;this._appendEmptyNotice();}, /**
	   * Creates and appends a label signaling that this container is empty.
	   */_appendEmptyNotice:function(){if(this._emptyTextNode || !this._emptyTextValue){return;}let label=this.document.createElement("label");label.className = "variables-view-empty-notice";label.setAttribute("value",this._emptyTextValue);this._parent.appendChild(label);this._emptyTextNode = label;}, /**
	   * Removes the label signaling that this container is empty.
	   */_removeEmptyNotice:function(){if(!this._emptyTextNode){return;}this._parent.removeChild(this._emptyTextNode);this._emptyTextNode = null;}, /**
	   * Gets if all values should be aligned together.
	   * @return boolean
	   */get alignedValues(){return this._alignedValues;}, /**
	   * Sets if all values should be aligned together.
	   * @param boolean aFlag
	   */set alignedValues(aFlag){this._alignedValues = aFlag;if(aFlag){this._parent.setAttribute("aligned-values","");}else {this._parent.removeAttribute("aligned-values");}}, /**
	   * Gets if action buttons (like delete) should be placed at the beginning or
	   * end of a line.
	   * @return boolean
	   */get actionsFirst(){return this._actionsFirst;}, /**
	   * Sets if action buttons (like delete) should be placed at the beginning or
	   * end of a line.
	   * @param boolean aFlag
	   */set actionsFirst(aFlag){this._actionsFirst = aFlag;if(aFlag){this._parent.setAttribute("actions-first","");}else {this._parent.removeAttribute("actions-first");}}, /**
	   * Gets the parent node holding this view.
	   * @return nsIDOMNode
	   */get boxObject(){return this._list.boxObject;}, /**
	   * Gets the parent node holding this view.
	   * @return nsIDOMNode
	   */get parentNode(){return this._parent;}, /**
	   * Gets the owner document holding this view.
	   * @return nsIHTMLDocument
	   */get document(){return this._document || (this._document = this._parent.ownerDocument);}, /**
	   * Gets the default window holding this view.
	   * @return nsIDOMWindow
	   */get window(){return this._window || (this._window = this.document.defaultView);},_document:null,_window:null,_store:null,_itemsByElement:null,_prevHierarchy:null,_currHierarchy:null,_enumVisible:true,_nonEnumVisible:true,_alignedValues:false,_actionsFirst:false,_parent:null,_list:null,_searchboxNode:null,_searchboxContainer:null,_searchboxPlaceholder:"",_emptyTextNode:null,_emptyTextValue:""};VariablesView.NON_SORTABLE_CLASSES = ["Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","NodeList"]; /**
	 * Determine whether an object's properties should be sorted based on its class.
	 *
	 * @param string aClassName
	 *        The class of the object.
	 */VariablesView.isSortable = function(aClassName){return VariablesView.NON_SORTABLE_CLASSES.indexOf(aClassName) == -1;}; /**
	 * Generates the string evaluated when performing simple value changes.
	 *
	 * @param Variable | Property aItem
	 *        The current variable or property.
	 * @param string aCurrentString
	 *        The trimmed user inputted string.
	 * @param string aPrefix [optional]
	 *        Prefix for the symbolic name.
	 * @return string
	 *         The string to be evaluated.
	 */VariablesView.simpleValueEvalMacro = function(aItem,aCurrentString,aPrefix = ""){return aPrefix + aItem.symbolicName + "=" + aCurrentString;}; /**
	 * Generates the string evaluated when overriding getters and setters with
	 * plain values.
	 *
	 * @param Property aItem
	 *        The current getter or setter property.
	 * @param string aCurrentString
	 *        The trimmed user inputted string.
	 * @param string aPrefix [optional]
	 *        Prefix for the symbolic name.
	 * @return string
	 *         The string to be evaluated.
	 */VariablesView.overrideValueEvalMacro = function(aItem,aCurrentString,aPrefix = ""){let property="\"" + aItem._nameString + "\"";let parent=aPrefix + aItem.ownerView.symbolicName || "this";return "Object.defineProperty(" + parent + "," + property + "," + "{ value: " + aCurrentString + ", enumerable: " + parent + ".propertyIsEnumerable(" + property + ")" + ", configurable: true" + ", writable: true" + "})";}; /**
	 * Generates the string evaluated when performing getters and setters changes.
	 *
	 * @param Property aItem
	 *        The current getter or setter property.
	 * @param string aCurrentString
	 *        The trimmed user inputted string.
	 * @param string aPrefix [optional]
	 *        Prefix for the symbolic name.
	 * @return string
	 *         The string to be evaluated.
	 */VariablesView.getterOrSetterEvalMacro = function(aItem,aCurrentString,aPrefix = ""){let type=aItem._nameString;let propertyObject=aItem.ownerView;let parentObject=propertyObject.ownerView;let property="\"" + propertyObject._nameString + "\"";let parent=aPrefix + parentObject.symbolicName || "this";switch(aCurrentString){case "":case "null":case "undefined":let mirrorType=type == "get"?"set":"get";let mirrorLookup=type == "get"?"__lookupSetter__":"__lookupGetter__"; // If the parent object will end up without any getter or setter,
	// morph it into a plain value.
	if(type == "set" && propertyObject.getter.type == "undefined" || type == "get" && propertyObject.setter.type == "undefined"){ // Make sure the right getter/setter to value override macro is applied
	// to the target object.
	return propertyObject.evaluationMacro(propertyObject,"undefined",aPrefix);} // Construct and return the getter/setter removal evaluation string.
	// e.g: Object.defineProperty(foo, "bar", {
	//   get: foo.__lookupGetter__("bar"),
	//   set: undefined,
	//   enumerable: true,
	//   configurable: true
	// })
	return "Object.defineProperty(" + parent + "," + property + "," + "{" + mirrorType + ":" + parent + "." + mirrorLookup + "(" + property + ")" + "," + type + ":" + undefined + ", enumerable: " + parent + ".propertyIsEnumerable(" + property + ")" + ", configurable: true" + "})";default: // Wrap statements inside a function declaration if not already wrapped.
	if(!aCurrentString.startsWith("function")){let header="function(" + (type == "set"?"value":"") + ")";let body=""; // If there's a return statement explicitly written, always use the
	// standard function definition syntax
	if(aCurrentString.includes("return ")){body = "{" + aCurrentString + "}";} // If block syntax is used, use the whole string as the function body.
	else if(aCurrentString.startsWith("{")){body = aCurrentString;} // Prefer an expression closure.
	else {body = "(" + aCurrentString + ")";}aCurrentString = header + body;} // Determine if a new getter or setter should be defined.
	let defineType=type == "get"?"__defineGetter__":"__defineSetter__"; // Make sure all quotes are escaped in the expression's syntax,
	let defineFunc="eval(\"(" + aCurrentString.replace(/"/g,"\\$&") + ")\")"; // Construct and return the getter/setter evaluation string.
	// e.g: foo.__defineGetter__("bar", eval("(function() { return 42; })"))
	return parent + "." + defineType + "(" + property + "," + defineFunc + ")";}}; /**
	 * Function invoked when a getter or setter is deleted.
	 *
	 * @param Property aItem
	 *        The current getter or setter property.
	 */VariablesView.getterOrSetterDeleteCallback = function(aItem){aItem._disable(); // Make sure the right getter/setter to value override macro is applied
	// to the target object.
	aItem.ownerView.eval(aItem,"");return true; // Don't hide the element.
	}; /**
	 * A Scope is an object holding Variable instances.
	 * Iterable via "for (let [name, variable] of instance) { }".
	 *
	 * @param VariablesView aView
	 *        The view to contain this scope.
	 * @param string aName
	 *        The scope's name.
	 * @param object aFlags [optional]
	 *        Additional options or flags for this scope.
	 */function Scope(aView,aName,aFlags = {}){this.ownerView = aView;this._onClick = this._onClick.bind(this);this._openEnum = this._openEnum.bind(this);this._openNonEnum = this._openNonEnum.bind(this); // Inherit properties and flags from the parent view. You can override
	// each of these directly onto any scope, variable or property instance.
	this.scrollPageSize = aView.scrollPageSize;this.eval = aView.eval;this.switch = aView.switch;this.delete = aView.delete;this.new = aView.new;this.preventDisableOnChange = aView.preventDisableOnChange;this.preventDescriptorModifiers = aView.preventDescriptorModifiers;this.editableNameTooltip = aView.editableNameTooltip;this.editableValueTooltip = aView.editableValueTooltip;this.editButtonTooltip = aView.editButtonTooltip;this.deleteButtonTooltip = aView.deleteButtonTooltip;this.domNodeValueTooltip = aView.domNodeValueTooltip;this.contextMenuId = aView.contextMenuId;this.separatorStr = aView.separatorStr;this._init(aName.trim(),aFlags);}Scope.prototype = { /**
	   * Whether this Scope should be prefetched when it is remoted.
	   */shouldPrefetch:true, /**
	   * Whether this Scope should paginate its contents.
	   */allowPaginate:false, /**
	   * The class name applied to this scope's target element.
	   */targetClassName:"variables-view-scope", /**
	   * Create a new Variable that is a child of this Scope.
	   *
	   * @param string aName
	   *        The name of the new Property.
	   * @param object aDescriptor
	   *        The variable's descriptor.
	   * @return Variable
	   *         The newly created child Variable.
	   */_createChild:function(aName,aDescriptor){return new Variable(this,aName,aDescriptor);}, /**
	   * Adds a child to contain any inspected properties.
	   *
	   * @param string aName
	   *        The child's name.
	   * @param object aDescriptor
	   *        Specifies the value and/or type & class of the child,
	   *        or 'get' & 'set' accessor properties. If the type is implicit,
	   *        it will be inferred from the value. If this parameter is omitted,
	   *        a property without a value will be added (useful for branch nodes).
	   *        e.g. - { value: 42 }
	   *             - { value: true }
	   *             - { value: "nasu" }
	   *             - { value: { type: "undefined" } }
	   *             - { value: { type: "null" } }
	   *             - { value: { type: "object", class: "Object" } }
	   *             - { get: { type: "object", class: "Function" },
	   *                 set: { type: "undefined" } }
	   * @param boolean aRelaxed [optional]
	   *        Pass true if name duplicates should be allowed.
	   *        You probably shouldn't do it. Use this with caution.
	   * @return Variable
	   *         The newly created Variable instance, null if it already exists.
	   */addItem:function(aName = "",aDescriptor = {},aRelaxed = false){if(this._store.has(aName) && !aRelaxed){return this._store.get(aName);}let child=this._createChild(aName,aDescriptor);this._store.set(aName,child);this._variablesView._itemsByElement.set(child._target,child);this._variablesView._currHierarchy.set(child.absoluteName,child);child.header = !!aName;return child;}, /**
	   * Adds items for this variable.
	   *
	   * @param object aItems
	   *        An object containing some { name: descriptor } data properties,
	   *        specifying the value and/or type & class of the variable,
	   *        or 'get' & 'set' accessor properties. If the type is implicit,
	   *        it will be inferred from the value.
	   *        e.g. - { someProp0: { value: 42 },
	   *                 someProp1: { value: true },
	   *                 someProp2: { value: "nasu" },
	   *                 someProp3: { value: { type: "undefined" } },
	   *                 someProp4: { value: { type: "null" } },
	   *                 someProp5: { value: { type: "object", class: "Object" } },
	   *                 someProp6: { get: { type: "object", class: "Function" },
	   *                              set: { type: "undefined" } } }
	   * @param object aOptions [optional]
	   *        Additional options for adding the properties. Supported options:
	   *        - sorted: true to sort all the properties before adding them
	   *        - callback: function invoked after each item is added
	   */addItems:function(aItems,aOptions = {}){let names=Object.keys(aItems); // Sort all of the properties before adding them, if preferred.
	if(aOptions.sorted){names.sort(this._naturalSort);} // Add the properties to the current scope.
	for(let name of names) {let descriptor=aItems[name];let item=this.addItem(name,descriptor);if(aOptions.callback){aOptions.callback(item,descriptor.value);}}}, /**
	   * Remove this Scope from its parent and remove all children recursively.
	   */remove:function(){let view=this._variablesView;view._store.splice(view._store.indexOf(this),1);view._itemsByElement.delete(this._target);view._currHierarchy.delete(this._nameString);this._target.remove();for(let variable of this._store.values()) {variable.remove();}}, /**
	   * Gets the variable in this container having the specified name.
	   *
	   * @param string aName
	   *        The name of the variable to get.
	   * @return Variable
	   *         The matched variable, or null if nothing is found.
	   */get:function(aName){return this._store.get(aName);}, /**
	   * Recursively searches for the variable or property in this container
	   * displayed by the specified node.
	   *
	   * @param nsIDOMNode aNode
	   *        The node to search for.
	   * @return Variable | Property
	   *         The matched variable or property, or null if nothing is found.
	   */find:function(aNode){for(let _ref of this._store) {var _ref2=_slicedToArray(_ref,2);let variable=_ref2[1];let match;if(variable._target == aNode){match = variable;}else {match = variable.find(aNode);}if(match){return match;}}return null;}, /**
	   * Determines if this scope is a direct child of a parent variables view,
	   * scope, variable or property.
	   *
	   * @param VariablesView | Scope | Variable | Property
	   *        The parent to check.
	   * @return boolean
	   *         True if the specified item is a direct child, false otherwise.
	   */isChildOf:function(aParent){return this.ownerView == aParent;}, /**
	   * Determines if this scope is a descendant of a parent variables view,
	   * scope, variable or property.
	   *
	   * @param VariablesView | Scope | Variable | Property
	   *        The parent to check.
	   * @return boolean
	   *         True if the specified item is a descendant, false otherwise.
	   */isDescendantOf:function(aParent){if(this.isChildOf(aParent)){return true;} // Recurse to parent if it is a Scope, Variable, or Property.
	if(this.ownerView instanceof Scope){return this.ownerView.isDescendantOf(aParent);}return false;}, /**
	   * Shows the scope.
	   */show:function(){this._target.hidden = false;this._isContentVisible = true;if(this.onshow){this.onshow(this);}}, /**
	   * Hides the scope.
	   */hide:function(){this._target.hidden = true;this._isContentVisible = false;if(this.onhide){this.onhide(this);}}, /**
	   * Expands the scope, showing all the added details.
	   */expand:function(){if(this._isExpanded || this._isLocked){return;}if(this._variablesView._enumVisible){this._openEnum();}if(this._variablesView._nonEnumVisible){Services.tm.currentThread.dispatch({run:this._openNonEnum},0);}this._isExpanded = true;if(this.onexpand){ // We return onexpand as it sometimes returns a promise
	// (up to the user of VariableView to do it)
	// that can indicate when the view is done expanding
	// and attributes are available. (Mostly used for tests)
	return this.onexpand(this);}}, /**
	   * Collapses the scope, hiding all the added details.
	   */collapse:function(){if(!this._isExpanded || this._isLocked){return;}this._arrow.removeAttribute("open");this._enum.removeAttribute("open");this._nonenum.removeAttribute("open");this._isExpanded = false;if(this.oncollapse){this.oncollapse(this);}}, /**
	   * Toggles between the scope's collapsed and expanded state.
	   */toggle:function(e){if(e && e.button != 0){ // Only allow left-click to trigger this event.
	return;}this.expanded ^= 1; // Make sure the scope and its contents are visibile.
	for(let _ref3 of this._store) {var _ref4=_slicedToArray(_ref3,2);let variable=_ref4[1];variable.header = true;variable._matched = true;}if(this.ontoggle){this.ontoggle(this);}}, /**
	   * Shows the scope's title header.
	   */showHeader:function(){if(this._isHeaderVisible || !this._nameString){return;}this._target.removeAttribute("untitled");this._isHeaderVisible = true;}, /**
	   * Hides the scope's title header.
	   * This action will automatically expand the scope.
	   */hideHeader:function(){if(!this._isHeaderVisible){return;}this.expand();this._target.setAttribute("untitled","");this._isHeaderVisible = false;}, /**
	   * Sort in ascending order
	   * This only needs to compare non-numbers since it is dealing with an array
	   * which numeric-based indices are placed in order.
	   *
	   * @param string a
	   * @param string b
	   * @return number
	   *         -1 if a is less than b, 0 if no change in order, +1 if a is greater than 0
	   */_naturalSort:function(a,b){if(isNaN(parseFloat(a)) && isNaN(parseFloat(b))){return a < b?-1:1;}}, /**
	   * Shows the scope's expand/collapse arrow.
	   */showArrow:function(){if(this._isArrowVisible){return;}this._arrow.removeAttribute("invisible");this._isArrowVisible = true;}, /**
	   * Hides the scope's expand/collapse arrow.
	   */hideArrow:function(){if(!this._isArrowVisible){return;}this._arrow.setAttribute("invisible","");this._isArrowVisible = false;}, /**
	   * Gets the visibility state.
	   * @return boolean
	   */get visible(){return this._isContentVisible;}, /**
	   * Gets the expanded state.
	   * @return boolean
	   */get expanded(){return this._isExpanded;}, /**
	   * Gets the header visibility state.
	   * @return boolean
	   */get header(){return this._isHeaderVisible;}, /**
	   * Gets the twisty visibility state.
	   * @return boolean
	   */get twisty(){return this._isArrowVisible;}, /**
	   * Gets the expand lock state.
	   * @return boolean
	   */get locked(){return this._isLocked;}, /**
	   * Sets the visibility state.
	   * @param boolean aFlag
	   */set visible(aFlag){aFlag?this.show():this.hide();}, /**
	   * Sets the expanded state.
	   * @param boolean aFlag
	   */set expanded(aFlag){aFlag?this.expand():this.collapse();}, /**
	   * Sets the header visibility state.
	   * @param boolean aFlag
	   */set header(aFlag){aFlag?this.showHeader():this.hideHeader();}, /**
	   * Sets the twisty visibility state.
	   * @param boolean aFlag
	   */set twisty(aFlag){aFlag?this.showArrow():this.hideArrow();}, /**
	   * Sets the expand lock state.
	   * @param boolean aFlag
	   */set locked(aFlag){this._isLocked = aFlag;}, /**
	   * Specifies if this target node may be focused.
	   * @return boolean
	   */get focusable(){ // Check if this target node is actually visibile.
	if(!this._nameString || !this._isContentVisible || !this._isHeaderVisible || !this._isMatch){return false;} // Check if all parent objects are expanded.
	let item=this; // Recurse while parent is a Scope, Variable, or Property
	while((item = item.ownerView) && item instanceof Scope) {if(!item._isExpanded){return false;}}return true;}, /**
	   * Focus this scope.
	   */focus:function(){this._variablesView._focusItem(this);}, /**
	   * Adds an event listener for a certain event on this scope's title.
	   * @param string aName
	   * @param function aCallback
	   * @param boolean aCapture
	   */addEventListener:function(aName,aCallback,aCapture){this._title.addEventListener(aName,aCallback,aCapture);}, /**
	   * Removes an event listener for a certain event on this scope's title.
	   * @param string aName
	   * @param function aCallback
	   * @param boolean aCapture
	   */removeEventListener:function(aName,aCallback,aCapture){this._title.removeEventListener(aName,aCallback,aCapture);}, /**
	   * Gets the id associated with this item.
	   * @return string
	   */get id(){return this._idString;}, /**
	   * Gets the name associated with this item.
	   * @return string
	   */get name(){return this._nameString;}, /**
	   * Gets the displayed value for this item.
	   * @return string
	   */get displayValue(){return this._valueString;}, /**
	   * Gets the class names used for the displayed value.
	   * @return string
	   */get displayValueClassName(){return this._valueClassName;}, /**
	   * Gets the element associated with this item.
	   * @return nsIDOMNode
	   */get target(){return this._target;}, /**
	   * Initializes this scope's id, view and binds event listeners.
	   *
	   * @param string aName
	   *        The scope's name.
	   * @param object aFlags [optional]
	   *        Additional options or flags for this scope.
	   */_init:function(aName,aFlags){this._idString = generateId(this._nameString = aName);this._displayScope(aName,this.targetClassName,"devtools-toolbar");this._addEventListeners();this.parentNode.appendChild(this._target);}, /**
	   * Creates the necessary nodes for this scope.
	   *
	   * @param string aName
	   *        The scope's name.
	   * @param string aTargetClassName
	   *        A custom class name for this scope's target element.
	   * @param string aTitleClassName [optional]
	   *        A custom class name for this scope's title element.
	   */_displayScope:function(aName,aTargetClassName,aTitleClassName = ""){let document=this.document;let element=this._target = document.createElement("vbox");element.id = this._idString;element.className = aTargetClassName;let arrow=this._arrow = document.createElement("hbox");arrow.className = "arrow theme-twisty";let name=this._name = document.createElement("label");name.className = "plain name";name.setAttribute("value",aName);let title=this._title = document.createElement("hbox");title.className = "title " + aTitleClassName;title.setAttribute("align","center");let enumerable=this._enum = document.createElement("vbox");let nonenum=this._nonenum = document.createElement("vbox");enumerable.className = "variables-view-element-details enum";nonenum.className = "variables-view-element-details nonenum";title.appendChild(arrow);title.appendChild(name);element.appendChild(title);element.appendChild(enumerable);element.appendChild(nonenum);}, /**
	   * Adds the necessary event listeners for this scope.
	   */_addEventListeners:function(){this._title.addEventListener("mousedown",this._onClick,false);}, /**
	   * The click listener for this scope's title.
	   */_onClick:function(e){if(this.editing || e.button != 0 || e.target == this._editNode || e.target == this._deleteNode || e.target == this._addPropertyNode){return;}this.toggle();this.focus();}, /**
	   * Opens the enumerable items container.
	   */_openEnum:function(){this._arrow.setAttribute("open","");this._enum.setAttribute("open","");}, /**
	   * Opens the non-enumerable items container.
	   */_openNonEnum:function(){this._nonenum.setAttribute("open","");}, /**
	   * Specifies if enumerable properties and variables should be displayed.
	   * @param boolean aFlag
	   */set _enumVisible(aFlag){for(let _ref5 of this._store) {var _ref6=_slicedToArray(_ref5,2);let variable=_ref6[1];variable._enumVisible = aFlag;if(!this._isExpanded){continue;}if(aFlag){this._enum.setAttribute("open","");}else {this._enum.removeAttribute("open");}}}, /**
	   * Specifies if non-enumerable properties and variables should be displayed.
	   * @param boolean aFlag
	   */set _nonEnumVisible(aFlag){for(let _ref7 of this._store) {var _ref8=_slicedToArray(_ref7,2);let variable=_ref8[1];variable._nonEnumVisible = aFlag;if(!this._isExpanded){continue;}if(aFlag){this._nonenum.setAttribute("open","");}else {this._nonenum.removeAttribute("open");}}}, /**
	   * Performs a case insensitive search for variables or properties matching
	   * the query, and hides non-matched items.
	   *
	   * @param string aLowerCaseQuery
	   *        The lowercased name of the variable or property to search for.
	   */_performSearch:function(aLowerCaseQuery){for(let _ref9 of this._store) {var _ref10=_slicedToArray(_ref9,2);let variable=_ref10[1];let currentObject=variable;let lowerCaseName=variable._nameString.toLowerCase();let lowerCaseValue=variable._valueString.toLowerCase(); // Non-matched variables or properties require a corresponding attribute.
	if(!lowerCaseName.includes(aLowerCaseQuery) && !lowerCaseValue.includes(aLowerCaseQuery)){variable._matched = false;} // Variable or property is matched.
	else {variable._matched = true; // If the variable was ever expanded, there's a possibility it may
	// contain some matched properties, so make sure they're visible
	// ("expand downwards").
	if(variable._store.size){variable.expand();} // If the variable is contained in another Scope, Variable, or Property,
	// the parent may not be a match, thus hidden. It should be visible
	// ("expand upwards").
	while((variable = variable.ownerView) && variable instanceof Scope) {variable._matched = true;variable.expand();}} // Proceed with the search recursively inside this variable or property.
	if(currentObject._store.size || currentObject.getter || currentObject.setter){currentObject._performSearch(aLowerCaseQuery);}}}, /**
	   * Sets if this object instance is a matched or non-matched item.
	   * @param boolean aStatus
	   */set _matched(aStatus){if(this._isMatch == aStatus){return;}if(aStatus){this._isMatch = true;this.target.removeAttribute("unmatched");}else {this._isMatch = false;this.target.setAttribute("unmatched","");}}, /**
	   * Find the first item in the tree of visible items in this item that matches
	   * the predicate. Searches in visual order (the order seen by the user).
	   * Tests itself, then descends into first the enumerable children and then
	   * the non-enumerable children (since they are presented in separate groups).
	   *
	   * @param function aPredicate
	   *        A function that returns true when a match is found.
	   * @return Scope | Variable | Property
	   *         The first visible scope, variable or property, or null if nothing
	   *         is found.
	   */_findInVisibleItems:function(aPredicate){if(aPredicate(this)){return this;}if(this._isExpanded){if(this._variablesView._enumVisible){for(let item of this._enumItems) {let result=item._findInVisibleItems(aPredicate);if(result){return result;}}}if(this._variablesView._nonEnumVisible){for(let item of this._nonEnumItems) {let result=item._findInVisibleItems(aPredicate);if(result){return result;}}}}return null;}, /**
	   * Find the last item in the tree of visible items in this item that matches
	   * the predicate. Searches in reverse visual order (opposite of the order
	   * seen by the user). Descends into first the non-enumerable children, then
	   * the enumerable children (since they are presented in separate groups), and
	   * finally tests itself.
	   *
	   * @param function aPredicate
	   *        A function that returns true when a match is found.
	   * @return Scope | Variable | Property
	   *         The last visible scope, variable or property, or null if nothing
	   *         is found.
	   */_findInVisibleItemsReverse:function(aPredicate){if(this._isExpanded){if(this._variablesView._nonEnumVisible){for(let i=this._nonEnumItems.length - 1;i >= 0;i--) {let item=this._nonEnumItems[i];let result=item._findInVisibleItemsReverse(aPredicate);if(result){return result;}}}if(this._variablesView._enumVisible){for(let i=this._enumItems.length - 1;i >= 0;i--) {let item=this._enumItems[i];let result=item._findInVisibleItemsReverse(aPredicate);if(result){return result;}}}}if(aPredicate(this)){return this;}return null;}, /**
	   * Gets top level variables view instance.
	   * @return VariablesView
	   */get _variablesView(){var _this3=this;return this._topView || (this._topView = (function(){let parentView=_this3.ownerView;let topView;while(topView = parentView.ownerView) {parentView = topView;}return parentView;})());}, /**
	   * Gets the parent node holding this scope.
	   * @return nsIDOMNode
	   */get parentNode(){return this.ownerView._list;}, /**
	   * Gets the owner document holding this scope.
	   * @return nsIHTMLDocument
	   */get document(){return this._document || (this._document = this.ownerView.document);}, /**
	   * Gets the default window holding this scope.
	   * @return nsIDOMWindow
	   */get window(){return this._window || (this._window = this.ownerView.window);},_topView:null,_document:null,_window:null,ownerView:null,eval:null,switch:null,delete:null,new:null,preventDisableOnChange:false,preventDescriptorModifiers:false,editing:false,editableNameTooltip:"",editableValueTooltip:"",editButtonTooltip:"",deleteButtonTooltip:"",domNodeValueTooltip:"",contextMenuId:"",separatorStr:"",_store:null,_enumItems:null,_nonEnumItems:null,_fetched:false,_committed:false,_isLocked:false,_isExpanded:false,_isContentVisible:true,_isHeaderVisible:true,_isArrowVisible:true,_isMatch:true,_idString:"",_nameString:"",_target:null,_arrow:null,_name:null,_title:null,_enum:null,_nonenum:null}; // Creating maps and arrays thousands of times for variables or properties
	// with a large number of children fills up a lot of memory. Make sure
	// these are instantiated only if needed.
	DevToolsUtils.defineLazyPrototypeGetter(Scope.prototype,"_store",function(){return new Map();});DevToolsUtils.defineLazyPrototypeGetter(Scope.prototype,"_enumItems",Array);DevToolsUtils.defineLazyPrototypeGetter(Scope.prototype,"_nonEnumItems",Array); // An ellipsis symbol (usually "…") used for localization.
	XPCOMUtils.defineLazyGetter(Scope,"ellipsis",function(){return "…";} /*Should be l10n'd*/); /**
	 * A Variable is a Scope holding Property instances.
	 * Iterable via "for (let [name, property] of instance) { }".
	 *
	 * @param Scope aScope
	 *        The scope to contain this variable.
	 * @param string aName
	 *        The variable's name.
	 * @param object aDescriptor
	 *        The variable's descriptor.
	 */function Variable(aScope,aName,aDescriptor){this._setTooltips = this._setTooltips.bind(this);this._activateNameInput = this._activateNameInput.bind(this);this._activateValueInput = this._activateValueInput.bind(this);this.openNodeInInspector = this.openNodeInInspector.bind(this);this.highlightDomNode = this.highlightDomNode.bind(this);this.unhighlightDomNode = this.unhighlightDomNode.bind(this); // Treat safe getter descriptors as descriptors with a value.
	if("getterValue" in aDescriptor){aDescriptor.value = aDescriptor.getterValue;delete aDescriptor.get;delete aDescriptor.set;}Scope.call(this,aScope,aName,this._initialDescriptor = aDescriptor);this.setGrip(aDescriptor.value);}Variable.prototype = Heritage.extend(Scope.prototype,{ /**
	   * Whether this Variable should be prefetched when it is remoted.
	   */get shouldPrefetch(){return this.name == "window" || this.name == "this";}, /**
	   * Whether this Variable should paginate its contents.
	   */get allowPaginate(){return this.name != "window" && this.name != "this";}, /**
	   * The class name applied to this variable's target element.
	   */targetClassName:"variables-view-variable variable-or-property", /**
	   * Create a new Property that is a child of Variable.
	   *
	   * @param string aName
	   *        The name of the new Property.
	   * @param object aDescriptor
	   *        The property's descriptor.
	   * @return Property
	   *         The newly created child Property.
	   */_createChild:function(aName,aDescriptor){return new Property(this,aName,aDescriptor);}, /**
	   * Remove this Variable from its parent and remove all children recursively.
	   */remove:function(){if(this._linkedToInspector){this.unhighlightDomNode();this._valueLabel.removeEventListener("mouseover",this.highlightDomNode,false);this._valueLabel.removeEventListener("mouseout",this.unhighlightDomNode,false);this._openInspectorNode.removeEventListener("mousedown",this.openNodeInInspector,false);}this.ownerView._store.delete(this._nameString);this._variablesView._itemsByElement.delete(this._target);this._variablesView._currHierarchy.delete(this.absoluteName);this._target.remove();for(let property of this._store.values()) {property.remove();}}, /**
	   * Populates this variable to contain all the properties of an object.
	   *
	   * @param object aObject
	   *        The raw object you want to display.
	   * @param object aOptions [optional]
	   *        Additional options for adding the properties. Supported options:
	   *        - sorted: true to sort all the properties before adding them
	   *        - expanded: true to expand all the properties after adding them
	   */populate:function(aObject,aOptions = {}){ // Retrieve the properties only once.
	if(this._fetched){return;}this._fetched = true;let propertyNames=Object.getOwnPropertyNames(aObject);let prototype=Object.getPrototypeOf(aObject); // Sort all of the properties before adding them, if preferred.
	if(aOptions.sorted){propertyNames.sort(this._naturalSort);} // Add all the variable properties.
	for(let name of propertyNames) {let descriptor=Object.getOwnPropertyDescriptor(aObject,name);if(descriptor.get || descriptor.set){let prop=this._addRawNonValueProperty(name,descriptor);if(aOptions.expanded){prop.expanded = true;}}else {let prop=this._addRawValueProperty(name,descriptor,aObject[name]);if(aOptions.expanded){prop.expanded = true;}}} // Add the variable's __proto__.
	if(prototype){this._addRawValueProperty("__proto__",{},prototype);}}, /**
	   * Populates a specific variable or property instance to contain all the
	   * properties of an object
	   *
	   * @param Variable | Property aVar
	   *        The target variable to populate.
	   * @param object aObject [optional]
	   *        The raw object you want to display. If unspecified, the object is
	   *        assumed to be defined in a _sourceValue property on the target.
	   */_populateTarget:function(aVar,aObject = aVar._sourceValue){aVar.populate(aObject);}, /**
	   * Adds a property for this variable based on a raw value descriptor.
	   *
	   * @param string aName
	   *        The property's name.
	   * @param object aDescriptor
	   *        Specifies the exact property descriptor as returned by a call to
	   *        Object.getOwnPropertyDescriptor.
	   * @param object aValue
	   *        The raw property value you want to display.
	   * @return Property
	   *         The newly added property instance.
	   */_addRawValueProperty:function(aName,aDescriptor,aValue){let descriptor=Object.create(aDescriptor);descriptor.value = VariablesView.getGrip(aValue);let propertyItem=this.addItem(aName,descriptor);propertyItem._sourceValue = aValue; // Add an 'onexpand' callback for the property, lazily handling
	// the addition of new child properties.
	if(!VariablesView.isPrimitive(descriptor)){propertyItem.onexpand = this._populateTarget;}return propertyItem;}, /**
	   * Adds a property for this variable based on a getter/setter descriptor.
	   *
	   * @param string aName
	   *        The property's name.
	   * @param object aDescriptor
	   *        Specifies the exact property descriptor as returned by a call to
	   *        Object.getOwnPropertyDescriptor.
	   * @return Property
	   *         The newly added property instance.
	   */_addRawNonValueProperty:function(aName,aDescriptor){let descriptor=Object.create(aDescriptor);descriptor.get = VariablesView.getGrip(aDescriptor.get);descriptor.set = VariablesView.getGrip(aDescriptor.set);return this.addItem(aName,descriptor);}, /**
	   * Gets this variable's path to the topmost scope in the form of a string
	   * meant for use via eval() or a similar approach.
	   * For example, a symbolic name may look like "arguments['0']['foo']['bar']".
	   * @return string
	   */get symbolicName(){return this._nameString;}, /**
	   * Gets full path to this variable, including name of the scope.
	   * @return string
	   */get absoluteName(){if(this._absoluteName){return this._absoluteName;}this._absoluteName = this.ownerView._nameString + "[\"" + this._nameString + "\"]";return this._absoluteName;}, /**
	   * Gets this variable's symbolic path to the topmost scope.
	   * @return array
	   * @see Variable._buildSymbolicPath
	   */get symbolicPath(){if(this._symbolicPath){return this._symbolicPath;}this._symbolicPath = this._buildSymbolicPath();return this._symbolicPath;}, /**
	   * Build this variable's path to the topmost scope in form of an array of
	   * strings, one for each segment of the path.
	   * For example, a symbolic path may look like ["0", "foo", "bar"].
	   * @return array
	   */_buildSymbolicPath:function(path = []){if(this.name){path.unshift(this.name);if(this.ownerView instanceof Variable){return this.ownerView._buildSymbolicPath(path);}}return path;}, /**
	   * Returns this variable's value from the descriptor if available.
	   * @return any
	   */get value(){return this._initialDescriptor.value;}, /**
	   * Returns this variable's getter from the descriptor if available.
	   * @return object
	   */get getter(){return this._initialDescriptor.get;}, /**
	   * Returns this variable's getter from the descriptor if available.
	   * @return object
	   */get setter(){return this._initialDescriptor.set;}, /**
	   * Sets the specific grip for this variable (applies the text content and
	   * class name to the value label).
	   *
	   * The grip should contain the value or the type & class, as defined in the
	   * remote debugger protocol. For convenience, undefined and null are
	   * both considered types.
	   *
	   * @param any aGrip
	   *        Specifies the value and/or type & class of the variable.
	   *        e.g. - 42
	   *             - true
	   *             - "nasu"
	   *             - { type: "undefined" }
	   *             - { type: "null" }
	   *             - { type: "object", class: "Object" }
	   */setGrip:function(aGrip){ // Don't allow displaying grip information if there's no name available
	// or the grip is malformed.
	if(!this._nameString || aGrip === undefined || aGrip === null){return;} // Getters and setters should display grip information in sub-properties.
	if(this.getter || this.setter){return;}let prevGrip=this._valueGrip;if(prevGrip){this._valueLabel.classList.remove(VariablesView.getClass(prevGrip));}this._valueGrip = aGrip;if(aGrip && (aGrip.optimizedOut || aGrip.uninitialized || aGrip.missingArguments)){if(aGrip.optimizedOut){this._valueString = STR.GetStringFromName("variablesViewOptimizedOut");}else if(aGrip.uninitialized){this._valueString = STR.GetStringFromName("variablesViewUninitialized");}else if(aGrip.missingArguments){this._valueString = STR.GetStringFromName("variablesViewMissingArgs");}this.eval = null;}else {this._valueString = VariablesView.getString(aGrip,{concise:true,noEllipsis:true});this.eval = this.ownerView.eval;}this._valueClassName = VariablesView.getClass(aGrip);this._valueLabel.classList.add(this._valueClassName);this._valueLabel.setAttribute("value",this._valueString);this._separatorLabel.hidden = false; // DOMNodes get special treatment since they can be linked to the inspector
	if(this._valueGrip.preview && this._valueGrip.preview.kind === "DOMNode"){this._linkToInspector();}}, /**
	   * Marks this variable as overridden.
	   *
	   * @param boolean aFlag
	   *        Whether this variable is overridden or not.
	   */setOverridden:function(aFlag){if(aFlag){this._target.setAttribute("overridden","");}else {this._target.removeAttribute("overridden");}}, /**
	   * Briefly flashes this variable.
	   *
	   * @param number aDuration [optional]
	   *        An optional flash animation duration.
	   */flash:function(aDuration = ITEM_FLASH_DURATION){var _this4=this;let fadeInDelay=this._variablesView.lazyEmptyDelay + 1;let fadeOutDelay=fadeInDelay + aDuration;setNamedTimeout("vview-flash-in" + this.absoluteName,fadeInDelay,function(){return _this4._target.setAttribute("changed","");});setNamedTimeout("vview-flash-out" + this.absoluteName,fadeOutDelay,function(){return _this4._target.removeAttribute("changed");});}, /**
	   * Initializes this variable's id, view and binds event listeners.
	   *
	   * @param string aName
	   *        The variable's name.
	   * @param object aDescriptor
	   *        The variable's descriptor.
	   */_init:function(aName,aDescriptor){this._idString = generateId(this._nameString = aName);this._displayScope(aName,this.targetClassName);this._displayVariable();this._customizeVariable();this._prepareTooltips();this._setAttributes();this._addEventListeners();if(this._initialDescriptor.enumerable || this._nameString == "this" || this._nameString == "<return>" || this._nameString == "<exception>"){this.ownerView._enum.appendChild(this._target);this.ownerView._enumItems.push(this);}else {this.ownerView._nonenum.appendChild(this._target);this.ownerView._nonEnumItems.push(this);}}, /**
	   * Creates the necessary nodes for this variable.
	   */_displayVariable:function(){let document=this.document;let descriptor=this._initialDescriptor;let separatorLabel=this._separatorLabel = document.createElement("label");separatorLabel.className = "plain separator";separatorLabel.setAttribute("value",this.separatorStr + " ");let valueLabel=this._valueLabel = document.createElement("label");valueLabel.className = "plain value";valueLabel.setAttribute("flex","1");valueLabel.setAttribute("crop","center");this._title.appendChild(separatorLabel);this._title.appendChild(valueLabel);if(VariablesView.isPrimitive(descriptor)){this.hideArrow();} // If no value will be displayed, we don't need the separator.
	if(!descriptor.get && !descriptor.set && !("value" in descriptor)){separatorLabel.hidden = true;} // If this is a getter/setter property, create two child pseudo-properties
	// called "get" and "set" that display the corresponding functions.
	if(descriptor.get || descriptor.set){separatorLabel.hidden = true;valueLabel.hidden = true; // Changing getter/setter names is never allowed.
	this.switch = null; // Getter/setter properties require special handling when it comes to
	// evaluation and deletion.
	if(this.ownerView.eval){this.delete = VariablesView.getterOrSetterDeleteCallback;this.evaluationMacro = VariablesView.overrideValueEvalMacro;} // Deleting getters and setters individually is not allowed if no
	// evaluation method is provided.
	else {this.delete = null;this.evaluationMacro = null;}let getter=this.addItem("get",{value:descriptor.get});let setter=this.addItem("set",{value:descriptor.set});getter.evaluationMacro = VariablesView.getterOrSetterEvalMacro;setter.evaluationMacro = VariablesView.getterOrSetterEvalMacro;getter.hideArrow();setter.hideArrow();this.expand();}}, /**
	   * Adds specific nodes for this variable based on custom flags.
	   */_customizeVariable:function(){let ownerView=this.ownerView;let descriptor=this._initialDescriptor;if(ownerView.eval && this.getter || this.setter){let editNode=this._editNode = this.document.createElement("toolbarbutton");editNode.className = "plain variables-view-edit";editNode.addEventListener("mousedown",this._onEdit.bind(this),false);this._title.insertBefore(editNode,this._spacer);}if(ownerView.delete){let deleteNode=this._deleteNode = this.document.createElement("toolbarbutton");deleteNode.className = "plain variables-view-delete";deleteNode.addEventListener("click",this._onDelete.bind(this),false);this._title.appendChild(deleteNode);}if(ownerView.new){let addPropertyNode=this._addPropertyNode = this.document.createElement("toolbarbutton");addPropertyNode.className = "plain variables-view-add-property";addPropertyNode.addEventListener("mousedown",this._onAddProperty.bind(this),false);this._title.appendChild(addPropertyNode); // Can't add properties to primitive values, hide the node in those cases.
	if(VariablesView.isPrimitive(descriptor)){addPropertyNode.setAttribute("invisible","");}}if(ownerView.contextMenuId){this._title.setAttribute("context",ownerView.contextMenuId);}if(ownerView.preventDescriptorModifiers){return;}if(!descriptor.writable && !ownerView.getter && !ownerView.setter){let nonWritableIcon=this.document.createElement("hbox");nonWritableIcon.className = "plain variable-or-property-non-writable-icon";nonWritableIcon.setAttribute("optional-visibility","");this._title.appendChild(nonWritableIcon);}if(descriptor.value && typeof descriptor.value == "object"){if(descriptor.value.frozen){let frozenLabel=this.document.createElement("label");frozenLabel.className = "plain variable-or-property-frozen-label";frozenLabel.setAttribute("optional-visibility","");frozenLabel.setAttribute("value","F");this._title.appendChild(frozenLabel);}if(descriptor.value.sealed){let sealedLabel=this.document.createElement("label");sealedLabel.className = "plain variable-or-property-sealed-label";sealedLabel.setAttribute("optional-visibility","");sealedLabel.setAttribute("value","S");this._title.appendChild(sealedLabel);}if(!descriptor.value.extensible){let nonExtensibleLabel=this.document.createElement("label");nonExtensibleLabel.className = "plain variable-or-property-non-extensible-label";nonExtensibleLabel.setAttribute("optional-visibility","");nonExtensibleLabel.setAttribute("value","N");this._title.appendChild(nonExtensibleLabel);}}}, /**
	   * Prepares all tooltips for this variable.
	   */_prepareTooltips:function(){this._target.addEventListener("mouseover",this._setTooltips,false);}, /**
	   * Sets all tooltips for this variable.
	   */_setTooltips:function(){this._target.removeEventListener("mouseover",this._setTooltips,false);let ownerView=this.ownerView;if(ownerView.preventDescriptorModifiers){return;}let tooltip=this.document.createElement("tooltip");tooltip.id = "tooltip-" + this._idString;tooltip.setAttribute("orient","horizontal");let labels=["configurable","enumerable","writable","frozen","sealed","extensible","overridden","WebIDL"];for(let type of labels) {let labelElement=this.document.createElement("label");labelElement.className = type;labelElement.setAttribute("value",STR.GetStringFromName(type + "Tooltip"));tooltip.appendChild(labelElement);}this._target.appendChild(tooltip);this._target.setAttribute("tooltip",tooltip.id);if(this._editNode && ownerView.eval){this._editNode.setAttribute("tooltiptext",ownerView.editButtonTooltip);}if(this._openInspectorNode && this._linkedToInspector){this._openInspectorNode.setAttribute("tooltiptext",this.ownerView.domNodeValueTooltip);}if(this._valueLabel && ownerView.eval){this._valueLabel.setAttribute("tooltiptext",ownerView.editableValueTooltip);}if(this._name && ownerView.switch){this._name.setAttribute("tooltiptext",ownerView.editableNameTooltip);}if(this._deleteNode && ownerView.delete){this._deleteNode.setAttribute("tooltiptext",ownerView.deleteButtonTooltip);}}, /**
	   * Get the parent variablesview toolbox, if any.
	   */get toolbox(){return this._variablesView.toolbox;}, /**
	   * Checks if this variable is a DOMNode and is part of a variablesview that
	   * has been linked to the toolbox, so that highlighting and jumping to the
	   * inspector can be done.
	   */_isLinkableToInspector:function(){let isDomNode=this._valueGrip && this._valueGrip.preview.kind === "DOMNode";let hasBeenLinked=this._linkedToInspector;let hasToolbox=!!this.toolbox;return isDomNode && !hasBeenLinked && hasToolbox;}, /**
	   * If the variable is a DOMNode, and if a toolbox is set, then link it to the
	   * inspector (highlight on hover, and jump to markup-view on click)
	   */_linkToInspector:function(){if(!this._isLinkableToInspector()){return;} // Listen to value mouseover/click events to highlight and jump
	this._valueLabel.addEventListener("mouseover",this.highlightDomNode,false);this._valueLabel.addEventListener("mouseout",this.unhighlightDomNode,false); // Add a button to open the node in the inspector
	this._openInspectorNode = this.document.createElement("toolbarbutton");this._openInspectorNode.className = "plain variables-view-open-inspector";this._openInspectorNode.addEventListener("mousedown",this.openNodeInInspector,false);this._title.appendChild(this._openInspectorNode);this._linkedToInspector = true;}, /**
	   * In case this variable is a DOMNode and part of a variablesview that has been
	   * linked to the toolbox's inspector, then select the corresponding node in
	   * the inspector, and switch the inspector tool in the toolbox
	   * @return a promise that resolves when the node is selected and the inspector
	   * has been switched to and is ready
	   */openNodeInInspector:function(event){if(!this.toolbox){return promise.reject(new Error("Toolbox not available"));}event && event.stopPropagation();return Task.spawn((function*(){yield this.toolbox.initInspector();let nodeFront=this._nodeFront;if(!nodeFront){nodeFront = yield this.toolbox.walker.getNodeActorFromObjectActor(this._valueGrip.actor);}if(nodeFront){yield this.toolbox.selectTool("inspector");let inspectorReady=promise.defer();this.toolbox.getPanel("inspector").once("inspector-updated",inspectorReady.resolve);yield this.toolbox.selection.setNodeFront(nodeFront,"variables-view");yield inspectorReady.promise;}}).bind(this));}, /**
	   * In case this variable is a DOMNode and part of a variablesview that has been
	   * linked to the toolbox's inspector, then highlight the corresponding node
	   */highlightDomNode:function(){var _this5=this;if(this.toolbox){if(this._nodeFront){ // If the nodeFront has been retrieved before, no need to ask the server
	// again for it
	this.toolbox.highlighterUtils.highlightNodeFront(this._nodeFront);return;}this.toolbox.highlighterUtils.highlightDomValueGrip(this._valueGrip).then(function(front){_this5._nodeFront = front;});}}, /**
	   * Unhighlight a previously highlit node
	   * @see highlightDomNode
	   */unhighlightDomNode:function(){if(this.toolbox){this.toolbox.highlighterUtils.unhighlight();}}, /**
	   * Sets a variable's configurable, enumerable and writable attributes,
	   * and specifies if it's a 'this', '<exception>', '<return>' or '__proto__'
	   * reference.
	   */_setAttributes:function(){let ownerView=this.ownerView;if(ownerView.preventDescriptorModifiers){return;}let descriptor=this._initialDescriptor;let target=this._target;let name=this._nameString;if(ownerView.eval){target.setAttribute("editable","");}if(!descriptor.configurable){target.setAttribute("non-configurable","");}if(!descriptor.enumerable){target.setAttribute("non-enumerable","");}if(!descriptor.writable && !ownerView.getter && !ownerView.setter){target.setAttribute("non-writable","");}if(descriptor.value && typeof descriptor.value == "object"){if(descriptor.value.frozen){target.setAttribute("frozen","");}if(descriptor.value.sealed){target.setAttribute("sealed","");}if(!descriptor.value.extensible){target.setAttribute("non-extensible","");}}if(descriptor && "getterValue" in descriptor){target.setAttribute("safe-getter","");}if(name == "this"){target.setAttribute("self","");}else if(name == "<exception>"){target.setAttribute("exception","");target.setAttribute("pseudo-item","");}else if(name == "<return>"){target.setAttribute("return","");target.setAttribute("pseudo-item","");}else if(name == "__proto__"){target.setAttribute("proto","");target.setAttribute("pseudo-item","");}if(Object.keys(descriptor).length == 0){target.setAttribute("pseudo-item","");}}, /**
	   * Adds the necessary event listeners for this variable.
	   */_addEventListeners:function(){this._name.addEventListener("dblclick",this._activateNameInput,false);this._valueLabel.addEventListener("mousedown",this._activateValueInput,false);this._title.addEventListener("mousedown",this._onClick,false);}, /**
	   * Makes this variable's name editable.
	   */_activateNameInput:function(e){var _this6=this;if(!this._variablesView.alignedValues){this._separatorLabel.hidden = true;this._valueLabel.hidden = true;}EditableName.create(this,{onSave:function(aKey){if(!_this6._variablesView.preventDisableOnChange){_this6._disable();}_this6.ownerView.switch(_this6,aKey);},onCleanup:function(){if(!_this6._variablesView.alignedValues){_this6._separatorLabel.hidden = false;_this6._valueLabel.hidden = false;}}},e);}, /**
	   * Makes this variable's value editable.
	   */_activateValueInput:function(e){var _this7=this;EditableValue.create(this,{onSave:function(aString){if(_this7._linkedToInspector){_this7.unhighlightDomNode();}if(!_this7._variablesView.preventDisableOnChange){_this7._disable();}_this7.ownerView.eval(_this7,aString);}},e);}, /**
	   * Disables this variable prior to a new name switch or value evaluation.
	   */_disable:function(){ // Prevent the variable from being collapsed or expanded.
	this.hideArrow(); // Hide any nodes that may offer information about the variable.
	for(let node of this._title.childNodes) {node.hidden = node != this._arrow && node != this._name;}this._enum.hidden = true;this._nonenum.hidden = true;}, /**
	   * The current macro used to generate the string evaluated when performing
	   * a variable or property value change.
	   */evaluationMacro:VariablesView.simpleValueEvalMacro, /**
	   * The click listener for the edit button.
	   */_onEdit:function(e){if(e.button != 0){return;}e.preventDefault();e.stopPropagation();this._activateValueInput();}, /**
	   * The click listener for the delete button.
	   */_onDelete:function(e){if("button" in e && e.button != 0){return;}e.preventDefault();e.stopPropagation();if(this.ownerView.delete){if(!this.ownerView.delete(this)){this.hide();}}}, /**
	   * The click listener for the add property button.
	   */_onAddProperty:function(e){var _this8=this;if("button" in e && e.button != 0){return;}e.preventDefault();e.stopPropagation();this.expanded = true;let item=this.addItem(" ",{value:undefined,configurable:true,enumerable:true,writable:true},true); // Force showing the separator.
	item._separatorLabel.hidden = false;EditableNameAndValue.create(item,{onSave:function([aKey,aValue]){if(!_this8._variablesView.preventDisableOnChange){_this8._disable();}_this8.ownerView.new(_this8,aKey,aValue);}},e);},_symbolicName:null,_symbolicPath:null,_absoluteName:null,_initialDescriptor:null,_separatorLabel:null,_valueLabel:null,_spacer:null,_editNode:null,_deleteNode:null,_addPropertyNode:null,_tooltip:null,_valueGrip:null,_valueString:"",_valueClassName:"",_prevExpandable:false,_prevExpanded:false}); /**
	 * A Property is a Variable holding additional child Property instances.
	 * Iterable via "for (let [name, property] of instance) { }".
	 *
	 * @param Variable aVar
	 *        The variable to contain this property.
	 * @param string aName
	 *        The property's name.
	 * @param object aDescriptor
	 *        The property's descriptor.
	 */function Property(aVar,aName,aDescriptor){Variable.call(this,aVar,aName,aDescriptor);}Property.prototype = Heritage.extend(Variable.prototype,{ /**
	   * The class name applied to this property's target element.
	   */targetClassName:"variables-view-property variable-or-property", /**
	   * @see Variable.symbolicName
	   * @return string
	   */get symbolicName(){if(this._symbolicName){return this._symbolicName;}this._symbolicName = this.ownerView.symbolicName + "[\"" + this._nameString + "\"]";return this._symbolicName;}, /**
	   * @see Variable.absoluteName
	   * @return string
	   */get absoluteName(){if(this._absoluteName){return this._absoluteName;}this._absoluteName = this.ownerView.absoluteName + "[\"" + this._nameString + "\"]";return this._absoluteName;}}); /**
	 * A generator-iterator over the VariablesView, Scopes, Variables and Properties.
	 */VariablesView.prototype[Symbol.iterator] = Scope.prototype[Symbol.iterator] = Variable.prototype[Symbol.iterator] = Property.prototype[Symbol.iterator] = function*(){yield* this._store;}; /**
	 * Forget everything recorded about added scopes, variables or properties.
	 * @see VariablesView.commitHierarchy
	 */VariablesView.prototype.clearHierarchy = function(){this._prevHierarchy.clear();this._currHierarchy.clear();}; /**
	 * Perform operations on all the VariablesView Scopes, Variables and Properties
	 * after you've added all the items you wanted.
	 *
	 * Calling this method is optional, and does the following:
	 *   - styles the items overridden by other items in parent scopes
	 *   - reopens the items which were previously expanded
	 *   - flashes the items whose values changed
	 */VariablesView.prototype.commitHierarchy = function(){for(let _ref11 of this._currHierarchy) {var _ref12=_slicedToArray(_ref11,2);let currItem=_ref12[1]; // Avoid performing expensive operations.
	if(this.commitHierarchyIgnoredItems[currItem._nameString]){continue;}let overridden=this.isOverridden(currItem);if(overridden){currItem.setOverridden(true);}let expanded=!currItem._committed && this.wasExpanded(currItem);if(expanded){currItem.expand();}let changed=!currItem._committed && this.hasChanged(currItem);if(changed){currItem.flash();}currItem._committed = true;}if(this.oncommit){this.oncommit(this);}}; // Some variables are likely to contain a very large number of properties.
	// It would be a bad idea to re-expand them or perform expensive operations.
	VariablesView.prototype.commitHierarchyIgnoredItems = Heritage.extend(null,{"window":true,"this":true}); /**
	 * Checks if the an item was previously expanded, if it existed in a
	 * previous hierarchy.
	 *
	 * @param Scope | Variable | Property aItem
	 *        The item to verify.
	 * @return boolean
	 *         Whether the item was expanded.
	 */VariablesView.prototype.wasExpanded = function(aItem){if(!(aItem instanceof Scope)){return false;}let prevItem=this._prevHierarchy.get(aItem.absoluteName || aItem._nameString);return prevItem?prevItem._isExpanded:false;}; /**
	 * Checks if the an item's displayed value (a representation of the grip)
	 * has changed, if it existed in a previous hierarchy.
	 *
	 * @param Variable | Property aItem
	 *        The item to verify.
	 * @return boolean
	 *         Whether the item has changed.
	 */VariablesView.prototype.hasChanged = function(aItem){ // Only analyze Variables and Properties for displayed value changes.
	// Scopes are just collections of Variables and Properties and
	// don't have a "value", so they can't change.
	if(!(aItem instanceof Variable)){return false;}let prevItem=this._prevHierarchy.get(aItem.absoluteName);return prevItem?prevItem._valueString != aItem._valueString:false;}; /**
	 * Checks if the an item was previously expanded, if it existed in a
	 * previous hierarchy.
	 *
	 * @param Scope | Variable | Property aItem
	 *        The item to verify.
	 * @return boolean
	 *         Whether the item was expanded.
	 */VariablesView.prototype.isOverridden = function(aItem){ // Only analyze Variables for being overridden in different Scopes.
	if(!(aItem instanceof Variable) || aItem instanceof Property){return false;}let currVariableName=aItem._nameString;let parentScopes=this.getParentScopesForVariableOrProperty(aItem);for(let otherScope of parentScopes) {for(let _ref13 of otherScope) {var _ref14=_slicedToArray(_ref13,1);let otherVariableName=_ref14[0];if(otherVariableName == currVariableName){return true;}}}return false;}; /**
	 * Returns true if the descriptor represents an undefined, null or
	 * primitive value.
	 *
	 * @param object aDescriptor
	 *        The variable's descriptor.
	 */VariablesView.isPrimitive = function(aDescriptor){ // For accessor property descriptors, the getter and setter need to be
	// contained in 'get' and 'set' properties.
	let getter=aDescriptor.get;let setter=aDescriptor.set;if(getter || setter){return false;} // As described in the remote debugger protocol, the value grip
	// must be contained in a 'value' property.
	let grip=aDescriptor.value;if(typeof grip != "object"){return true;} // For convenience, undefined, null, Infinity, -Infinity, NaN, -0, and long
	// strings are considered types.
	let type=grip.type;if(type == "undefined" || type == "null" || type == "Infinity" || type == "-Infinity" || type == "NaN" || type == "-0" || type == "symbol" || type == "longString"){return true;}return false;}; /**
	 * Returns true if the descriptor represents an undefined value.
	 *
	 * @param object aDescriptor
	 *        The variable's descriptor.
	 */VariablesView.isUndefined = function(aDescriptor){ // For accessor property descriptors, the getter and setter need to be
	// contained in 'get' and 'set' properties.
	let getter=aDescriptor.get;let setter=aDescriptor.set;if(typeof getter == "object" && getter.type == "undefined" && typeof setter == "object" && setter.type == "undefined"){return true;} // As described in the remote debugger protocol, the value grip
	// must be contained in a 'value' property.
	let grip=aDescriptor.value;if(typeof grip == "object" && grip.type == "undefined"){return true;}return false;}; /**
	 * Returns true if the descriptor represents a falsy value.
	 *
	 * @param object aDescriptor
	 *        The variable's descriptor.
	 */VariablesView.isFalsy = function(aDescriptor){ // As described in the remote debugger protocol, the value grip
	// must be contained in a 'value' property.
	let grip=aDescriptor.value;if(typeof grip != "object"){return !grip;} // For convenience, undefined, null, NaN, and -0 are all considered types.
	let type=grip.type;if(type == "undefined" || type == "null" || type == "NaN" || type == "-0"){return true;}return false;}; /**
	 * Returns true if the value is an instance of Variable or Property.
	 *
	 * @param any aValue
	 *        The value to test.
	 */VariablesView.isVariable = function(aValue){return aValue instanceof Variable;}; /**
	 * Returns a standard grip for a value.
	 *
	 * @param any aValue
	 *        The raw value to get a grip for.
	 * @return any
	 *         The value's grip.
	 */VariablesView.getGrip = function(aValue){switch(typeof aValue){case "boolean":case "string":return aValue;case "number":if(aValue === Infinity){return {type:"Infinity"};}else if(aValue === -Infinity){return {type:"-Infinity"};}else if(Number.isNaN(aValue)){return {type:"NaN"};}else if(1 / aValue === -Infinity){return {type:"-0"};}return aValue;case "undefined": // document.all is also "undefined"
	if(aValue === undefined){return {type:"undefined"};}case "object":if(aValue === null){return {type:"null"};}case "function":return {type:"object",class:WebConsoleUtils.getObjectClassName(aValue)};default:Cu.reportError("Failed to provide a grip for value of " + typeof value + ": " + aValue);return null;}}; /**
	 * Returns a custom formatted property string for a grip.
	 *
	 * @param any aGrip
	 *        @see Variable.setGrip
	 * @param object aOptions
	 *        Options:
	 *        - concise: boolean that tells you want a concisely formatted string.
	 *        - noStringQuotes: boolean that tells to not quote strings.
	 *        - noEllipsis: boolean that tells to not add an ellipsis after the
	 *        initial text of a longString.
	 * @return string
	 *         The formatted property string.
	 */VariablesView.getString = function(aGrip,aOptions = {}){if(aGrip && typeof aGrip == "object"){switch(aGrip.type){case "undefined":case "null":case "NaN":case "Infinity":case "-Infinity":case "-0":return aGrip.type;default:let stringifier=VariablesView.stringifiers.byType[aGrip.type];if(stringifier){let result=stringifier(aGrip,aOptions);if(result != null){return result;}}if(aGrip.displayString){return VariablesView.getString(aGrip.displayString,aOptions);}if(aGrip.type == "object" && aOptions.concise){return aGrip.class;}return "[" + aGrip.type + " " + aGrip.class + "]";}}switch(typeof aGrip){case "string":return VariablesView.stringifiers.byType.string(aGrip,aOptions);case "boolean":return aGrip?"true":"false";case "number":if(!aGrip && 1 / aGrip === -Infinity){return "-0";}default:return aGrip + "";}}; /**
	 * The VariablesView stringifiers are used by VariablesView.getString(). These
	 * are organized by object type, object class and by object actor preview kind.
	 * Some objects share identical ways for previews, for example Arrays, Sets and
	 * NodeLists.
	 *
	 * Any stringifier function must return a string. If null is returned, * then
	 * the default stringifier will be used. When invoked, the stringifier is
	 * given the same two arguments as those given to VariablesView.getString().
	 */VariablesView.stringifiers = {};VariablesView.stringifiers.byType = {string:function(aGrip,{noStringQuotes}){if(noStringQuotes){return aGrip;}return '"' + aGrip + '"';},longString:function({initial},{noStringQuotes,noEllipsis}){let ellipsis=noEllipsis?"":Scope.ellipsis;if(noStringQuotes){return initial + ellipsis;}let result='"' + initial + '"';if(!ellipsis){return result;}return result.substr(0,result.length - 1) + ellipsis + '"';},object:function(aGrip,aOptions){let preview=aGrip.preview;let stringifier;if(preview && preview.kind){stringifier = VariablesView.stringifiers.byObjectKind[preview.kind];}if(!stringifier && aGrip.class){stringifier = VariablesView.stringifiers.byObjectClass[aGrip.class];}if(stringifier){return stringifier(aGrip,aOptions);}return null;},symbol:function(aGrip,aOptions){const name=aGrip.name || "";return "Symbol(" + name + ")";}}; // VariablesView.stringifiers.byType
	VariablesView.stringifiers.byObjectClass = {Function:function(aGrip,{concise}){ // TODO: Bug 948484 - support arrow functions and ES6 generators
	let name=aGrip.userDisplayName || aGrip.displayName || aGrip.name || "";name = VariablesView.getString(name,{noStringQuotes:true}); // TODO: Bug 948489 - Support functions with destructured parameters and
	// rest parameters
	let params=aGrip.parameterNames || "";if(!concise){return "function " + name + "(" + params + ")";}return (name || "function ") + "(" + params + ")";},RegExp:function({displayString}){return VariablesView.getString(displayString,{noStringQuotes:true});},Date:function({preview}){if(!preview || !("timestamp" in preview)){return null;}if(typeof preview.timestamp != "number"){return new Date(preview.timestamp).toString(); // invalid date
	}return "Date " + new Date(preview.timestamp).toISOString();},String:function({displayString}){if(displayString === undefined){return null;}return VariablesView.getString(displayString);},Number:function({preview}){if(preview === undefined){return null;}return VariablesView.getString(preview.value);}}; // VariablesView.stringifiers.byObjectClass
	VariablesView.stringifiers.byObjectClass.Boolean = VariablesView.stringifiers.byObjectClass.Number;VariablesView.stringifiers.byObjectKind = {ArrayLike:function(aGrip,{concise}){let preview=aGrip.preview;if(concise){return aGrip.class + "[" + preview.length + "]";}if(!preview.items){return null;}let shown=0,result=[],lastHole=null;for(let item of preview.items) {if(item === null){if(lastHole !== null){result[lastHole] += ",";}else {result.push("");}lastHole = result.length - 1;}else {lastHole = null;result.push(VariablesView.getString(item,{concise:true}));}shown++;}if(shown < preview.length){let n=preview.length - shown;result.push(VariablesView.stringifiers._getNMoreString(n));}else if(lastHole !== null){ // make sure we have the right number of commas...
	result[lastHole] += ",";}let prefix=aGrip.class == "Array"?"":aGrip.class + " ";return prefix + "[" + result.join(", ") + "]";},MapLike:function(aGrip,{concise}){let preview=aGrip.preview;if(concise || !preview.entries){let size=typeof preview.size == "number"?"[" + preview.size + "]":"";return aGrip.class + size;}let entries=[];for(let _ref15 of preview.entries) {var _ref16=_slicedToArray(_ref15,2);let key=_ref16[0];let value=_ref16[1];let keyString=VariablesView.getString(key,{concise:true,noStringQuotes:true});let valueString=VariablesView.getString(value,{concise:true});entries.push(keyString + ": " + valueString);}if(typeof preview.size == "number" && preview.size > entries.length){let n=preview.size - entries.length;entries.push(VariablesView.stringifiers._getNMoreString(n));}return aGrip.class + " {" + entries.join(", ") + "}";},ObjectWithText:function(aGrip,{concise}){if(concise){return aGrip.class;}return aGrip.class + " " + VariablesView.getString(aGrip.preview.text);},ObjectWithURL:function(aGrip,{concise}){let result=aGrip.class;let url=aGrip.preview.url;if(!VariablesView.isFalsy({value:url})){result += " \u2192 " + WebConsoleUtils.abbreviateSourceURL(url,{onlyCropQuery:!concise});}return result;}, // Stringifier for any kind of object.
	Object:function(aGrip,{concise}){if(concise){return aGrip.class;}let preview=aGrip.preview;let props=[];if(aGrip.class == "Promise" && aGrip.promiseState){var _aGrip$promiseState=aGrip.promiseState;let state=_aGrip$promiseState.state;let value=_aGrip$promiseState.value;let reason=_aGrip$promiseState.reason;props.push("<state>: " + VariablesView.getString(state));if(state == "fulfilled"){props.push("<value>: " + VariablesView.getString(value,{concise:true}));}else if(state == "rejected"){props.push("<reason>: " + VariablesView.getString(reason,{concise:true}));}}for(let key of Object.keys(preview.ownProperties || {})) {let value=preview.ownProperties[key];let valueString="";if(value.get){valueString = "Getter";}else if(value.set){valueString = "Setter";}else {valueString = VariablesView.getString(value.value,{concise:true});}props.push(key + ": " + valueString);}for(let key of Object.keys(preview.safeGetterValues || {})) {let value=preview.safeGetterValues[key];let valueString=VariablesView.getString(value.getterValue,{concise:true});props.push(key + ": " + valueString);}if(!props.length){return null;}if(preview.ownPropertiesLength){let previewLength=Object.keys(preview.ownProperties).length;let diff=preview.ownPropertiesLength - previewLength;if(diff > 0){props.push(VariablesView.stringifiers._getNMoreString(diff));}}let prefix=aGrip.class != "Object"?aGrip.class + " ":"";return prefix + "{" + props.join(", ") + "}";}, // Object
	Error:function(aGrip,{concise}){let preview=aGrip.preview;let name=VariablesView.getString(preview.name,{noStringQuotes:true});if(concise){return name || aGrip.class;}let msg=name + ": " + VariablesView.getString(preview.message,{noStringQuotes:true});if(!VariablesView.isFalsy({value:preview.stack})){msg += "\n" + STR.GetStringFromName("variablesViewErrorStacktrace") + "\n" + preview.stack;}return msg;},DOMException:function(aGrip,{concise}){let preview=aGrip.preview;if(concise){return preview.name || aGrip.class;}let msg=aGrip.class + " [" + preview.name + ": " + VariablesView.getString(preview.message) + "\n" + "code: " + preview.code + "\n" + "nsresult: 0x" + (+preview.result).toString(16);if(preview.filename){msg += "\nlocation: " + preview.filename;if(preview.lineNumber){msg += ":" + preview.lineNumber;}}return msg + "]";},DOMEvent:function(aGrip,{concise}){let preview=aGrip.preview;if(!preview.type){return null;}if(concise){return aGrip.class + " " + preview.type;}let result=preview.type;if(preview.eventKind == "key" && preview.modifiers && preview.modifiers.length){result += " " + preview.modifiers.join("-");}let props=[];if(preview.target){let target=VariablesView.getString(preview.target,{concise:true});props.push("target: " + target);}for(let prop in preview.properties) {let value=preview.properties[prop];props.push(prop + ": " + VariablesView.getString(value,{concise:true}));}return result + " {" + props.join(", ") + "}";}, // DOMEvent
	DOMNode:function(aGrip,{concise}){let preview=aGrip.preview;switch(preview.nodeType){case Ci.nsIDOMNode.DOCUMENT_NODE:{let result=aGrip.class;if(preview.location){let location=WebConsoleUtils.abbreviateSourceURL(preview.location,{onlyCropQuery:!concise});result += " \u2192 " + location;}return result;}case Ci.nsIDOMNode.ATTRIBUTE_NODE:{let value=VariablesView.getString(preview.value,{noStringQuotes:true});return preview.nodeName + '="' + escapeHTML(value) + '"';}case Ci.nsIDOMNode.TEXT_NODE:return preview.nodeName + " " + VariablesView.getString(preview.textContent);case Ci.nsIDOMNode.COMMENT_NODE:{let comment=VariablesView.getString(preview.textContent,{noStringQuotes:true});return "<!--" + comment + "-->";}case Ci.nsIDOMNode.DOCUMENT_FRAGMENT_NODE:{if(concise || !preview.childNodes){return aGrip.class + "[" + preview.childNodesLength + "]";}let nodes=[];for(let node of preview.childNodes) {nodes.push(VariablesView.getString(node));}if(nodes.length < preview.childNodesLength){let n=preview.childNodesLength - nodes.length;nodes.push(VariablesView.stringifiers._getNMoreString(n));}return aGrip.class + " [" + nodes.join(", ") + "]";}case Ci.nsIDOMNode.ELEMENT_NODE:{let attrs=preview.attributes;if(!concise){let n=0,result="<" + preview.nodeName;for(let name in attrs) {let value=VariablesView.getString(attrs[name],{noStringQuotes:true});result += " " + name + '="' + escapeHTML(value) + '"';n++;}if(preview.attributesLength > n){result += " " + Scope.ellipsis;}return result + ">";}let result="<" + preview.nodeName;if(attrs.id){result += "#" + attrs.id;}if(attrs.class){result += "." + attrs.class.trim().replace(/\s+/,".");}return result + ">";}default:return null;}}}; // VariablesView.stringifiers.byObjectKind
	/**
	 * Get the "N more…" formatted string, given an N. This is used for displaying
	 * how many elements are not displayed in an object preview (eg. an array).
	 *
	 * @private
	 * @param number aNumber
	 * @return string
	 */ // DOMNode
	VariablesView.stringifiers._getNMoreString = function(aNumber){let str=STR.GetStringFromName("variablesViewMoreObjects");return PluralForm.get(aNumber,str).replace("#1",aNumber);}; /**
	 * Returns a custom class style for a grip.
	 *
	 * @param any aGrip
	 *        @see Variable.setGrip
	 * @return string
	 *         The custom class style.
	 */VariablesView.getClass = function(aGrip){if(aGrip && typeof aGrip == "object"){if(aGrip.preview){switch(aGrip.preview.kind){case "DOMNode":return "token-domnode";}}switch(aGrip.type){case "undefined":return "token-undefined";case "null":return "token-null";case "Infinity":case "-Infinity":case "NaN":case "-0":return "token-number";case "longString":return "token-string";}}switch(typeof aGrip){case "string":return "token-string";case "boolean":return "token-boolean";case "number":return "token-number";default:return "token-other";}}; /**
	 * A monotonically-increasing counter, that guarantees the uniqueness of scope,
	 * variables and properties ids.
	 *
	 * @param string aName
	 *        An optional string to prefix the id with.
	 * @return number
	 *         A unique id.
	 */var generateId=(function(){let count=0;return function(aName = ""){return aName.toLowerCase().trim().replace(/\s+/g,"-") + ++count;};})(); /**
	 * Escape some HTML special characters. We do not need full HTML serialization
	 * here, we just want to make strings safe to display in HTML attributes, for
	 * the stringifiers.
	 *
	 * @param string aString
	 * @return string
	 */function escapeHTML(aString){return aString.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/</g,"&lt;").replace(/>/g,"&gt;");} /**
	 * An Editable encapsulates the UI of an edit box that overlays a label,
	 * allowing the user to edit the value.
	 *
	 * @param Variable aVariable
	 *        The Variable or Property to make editable.
	 * @param object aOptions
	 *        - onSave
	 *          The callback to call with the value when editing is complete.
	 *        - onCleanup
	 *          The callback to call when the editable is removed for any reason.
	 */function Editable(aVariable,aOptions){this._variable = aVariable;this._onSave = aOptions.onSave;this._onCleanup = aOptions.onCleanup;}Editable.create = function(aVariable,aOptions,aEvent){let editable=new this(aVariable,aOptions);editable.activate(aEvent);return editable;};Editable.prototype = { /**
	   * The class name for targeting this Editable type's label element. Overridden
	   * by inheriting classes.
	   */className:null, /**
	   * Boolean indicating whether this Editable should activate. Overridden by
	   * inheriting classes.
	   */shouldActivate:null, /**
	   * The label element for this Editable. Overridden by inheriting classes.
	   */label:null, /**
	   * Activate this editable by replacing the input box it overlays and
	   * initialize the handlers.
	   *
	   * @param Event e [optional]
	   *        Optionally, the Event object that was used to activate the Editable.
	   */activate:function(e){if(!this.shouldActivate){this._onCleanup && this._onCleanup();return;}let label=this.label;let initialString=label.getAttribute("value");if(e){e.preventDefault();e.stopPropagation();} // Create a texbox input element which will be shown in the current
	// element's specified label location.
	let input=this._input = this._variable.document.createElement("textbox");input.className = "plain " + this.className;input.setAttribute("value",initialString);input.setAttribute("flex","1"); // Replace the specified label with a textbox input element.
	label.parentNode.replaceChild(input,label);this._variable._variablesView.boxObject.ensureElementIsVisible(input);input.select(); // When the value is a string (displayed as "value"), then we probably want
	// to change it to another string in the textbox, so to avoid typing the ""
	// again, tackle with the selection bounds just a bit.
	if(initialString.match(/^".+"$/)){input.selectionEnd--;input.selectionStart++;}this._onKeypress = this._onKeypress.bind(this);this._onBlur = this._onBlur.bind(this);input.addEventListener("keypress",this._onKeypress);input.addEventListener("blur",this._onBlur);this._prevExpandable = this._variable.twisty;this._prevExpanded = this._variable.expanded;this._variable.collapse();this._variable.hideArrow();this._variable.locked = true;this._variable.editing = true;}, /**
	   * Remove the input box and restore the Variable or Property to its previous
	   * state.
	   */deactivate:function(){this._input.removeEventListener("keypress",this._onKeypress);this._input.removeEventListener("blur",this.deactivate);this._input.parentNode.replaceChild(this.label,this._input);this._input = null;let boxObject=this._variable._variablesView.boxObject;boxObject.scrollBy(-this._variable._target,0);this._variable.locked = false;this._variable.twisty = this._prevExpandable;this._variable.expanded = this._prevExpanded;this._variable.editing = false;this._onCleanup && this._onCleanup();}, /**
	   * Save the current value and deactivate the Editable.
	   */_save:function(){let initial=this.label.getAttribute("value");let current=this._input.value.trim();this.deactivate();if(initial != current){this._onSave(current);}}, /**
	   * Called when tab is pressed, allowing subclasses to link different
	   * behavior to tabbing if desired.
	   */_next:function(){this._save();}, /**
	   * Called when escape is pressed, indicating a cancelling of editing without
	   * saving.
	   */_reset:function(){this.deactivate();this._variable.focus();}, /**
	   * Event handler for when the input loses focus.
	   */_onBlur:function(){this.deactivate();}, /**
	   * Event handler for when the input receives a key press.
	   */_onKeypress:function(e){e.stopPropagation();switch(e.keyCode){case e.DOM_VK_TAB:this._next();break;case e.DOM_VK_RETURN:this._save();break;case e.DOM_VK_ESCAPE:this._reset();break;}}}; /**
	 * An Editable specific to editing the name of a Variable or Property.
	 */function EditableName(aVariable,aOptions){Editable.call(this,aVariable,aOptions);}EditableName.create = Editable.create;EditableName.prototype = Heritage.extend(Editable.prototype,{className:"element-name-input",get label(){return this._variable._name;},get shouldActivate(){return !!this._variable.ownerView.switch;}}); /**
	 * An Editable specific to editing the value of a Variable or Property.
	 */function EditableValue(aVariable,aOptions){Editable.call(this,aVariable,aOptions);}EditableValue.create = Editable.create;EditableValue.prototype = Heritage.extend(Editable.prototype,{className:"element-value-input",get label(){return this._variable._valueLabel;},get shouldActivate(){return !!this._variable.ownerView.eval;}}); /**
	 * An Editable specific to editing the key and value of a new property.
	 */function EditableNameAndValue(aVariable,aOptions){EditableName.call(this,aVariable,aOptions);}EditableNameAndValue.create = Editable.create;EditableNameAndValue.prototype = Heritage.extend(EditableName.prototype,{_reset:function(e){ // Hide the Variable or Property if the user presses escape.
	this._variable.remove();this.deactivate();},_next:function(e){var _this9=this; // Override _next so as to set both key and value at the same time.
	let key=this._input.value;this.label.setAttribute("value",key);let valueEditable=EditableValue.create(this._variable,{onSave:function(aValue){_this9._onSave([key,aValue]);}});valueEditable._reset = function(){_this9._variable.remove();valueEditable.deactivate();};},_save:function(e){ // Both _save and _next activate the value edit box.
	this._next(e);}});exports.VariablesView = VariablesView;exports.escapeHTML = escapeHTML;

/***/ },
/* 71 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/intl/locale/PluralForm.jsm
	 */
	"use strict";

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- js-indent-level: 2; indent-tabs-mode: nil -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;
	const components = _require.components;

	var _require2 = __webpack_require__(73);

	const isWindowIncluded = _require2.isWindowIncluded;

	var _require3 = __webpack_require__(15);

	const XPCOMUtils = _require3.XPCOMUtils;

	var _require4 = __webpack_require__(9);

	const Services = _require4.Services;

	// TODO: Bug 842672 - browser/ imports modules from toolkit/.
	// Note that these are only used in WebConsoleCommands, see $0 and pprint().

	var _require5 = __webpack_require__(70);

	const VariablesView = _require5.VariablesView;
	const escapeHTML = _require5.escapeHTML;

	const DevToolsUtils = __webpack_require__(19);

	XPCOMUtils.defineLazyServiceGetter(this, "swm", "@mozilla.org/serviceworkers/manager;1", "nsIServiceWorkerManager");

	// Match the function name from the result of toString() or toSource().
	//
	// Examples:
	// (function foobar(a, b) { ...
	// function foobar2(a) { ...
	// function() { ...
	const REGEX_MATCH_FUNCTION_NAME = /^\(?function\s+([^(\s]+)\s*\(/;

	// Match the function arguments from the result of toString() or toSource().
	const REGEX_MATCH_FUNCTION_ARGS = /^\(?function\s*[^\s(]*\s*\((.+?)\)/;

	// Number of terminal entries for the self-xss prevention to go away
	const CONSOLE_ENTRY_THRESHOLD = 5;

	const CONSOLE_WORKER_IDS = exports.CONSOLE_WORKER_IDS = ['SharedWorker', 'ServiceWorker', 'Worker'];

	var WebConsoleUtils = {

	  /**
	   * Wrap a string in an nsISupportsString object.
	   *
	   * @param string aString
	   * @return nsISupportsString
	   */
	  supportsString: function WCU_supportsString(aString) {
	    let str = Cc("@mozilla.org/supports-string;1").createInstance(Ci.nsISupportsString);
	    str.data = aString;
	    return str;
	  },

	  /**
	   * Given a message, return one of CONSOLE_WORKER_IDS if it matches
	   * one of those.
	   *
	   * @return string
	   */
	  getWorkerType: function (message) {
	    let id = message ? message.innerID : null;
	    return CONSOLE_WORKER_IDS[CONSOLE_WORKER_IDS.indexOf(id)] || null;
	  },

	  /**
	   * Clone an object.
	   *
	   * @param object aObject
	   *        The object you want cloned.
	   * @param boolean aRecursive
	   *        Tells if you want to dig deeper into the object, to clone
	   *        recursively.
	   * @param function [aFilter]
	   *        Optional, filter function, called for every property. Three
	   *        arguments are passed: key, value and object. Return true if the
	   *        property should be added to the cloned object. Return false to skip
	   *        the property.
	   * @return object
	   *         The cloned object.
	   */
	  cloneObject: function WCU_cloneObject(aObject, aRecursive, aFilter) {
	    if (typeof aObject != "object") {
	      return aObject;
	    }

	    let temp;

	    if (Array.isArray(aObject)) {
	      temp = [];
	      Array.forEach(aObject, function (aValue, aIndex) {
	        if (!aFilter || aFilter(aIndex, aValue, aObject)) {
	          temp.push(aRecursive ? WCU_cloneObject(aValue) : aValue);
	        }
	      });
	    } else {
	      temp = {};
	      for (let key in aObject) {
	        let value = aObject[key];
	        if (aObject.hasOwnProperty(key) && (!aFilter || aFilter(key, value, aObject))) {
	          temp[key] = aRecursive ? WCU_cloneObject(value) : value;
	        }
	      }
	    }

	    return temp;
	  },

	  /**
	   * Copies certain style attributes from one element to another.
	   *
	   * @param nsIDOMNode aFrom
	   *        The target node.
	   * @param nsIDOMNode aTo
	   *        The destination node.
	   */
	  copyTextStyles: function WCU_copyTextStyles(aFrom, aTo) {
	    let win = aFrom.ownerDocument.defaultView;
	    let style = win.getComputedStyle(aFrom);
	    aTo.style.fontFamily = style.getPropertyCSSValue("font-family").cssText;
	    aTo.style.fontSize = style.getPropertyCSSValue("font-size").cssText;
	    aTo.style.fontWeight = style.getPropertyCSSValue("font-weight").cssText;
	    aTo.style.fontStyle = style.getPropertyCSSValue("font-style").cssText;
	  },

	  /**
	   * Gets the ID of the inner window of this DOM window.
	   *
	   * @param nsIDOMWindow aWindow
	   * @return integer
	   *         Inner ID for the given aWindow.
	   */
	  getInnerWindowId: function WCU_getInnerWindowId(aWindow) {
	    return aWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
	  },

	  /**
	   * Recursively gather a list of inner window ids given a
	   * top level window.
	   *
	   * @param nsIDOMWindow aWindow
	   * @return Array
	   *         list of inner window ids.
	   */
	  getInnerWindowIDsForFrames: function WCU_getInnerWindowIDsForFrames(aWindow) {
	    let innerWindowID = this.getInnerWindowId(aWindow);
	    let ids = [innerWindowID];

	    if (aWindow.frames) {
	      for (let i = 0; i < aWindow.frames.length; i++) {
	        let frame = aWindow.frames[i];
	        ids = ids.concat(this.getInnerWindowIDsForFrames(frame));
	      }
	    }

	    return ids;
	  },

	  /**
	   * Gets the ID of the outer window of this DOM window.
	   *
	   * @param nsIDOMWindow aWindow
	   * @return integer
	   *         Outer ID for the given aWindow.
	   */
	  getOuterWindowId: function WCU_getOuterWindowId(aWindow) {
	    return aWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
	  },

	  /**
	   * Abbreviates the given source URL so that it can be displayed flush-right
	   * without being too distracting.
	   *
	   * @param string aSourceURL
	   *        The source URL to shorten.
	   * @param object [aOptions]
	   *        Options:
	   *        - onlyCropQuery: boolean that tells if the URL abbreviation function
	   *        should only remove the query parameters and the hash fragment from
	   *        the given URL.
	   * @return string
	   *         The abbreviated form of the source URL.
	   */
	  abbreviateSourceURL: function WCU_abbreviateSourceURL(aSourceURL, aOptions = {}) {
	    if (!aOptions.onlyCropQuery && aSourceURL.substr(0, 5) == "data:") {
	      let commaIndex = aSourceURL.indexOf(",");
	      if (commaIndex > -1) {
	        aSourceURL = "data:" + aSourceURL.substring(commaIndex + 1);
	      }
	    }

	    // Remove any query parameters.
	    let hookIndex = aSourceURL.indexOf("?");
	    if (hookIndex > -1) {
	      aSourceURL = aSourceURL.substring(0, hookIndex);
	    }

	    // Remove any hash fragments.
	    let hashIndex = aSourceURL.indexOf("#");
	    if (hashIndex > -1) {
	      aSourceURL = aSourceURL.substring(0, hashIndex);
	    }

	    // Remove a trailing "/".
	    if (aSourceURL[aSourceURL.length - 1] == "/") {
	      aSourceURL = aSourceURL.replace(/\/+$/, "");
	    }

	    // Remove all but the last path component.
	    if (!aOptions.onlyCropQuery) {
	      let slashIndex = aSourceURL.lastIndexOf("/");
	      if (slashIndex > -1) {
	        aSourceURL = aSourceURL.substring(slashIndex + 1);
	      }
	    }

	    return aSourceURL;
	  },

	  /**
	   * Tells if the given function is native or not.
	   *
	   * @param function aFunction
	   *        The function you want to check if it is native or not.
	   * @return boolean
	   *         True if the given function is native, false otherwise.
	   */
	  isNativeFunction: function WCU_isNativeFunction(aFunction) {
	    return typeof aFunction == "function" && !("prototype" in aFunction);
	  },

	  /**
	   * Tells if the given property of the provided object is a non-native getter or
	   * not.
	   *
	   * @param object aObject
	   *        The object that contains the property.
	   * @param string aProp
	   *        The property you want to check if it is a getter or not.
	   * @return boolean
	   *         True if the given property is a getter, false otherwise.
	   */
	  isNonNativeGetter: function WCU_isNonNativeGetter(aObject, aProp) {
	    if (typeof aObject != "object") {
	      return false;
	    }
	    let desc = this.getPropertyDescriptor(aObject, aProp);
	    return desc && desc.get && !this.isNativeFunction(desc.get);
	  },

	  /**
	   * Get the property descriptor for the given object.
	   *
	   * @param object aObject
	   *        The object that contains the property.
	   * @param string aProp
	   *        The property you want to get the descriptor for.
	   * @return object
	   *         Property descriptor.
	   */
	  getPropertyDescriptor: function WCU_getPropertyDescriptor(aObject, aProp) {
	    let desc = null;
	    while (aObject) {
	      try {
	        if (desc = Object.getOwnPropertyDescriptor(aObject, aProp)) {
	          break;
	        }
	      } catch (ex) {
	        // Native getters throw here. See bug 520882.
	        // null throws TypeError.
	        if (ex.name != "NS_ERROR_XPC_BAD_CONVERT_JS" && ex.name != "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO" && ex.name != "TypeError") {
	          throw ex;
	        }
	      }

	      try {
	        aObject = Object.getPrototypeOf(aObject);
	      } catch (ex) {
	        if (ex.name == "TypeError") {
	          return desc;
	        }
	        throw ex;
	      }
	    }
	    return desc;
	  },

	  /**
	   * Sort function for object properties.
	   *
	   * @param object a
	   *        Property descriptor.
	   * @param object b
	   *        Property descriptor.
	   * @return integer
	   *         -1 if a.name < b.name,
	   *         1 if a.name > b.name,
	   *         0 otherwise.
	   */
	  propertiesSort: function WCU_propertiesSort(a, b) {
	    // Convert the pair.name to a number for later sorting.
	    let aNumber = parseFloat(a.name);
	    let bNumber = parseFloat(b.name);

	    // Sort numbers.
	    if (!isNaN(aNumber) && isNaN(bNumber)) {
	      return -1;
	    } else if (isNaN(aNumber) && !isNaN(bNumber)) {
	      return 1;
	    } else if (!isNaN(aNumber) && !isNaN(bNumber)) {
	      return aNumber - bNumber;
	    }
	    // Sort string.
	    else if (a.name < b.name) {
	        return -1;
	      } else if (a.name > b.name) {
	        return 1;
	      } else {
	        return 0;
	      }
	  },

	  /**
	   * Create a grip for the given value. If the value is an object,
	   * an object wrapper will be created.
	   *
	   * @param mixed aValue
	   *        The value you want to create a grip for, before sending it to the
	   *        client.
	   * @param function aObjectWrapper
	   *        If the value is an object then the aObjectWrapper function is
	   *        invoked to give us an object grip. See this.getObjectGrip().
	   * @return mixed
	   *         The value grip.
	   */
	  createValueGrip: function WCU_createValueGrip(aValue, aObjectWrapper) {
	    switch (typeof aValue) {
	      case "boolean":
	        return aValue;
	      case "string":
	        return aObjectWrapper(aValue);
	      case "number":
	        if (aValue === Infinity) {
	          return { type: "Infinity" };
	        } else if (aValue === -Infinity) {
	          return { type: "-Infinity" };
	        } else if (Number.isNaN(aValue)) {
	          return { type: "NaN" };
	        } else if (!aValue && 1 / aValue === -Infinity) {
	          return { type: "-0" };
	        }
	        return aValue;
	      case "undefined":
	        return { type: "undefined" };
	      case "object":
	        if (aValue === null) {
	          return { type: "null" };
	        }
	      case "function":
	        return aObjectWrapper(aValue);
	      default:
	        Cu.reportError("Failed to provide a grip for value of " + typeof aValue + ": " + aValue);
	        return null;
	    }
	  },

	  /**
	   * Check if the given object is an iterator or a generator.
	   *
	   * @param object aObject
	   *        The object you want to check.
	   * @return boolean
	   *         True if the given object is an iterator or a generator, otherwise
	   *         false is returned.
	   */
	  isIteratorOrGenerator: function WCU_isIteratorOrGenerator(aObject) {
	    if (aObject === null) {
	      return false;
	    }

	    if (typeof aObject == "object") {
	      if (typeof aObject.__iterator__ == "function" || aObject.constructor && aObject.constructor.name == "Iterator") {
	        return true;
	      }

	      try {
	        let str = aObject.toString();
	        if (typeof aObject.next == "function" && str.indexOf("[object Generator") == 0) {
	          return true;
	        }
	      } catch (ex) {
	        // window.history.next throws in the typeof check above.
	        return false;
	      }
	    }

	    return false;
	  },

	  /**
	   * Determine if the given request mixes HTTP with HTTPS content.
	   *
	   * @param string aRequest
	   *        Location of the requested content.
	   * @param string aLocation
	   *        Location of the current page.
	   * @return boolean
	   *         True if the content is mixed, false if not.
	   */
	  isMixedHTTPSRequest: function WCU_isMixedHTTPSRequest(aRequest, aLocation) {
	    try {
	      let requestURI = Services.io.newURI(aRequest, null, null);
	      let contentURI = Services.io.newURI(aLocation, null, null);
	      return contentURI.scheme == "https" && requestURI.scheme != "https";
	    } catch (ex) {
	      return false;
	    }
	  },

	  /**
	   * Helper function to deduce the name of the provided function.
	   *
	   * @param funtion aFunction
	   *        The function whose name will be returned.
	   * @return string
	   *         Function name.
	   */
	  getFunctionName: function WCF_getFunctionName(aFunction) {
	    let name = null;
	    if (aFunction.name) {
	      name = aFunction.name;
	    } else {
	      let desc;
	      try {
	        desc = aFunction.getOwnPropertyDescriptor("displayName");
	      } catch (ex) {}
	      if (desc && typeof desc.value == "string") {
	        name = desc.value;
	      }
	    }
	    if (!name) {
	      try {
	        let str = (aFunction.toString() || aFunction.toSource()) + "";
	        name = (str.match(REGEX_MATCH_FUNCTION_NAME) || [])[1];
	      } catch (ex) {}
	    }
	    return name;
	  },

	  /**
	   * Get the object class name. For example, the |window| object has the Window
	   * class name (based on [object Window]).
	   *
	   * @param object aObject
	   *        The object you want to get the class name for.
	   * @return string
	   *         The object class name.
	   */
	  getObjectClassName: function WCU_getObjectClassName(aObject) {
	    if (aObject === null) {
	      return "null";
	    }
	    if (aObject === undefined) {
	      return "undefined";
	    }

	    let type = typeof aObject;
	    if (type != "object") {
	      // Grip class names should start with an uppercase letter.
	      return type.charAt(0).toUpperCase() + type.substr(1);
	    }

	    let className;

	    try {
	      className = ((aObject + "").match(/^\[object (\S+)\]$/) || [])[1];
	      if (!className) {
	        className = ((aObject.constructor + "").match(/^\[object (\S+)\]$/) || [])[1];
	      }
	      if (!className && typeof aObject.constructor == "function") {
	        className = this.getFunctionName(aObject.constructor);
	      }
	    } catch (ex) {}

	    return className;
	  },

	  /**
	   * Check if the given value is a grip with an actor.
	   *
	   * @param mixed aGrip
	   *        Value you want to check if it is a grip with an actor.
	   * @return boolean
	   *         True if the given value is a grip with an actor.
	   */
	  isActorGrip: function WCU_isActorGrip(aGrip) {
	    return aGrip && typeof aGrip == "object" && aGrip.actor;
	  },
	  /**
	   * Value of devtools.selfxss.count preference
	   *
	   * @type number
	   * @private
	   */
	  _usageCount: 0,
	  get usageCount() {
	    if (WebConsoleUtils._usageCount < CONSOLE_ENTRY_THRESHOLD) {
	      WebConsoleUtils._usageCount = Services.prefs.getIntPref("devtools.selfxss.count");
	      if (Services.prefs.getBoolPref("devtools.chrome.enabled")) {
	        WebConsoleUtils.usageCount = CONSOLE_ENTRY_THRESHOLD;
	      }
	    }
	    return WebConsoleUtils._usageCount;
	  },
	  set usageCount(newUC) {
	    if (newUC <= CONSOLE_ENTRY_THRESHOLD) {
	      WebConsoleUtils._usageCount = newUC;
	      Services.prefs.setIntPref("devtools.selfxss.count", newUC);
	    }
	  },
	  /**
	   * The inputNode "paste" event handler generator. Helps prevent self-xss attacks
	   *
	   * @param nsIDOMElement inputField
	   * @param nsIDOMElement notificationBox
	   * @returns A function to be added as a handler to 'paste' and 'drop' events on the input field
	   */
	  pasteHandlerGen: function WCU_pasteHandlerGen(inputField, notificationBox, msg, okstring) {
	    let handler = function WCU_pasteHandler(aEvent) {
	      if (WebConsoleUtils.usageCount >= CONSOLE_ENTRY_THRESHOLD) {
	        inputField.removeEventListener("paste", handler);
	        inputField.removeEventListener("drop", handler);
	        return true;
	      }
	      if (notificationBox.getNotificationWithValue("selfxss-notification")) {
	        aEvent.preventDefault();
	        aEvent.stopPropagation();
	        return false;
	      }

	      let notification = notificationBox.appendNotification(msg, "selfxss-notification", null, notificationBox.PRIORITY_WARNING_HIGH, null, function (eventType) {
	        // Cleanup function if notification is dismissed
	        if (eventType == "removed") {
	          inputField.removeEventListener("keyup", pasteKeyUpHandler);
	        }
	      });

	      function pasteKeyUpHandler(aEvent2) {
	        let value = inputField.value || inputField.textContent;
	        if (value.includes(okstring)) {
	          notificationBox.removeNotification(notification);
	          inputField.removeEventListener("keyup", pasteKeyUpHandler);
	          WebConsoleUtils.usageCount = CONSOLE_ENTRY_THRESHOLD;
	        }
	      }
	      inputField.addEventListener("keyup", pasteKeyUpHandler);

	      aEvent.preventDefault();
	      aEvent.stopPropagation();
	      return false;
	    };
	    return handler;
	  }

	};

	exports.Utils = WebConsoleUtils;

	//////////////////////////////////////////////////////////////////////////
	// Localization
	//////////////////////////////////////////////////////////////////////////

	WebConsoleUtils.l10n = function WCU_l10n(aBundleURI) {
	  this._bundleUri = aBundleURI;
	};

	WebConsoleUtils.l10n.prototype = {
	  _stringBundle: null,

	  get stringBundle() {
	    if (!this._stringBundle) {
	      this._stringBundle = Services.strings.createBundle(this._bundleUri);
	    }
	    return this._stringBundle;
	  },

	  /**
	   * Generates a formatted timestamp string for displaying in console messages.
	   *
	   * @param integer [aMilliseconds]
	   *        Optional, allows you to specify the timestamp in milliseconds since
	   *        the UNIX epoch.
	   * @return string
	   *         The timestamp formatted for display.
	   */
	  timestampString: function WCU_l10n_timestampString(aMilliseconds) {
	    let d = new Date(aMilliseconds ? aMilliseconds : null);
	    let hours = d.getHours(),
	        minutes = d.getMinutes();
	    let seconds = d.getSeconds(),
	        milliseconds = d.getMilliseconds();
	    let parameters = [hours, minutes, seconds, milliseconds];
	    return this.getFormatStr("timestampFormat", parameters);
	  },

	  /**
	   * Retrieve a localized string.
	   *
	   * @param string aName
	   *        The string name you want from the Web Console string bundle.
	   * @return string
	   *         The localized string.
	   */
	  getStr: function WCU_l10n_getStr(aName) {
	    let result;
	    try {
	      result = this.stringBundle.GetStringFromName(aName);
	    } catch (ex) {
	      Cu.reportError("Failed to get string: " + aName);
	      throw ex;
	    }
	    return result;
	  },

	  /**
	   * Retrieve a localized string formatted with values coming from the given
	   * array.
	   *
	   * @param string aName
	   *        The string name you want from the Web Console string bundle.
	   * @param array aArray
	   *        The array of values you want in the formatted string.
	   * @return string
	   *         The formatted local string.
	   */
	  getFormatStr: function WCU_l10n_getFormatStr(aName, aArray) {
	    let result;
	    try {
	      result = this.stringBundle.formatStringFromName(aName, aArray, aArray.length);
	    } catch (ex) {
	      Cu.reportError("Failed to format string: " + aName);
	      throw ex;
	    }
	    return result;
	  }
	};

	///////////////////////////////////////////////////////////////////////////////
	// The page errors listener
	///////////////////////////////////////////////////////////////////////////////

	/**
	 * The nsIConsoleService listener. This is used to send all of the console
	 * messages (JavaScript, CSS and more) to the remote Web Console instance.
	 *
	 * @constructor
	 * @param nsIDOMWindow [aWindow]
	 *        Optional - the window object for which we are created. This is used
	 *        for filtering out messages that belong to other windows.
	 * @param object aListener
	 *        The listener object must have one method:
	 *        - onConsoleServiceMessage(). This method is invoked with one argument,
	 *        the nsIConsoleMessage, whenever a relevant message is received.
	 */
	function ConsoleServiceListener(aWindow, aListener) {
	  this.window = aWindow;
	  this.listener = aListener;
	}
	exports.ConsoleServiceListener = ConsoleServiceListener;

	ConsoleServiceListener.prototype = {
	  QueryInterface: XPCOMUtils.generateQI([Ci.nsIConsoleListener]),

	  /**
	   * The content window for which we listen to page errors.
	   * @type nsIDOMWindow
	   */
	  window: null,

	  /**
	   * The listener object which is notified of messages from the console service.
	   * @type object
	   */
	  listener: null,

	  /**
	   * Initialize the nsIConsoleService listener.
	   */
	  init: function CSL_init() {
	    Services.console.registerListener(this);
	  },

	  /**
	   * The nsIConsoleService observer. This method takes all the script error
	   * messages belonging to the current window and sends them to the remote Web
	   * Console instance.
	   *
	   * @param nsIConsoleMessage aMessage
	   *        The message object coming from the nsIConsoleService.
	   */
	  observe: function CSL_observe(aMessage) {
	    if (!this.listener) {
	      return;
	    }

	    if (this.window) {
	      if (!(aMessage instanceof Ci.nsIScriptError) || !aMessage.outerWindowID || !this.isCategoryAllowed(aMessage.category)) {
	        return;
	      }

	      let errorWindow = Services.wm.getOuterWindowWithId(aMessage.outerWindowID);
	      if (!errorWindow || !isWindowIncluded(this.window, errorWindow)) {
	        return;
	      }
	    }

	    this.listener.onConsoleServiceMessage(aMessage);
	  },

	  /**
	   * Check if the given message category is allowed to be tracked or not.
	   * We ignore chrome-originating errors as we only care about content.
	   *
	   * @param string aCategory
	   *        The message category you want to check.
	   * @return boolean
	   *         True if the category is allowed to be logged, false otherwise.
	   */
	  isCategoryAllowed: function CSL_isCategoryAllowed(aCategory) {
	    if (!aCategory) {
	      return false;
	    }

	    switch (aCategory) {
	      case "XPConnect JavaScript":
	      case "component javascript":
	      case "chrome javascript":
	      case "chrome registration":
	      case "XBL":
	      case "XBL Prototype Handler":
	      case "XBL Content Sink":
	      case "xbl javascript":
	        return false;
	    }

	    return true;
	  },

	  /**
	   * Get the cached page errors for the current inner window and its (i)frames.
	   *
	   * @param boolean [aIncludePrivate=false]
	   *        Tells if you want to also retrieve messages coming from private
	   *        windows. Defaults to false.
	   * @return array
	   *         The array of cached messages. Each element is an nsIScriptError or
	   *         an nsIConsoleMessage
	   */
	  getCachedMessages: function CSL_getCachedMessages(aIncludePrivate = false) {
	    var _this = this;

	    let errors = Services.console.getMessageArray() || [];

	    // if !this.window, we're in a browser console. Still need to filter
	    // private messages.
	    if (!this.window) {
	      return errors.filter(function (aError) {
	        if (aError instanceof Ci.nsIScriptError) {
	          if (!aIncludePrivate && aError.isFromPrivateWindow) {
	            return false;
	          }
	        }

	        return true;
	      });
	    }

	    let ids = WebConsoleUtils.getInnerWindowIDsForFrames(this.window);

	    return errors.filter(function (aError) {
	      if (aError instanceof Ci.nsIScriptError) {
	        if (!aIncludePrivate && aError.isFromPrivateWindow) {
	          return false;
	        }
	        if (ids && (ids.indexOf(aError.innerWindowID) == -1 || !_this.isCategoryAllowed(aError.category))) {
	          return false;
	        }
	      } else if (ids && ids[0]) {
	        // If this is not an nsIScriptError and we need to do window-based
	        // filtering we skip this message.
	        return false;
	      }

	      return true;
	    });
	  },

	  /**
	   * Remove the nsIConsoleService listener.
	   */
	  destroy: function CSL_destroy() {
	    Services.console.unregisterListener(this);
	    this.listener = this.window = null;
	  }
	};

	///////////////////////////////////////////////////////////////////////////////
	// The window.console API observer
	///////////////////////////////////////////////////////////////////////////////

	/**
	 * The window.console API observer. This allows the window.console API messages
	 * to be sent to the remote Web Console instance.
	 *
	 * @constructor
	 * @param nsIDOMWindow aWindow
	 *        Optional - the window object for which we are created. This is used
	 *        for filtering out messages that belong to other windows.
	 * @param object aOwner
	 *        The owner object must have the following methods:
	 *        - onConsoleAPICall(). This method is invoked with one argument, the
	 *        Console API message that comes from the observer service, whenever
	 *        a relevant console API call is received.
	 * @param string aConsoleID
	 *        Options - The consoleID that this listener should listen to
	 */
	function ConsoleAPIListener(aWindow, aOwner, aConsoleID) {
	  this.window = aWindow;
	  this.owner = aOwner;
	  this.consoleID = aConsoleID;
	}
	exports.ConsoleAPIListener = ConsoleAPIListener;

	ConsoleAPIListener.prototype = {
	  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),

	  /**
	   * The content window for which we listen to window.console API calls.
	   * @type nsIDOMWindow
	   */
	  window: null,

	  /**
	   * The owner object which is notified of window.console API calls. It must
	   * have a onConsoleAPICall method which is invoked with one argument: the
	   * console API call object that comes from the observer service.
	   *
	   * @type object
	   * @see WebConsoleActor
	   */
	  owner: null,

	  /**
	   * The consoleID that we listen for. If not null then only messages from this
	   * console will be returned.
	   */
	  consoleID: null,

	  /**
	   * Initialize the window.console API observer.
	   */
	  init: function CAL_init() {
	    // Note that the observer is process-wide. We will filter the messages as
	    // needed, see CAL_observe().
	    Services.obs.addObserver(this, "console-api-log-event", false);
	  },

	  /**
	   * The console API message observer. When messages are received from the
	   * observer service we forward them to the remote Web Console instance.
	   *
	   * @param object aMessage
	   *        The message object receives from the observer service.
	   * @param string aTopic
	   *        The message topic received from the observer service.
	   */
	  observe: function CAL_observe(aMessage, aTopic) {
	    if (!this.owner) {
	      return;
	    }

	    // Here, wrappedJSObject is not a security wrapper but a property defined
	    // by the XPCOM component which allows us to unwrap the XPCOM interface and
	    // access the underlying JSObject.
	    let apiMessage = aMessage.wrappedJSObject;

	    if (!this.isMessageRelevant(apiMessage)) {
	      return;
	    }

	    this.owner.onConsoleAPICall(apiMessage);
	  },

	  /**
	   * Given a message, return true if this window should show it and false
	   * if it should be ignored.
	   *
	   * @param message
	   *        The message from the Storage Service
	   * @return bool
	   *         Do we care about this message?
	   */
	  isMessageRelevant: function (message) {
	    let workerType = WebConsoleUtils.getWorkerType(message);

	    if (this.window && workerType === "ServiceWorker") {
	      // For messages from Service Workers, message.ID is the
	      // scope, which can be used to determine whether it's controlling
	      // a window.
	      let scope = message.ID;

	      if (!swm.shouldReportToWindow(this.window, scope)) {
	        return false;
	      }
	    }

	    if (this.window && !workerType) {
	      let msgWindow = Services.wm.getCurrentInnerWindowWithId(message.innerID);
	      if (!msgWindow || !isWindowIncluded(this.window, msgWindow)) {
	        // Not the same window!
	        return false;
	      }
	    }

	    if (this.consoleID && message.consoleID !== this.consoleID) {
	      return false;
	    }

	    return true;
	  },

	  /**
	   * Get the cached messages for the current inner window and its (i)frames.
	   *
	   * @param boolean [aIncludePrivate=false]
	   *        Tells if you want to also retrieve messages coming from private
	   *        windows. Defaults to false.
	   * @return array
	   *         The array of cached messages.
	   */
	  getCachedMessages: function CAL_getCachedMessages(aIncludePrivate = false) {
	    var _this2 = this;

	    let messages = [];
	    let ConsoleAPIStorage = Cc("@mozilla.org/consoleAPI-storage;1").getService(Ci.nsIConsoleAPIStorage);

	    // if !this.window, we're in a browser console. Retrieve all events
	    // for filtering based on privacy.
	    if (!this.window) {
	      messages = ConsoleAPIStorage.getEvents();
	    } else {
	      let ids = WebConsoleUtils.getInnerWindowIDsForFrames(this.window);
	      ids.forEach(function (id) {
	        messages = messages.concat(ConsoleAPIStorage.getEvents(id));
	      });
	    }

	    CONSOLE_WORKER_IDS.forEach(function (id) {
	      messages = messages.concat(ConsoleAPIStorage.getEvents(id));
	    });

	    messages = messages.filter(function (msg) {
	      return _this2.isMessageRelevant(msg);
	    });

	    if (aIncludePrivate) {
	      return messages;
	    }

	    return messages.filter(function (m) {
	      return !m.private;
	    });
	  },

	  /**
	   * Destroy the console API listener.
	   */
	  destroy: function CAL_destroy() {
	    Services.obs.removeObserver(this, "console-api-log-event");
	    this.window = this.owner = null;
	  }
	};

	/**
	 * WebConsole commands manager.
	 *
	 * Defines a set of functions /variables ("commands") that are available from
	 * the Web Console but not from the web page.
	 *
	 */
	var WebConsoleCommands = {
	  _registeredCommands: new Map(),
	  _originalCommands: new Map(),

	  /**
	   * @private
	   * Reserved for built-in commands. To register a command from the code of an
	   * add-on, see WebConsoleCommands.register instead.
	   *
	   * @see WebConsoleCommands.register
	   */
	  _registerOriginal: function (name, command) {
	    this.register(name, command);
	    this._originalCommands.set(name, this.getCommand(name));
	  },

	  /**
	   * Register a new command.
	   * @param {string} name The command name (exemple: "$")
	   * @param {(function|object)} command The command to register.
	   *  It can be a function so the command is a function (like "$()"),
	   *  or it can also be a property descriptor to describe a getter / value (like
	   *  "$0").
	   *
	   *  The command function or the command getter are passed a owner object as
	   *  their first parameter (see the example below).
	   *
	   *  Note that setters don't work currently and "enumerable" and "configurable"
	   *  are forced to true.
	   *
	   * @example
	   *
	   *   WebConsoleCommands.register("$", function JSTH_$(aOwner, aSelector)
	   *   {
	   *     return aOwner.window.document.querySelector(aSelector);
	   *   });
	   *
	   *   WebConsoleCommands.register("$0", {
	   *     get: function(aOwner) {
	   *       return aOwner.makeDebuggeeValue(aOwner.selectedNode);
	   *     }
	   *   });
	   */
	  register: function (name, command) {
	    this._registeredCommands.set(name, command);
	  },

	  /**
	   * Unregister a command.
	   *
	   * If the command being unregister overrode a built-in command,
	   * the latter is restored.
	   *
	   * @param {string} name The name of the command
	   */
	  unregister: function (name) {
	    this._registeredCommands.delete(name);
	    if (this._originalCommands.has(name)) {
	      this.register(name, this._originalCommands.get(name));
	    }
	  },

	  /**
	   * Returns a command by its name.
	   *
	   * @param {string} name The name of the command.
	   *
	   * @return {(function|object)} The command.
	   */
	  getCommand: function (name) {
	    return this._registeredCommands.get(name);
	  },

	  /**
	   * Returns true if a command is registered with the given name.
	   *
	   * @param {string} name The name of the command.
	   *
	   * @return {boolean} True if the command is registered.
	   */
	  hasCommand: function (name) {
	    return this._registeredCommands.has(name);
	  }
	};

	exports.WebConsoleCommands = WebConsoleCommands;

	/*
	 * Built-in commands.
	  *
	  * A list of helper functions used by Firebug can be found here:
	  *   http://getfirebug.com/wiki/index.php/Command_Line_API
	 */

	/**
	 * Find a node by ID.
	 *
	 * @param string aId
	 *        The ID of the element you want.
	 * @return nsIDOMNode or null
	 *         The result of calling document.querySelector(aSelector).
	 */
	WebConsoleCommands._registerOriginal("$", function JSTH_$(aOwner, aSelector) {
	  return aOwner.window.document.querySelector(aSelector);
	});

	/**
	 * Find the nodes matching a CSS selector.
	 *
	 * @param string aSelector
	 *        A string that is passed to window.document.querySelectorAll.
	 * @return nsIDOMNodeList
	 *         Returns the result of document.querySelectorAll(aSelector).
	 */
	WebConsoleCommands._registerOriginal("$$", function JSTH_$$(aOwner, aSelector) {
	  let nodes = aOwner.window.document.querySelectorAll(aSelector);

	  // Calling aOwner.window.Array.from() doesn't work without accessing the
	  // wrappedJSObject, so just loop through the results instead.
	  let result = new aOwner.window.Array();
	  for (let i = 0; i < nodes.length; i++) {
	    result.push(nodes[i]);
	  }
	  return result;
	});

	/**
	 * Returns the result of the last console input evaluation
	 *
	 * @return object|undefined
	 * Returns last console evaluation or undefined
	 */
	WebConsoleCommands._registerOriginal("$_", {
	  get: function (aOwner) {
	    return aOwner.consoleActor.getLastConsoleInputEvaluation();
	  }
	});

	/**
	 * Runs an xPath query and returns all matched nodes.
	 *
	 * @param string aXPath
	 *        xPath search query to execute.
	 * @param [optional] nsIDOMNode aContext
	 *        Context to run the xPath query on. Uses window.document if not set.
	 * @return array of nsIDOMNode
	 */
	WebConsoleCommands._registerOriginal("$x", function JSTH_$x(aOwner, aXPath, aContext) {
	  let nodes = new aOwner.window.Array();

	  // Not waiving Xrays, since we want the original Document.evaluate function,
	  // instead of anything that's been redefined.
	  let doc = aOwner.window.document;
	  aContext = aContext || doc;

	  let results = doc.evaluate(aXPath, aContext, null, Ci.nsIDOMXPathResult.ANY_TYPE, null);
	  let node;
	  while (node = results.iterateNext()) {
	    nodes.push(node);
	  }

	  return nodes;
	});

	/**
	 * Returns the currently selected object in the highlighter.
	 *
	 * @return Object representing the current selection in the
	 *         Inspector, or null if no selection exists.
	 */
	WebConsoleCommands._registerOriginal("$0", {
	  get: function (aOwner) {
	    return aOwner.makeDebuggeeValue(aOwner.selectedNode);
	  }
	});

	/**
	 * Clears the output of the WebConsole.
	 */
	WebConsoleCommands._registerOriginal("clear", function JSTH_clear(aOwner) {
	  aOwner.helperResult = {
	    type: "clearOutput"
	  };
	});

	/**
	 * Clears the input history of the WebConsole.
	 */
	WebConsoleCommands._registerOriginal("clearHistory", function JSTH_clearHistory(aOwner) {
	  aOwner.helperResult = {
	    type: "clearHistory"
	  };
	});

	/**
	 * Returns the result of Object.keys(aObject).
	 *
	 * @param object aObject
	 *        Object to return the property names from.
	 * @return array of strings
	 */
	WebConsoleCommands._registerOriginal("keys", function JSTH_keys(aOwner, aObject) {
	  // Need to waive Xrays so we can iterate functions and accessor properties
	  return Cu.cloneInto(Object.keys(Cu.waiveXrays(aObject)), aOwner.window);
	});

	/**
	 * Returns the values of all properties on aObject.
	 *
	 * @param object aObject
	 *        Object to display the values from.
	 * @return array of string
	 */
	WebConsoleCommands._registerOriginal("values", function JSTH_values(aOwner, aObject) {
	  let values = [];
	  // Need to waive Xrays so we can iterate functions and accessor properties
	  let waived = Cu.waiveXrays(aObject);
	  let names = Object.getOwnPropertyNames(waived);

	  for (let name of names) {
	    values.push(waived[name]);
	  }

	  return Cu.cloneInto(values, aOwner.window);
	});

	/**
	 * Opens a help window in MDN.
	 */
	WebConsoleCommands._registerOriginal("help", function JSTH_help(aOwner) {
	  aOwner.helperResult = { type: "help" };
	});

	/**
	 * Change the JS evaluation scope.
	 *
	 * @param DOMElement|string|window aWindow
	 *        The window object to use for eval scope. This can be a string that
	 *        is used to perform document.querySelector(), to find the iframe that
	 *        you want to cd() to. A DOMElement can be given as well, the
	 *        .contentWindow property is used. Lastly, you can directly pass
	 *        a window object. If you call cd() with no arguments, the current
	 *        eval scope is cleared back to its default (the top window).
	 */
	WebConsoleCommands._registerOriginal("cd", function JSTH_cd(aOwner, aWindow) {
	  if (!aWindow) {
	    aOwner.consoleActor.evalWindow = null;
	    aOwner.helperResult = { type: "cd" };
	    return;
	  }

	  if (typeof aWindow == "string") {
	    aWindow = aOwner.window.document.querySelector(aWindow);
	  }
	  if (aWindow instanceof Ci.nsIDOMElement && aWindow.contentWindow) {
	    aWindow = aWindow.contentWindow;
	  }
	  if (!(aWindow instanceof Ci.nsIDOMWindow)) {
	    aOwner.helperResult = { type: "error", message: "cdFunctionInvalidArgument" };
	    return;
	  }

	  aOwner.consoleActor.evalWindow = aWindow;
	  aOwner.helperResult = { type: "cd" };
	});

	/**
	 * Inspects the passed aObject. This is done by opening the PropertyPanel.
	 *
	 * @param object aObject
	 *        Object to inspect.
	 */
	WebConsoleCommands._registerOriginal("inspect", function JSTH_inspect(aOwner, aObject) {
	  let dbgObj = aOwner.makeDebuggeeValue(aObject);
	  let grip = aOwner.createValueGrip(dbgObj);
	  aOwner.helperResult = {
	    type: "inspectObject",
	    input: aOwner.evalInput,
	    object: grip
	  };
	});

	/**
	 * Prints aObject to the output.
	 *
	 * @param object aObject
	 *        Object to print to the output.
	 * @return string
	 */
	WebConsoleCommands._registerOriginal("pprint", function JSTH_pprint(aOwner, aObject) {
	  if (aObject === null || aObject === undefined || aObject === true || aObject === false) {
	    aOwner.helperResult = {
	      type: "error",
	      message: "helperFuncUnsupportedTypeError"
	    };
	    return null;
	  }

	  aOwner.helperResult = { rawOutput: true };

	  if (typeof aObject == "function") {
	    return aObject + "\n";
	  }

	  let output = [];

	  let obj = aObject;
	  for (let name in obj) {
	    let desc = WebConsoleUtils.getPropertyDescriptor(obj, name) || {};
	    if (desc.get || desc.set) {
	      // TODO: Bug 842672 - toolkit/ imports modules from browser/.
	      let getGrip = VariablesView.getGrip(desc.get);
	      let setGrip = VariablesView.getGrip(desc.set);
	      let getString = VariablesView.getString(getGrip);
	      let setString = VariablesView.getString(setGrip);
	      output.push(name + ":", "  get: " + getString, "  set: " + setString);
	    } else {
	      let valueGrip = VariablesView.getGrip(obj[name]);
	      let valueString = VariablesView.getString(valueGrip);
	      output.push(name + ": " + valueString);
	    }
	  }

	  return "  " + output.join("\n  ");
	});

	/**
	 * Print the String representation of a value to the output, as-is.
	 *
	 * @param any aValue
	 *        A value you want to output as a string.
	 * @return void
	 */
	WebConsoleCommands._registerOriginal("print", function JSTH_print(aOwner, aValue) {
	  aOwner.helperResult = { rawOutput: true };
	  if (typeof aValue === "symbol") {
	    return Symbol.prototype.toString.call(aValue);
	  }
	  // Waiving Xrays here allows us to see a closer representation of the
	  // underlying object. This may execute arbitrary content code, but that
	  // code will run with content privileges, and the result will be rendered
	  // inert by coercing it to a String.
	  return String(Cu.waiveXrays(aValue));
	});

	/**
	 * Copy the String representation of a value to the clipboard.
	 *
	 * @param any aValue
	 *        A value you want to copy as a string.
	 * @return void
	 */
	WebConsoleCommands._registerOriginal("copy", function JSTH_copy(aOwner, aValue) {
	  let payload;
	  try {
	    if (aValue instanceof Ci.nsIDOMElement) {
	      payload = aValue.outerHTML;
	    } else if (typeof aValue == "string") {
	      payload = aValue;
	    } else {
	      payload = JSON.stringify(aValue, null, "  ");
	    }
	  } catch (ex) {
	    payload = "/* " + ex + " */";
	  }
	  aOwner.helperResult = {
	    type: "copyValueToClipboard",
	    value: payload
	  };
	});

	/**
	 * (Internal only) Add the bindings to |owner.sandbox|.
	 * This is intended to be used by the WebConsole actor only.
	  *
	  * @param object aOwner
	  *        The owning object.
	  */
	function addWebConsoleCommands(owner) {
	  if (!owner) {
	    throw new Error("The owner is required");
	  }
	  for (let _ref of WebConsoleCommands._registeredCommands) {
	    var _ref2 = _slicedToArray(_ref, 2);

	    let name = _ref2[0];
	    let command = _ref2[1];

	    if (typeof command === "function") {
	      owner.sandbox[name] = command.bind(undefined, owner);
	    } else if (typeof command === "object") {
	      let clone = Object.assign({}, command, {
	        // We force the enumerability and the configurability (so the
	        // WebConsoleActor can reconfigure the property).
	        enumerable: true,
	        configurable: true
	      });

	      if (typeof command.get === "function") {
	        clone.get = command.get.bind(undefined, owner);
	      }
	      if (typeof command.set === "function") {
	        clone.set = command.set.bind(undefined, owner);
	      }

	      Object.defineProperty(owner.sandbox, name, clone);
	    }
	  }
	}

	exports.addWebConsoleCommands = addWebConsoleCommands;

	/**
	 * A ReflowObserver that listens for reflow events from the page.
	 * Implements nsIReflowObserver.
	 *
	 * @constructor
	 * @param object aWindow
	 *        The window for which we need to track reflow.
	 * @param object aOwner
	 *        The listener owner which needs to implement:
	 *        - onReflowActivity(aReflowInfo)
	 */

	function ConsoleReflowListener(aWindow, aListener) {
	  this.docshell = aWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocShell);
	  this.listener = aListener;
	  this.docshell.addWeakReflowObserver(this);
	}

	exports.ConsoleReflowListener = ConsoleReflowListener;

	ConsoleReflowListener.prototype = {
	  QueryInterface: XPCOMUtils.generateQI([Ci.nsIReflowObserver, Ci.nsISupportsWeakReference]),
	  docshell: null,
	  listener: null,

	  /**
	   * Forward reflow event to listener.
	   *
	   * @param DOMHighResTimeStamp aStart
	   * @param DOMHighResTimeStamp aEnd
	   * @param boolean aInterruptible
	   */
	  sendReflow: function CRL_sendReflow(aStart, aEnd, aInterruptible) {
	    let frame = components.stack.caller.caller;

	    let filename = frame ? frame.filename : null;

	    if (filename) {
	      // Because filename could be of the form "xxx.js -> xxx.js -> xxx.js",
	      // we only take the last part.
	      filename = filename.split(" ").pop();
	    }

	    this.listener.onReflowActivity({
	      interruptible: aInterruptible,
	      start: aStart,
	      end: aEnd,
	      sourceURL: filename,
	      sourceLine: frame ? frame.lineNumber : null,
	      functionName: frame ? frame.name : null
	    });
	  },

	  /**
	   * On uninterruptible reflow
	   *
	   * @param DOMHighResTimeStamp aStart
	   * @param DOMHighResTimeStamp aEnd
	   */
	  reflow: function CRL_reflow(aStart, aEnd) {
	    this.sendReflow(aStart, aEnd, false);
	  },

	  /**
	   * On interruptible reflow
	   *
	   * @param DOMHighResTimeStamp aStart
	   * @param DOMHighResTimeStamp aEnd
	   */
	  reflowInterruptible: function CRL_reflowInterruptible(aStart, aEnd) {
	    this.sendReflow(aStart, aEnd, true);
	  },

	  /**
	   * Unregister listener.
	   */
	  destroy: function CRL_destroy() {
	    this.docshell.removeWeakReflowObserver(this);
	    this.listener = this.docshell = null;
	  }
	};

	function gSequenceId() {
	  return gSequenceId.n++;
	}
	gSequenceId.n = 0;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var _this = this;

	var _require = __webpack_require__(1);

	const Ci = _require.Ci;

	var _require2 = __webpack_require__(74);

	const memoize = _require2.memoize;

	var _require3 = __webpack_require__(78);

	const setIgnoreLayoutChanges = _require3.setIgnoreLayoutChanges;

	exports.setIgnoreLayoutChanges = function (...args) {
	  return _this.setIgnoreLayoutChanges(...args);
	};

	/**
	 * Returns the `DOMWindowUtils` for the window given.
	 *
	 * @param {DOMWindow} win
	 * @returns {DOMWindowUtils}
	 */
	const utilsFor = memoize(function (win) {
	  return win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
	});

	/**
	 * like win.top, but goes through mozbrowsers and mozapps iframes.
	 *
	 * @param {DOMWindow} win
	 * @return {DOMWindow}
	 */
	function getTopWindow(win) {
	  let docShell = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocShell);

	  if (!docShell.isBrowserOrApp) {
	    return win.top;
	  }

	  let topDocShell = docShell.getSameTypeRootTreeItemIgnoreBrowserAndAppBoundaries();

	  return topDocShell ? topDocShell.contentViewer.DOMDocument.defaultView : null;
	}

	exports.getTopWindow = getTopWindow;

	/**
	 * Returns `true` is the window given is a top level window.
	 * like win.top === win, but goes through mozbrowsers and mozapps iframes.
	 *
	 * @param {DOMWindow} win
	 * @return {Boolean}
	 */
	const isTopWindow = function (win) {
	  return win && getTopWindow(win) === win;
	};
	exports.isTopWindow = isTopWindow;

	/**
	   * Check a window is part of the boundary window given.
	   *
	   * @param {DOMWindow} boundaryWindow
	   * @param {DOMWindow} win
	   * @return {Boolean}
	   */
	function isWindowIncluded(boundaryWindow, win) {
	  if (win === boundaryWindow) {
	    return true;
	  }

	  let parent = getParentWindow(win);

	  if (!parent || parent === win) {
	    return false;
	  }

	  return isWindowIncluded(boundaryWindow, parent);
	}
	exports.isWindowIncluded = isWindowIncluded;

	/**
	 * like win.parent, but goes through mozbrowsers and mozapps iframes.
	 *
	 * @param {DOMWindow} win
	 * @return {DOMWindow}
	 */
	function getParentWindow(win) {
	  if (isTopWindow(win)) {
	    return null;
	  }

	  let docShell = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocShell);

	  if (!docShell.isBrowserOrApp) {
	    return win.parent;
	  }

	  let parentDocShell = docShell.getSameTypeParentIgnoreBrowserAndAppBoundaries();

	  return parentDocShell ? parentDocShell.contentViewer.DOMDocument.defaultView : null;
	}

	exports.getParentWindow = getParentWindow;

	/**
	 * like win.frameElement, but goes through mozbrowsers and mozapps iframes.
	 *
	 * @param {DOMWindow} win
	 *        The window to get the frame for
	 * @return {DOMNode}
	 *         The element in which the window is embedded.
	 */
	const getFrameElement = function (win) {
	  return isTopWindow(win) ? null : utilsFor(win).containerElement;
	};
	exports.getFrameElement = getFrameElement;

	/**
	 * Get the x/y offsets for of all the parent frames of a given node, limited to
	 * the boundary window given.
	 *
	 * @param {DOMWindow} boundaryWindow
	 *        The window where to stop to iterate. If `null` is given, the top
	 *        window is used.
	 * @param {DOMNode} node
	 *        The node for which we are to get the offset
	 * @return {Array}
	 *         The frame offset [x, y]
	 */
	function getFrameOffsets(boundaryWindow, node) {
	  let xOffset = 0;
	  let yOffset = 0;
	  let frameWin = node.ownerDocument.defaultView;
	  let scale = getCurrentZoom(node);

	  if (boundaryWindow === null) {
	    boundaryWindow = getTopWindow(frameWin);
	  } else if (typeof boundaryWindow === "undefined") {
	    throw new Error("No `boundaryWindow` given. Use `null` for the default one.");
	  }

	  while (frameWin !== boundaryWindow) {

	    let frameElement = getFrameElement(frameWin);
	    if (!frameElement) {
	      break;
	    }

	    // We are in an iframe.
	    // We take into account the parent iframe position and its
	    // offset (borders and padding).
	    let frameRect = frameElement.getBoundingClientRect();

	    var _getIframeContentOffs = getIframeContentOffset(frameElement);

	    var _getIframeContentOffs2 = _slicedToArray(_getIframeContentOffs, 2);

	    let offsetTop = _getIframeContentOffs2[0];
	    let offsetLeft = _getIframeContentOffs2[1];

	    xOffset += frameRect.left + offsetLeft;
	    yOffset += frameRect.top + offsetTop;

	    frameWin = getParentWindow(frameWin);
	  }

	  return [xOffset * scale, yOffset * scale];
	}

	/**
	 * Get box quads adjusted for iframes and zoom level.
	 *
	 * @param {DOMWindow} boundaryWindow
	 *        The window where to stop to iterate. If `null` is given, the top
	 *        window is used.
	 * @param {DOMNode} node
	 *        The node for which we are to get the box model region
	 *        quads.
	 * @param {String} region
	 *        The box model region to return: "content", "padding", "border" or
	 *        "margin".
	 * @return {Array}
	 *        An array of objects that have the same structure as quads returned by
	 *        getBoxQuads. An empty array if the node has no quads or is invalid.
	 */
	function getAdjustedQuads(boundaryWindow, node, region) {
	  if (!node || !node.getBoxQuads) {
	    return [];
	  }

	  let quads = node.getBoxQuads({
	    box: region
	  });

	  if (!quads.length) {
	    return [];
	  }

	  var _getFrameOffsets = getFrameOffsets(boundaryWindow, node);

	  var _getFrameOffsets2 = _slicedToArray(_getFrameOffsets, 2);

	  let xOffset = _getFrameOffsets2[0];
	  let yOffset = _getFrameOffsets2[1];

	  let scale = getCurrentZoom(node);

	  let adjustedQuads = [];
	  for (let quad of quads) {
	    adjustedQuads.push({
	      p1: {
	        w: quad.p1.w * scale,
	        x: quad.p1.x * scale + xOffset,
	        y: quad.p1.y * scale + yOffset,
	        z: quad.p1.z * scale
	      },
	      p2: {
	        w: quad.p2.w * scale,
	        x: quad.p2.x * scale + xOffset,
	        y: quad.p2.y * scale + yOffset,
	        z: quad.p2.z * scale
	      },
	      p3: {
	        w: quad.p3.w * scale,
	        x: quad.p3.x * scale + xOffset,
	        y: quad.p3.y * scale + yOffset,
	        z: quad.p3.z * scale
	      },
	      p4: {
	        w: quad.p4.w * scale,
	        x: quad.p4.x * scale + xOffset,
	        y: quad.p4.y * scale + yOffset,
	        z: quad.p4.z * scale
	      },
	      bounds: {
	        bottom: quad.bounds.bottom * scale + yOffset,
	        height: quad.bounds.height * scale,
	        left: quad.bounds.left * scale + xOffset,
	        right: quad.bounds.right * scale + xOffset,
	        top: quad.bounds.top * scale + yOffset,
	        width: quad.bounds.width * scale,
	        x: quad.bounds.x * scale + xOffset,
	        y: quad.bounds.y * scale + yOffset
	      }
	    });
	  }

	  return adjustedQuads;
	}
	exports.getAdjustedQuads = getAdjustedQuads;

	/**
	 * Compute the absolute position and the dimensions of a node, relativalely
	 * to the root window.

	 * @param {DOMWindow} boundaryWindow
	 *        The window where to stop to iterate. If `null` is given, the top
	 *        window is used.
	 * @param {DOMNode} aNode
	 *        a DOM element to get the bounds for
	 * @param {DOMWindow} aContentWindow
	 *        the content window holding the node
	 * @return {Object}
	 *         A rect object with the {top, left, width, height} properties
	 */
	function getRect(boundaryWindow, aNode, aContentWindow) {
	  let frameWin = aNode.ownerDocument.defaultView;
	  let clientRect = aNode.getBoundingClientRect();

	  if (boundaryWindow === null) {
	    boundaryWindow = getTopWindow(frameWin);
	  } else if (typeof boundaryWindow === "undefined") {
	    throw new Error("No `boundaryWindow` given. Use `null` for the default one.");
	  }

	  // Go up in the tree of frames to determine the correct rectangle.
	  // clientRect is read-only, we need to be able to change properties.
	  let rect = {
	    top: clientRect.top + aContentWindow.pageYOffset,
	    left: clientRect.left + aContentWindow.pageXOffset,
	    width: clientRect.width,
	    height: clientRect.height
	  };

	  // We iterate through all the parent windows.
	  while (frameWin !== boundaryWindow) {
	    let frameElement = getFrameElement(frameWin);
	    if (!frameElement) {
	      break;
	    }

	    // We are in an iframe.
	    // We take into account the parent iframe position and its
	    // offset (borders and padding).
	    let frameRect = frameElement.getBoundingClientRect();

	    var _getIframeContentOffs3 = getIframeContentOffset(frameElement);

	    var _getIframeContentOffs4 = _slicedToArray(_getIframeContentOffs3, 2);

	    let offsetTop = _getIframeContentOffs4[0];
	    let offsetLeft = _getIframeContentOffs4[1];

	    rect.top += frameRect.top + offsetTop;
	    rect.left += frameRect.left + offsetLeft;

	    frameWin = getParentWindow(frameWin);
	  }

	  return rect;
	};
	exports.getRect = getRect;

	/**
	 * Get the 4 bounding points for a node taking iframes into account.
	 * Note that for transformed nodes, this will return the untransformed bound.
	 *
	 * @param {DOMWindow} boundaryWindow
	 *        The window where to stop to iterate. If `null` is given, the top
	 *        window is used.
	 * @param {DOMNode} node
	 * @return {Object}
	 *         An object with p1,p2,p3,p4 properties being {x,y} objects
	 */
	function getNodeBounds(boundaryWindow, node) {
	  if (!node) {
	    return;
	  }

	  let scale = getCurrentZoom(node);

	  // Find out the offset of the node in its current frame
	  let offsetLeft = 0;
	  let offsetTop = 0;
	  let el = node;
	  while (el && el.parentNode) {
	    offsetLeft += el.offsetLeft;
	    offsetTop += el.offsetTop;
	    el = el.offsetParent;
	  }

	  // Also take scrolled containers into account
	  el = node;
	  while (el && el.parentNode) {
	    if (el.scrollTop) {
	      offsetTop -= el.scrollTop;
	    }
	    if (el.scrollLeft) {
	      offsetLeft -= el.scrollLeft;
	    }
	    el = el.parentNode;
	  }

	  // And add the potential frame offset if the node is nested

	  var _getFrameOffsets3 = getFrameOffsets(boundaryWindow, node);

	  var _getFrameOffsets4 = _slicedToArray(_getFrameOffsets3, 2);

	  let xOffset = _getFrameOffsets4[0];
	  let yOffset = _getFrameOffsets4[1];

	  xOffset += offsetLeft;
	  yOffset += offsetTop;

	  xOffset *= scale;
	  yOffset *= scale;

	  // Get the width and height
	  let width = node.offsetWidth * scale;
	  let height = node.offsetHeight * scale;

	  return {
	    p1: { x: xOffset, y: yOffset },
	    p2: { x: xOffset + width, y: yOffset },
	    p3: { x: xOffset + width, y: yOffset + height },
	    p4: { x: xOffset, y: yOffset + height }
	  };
	}
	exports.getNodeBounds = getNodeBounds;

	/**
	 * Returns iframe content offset (iframe border + padding).
	 * Note: this function shouldn't need to exist, had the platform provided a
	 * suitable API for determining the offset between the iframe's content and
	 * its bounding client rect. Bug 626359 should provide us with such an API.
	 *
	 * @param {DOMNode} aIframe
	 *        The iframe.
	 * @return {Array} [offsetTop, offsetLeft]
	 *         offsetTop is the distance from the top of the iframe and the top of
	 *         the content document.
	 *         offsetLeft is the distance from the left of the iframe and the left
	 *         of the content document.
	 */
	function getIframeContentOffset(aIframe) {
	  let style = aIframe.contentWindow.getComputedStyle(aIframe, null);

	  // In some cases, the computed style is null
	  if (!style) {
	    return [0, 0];
	  }

	  let paddingTop = parseInt(style.getPropertyValue("padding-top"));
	  let paddingLeft = parseInt(style.getPropertyValue("padding-left"));

	  let borderTop = parseInt(style.getPropertyValue("border-top-width"));
	  let borderLeft = parseInt(style.getPropertyValue("border-left-width"));

	  return [borderTop + paddingTop, borderLeft + paddingLeft];
	}
	exports.getIframeContentOffset = getIframeContentOffset;

	/**
	 * Find an element from the given coordinates. This method descends through
	 * frames to find the element the user clicked inside frames.
	 *
	 * @param {DOMDocument} aDocument
	 *        The document to look into.
	 * @param {Number} aX
	 * @param {Number} aY
	 * @return {DOMNode}
	 *         the element node found at the given coordinates, or null if no node
	 *         was found
	 */
	function getElementFromPoint(aDocument, aX, aY) {
	  let node = aDocument.elementFromPoint(aX, aY);
	  if (node && node.contentDocument) {
	    if (node instanceof Ci.nsIDOMHTMLIFrameElement) {
	      let rect = node.getBoundingClientRect();

	      // Gap between the iframe and its content window.

	      var _getIframeContentOffs5 = getIframeContentOffset(node);

	      var _getIframeContentOffs6 = _slicedToArray(_getIframeContentOffs5, 2);

	      let offsetTop = _getIframeContentOffs6[0];
	      let offsetLeft = _getIframeContentOffs6[1];

	      aX -= rect.left + offsetLeft;
	      aY -= rect.top + offsetTop;

	      if (aX < 0 || aY < 0) {
	        // Didn't reach the content document, still over the iframe.
	        return node;
	      }
	    }
	    if (node instanceof Ci.nsIDOMHTMLIFrameElement || node instanceof Ci.nsIDOMHTMLFrameElement) {
	      let subnode = getElementFromPoint(node.contentDocument, aX, aY);
	      if (subnode) {
	        node = subnode;
	      }
	    }
	  }
	  return node;
	}
	exports.getElementFromPoint = getElementFromPoint;

	/**
	 * Scroll the document so that the element "elem" appears in the viewport.
	 *
	 * @param {DOMNode} elem
	 *        The element that needs to appear in the viewport.
	 * @param {Boolean} centered
	 *        true if you want it centered, false if you want it to appear on the
	 *        top of the viewport. It is true by default, and that is usually what
	 *        you want.
	 */
	function scrollIntoViewIfNeeded(elem, centered = true) {
	  let win = elem.ownerDocument.defaultView;
	  let clientRect = elem.getBoundingClientRect();

	  // The following are always from the {top, bottom}
	  // of the viewport, to the {top, …} of the box.
	  // Think of them as geometrical vectors, it helps.
	  // The origin is at the top left.

	  let topToBottom = clientRect.bottom;
	  let bottomToTop = clientRect.top - win.innerHeight;
	  let yAllowed = true; // We allow one translation on the y axis.

	  // Whatever `centered` is, the behavior is the same if the box is
	  // (even partially) visible.
	  if ((topToBottom > 0 || !centered) && topToBottom <= elem.offsetHeight) {
	    win.scrollBy(0, topToBottom - elem.offsetHeight);
	    yAllowed = false;
	  } else if ((bottomToTop < 0 || !centered) && bottomToTop >= -elem.offsetHeight) {
	    win.scrollBy(0, bottomToTop + elem.offsetHeight);
	    yAllowed = false;
	  }

	  // If we want it centered, and the box is completely hidden,
	  // then we center it explicitly.
	  if (centered) {
	    if (yAllowed && (topToBottom <= 0 || bottomToTop >= 0)) {
	      win.scroll(win.scrollX, win.scrollY + clientRect.top - (win.innerHeight - elem.offsetHeight) / 2);
	    }
	  }
	}
	exports.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;

	/**
	 * Check if a node and its document are still alive
	 * and attached to the window.
	 *
	 * @param {DOMNode} aNode
	 * @return {Boolean}
	 */
	function isNodeConnected(aNode) {
	  try {
	    let connected = aNode.ownerDocument && aNode.ownerDocument.defaultView && !(aNode.compareDocumentPosition(aNode.ownerDocument.documentElement) & aNode.DOCUMENT_POSITION_DISCONNECTED);
	    return connected;
	  } catch (e) {
	    // "can't access dead object" error
	    return false;
	  }
	}
	exports.isNodeConnected = isNodeConnected;

	/**
	 * Traverse getBindingParent until arriving upon the bound element
	 * responsible for the generation of the specified node.
	 * See https://developer.mozilla.org/en-US/docs/XBL/XBL_1.0_Reference/DOM_Interfaces#getBindingParent.
	 *
	 * @param {DOMNode} node
	 * @return {DOMNode}
	 *         If node is not anonymous, this will return node. Otherwise,
	 *         it will return the bound element
	 *
	 */
	function getRootBindingParent(node) {
	  let parent;
	  let doc = node.ownerDocument;
	  if (!doc) {
	    return node;
	  }
	  while (parent = doc.getBindingParent(node)) {
	    node = parent;
	  }
	  return node;
	}
	exports.getRootBindingParent = getRootBindingParent;

	function getBindingParent(node) {
	  let doc = node.ownerDocument;
	  if (!doc) {
	    return null;
	  }

	  // If there is no binding parent then it is not anonymous.
	  let parent = doc.getBindingParent(node);
	  if (!parent) {
	    return null;
	  }

	  return parent;
	}
	exports.getBindingParent = getBindingParent;

	/**
	 * Determine whether a node is anonymous by determining if there
	 * is a bindingParent.
	 *
	 * @param {DOMNode} node
	 * @return {Boolean}
	 *
	 */
	const isAnonymous = function (node) {
	  return getRootBindingParent(node) !== node;
	};
	exports.isAnonymous = isAnonymous;

	/**
	 * Determine whether a node has a bindingParent.
	 *
	 * @param {DOMNode} node
	 * @return {Boolean}
	 *
	 */
	const hasBindingParent = function (node) {
	  return !!getBindingParent(node);
	};

	/**
	 * Determine whether a node is native anonymous content (as opposed
	 * to XBL anonymous or shadow DOM).
	 * Native anonymous content includes elements like internals to form
	 * controls and ::before/::after.
	 *
	 * @param {DOMNode} node
	 * @return {Boolean}
	 *
	 */
	const isNativeAnonymous = function (node) {
	  return hasBindingParent(node) && !(isXBLAnonymous(node) || isShadowAnonymous(node));
	};

	exports.isNativeAnonymous = isNativeAnonymous;

	/**
	 * Determine whether a node is XBL anonymous content (as opposed
	 * to native anonymous or shadow DOM).
	 * See https://developer.mozilla.org/en-US/docs/XBL/XBL_1.0_Reference/Anonymous_Content.
	 *
	 * @param {DOMNode} node
	 * @return {Boolean}
	 *
	 */
	function isXBLAnonymous(node) {
	  let parent = getBindingParent(node);
	  if (!parent) {
	    return false;
	  }

	  // Shadow nodes also show up in getAnonymousNodes, so return false.
	  if (parent.shadowRoot && parent.shadowRoot.contains(node)) {
	    return false;
	  }

	  let anonNodes = [...(node.ownerDocument.getAnonymousNodes(parent) || [])];
	  return anonNodes.indexOf(node) > -1;
	}
	exports.isXBLAnonymous = isXBLAnonymous;

	/**
	 * Determine whether a node is a child of a shadow root.
	 * See https://w3c.github.io/webcomponents/spec/shadow/
	 *
	 * @param {DOMNode} node
	 * @return {Boolean}
	 */
	function isShadowAnonymous(node) {
	  let parent = getBindingParent(node);
	  if (!parent) {
	    return false;
	  }

	  // If there is a shadowRoot and this is part of it then this
	  // is not native anonymous
	  return parent.shadowRoot && parent.shadowRoot.contains(node);
	}
	exports.isShadowAnonymous = isShadowAnonymous;

	/**
	 * Get the current zoom factor applied to the container window of a given node.
	 * Container windows are used as a weakmap key to store the corresponding
	 * nsIDOMWindowUtils instance to avoid querying it every time.
	 *
	 * @param {DOMNode|DOMWindow}
	 *        The node for which the zoom factor should be calculated, or its
	 *        owner window.
	 * @return {Number}
	 */
	function getCurrentZoom(node) {
	  let win = node instanceof Ci.nsIDOMNode ? node.ownerDocument.defaultView : node instanceof Ci.nsIDOMWindow ? node : null;

	  if (!win) {
	    throw new Error("Unable to get the zoom from the given argument.");
	  }

	  return utilsFor(win).fullZoom;
	}
	exports.getCurrentZoom = getCurrentZoom;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// Disclaimer: Some of the functions in this module implement APIs from
	// Jeremy Ashkenas's http://underscorejs.org/ library and all credits for
	// those goes to him.

	"use strict";

	module.metadata = {
	        "stability": "unstable"
	};

	var _require = __webpack_require__(75);

	const defer = _require.defer;
	const remit = _require.remit;
	const delay = _require.delay;
	const debounce = _require.debounce;
	const throttle = _require.throttle;

	var _require2 = __webpack_require__(77);

	const method = _require2.method;
	const invoke = _require2.invoke;
	const partial = _require2.partial;
	const curry = _require2.curry;
	const compose = _require2.compose;
	const wrap = _require2.wrap;
	const identity = _require2.identity;
	const memoize = _require2.memoize;
	const once = _require2.once;
	const cache = _require2.cache;
	const complement = _require2.complement;
	const constant = _require2.constant;
	const when = _require2.when;
	const apply = _require2.apply;
	const flip = _require2.flip;
	const field = _require2.field;
	const query = _require2.query;
	const isInstance = _require2.isInstance;
	const chainable = _require2.chainable;
	const is = _require2.is;
	const isnt = _require2.isnt;

	exports.defer = defer;
	exports.remit = remit;
	exports.delay = delay;
	exports.debounce = debounce;
	exports.throttle = throttle;

	exports.method = method;
	exports.invoke = invoke;
	exports.partial = partial;
	exports.curry = curry;
	exports.compose = compose;
	exports.wrap = wrap;
	exports.identity = identity;
	exports.memoize = memoize;
	exports.once = once;
	exports.cache = cache;
	exports.complement = complement;
	exports.constant = constant;
	exports.when = when;
	exports.apply = apply;
	exports.flip = flip;
	exports.field = field;
	exports.query = query;
	exports.isInstance = isInstance;
	exports.chainable = chainable;
	exports.is = is;
	exports.isnt = isnt;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module)))

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, setImmediate) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// Disclaimer: Some of the functions in this module implement APIs from
	// Jeremy Ashkenas's http://underscorejs.org/ library and all credits for
	// those goes to him.

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	var _require = __webpack_require__(76);

	const arity = _require.arity;
	const name = _require.name;
	const derive = _require.derive;
	const invoke = _require.invoke;
	//const { setTimeout, clearTimeout, setImmediate } = require("../../timers");

	/**
	 * Takes a function and returns a wrapped one instead, calling which will call
	 * original function in the next turn of event loop. This is basically utility
	 * to do `setImmediate(function() { ... })`, with a difference that returned
	 * function is reused, instead of creating a new one each time. This also allows
	 * to use this functions as event listeners.
	 */

	const defer = function (f) {
	  return derive(function (...args) {
	    setImmediate(invoke, f, args, this);
	  }, f);
	};
	exports.defer = defer;
	// Exporting `remit` alias as `defer` may conflict with promises.
	exports.remit = defer;

	/**
	 * Much like setTimeout, invokes function after wait milliseconds. If you pass
	 * the optional arguments, they will be forwarded on to the function when it is
	 * invoked.
	 */
	const delay = function delay(f, ms, ...args) {
	  var _this = this;

	  setTimeout(function () {
	    return f.apply(_this, args);
	  }, ms);
	};
	exports.delay = delay;

	/**
	 * From underscore's `_.debounce`
	 * http://underscorejs.org
	 * (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Underscore may be freely distributed under the MIT license.
	 */
	const debounce = function debounce(fn, wait) {
	  let timeout, args, context, timestamp, result;

	  let later = function () {
	    let last = Date.now() - timestamp;
	    if (last < wait) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      result = fn.apply(context, args);
	      context = args = null;
	    }
	  };

	  return function (...aArgs) {
	    context = this;
	    args = aArgs;
	    timestamp = Date.now();
	    if (!timeout) {
	      timeout = setTimeout(later, wait);
	    }

	    return result;
	  };
	};
	exports.debounce = debounce;

	/**
	 * From underscore's `_.throttle`
	 * http://underscorejs.org
	 * (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Underscore may be freely distributed under the MIT license.
	 */
	const throttle = function throttle(func, wait, options) {
	  let context, args, result;
	  let timeout = null;
	  let previous = 0;
	  options || (options = {});
	  let later = function () {
	    previous = options.leading === false ? 0 : Date.now();
	    timeout = null;
	    result = func.apply(context, args);
	    context = args = null;
	  };
	  return function () {
	    let now = Date.now();
	    if (!previous && options.leading === false) previous = now;
	    let remaining = wait - (now - previous);
	    context = this;
	    args = arguments;
	    if (remaining <= 0) {
	      clearTimeout(timeout);
	      timeout = null;
	      previous = now;
	      result = func.apply(context, args);
	      context = args = null;
	    } else if (!timeout && options.trailing !== false) {
	      timeout = setTimeout(later, remaining);
	    }
	    return result;
	  };
	};
	exports.throttle = throttle;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module), __webpack_require__(10).setImmediate))

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// Disclaimer: Some of the functions in this module implement APIs from
	// Jeremy Ashkenas's http://underscorejs.org/ library and all credits for
	// those goes to him.

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const arity = function (f) {
	  return f.arity || f.length;
	};
	exports.arity = arity;

	const name = function (f) {
	  return f.displayName || f.name;
	};
	exports.name = name;

	const derive = function (f, source) {
	  f.displayName = name(source);
	  f.arity = arity(source);
	  return f;
	};
	exports.derive = derive;

	const invoke = function (callee, params, self) {
	  return callee.apply(self, params);
	};
	exports.invoke = invoke;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// Disclaimer: Some of the functions in this module implement APIs from
	// Jeremy Ashkenas's http://underscorejs.org/ library and all credits for
	// those goes to him.

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	var _require = __webpack_require__(76);

	const arity = _require.arity;
	const name = _require.name;
	const derive = _require.derive;
	const invoke = _require.invoke;

	/**
	 * Takes variadic numeber of functions and returns composed one.
	 * Returned function pushes `this` pseudo-variable to the head
	 * of the passed arguments and invokes all the functions from
	 * left to right passing same arguments to them. Composite function
	 * returns return value of the right most funciton.
	 */

	const method = function (...lambdas) {
	  return function method(...args) {
	    var _this = this;

	    args.unshift(this);
	    return lambdas.reduce(function (_, lambda) {
	      return lambda.apply(_this, args);
	    }, void 0);
	  };
	};
	exports.method = method;

	/**
	 * Invokes `callee` by passing `params` as an arguments and `self` as `this`
	 * pseudo-variable. Returns value that is returned by a callee.
	 * @param {Function} callee
	 *    Function to invoke.
	 * @param {Array} params
	 *    Arguments to invoke function with.
	 * @param {Object} self
	 *    Object to be passed as a `this` pseudo variable.
	 */
	exports.invoke = invoke;

	/**
	 * Takes a function and bind values to one or more arguments, returning a new
	 * function of smaller arity.
	 *
	 * @param {Function} fn
	 *    The function to partial
	 *
	 * @returns The new function with binded values
	 */
	const partial = function (f, ...curried) {
	  if (typeof f !== "function") throw new TypeError(String(f) + " is not a function");

	  let fn = derive(function (...args) {
	    return f.apply(this, curried.concat(args));
	  }, f);
	  fn.arity = arity(f) - curried.length;
	  return fn;
	};
	exports.partial = partial;

	/**
	 * Returns function with implicit currying, which will continue currying until
	 * expected number of argument is collected. Expected number of arguments is
	 * determined by `fn.length`. Using this with variadic functions is stupid,
	 * so don't do it.
	 *
	 * @examples
	 *
	 * var sum = curry(function(a, b) {
	 *   return a + b
	 * })
	 * console.log(sum(2, 2)) // 4
	 * console.log(sum(2)(4)) // 6
	 */
	const curry = new (function () {
	  const currier = function (fn, arity, params) {
	    // Function either continues to curry arguments or executes function
	    // if desired arguments have being collected.
	    const curried = function (...input) {
	      // Prepend all curried arguments to the given arguments.
	      if (params) input.unshift.apply(input, params);
	      // If expected number of arguments has being collected invoke fn,
	      // othrewise return curried version Otherwise continue curried.
	      return input.length >= arity ? fn.apply(this, input) : currier(fn, arity, input);
	    };
	    curried.arity = arity - (params ? params.length : 0);

	    return curried;
	  };

	  return function (fn) {
	    return currier(fn, arity(fn));
	  };
	})();
	exports.curry = curry;

	/**
	 * Returns the composition of a list of functions, where each function consumes
	 * the return value of the function that follows. In math terms, composing the
	 * functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
	 * @example
	 *
	 *   var greet = function(name) { return "hi: " + name; };
	 *   var exclaim = function(statement) { return statement + "!"; };
	 *   var welcome = compose(exclaim, greet);
	 *
	 *   welcome('moe');    // => 'hi: moe!'
	 */
	function compose(...lambdas) {
	  return function composed(...args) {
	    let index = lambdas.length;
	    while (0 <= --index) args = [lambdas[index].apply(this, args)];

	    return args[0];
	  };
	}
	exports.compose = compose;

	/*
	 * Returns the first function passed as an argument to the second,
	 * allowing you to adjust arguments, run code before and after, and
	 * conditionally execute the original function.
	 * @example
	 *
	 *  var hello = function(name) { return "hello: " + name; };
	 *  hello = wrap(hello, function(f) {
	 *    return "before, " + f("moe") + ", after";
	 *  });
	 *
	 *  hello();    // => 'before, hello: moe, after'
	 */
	const wrap = function (f, wrapper) {
	  return derive(function wrapped(...args) {
	    return wrapper.apply(this, [f].concat(args));
	  }, f);
	};
	exports.wrap = wrap;

	/**
	 * Returns the same value that is used as the argument. In math: f(x) = x
	 */
	const identity = function (value) {
	  return value;
	};
	exports.identity = identity;

	/**
	 * Memoizes a given function by caching the computed result. Useful for
	 * speeding up slow-running computations. If passed an optional hashFunction,
	 * it will be used to compute the hash key for storing the result, based on
	 * the arguments to the original function. The default hashFunction just uses
	 * the first argument to the memoized function as the key.
	 */
	const memoize = function (f, hasher) {
	  let memo = Object.create(null);
	  let cache = new WeakMap();
	  hasher = hasher || identity;
	  return derive(function memoizer(...args) {
	    const key = hasher.apply(this, args);
	    const type = typeof key;
	    if (key && (type === "object" || type === "function")) {
	      if (!cache.has(key)) cache.set(key, f.apply(this, args));
	      return cache.get(key);
	    } else {
	      if (!(key in memo)) memo[key] = f.apply(this, args);
	      return memo[key];
	    }
	  }, f);
	};
	exports.memoize = memoize;

	/*
	 * Creates a version of the function that can only be called one time. Repeated
	 * calls to the modified function will have no effect, returning the value from
	 * the original call. Useful for initialization functions, instead of having to
	 * set a boolean flag and then check it later.
	 */
	const once = function (f) {
	  let ran = false,
	      cache;
	  return derive(function (...args) {
	    return ran ? cache : (ran = true, cache = f.apply(this, args));
	  }, f);
	};
	exports.once = once;
	// export cache as once will may be conflicting with event once a lot.
	exports.cache = once;

	// Takes a `f` function and returns a function that takes the same
	// arguments as `f`, has the same effects, if any, and returns the
	// opposite truth value.
	const complement = function (f) {
	  return derive(function (...args) {
	    return args.length < arity(f) ? complement(partial(f, ...args)) : !f.apply(this, args);
	  }, f);
	};
	exports.complement = complement;

	// Constructs function that returns `x` no matter what is it
	// invoked with.
	const constant = function (x) {
	  return function (_) {
	    return x;
	  };
	};
	exports.constant = constant;

	// Takes `p` predicate, `consequent` function and an optional
	// `alternate` function and composes function that returns
	// application of arguments over `consequent` if application over
	// `p` is `true` otherwise returns application over `alternate`.
	// If `alternate` is not a function returns `undefined`.
	const when = function (p, consequent, alternate) {
	  if (typeof alternate !== "function" && alternate !== void 0) throw TypeError("alternate must be a function");
	  if (typeof consequent !== "function") throw TypeError("consequent must be a function");

	  return function (...args) {
	    return p.apply(this, args) ? consequent.apply(this, args) : alternate && alternate.apply(this, args);
	  };
	};
	exports.when = when;

	// Apply function that behaves as `apply` does in lisp:
	// apply(f, x, [y, z]) => f.apply(f, [x, y, z])
	// apply(f, x) => f.apply(f, [x])
	const apply = function (f, ...rest) {
	  return f.apply(f, rest.concat(rest.pop()));
	};
	exports.apply = apply;

	// Returns function identical to given `f` but with flipped order
	// of arguments.
	const flip = function (f) {
	  return derive(function (...args) {
	    return f.apply(this, args.reverse());
	  }, f);
	};
	exports.flip = flip;

	// Takes field `name` and `target` and returns value of that field.
	// If `target` is `null` or `undefined` it would be returned back
	// instead of attempt to access it's field. Function is implicitly
	// curried, this allows accessor function generation by calling it
	// with only `name` argument.
	const field = curry(function (name, target) {
	  return(
	    // Note: Permisive `==` is intentional.
	    target == null ? target : target[name]
	  );
	});
	exports.field = field;

	// Takes `.` delimited string representing `path` to a nested field
	// and a `target` to get it from. For convinience function is
	// implicitly curried, there for accessors can be created by invoking
	// it with just a `path` argument.
	const query = curry(function (path, target) {
	  const names = path.split(".");
	  const count = names.length;
	  let index = 0;
	  let result = target;
	  // Note: Permisive `!=` is intentional.
	  while (result != null && index < count) {
	    result = result[names[index]];
	    index = index + 1;
	  }
	  return result;
	});
	exports.query = query;

	// Takes `Type` (constructor function) and a `value` and returns
	// `true` if `value` is instance of the given `Type`. Function is
	// implicitly curried this allows predicate generation by calling
	// function with just first argument.
	const isInstance = curry(function (Type, value) {
	  return value instanceof Type;
	});
	exports.isInstance = isInstance;

	/*
	 * Takes a funtion and returns a wrapped function that returns `this`
	 */
	const chainable = function (f) {
	  return derive(function (...args) {
	    f.apply(this, args);
	    return this;
	  }, f);
	};
	exports.chainable = chainable;

	// Functions takes `expected` and `actual` values and returns `true` if
	// `expected === actual`. Returns curried function if called with less then
	// two arguments.
	//
	// [ 1, 0, 1, 0, 1 ].map(is(1)) // => [ true, false, true, false, true ]
	const is = curry(function (expected, actual) {
	  return actual === expected;
	});
	exports.is = is;

	const isnt = complement(is);
	exports.isnt = isnt;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module)))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict"

	/**
	 * About the types of objects in this file:
	 *
	 * - ReflowActor: the actor class used for protocol purposes.
	 *   Mostly empty, just gets an instance of LayoutChangesObserver and forwards
	 *   its "reflows" events to clients.
	 *
	 * - Observable: A utility parent class, meant at being extended by classes that
	 *   need a start/stop behavior.
	 *
	 * - LayoutChangesObserver: extends Observable and uses the ReflowObserver, to
	 *   track reflows on the page.
	 *   Used by the LayoutActor, but is also exported on the module, so can be used
	 *   by any other actor that needs it.
	 *
	 * - Dedicated observers: There's only one of them for now: ReflowObserver which
	 *   listens to reflow events via the docshell,
	 *   These dedicated classes are used by the LayoutChangesObserver.
	 */

	;

	var _require = __webpack_require__(1);

	const Ci = _require.Ci;
	const Cu = _require.Cu;

	var _require2 = __webpack_require__(15);

	const XPCOMUtils = _require2.XPCOMUtils;

	const protocol = __webpack_require__(79);
	const method = protocol.method;
	const Arg = protocol.Arg;
	const RetVal = protocol.RetVal;
	const types = protocol.types;

	const events = __webpack_require__(25);
	const Heritage = __webpack_require__(64);
	/*const {setTimeout, clearTimeout} = require("sdk/timers");*/
	const EventEmitter = __webpack_require__(7);

	/**
	 * The reflow actor tracks reflows and emits events about them.
	 */
	var ReflowActor = exports.ReflowActor = protocol.ActorClass({
	  typeName: "reflow",

	  events: {
	    /**
	     * The reflows event is emitted when reflows have been detected. The event
	     * is sent with an array of reflows that occured. Each item has the
	     * following properties:
	     * - start {Number}
	     * - end {Number}
	     * - isInterruptible {Boolean}
	     */
	    "reflows": {
	      type: "reflows",
	      reflows: Arg(0, "array:json")
	    }
	  },

	  initialize: function (conn, tabActor) {
	    protocol.Actor.prototype.initialize.call(this, conn);

	    this.tabActor = tabActor;
	    this._onReflow = this._onReflow.bind(this);
	    this.observer = getLayoutChangesObserver(tabActor);
	    this._isStarted = false;
	  },

	  /**
	   * The reflow actor is the first (and last) in its hierarchy to use protocol.js
	   * so it doesn't have a parent protocol actor that takes care of its lifetime.
	   * So it needs a disconnect method to cleanup.
	   */
	  disconnect: function () {
	    this.destroy();
	  },

	  destroy: function () {
	    this.stop();
	    releaseLayoutChangesObserver(this.tabActor);
	    this.observer = null;
	    this.tabActor = null;

	    protocol.Actor.prototype.destroy.call(this);
	  },

	  /**
	   * Start tracking reflows and sending events to clients about them.
	   * This is a oneway method, do not expect a response and it won't return a
	   * promise.
	   */
	  start: method(function () {
	    if (!this._isStarted) {
	      this.observer.on("reflows", this._onReflow);
	      this._isStarted = true;
	    }
	  }, { oneway: true }),

	  /**
	   * Stop tracking reflows and sending events to clients about them.
	   * This is a oneway method, do not expect a response and it won't return a
	   * promise.
	   */
	  stop: method(function () {
	    if (this._isStarted) {
	      this.observer.off("reflows", this._onReflow);
	      this._isStarted = false;
	    }
	  }, { oneway: true }),

	  _onReflow: function (event, reflows) {
	    if (this._isStarted) {
	      events.emit(this, "reflows", reflows);
	    }
	  }
	});

	/**
	 * Usage example of the reflow front:
	 *
	 * let front = ReflowFront(toolbox.target.client, toolbox.target.form);
	 * front.on("reflows", this._onReflows);
	 * front.start();
	 * // now wait for events to come
	 */
	exports.ReflowFront = protocol.FrontClass(ReflowActor, {
	  initialize: function (client, { reflowActor }) {
	    protocol.Front.prototype.initialize.call(this, client, { actor: reflowActor });
	    this.manage(this);
	  },

	  destroy: function () {
	    protocol.Front.prototype.destroy.call(this);
	  }
	});

	/**
	 * Base class for all sorts of observers we need to create for a given window.
	 * @param {TabActor} tabActor
	 * @param {Function} callback Executed everytime the observer observes something
	 */
	function Observable(tabActor, callback) {
	  this.tabActor = tabActor;
	  this.callback = callback;
	}

	Observable.prototype = {
	  /**
	   * Is the observer currently observing
	   */
	  observing: false,

	  /**
	   * Start observing whatever it is this observer is supposed to observe
	   */
	  start: function () {
	    if (!this.observing) {
	      this._start();
	      this.observing = true;
	    }
	  },

	  _start: function () {
	    /* To be implemented by sub-classes */
	  },

	  /**
	   * Stop observing
	   */
	  stop: function () {
	    if (this.observing) {
	      this._stop();
	      this.observing = false;
	    }
	  },

	  _stop: function () {
	    /* To be implemented by sub-classes */
	  },

	  /**
	   * To be called by sub-classes when something has been observed
	   */
	  notifyCallback: function (...args) {
	    this.observing && this.callback && this.callback.apply(null, args);
	  },

	  /**
	   * Stop observing and detroy this observer instance
	   */
	  destroy: function () {
	    this.stop();
	    this.callback = null;
	    this.tabActor = null;
	  }
	};

	/**
	 * The LayouChangesObserver will observe reflows as soon as it is started.
	 * Some devtools actors may cause reflows and it may be wanted to "hide" these
	 * reflows from the LayouChangesObserver consumers.
	 * If this is the case, such actors should require this module and use this
	 * global function to turn the ignore mode on and off temporarily.
	 *
	 * Note that if a node is provided, it will be used to force a sync reflow to
	 * make sure all reflows which occurred before switching the mode on or off are
	 * either observed or ignored depending on the current mode.
	 *
	 * @param {Boolean} ignore
	 * @param {DOMNode} syncReflowNode The node to use to force a sync reflow
	 */
	var gIgnoreLayoutChanges = false;
	exports.setIgnoreLayoutChanges = function (ignore, syncReflowNode) {
	  if (syncReflowNode) {
	    let forceSyncReflow = syncReflowNode.offsetWidth;
	  }
	  gIgnoreLayoutChanges = ignore;
	};

	/**
	 * The LayoutChangesObserver class is instantiated only once per given tab
	 * and is used to track reflows and dom and style changes in that tab.
	 * The LayoutActor uses this class to send reflow events to its clients.
	 *
	 * This class isn't exported on the module because it shouldn't be instantiated
	 * to avoid creating several instances per tabs.
	 * Use `getLayoutChangesObserver(tabActor)`
	 * and `releaseLayoutChangesObserver(tabActor)`
	 * which are exported to get and release instances.
	 *
	 * The observer loops every EVENT_BATCHING_DELAY ms and checks if layout changes
	 * have happened since the last loop iteration. If there are, it sends the
	 * corresponding events:
	 *
	 * - "reflows", with an array of all the reflows that occured,
	 *
	 * @param {TabActor} tabActor
	 */
	function LayoutChangesObserver(tabActor) {
	  Observable.call(this, tabActor);

	  this._startEventLoop = this._startEventLoop.bind(this);

	  // Creating the various observers we're going to need
	  // For now, just the reflow observer, but later we can add markupMutation,
	  // styleSheetChanges and styleRuleChanges
	  this._onReflow = this._onReflow.bind(this);
	  this.reflowObserver = new ReflowObserver(this.tabActor, this._onReflow);

	  EventEmitter.decorate(this);
	}

	exports.LayoutChangesObserver = LayoutChangesObserver;

	LayoutChangesObserver.prototype = Heritage.extend(Observable.prototype, {
	  /**
	   * How long does this observer waits before emitting a batched reflows event.
	   * The lower the value, the more event packets will be sent to clients,
	   * potentially impacting performance.
	   * The higher the value, the more time we'll wait, this is better for
	   * performance but has an effect on how soon changes are shown in the toolbox.
	   */
	  EVENT_BATCHING_DELAY: 300,

	  /**
	   * Destroying this instance of LayoutChangesObserver will stop the batched
	   * events from being sent.
	   */
	  destroy: function () {
	    this.reflowObserver.destroy();
	    this.reflows = null;

	    Observable.prototype.destroy.call(this);
	  },

	  _start: function () {
	    this.reflows = [];
	    this._startEventLoop();
	    this.reflowObserver.start();
	  },

	  _stop: function () {
	    this._stopEventLoop();
	    this.reflows = [];
	    this.reflowObserver.stop();
	  },

	  /**
	   * Start the event loop, which regularly checks if there are any observer
	   * events to be sent as batched events
	   * Calls itself in a loop.
	   */
	  _startEventLoop: function () {
	    // Avoid emitting events if the tabActor has been detached (may happen
	    // during shutdown)
	    if (!this.tabActor.attached) {
	      return;
	    }

	    // Send any reflows we have
	    if (this.reflows && this.reflows.length) {
	      this.emit("reflows", this.reflows);
	      this.reflows = [];
	    }
	    this.eventLoopTimer = this._setTimeout(this._startEventLoop, this.EVENT_BATCHING_DELAY);
	  },

	  _stopEventLoop: function () {
	    this._clearTimeout(this.eventLoopTimer);
	  },

	  // Exposing set/clearTimeout here to let tests override them if needed
	  _setTimeout: function (cb, ms) {
	    return setTimeout(cb, ms);
	  },
	  _clearTimeout: function (t) {
	    return clearTimeout(t);
	  },

	  /**
	   * Executed whenever a reflow is observed. Only stacks the reflow in the
	   * reflows array.
	   * The EVENT_BATCHING_DELAY loop will take care of it later.
	   * @param {Number} start When the reflow started
	   * @param {Number} end When the reflow ended
	   * @param {Boolean} isInterruptible
	   */
	  _onReflow: function (start, end, isInterruptible) {
	    if (gIgnoreLayoutChanges) {
	      return;
	    }

	    // XXX: when/if bug 997092 gets fixed, we will be able to know which
	    // elements have been reflowed, which would be a nice thing to add here.
	    this.reflows.push({
	      start: start,
	      end: end,
	      isInterruptible: isInterruptible
	    });
	  }
	});

	/**
	 * Get a LayoutChangesObserver instance for a given window. This function makes
	 * sure there is only one instance per window.
	 * @param {TabActor} tabActor
	 * @return {LayoutChangesObserver}
	 */
	var observedWindows = new Map();
	function getLayoutChangesObserver(tabActor) {
	  let observerData = observedWindows.get(tabActor);
	  if (observerData) {
	    observerData.refCounting++;
	    return observerData.observer;
	  }

	  let obs = new LayoutChangesObserver(tabActor);
	  observedWindows.set(tabActor, {
	    observer: obs,
	    refCounting: 1 // counting references allows to stop the observer when no
	    // tabActor owns an instance
	  });
	  obs.start();
	  return obs;
	};
	exports.getLayoutChangesObserver = getLayoutChangesObserver;

	/**
	 * Release a LayoutChangesObserver instance that was retrieved by
	 * getLayoutChangesObserver. This is required to ensure the tabActor reference
	 * is removed and the observer is eventually stopped and destroyed.
	 * @param {TabActor} tabActor
	 */
	function releaseLayoutChangesObserver(tabActor) {
	  let observerData = observedWindows.get(tabActor);
	  if (!observerData) {
	    return;
	  }

	  observerData.refCounting--;
	  if (!observerData.refCounting) {
	    observerData.observer.destroy();
	    observedWindows.delete(tabActor);
	  }
	};
	exports.releaseLayoutChangesObserver = releaseLayoutChangesObserver;

	/**
	 * Instantiate and start a reflow observer on a given window's document element.
	 * Will report any reflow that occurs in this window's docshell.
	 * @extends Observable
	 * @param {TabActor} tabActor
	 * @param {Function} callback Executed everytime a reflow occurs
	 */
	function ReflowObserver(tabActor, callback) {
	  Observable.call(this, tabActor, callback);

	  this._onWindowReady = this._onWindowReady.bind(this);
	  events.on(this.tabActor, "window-ready", this._onWindowReady);
	  this._onWindowDestroyed = this._onWindowDestroyed.bind(this);
	  events.on(this.tabActor, "window-destroyed", this._onWindowDestroyed);
	}

	ReflowObserver.prototype = Heritage.extend(Observable.prototype, {
	  QueryInterface: XPCOMUtils.generateQI([Ci.nsIReflowObserver, Ci.nsISupportsWeakReference]),

	  _onWindowReady: function ({ window }) {
	    if (this.observing) {
	      this._startListeners([window]);
	    }
	  },

	  _onWindowDestroyed: function ({ window }) {
	    if (this.observing) {
	      this._stopListeners([window]);
	    }
	  },

	  _start: function () {
	    this._startListeners(this.tabActor.windows);
	  },

	  _stop: function () {
	    if (this.tabActor.attached && this.tabActor.docShell) {
	      // It's only worth stopping if the tabActor is still attached
	      this._stopListeners(this.tabActor.windows);
	    }
	  },

	  _startListeners: function (windows) {
	    for (let window of windows) {
	      let docshell = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocShell);
	      docshell.addWeakReflowObserver(this);
	    }
	  },

	  _stopListeners: function (windows) {
	    for (let window of windows) {
	      // Corner cases where a global has already been freed may happen, in which
	      // case, no need to remove the observer
	      try {
	        let docshell = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocShell);
	        docshell.removeWeakReflowObserver(this);
	      } catch (e) {}
	    }
	  },

	  reflow: function (start, end) {
	    this.notifyCallback(start, end, false);
	  },

	  reflowInterruptible: function (start, end) {
	    this.notifyCallback(start, end, true);
	  },

	  destroy: function () {
	    if (this._isDestroyed) {
	      return;
	    }
	    this._isDestroyed = true;

	    events.off(this.tabActor, "window-ready", this._onWindowReady);
	    events.off(this.tabActor, "window-destroyed", this._onWindowDestroyed);
	    Observable.prototype.destroy.call(this);
	  }
	});

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var _require = __webpack_require__(1);

	var Cu = _require.Cu;
	var components = _require.components;

	var DevToolsUtils = __webpack_require__(19);
	var Services = __webpack_require__(9);
	var promise = __webpack_require__(6);

	var _require2 = __webpack_require__(64);

	var Class = _require2.Class;

	var _require3 = __webpack_require__(80);

	var EventTarget = _require3.EventTarget;

	var events = __webpack_require__(25);
	var object = __webpack_require__(81);

	exports.emit = events.emit;

	/**
	 * Types: named marshallers/demarshallers.
	 *
	 * Types provide a 'write' function that takes a js representation and
	 * returns a protocol representation, and a "read" function that
	 * takes a protocol representation and returns a js representation.
	 *
	 * The read and write methods are also passed a context object that
	 * represent the actor or front requesting the translation.
	 *
	 * Types are referred to with a typestring.  Basic types are
	 * registered by name using addType, and more complex types can
	 * be generated by adding detail to the type name.
	 */

	var types = Object.create(null);
	exports.types = types;

	var registeredTypes = types.registeredTypes = new Map();
	var registeredLifetimes = types.registeredLifetimes = new Map();

	/**
	 * Return the type object associated with a given typestring.
	 * If passed a type object, it will be returned unchanged.
	 *
	 * Types can be registered with addType, or can be created on
	 * the fly with typestrings.  Examples:
	 *
	 *   boolean
	 *   threadActor
	 *   threadActor#detail
	 *   array:threadActor
	 *   array:array:threadActor#detail
	 *
	 * @param [typestring|type] type
	 *    Either a typestring naming a type or a type object.
	 *
	 * @returns a type object.
	 */
	types.getType = function (type) {
	  if (!type) {
	    return types.Primitive;
	  }

	  if (typeof type !== "string") {
	    return type;
	  }

	  // If already registered, we're done here.
	  let reg = registeredTypes.get(type);
	  if (reg) return reg;

	  // New type, see if it's a collection/lifetime type:
	  let sep = type.indexOf(":");
	  if (sep >= 0) {
	    let collection = type.substring(0, sep);
	    let subtype = types.getType(type.substring(sep + 1));

	    if (collection === "array") {
	      return types.addArrayType(subtype);
	    } else if (collection === "nullable") {
	      return types.addNullableType(subtype);
	    }

	    if (registeredLifetimes.has(collection)) {
	      return types.addLifetimeType(collection, subtype);
	    }

	    throw Error("Unknown collection type: " + collection);
	  }

	  // Not a collection, might be actor detail
	  let pieces = type.split("#", 2);
	  if (pieces.length > 1) {
	    return types.addActorDetail(type, pieces[0], pieces[1]);
	  }

	  // Might be a lazily-loaded type
	  if (type === "longstring") {
	    __webpack_require__(83);
	    return registeredTypes.get("longstring");
	  }

	  throw Error("Unknown type: " + type);
	};

	/**
	 * Don't allow undefined when writing primitive types to packets.  If
	 * you want to allow undefined, use a nullable type.
	 */
	function identityWrite(v) {
	  if (v === undefined) {
	    throw Error("undefined passed where a value is required");
	  }
	  // This has to handle iterator->array conversion because arrays of
	  // primitive types pass through here.
	  if (v && typeof v === "object" && Symbol.iterator in v) {
	    return [...v];
	  }
	  return v;
	}

	/**
	 * Add a type to the type system.
	 *
	 * When registering a type, you can provide `read` and `write` methods.
	 *
	 * The `read` method will be passed a JS object value from the JSON
	 * packet and must return a native representation.  The `write` method will
	 * be passed a native representation and should provide a JSONable value.
	 *
	 * These methods will both be passed a context.  The context is the object
	 * performing or servicing the request - on the server side it will be
	 * an Actor, on the client side it will be a Front.
	 *
	 * @param typestring name
	 *    Name to register
	 * @param object typeObject
	 *    An object whose properties will be stored in the type, including
	 *    the `read` and `write` methods.
	 * @param object options
	 *    Can specify `thawed` to prevent the type from being frozen.
	 *
	 * @returns a type object that can be used in protocol definitions.
	 */
	types.addType = function (name, typeObject = {}, options = {}) {
	  if (registeredTypes.has(name)) {
	    throw Error("Type '" + name + "' already exists.");
	  }

	  let type = object.merge({
	    toString() {
	      return "[protocol type:" + name + "]";
	    },
	    name: name,
	    primitive: !(typeObject.read || typeObject.write),
	    read: identityWrite,
	    write: identityWrite
	  }, typeObject);

	  registeredTypes.set(name, type);

	  return type;
	};

	/**
	 * Remove a type previously registered with the system.
	 * Primarily useful for types registered by addons.
	 */
	types.removeType = function (name) {
	  // This type may still be referenced by other types, make sure
	  // those references don't work.
	  let type = registeredTypes.get(name);

	  type.name = "DEFUNCT:" + name;
	  type.category = "defunct";
	  type.primitive = false;
	  type.read = type.write = function () {
	    throw new Error("Using defunct type: " + name);
	  };

	  registeredTypes.delete(name);
	};

	/**
	 * Add an array type to the type system.
	 *
	 * getType() will call this function if provided an "array:<type>"
	 * typestring.
	 *
	 * @param type subtype
	 *    The subtype to be held by the array.
	 */
	types.addArrayType = function (subtype) {
	  subtype = types.getType(subtype);

	  let name = "array:" + subtype.name;

	  // Arrays of primitive types are primitive types themselves.
	  if (subtype.primitive) {
	    return types.addType(name);
	  }
	  return types.addType(name, {
	    category: "array",
	    read: function (v, ctx) {
	      return [...v].map(function (i) {
	        return subtype.read(i, ctx);
	      });
	    },
	    write: function (v, ctx) {
	      return [...v].map(function (i) {
	        return subtype.write(i, ctx);
	      });
	    }
	  });
	};

	/**
	 * Add a dict type to the type system.  This allows you to serialize
	 * a JS object that contains non-primitive subtypes.
	 *
	 * Properties of the value that aren't included in the specializations
	 * will be serialized as primitive values.
	 *
	 * @param object specializations
	 *    A dict of property names => type
	 */
	types.addDictType = function (name, specializations) {
	  return types.addType(name, {
	    category: "dict",
	    specializations: specializations,
	    read: function (v, ctx) {
	      let ret = {};
	      for (let prop in v) {
	        if (prop in specializations) {
	          ret[prop] = types.getType(specializations[prop]).read(v[prop], ctx);
	        } else {
	          ret[prop] = v[prop];
	        }
	      }
	      return ret;
	    },

	    write: function (v, ctx) {
	      let ret = {};
	      for (let prop in v) {
	        if (prop in specializations) {
	          ret[prop] = types.getType(specializations[prop]).write(v[prop], ctx);
	        } else {
	          ret[prop] = v[prop];
	        }
	      }
	      return ret;
	    }
	  });
	};

	/**
	 * Register an actor type with the type system.
	 *
	 * Types are marshalled differently when communicating server->client
	 * than they are when communicating client->server.  The server needs
	 * to provide useful information to the client, so uses the actor's
	 * `form` method to get a json representation of the actor.  When
	 * making a request from the client we only need the actor ID string.
	 *
	 * This function can be called before the associated actor has been
	 * constructed, but the read and write methods won't work until
	 * the associated addActorImpl or addActorFront methods have been
	 * called during actor/front construction.
	 *
	 * @param string name
	 *    The typestring to register.
	 */
	types.addActorType = function (name) {
	  let type = types.addType(name, {
	    _actor: true,
	    category: "actor",
	    read: function (v, ctx, detail) {
	      // If we're reading a request on the server side, just
	      // find the actor registered with this actorID.
	      if (ctx instanceof Actor) {
	        return ctx.conn.getActor(v);
	      }

	      // Reading a response on the client side, check for an
	      // existing front on the connection, and create the front
	      // if it isn't found.
	      let actorID = typeof v === "string" ? v : v.actor;
	      let front = ctx.conn.getActor(actorID);
	      if (!front) {
	        front = new type.frontClass(ctx.conn);
	        front.actorID = actorID;
	        ctx.marshallPool().manage(front);
	      }

	      v = type.formType(detail).read(v, front, detail);
	      front.form(v, detail, ctx);

	      return front;
	    },
	    write: function (v, ctx, detail) {
	      // If returning a response from the server side, make sure
	      // the actor is added to a parent object and return its form.
	      if (v instanceof Actor) {
	        if (!v.actorID) {
	          ctx.marshallPool().manage(v);
	        }
	        return type.formType(detail).write(v.form(detail), ctx, detail);
	      }

	      // Writing a request from the client side, just send the actor id.
	      return v.actorID;
	    },
	    formType: function (detail) {
	      if (!("formType" in type.actorSpec)) {
	        return types.Primitive;
	      }

	      let formAttr = "formType";
	      if (detail) {
	        formAttr += "#" + detail;
	      }

	      if (!(formAttr in type.actorSpec)) {
	        throw new Error("No type defined for " + formAttr);
	      }

	      return type.actorSpec[formAttr];
	    }
	  });
	  return type;
	};

	types.addNullableType = function (subtype) {
	  subtype = types.getType(subtype);
	  return types.addType("nullable:" + subtype.name, {
	    category: "nullable",
	    read: function (value, ctx) {
	      if (value == null) {
	        return value;
	      }
	      return subtype.read(value, ctx);
	    },
	    write: function (value, ctx) {
	      if (value == null) {
	        return value;
	      }
	      return subtype.write(value, ctx);
	    }
	  });
	};

	/**
	 * Register an actor detail type.  This is just like an actor type, but
	 * will pass a detail hint to the actor's form method during serialization/
	 * deserialization.
	 *
	 * This is called by getType() when passed an 'actorType#detail' string.
	 *
	 * @param string name
	 *   The typestring to register this type as.
	 * @param type actorType
	 *   The actor type you'll be detailing.
	 * @param string detail
	 *   The detail to pass.
	 */
	types.addActorDetail = function (name, actorType, detail) {
	  actorType = types.getType(actorType);
	  if (!actorType._actor) {
	    throw Error("Details only apply to actor types, tried to add detail '" + detail + "'' to " + actorType.name + "\n");
	  }
	  return types.addType(name, {
	    _actor: true,
	    category: "detail",
	    read: function (v, ctx) {
	      return actorType.read(v, ctx, detail);
	    },
	    write: function (v, ctx) {
	      return actorType.write(v, ctx, detail);
	    }
	  });
	};

	/**
	 * Register an actor lifetime.  This lets the type system find a parent
	 * actor that differs from the actor fulfilling the request.
	 *
	 * @param string name
	 *    The lifetime name to use in typestrings.
	 * @param string prop
	 *    The property of the actor that holds the parent that should be used.
	 */
	types.addLifetime = function (name, prop) {
	  if (registeredLifetimes.has(name)) {
	    throw Error("Lifetime '" + name + "' already registered.");
	  }
	  registeredLifetimes.set(name, prop);
	};

	/**
	 * Remove a previously-registered lifetime.  Useful for lifetimes registered
	 * in addons.
	 */
	types.removeLifetime = function (name) {
	  registeredLifetimes.delete(name);
	};

	/**
	 * Register a lifetime type.  This creates an actor type tied to the given
	 * lifetime.
	 *
	 * This is called by getType() when passed a '<lifetimeType>:<actorType>'
	 * typestring.
	 *
	 * @param string lifetime
	 *    A lifetime string previously regisered with addLifetime()
	 * @param type subtype
	 *    An actor type
	 */
	types.addLifetimeType = function (lifetime, subtype) {
	  subtype = types.getType(subtype);
	  if (!subtype._actor) {
	    throw Error("Lifetimes only apply to actor types, tried to apply lifetime '" + lifetime + "'' to " + subtype.name);
	  }
	  let prop = registeredLifetimes.get(lifetime);
	  return types.addType(lifetime + ":" + subtype.name, {
	    category: "lifetime",
	    read: function (value, ctx) {
	      return subtype.read(value, ctx[prop]);
	    },
	    write: function (value, ctx) {
	      return subtype.write(value, ctx[prop]);
	    }
	  });
	};

	// Add a few named primitive types.
	types.Primitive = types.addType("primitive");
	types.String = types.addType("string");
	types.Number = types.addType("number");
	types.Boolean = types.addType("boolean");
	types.JSON = types.addType("json");

	/**
	 * Request/Response templates and generation
	 *
	 * Request packets are specified as json templates with
	 * Arg and Option placeholders where arguments should be
	 * placed.
	 *
	 * Reponse packets are also specified as json templates,
	 * with a RetVal placeholder where the return value should be
	 * placed.
	 */

	/**
	 * Placeholder for simple arguments.
	 *
	 * @param number index
	 *    The argument index to place at this position.
	 * @param type type
	 *    The argument should be marshalled as this type.
	 * @constructor
	 */
	var Arg = Class({
	  initialize: function (index, type) {
	    this.index = index;
	    this.type = types.getType(type);
	  },

	  write: function (arg, ctx) {
	    return this.type.write(arg, ctx);
	  },

	  read: function (v, ctx, outArgs) {
	    outArgs[this.index] = this.type.read(v, ctx);
	  },

	  describe: function () {
	    return {
	      _arg: this.index,
	      type: this.type.name
	    };
	  }
	});
	exports.Arg = Arg;

	/**
	 * Placeholder for an options argument value that should be hoisted
	 * into the packet.
	 *
	 * If provided in a method specification:
	 *
	 *   { optionArg: Option(1)}
	 *
	 * Then arguments[1].optionArg will be placed in the packet in this
	 * value's place.
	 *
	 * @param number index
	 *    The argument index of the options value.
	 * @param type type
	 *    The argument should be marshalled as this type.
	 * @constructor
	 */
	var Option = Class({
	  extends: Arg,
	  initialize: function (index, type) {
	    Arg.prototype.initialize.call(this, index, type);
	  },

	  write: function (arg, ctx, name) {
	    // Ignore if arg is undefined or null; allow other falsy values
	    if (arg == undefined || arg[name] == undefined) {
	      return undefined;
	    }
	    let v = arg[name];
	    return this.type.write(v, ctx);
	  },
	  read: function (v, ctx, outArgs, name) {
	    if (outArgs[this.index] === undefined) {
	      outArgs[this.index] = {};
	    }
	    if (v === undefined) {
	      return;
	    }
	    outArgs[this.index][name] = this.type.read(v, ctx);
	  },

	  describe: function () {
	    return {
	      _option: this.index,
	      type: this.type.name
	    };
	  }
	});

	exports.Option = Option;

	/**
	 * Placeholder for return values in a response template.
	 *
	 * @param type type
	 *    The return value should be marshalled as this type.
	 */
	var RetVal = Class({
	  initialize: function (type) {
	    this.type = types.getType(type);
	  },

	  write: function (v, ctx) {
	    return this.type.write(v, ctx);
	  },

	  read: function (v, ctx) {
	    return this.type.read(v, ctx);
	  },

	  describe: function () {
	    return {
	      _retval: this.type.name
	    };
	  }
	});

	exports.RetVal = RetVal;

	/* Template handling functions */

	/**
	 * Get the value at a given path, or undefined if not found.
	 */
	function getPath(obj, path) {
	  for (let name of path) {
	    if (!(name in obj)) {
	      return undefined;
	    }
	    obj = obj[name];
	  }
	  return obj;
	}

	/**
	 * Find Placeholders in the template and save them along with their
	 * paths.
	 */
	function findPlaceholders(template, constructor, path = [], placeholders = []) {
	  if (!template || typeof template != "object") {
	    return placeholders;
	  }

	  if (template instanceof constructor) {
	    placeholders.push({ placeholder: template, path: [...path] });
	    return placeholders;
	  }

	  for (let name in template) {
	    path.push(name);
	    findPlaceholders(template[name], constructor, path, placeholders);
	    path.pop();
	  }

	  return placeholders;
	}

	function describeTemplate(template) {
	  return JSON.parse(JSON.stringify(template, function (key, value) {
	    if (value.describe) {
	      return value.describe();
	    }
	    return value;
	  }));
	}

	/**
	 * Manages a request template.
	 *
	 * @param object template
	 *    The request template.
	 * @construcor
	 */
	var Request = Class({
	  initialize: function (template = {}) {
	    this.type = template.type;
	    this.template = template;
	    this.args = findPlaceholders(template, Arg);
	  },

	  /**
	   * Write a request.
	   *
	   * @param array fnArgs
	   *    The function arguments to place in the request.
	   * @param object ctx
	   *    The object making the request.
	   * @returns a request packet.
	   */
	  write: function (fnArgs, ctx) {
	    let str = JSON.stringify(this.template, function (key, value) {
	      if (value instanceof Arg) {
	        return value.write(value.index in fnArgs ? fnArgs[value.index] : undefined, ctx, key);
	      }
	      return value;
	    });
	    return JSON.parse(str);
	  },

	  /**
	   * Read a request.
	   *
	   * @param object packet
	   *    The request packet.
	   * @param object ctx
	   *    The object making the request.
	   * @returns an arguments array
	   */
	  read: function (packet, ctx) {
	    let fnArgs = [];
	    for (let templateArg of this.args) {
	      let arg = templateArg.placeholder;
	      let path = templateArg.path;
	      let name = path[path.length - 1];
	      arg.read(getPath(packet, path), ctx, fnArgs, name);
	    }
	    return fnArgs;
	  },

	  describe: function () {
	    return describeTemplate(this.template);
	  }
	});

	/**
	 * Manages a response template.
	 *
	 * @param object template
	 *    The response template.
	 * @construcor
	 */
	var Response = Class({
	  initialize: function (template = {}) {
	    this.template = template;
	    let placeholders = findPlaceholders(template, RetVal);
	    if (placeholders.length > 1) {
	      throw Error("More than one RetVal specified in response");
	    }
	    let placeholder = placeholders.shift();
	    if (placeholder) {
	      this.retVal = placeholder.placeholder;
	      this.path = placeholder.path;
	    }
	  },

	  /**
	   * Write a response for the given return value.
	   *
	   * @param val ret
	   *    The return value.
	   * @param object ctx
	   *    The object writing the response.
	   */
	  write: function (ret, ctx) {
	    return JSON.parse(JSON.stringify(this.template, function (key, value) {
	      if (value instanceof RetVal) {
	        return value.write(ret, ctx);
	      }
	      return value;
	    }));
	  },

	  /**
	   * Read a return value from the given response.
	   *
	   * @param object packet
	   *    The response packet.
	   * @param object ctx
	   *    The object reading the response.
	   */
	  read: function (packet, ctx) {
	    if (!this.retVal) {
	      return undefined;
	    }
	    let v = getPath(packet, this.path);
	    return this.retVal.read(v, ctx);
	  },

	  describe: function () {
	    return describeTemplate(this.template);
	  }
	});

	/**
	 * Actor and Front implementations
	 */

	/**
	 * A protocol object that can manage the lifetime of other protocol
	 * objects.
	 */
	var Pool = Class({
	  extends: EventTarget,

	  /**
	   * Pools are used on both sides of the connection to help coordinate
	   * lifetimes.
	   *
	   * @param optional conn
	   *   Either a DebuggerServerConnection or a DebuggerClient.  Must have
	   *   addActorPool, removeActorPool, and poolFor.
	   *   conn can be null if the subclass provides a conn property.
	   * @constructor
	   */
	  initialize: function (conn) {
	    if (conn) {
	      this.conn = conn;
	    }
	  },

	  /**
	   * Return the parent pool for this client.
	   */
	  parent: function () {
	    return this.conn.poolFor(this.actorID);
	  },

	  /**
	   * Override this if you want actors returned by this actor
	   * to belong to a different actor by default.
	   */
	  marshallPool: function () {
	    return this;
	  },

	  /**
	   * Pool is the base class for all actors, even leaf nodes.
	   * If the child map is actually referenced, go ahead and create
	   * the stuff needed by the pool.
	   */
	  __poolMap: null,
	  get _poolMap() {
	    if (this.__poolMap) return this.__poolMap;
	    this.__poolMap = new Map();
	    this.conn.addActorPool(this);
	    return this.__poolMap;
	  },

	  /**
	   * Add an actor as a child of this pool.
	   */
	  manage: function (actor) {
	    if (!actor.actorID) {
	      actor.actorID = this.conn.allocID(actor.actorPrefix || actor.typeName);
	    }

	    this._poolMap.set(actor.actorID, actor);
	    return actor;
	  },

	  /**
	   * Remove an actor as a child of this pool.
	   */
	  unmanage: function (actor) {
	    this.__poolMap && this.__poolMap.delete(actor.actorID);
	  },

	  // true if the given actor ID exists in the pool.
	  has: function (actorID) {
	    return this.__poolMap && this._poolMap.has(actorID);
	  },

	  // The actor for a given actor id stored in this pool
	  actor: function (actorID) {
	    return this.__poolMap ? this._poolMap.get(actorID) : null;
	  },

	  // Same as actor, should update debugger connection to use 'actor'
	  // and then remove this.
	  get: function (actorID) {
	    return this.__poolMap ? this._poolMap.get(actorID) : null;
	  },

	  // True if this pool has no children.
	  isEmpty: function () {
	    return !this.__poolMap || this._poolMap.size == 0;
	  },

	  /**
	   * Destroy this item, removing it from a parent if it has one,
	   * and destroying all children if necessary.
	   */
	  destroy: function () {
	    let parent = this.parent();
	    if (parent) {
	      parent.unmanage(this);
	    }
	    if (!this.__poolMap) {
	      return;
	    }
	    for (let actor of this.__poolMap.values()) {
	      // Self-owned actors are ok, but don't need destroying twice.
	      if (actor === this) {
	        continue;
	      }
	      let destroy = actor.destroy;
	      if (destroy) {
	        // Disconnect destroy while we're destroying in case of (misbehaving)
	        // circular ownership.
	        actor.destroy = null;
	        destroy.call(actor);
	        actor.destroy = destroy;
	      }
	    };
	    this.conn.removeActorPool(this, true);
	    this.__poolMap.clear();
	    this.__poolMap = null;
	  },

	  /**
	   * For getting along with the debugger server pools, should be removable
	   * eventually.
	   */
	  cleanup: function () {
	    this.destroy();
	  }
	});
	exports.Pool = Pool;

	/**
	 * An actor in the actor tree.
	 */
	var Actor = Class({
	  extends: Pool,

	  // Will contain the actor's ID
	  actorID: null,

	  /**
	   * Initialize an actor.
	   *
	   * @param optional conn
	   *   Either a DebuggerServerConnection or a DebuggerClient.  Must have
	   *   addActorPool, removeActorPool, and poolFor.
	   *   conn can be null if the subclass provides a conn property.
	   * @constructor
	   */
	  initialize: function (conn) {
	    Pool.prototype.initialize.call(this, conn);

	    // Forward events to the connection.
	    if (this._actorSpec && this._actorSpec.events) {
	      for (let key of this._actorSpec.events.keys()) {
	        let name = key;
	        let sendEvent = this._sendEvent.bind(this, name);
	        this.on(name, function (...args) {
	          sendEvent.apply(null, args);
	        });
	      }
	    }
	  },

	  toString: function () {
	    return "[Actor " + this.typeName + "/" + this.actorID + "]";
	  },

	  _sendEvent: function (name, ...args) {
	    if (!this._actorSpec.events.has(name)) {
	      // It's ok to emit events that don't go over the wire.
	      return;
	    }
	    let request = this._actorSpec.events.get(name);
	    let packet;
	    try {
	      packet = request.write(args, this);
	    } catch (ex) {
	      console.error("Error sending event: " + name);
	      throw ex;
	    }
	    packet.from = packet.from || this.actorID;
	    this.conn.send(packet);
	  },

	  destroy: function () {
	    Pool.prototype.destroy.call(this);
	    this.actorID = null;
	  },

	  /**
	   * Override this method in subclasses to serialize the actor.
	   * @param [optional] string hint
	   *   Optional string to customize the form.
	   * @returns A jsonable object.
	   */
	  form: function (hint) {
	    return { actor: this.actorID };
	  },

	  writeError: function (err) {
	    console.error(err);
	    if (err.stack) {
	      dump(err.stack);
	    }
	    this.conn.send({
	      from: this.actorID,
	      error: "unknownError",
	      message: err.toString()
	    });
	  },

	  _queueResponse: function (create) {
	    let pending = this._pendingResponse || promise.resolve(null);
	    let response = create(pending);
	    this._pendingResponse = response;
	  }
	});
	exports.Actor = Actor;

	/**
	 * Tags a prtotype method as an actor method implementation.
	 *
	 * @param function fn
	 *    The implementation function, will be returned.
	 * @param spec
	 *    The method specification, with the following (optional) properties:
	 *      request (object): a request template.
	 *      response (object): a response template.
	 *      oneway (bool): 'true' if no response should be sent.
	 *      telemetry (string): Telemetry probe ID for measuring completion time.
	 */
	exports.method = function (fn, spec = {}) {
	  fn._methodSpec = Object.freeze(spec);
	  if (spec.request) Object.freeze(spec.request);
	  if (spec.response) Object.freeze(spec.response);
	  return fn;
	};

	/**
	 * Process an actor definition from its prototype and generate
	 * request handlers.
	 */
	var actorProto = function (actorProto) {
	  if (actorProto._actorSpec) {
	    throw new Error("actorProto called twice on the same actor prototype!");
	  }

	  let protoSpec = {
	    methods: []
	  };

	  // Find method and form specifications attached to prototype properties.
	  for (let name of Object.getOwnPropertyNames(actorProto)) {
	    let desc = Object.getOwnPropertyDescriptor(actorProto, name);
	    if (!desc.value) {
	      continue;
	    }

	    if (name.startsWith("formType")) {
	      if (typeof desc.value === "string") {
	        protoSpec[name] = types.getType(desc.value);
	      } else if (desc.value.name && registeredTypes.has(desc.value.name)) {
	        protoSpec[name] = desc.value;
	      } else {
	        // Shorthand for a newly-registered DictType.
	        protoSpec[name] = types.addDictType(actorProto.typeName + "__" + name, desc.value);
	      }
	    }

	    if (desc.value._methodSpec) {
	      let frozenSpec = desc.value._methodSpec;
	      let spec = {};
	      spec.name = frozenSpec.name || name;
	      spec.request = Request(object.merge({ type: spec.name }, frozenSpec.request || undefined));
	      spec.response = Response(frozenSpec.response || undefined);
	      spec.telemetry = frozenSpec.telemetry;
	      spec.release = frozenSpec.release;
	      spec.oneway = frozenSpec.oneway;

	      protoSpec.methods.push(spec);
	    }
	  }

	  // Find event specifications
	  if (actorProto.events) {
	    protoSpec.events = new Map();
	    for (let name in actorProto.events) {
	      let eventRequest = actorProto.events[name];
	      Object.freeze(eventRequest);
	      protoSpec.events.set(name, Request(object.merge({ type: name }, eventRequest)));
	    }
	  }

	  // Generate request handlers for each method definition
	  actorProto.requestTypes = Object.create(null);
	  protoSpec.methods.forEach(function (spec) {
	    let handler = function (packet, conn) {
	      var _this = this;

	      try {
	        let args;
	        try {
	          args = spec.request.read(packet, this);
	        } catch (ex) {
	          console.error("Error reading request: " + packet.type);
	          throw ex;
	        }

	        let ret = this[spec.name].apply(this, args);

	        let sendReturn = function (ret) {
	          if (spec.oneway) {
	            // No need to send a response.
	            return;
	          }

	          let response;
	          try {
	            response = spec.response.write(ret, _this);
	          } catch (ex) {
	            console.error("Error writing response to: " + spec.name);
	            throw ex;
	          }
	          response.from = _this.actorID;
	          // If spec.release has been specified, destroy the object.
	          if (spec.release) {
	            try {
	              _this.destroy();
	            } catch (e) {
	              _this.writeError(e);
	              return;
	            }
	          }

	          conn.send(response);
	        };

	        this._queueResponse(function (p) {
	          return p.then(function () {
	            return ret;
	          }).then(sendReturn).then(null, _this.writeError.bind(_this));
	        });
	      } catch (e) {
	        this._queueResponse(function (p) {
	          return p.then(function () {
	            return _this.writeError(e);
	          });
	        });
	      }
	    };

	    actorProto.requestTypes[spec.request.type] = handler;
	  });

	  actorProto._actorSpec = protoSpec;
	  return actorProto;
	};

	/**
	 * Create an actor class for the given actor prototype.
	 *
	 * @param object proto
	 *    The object prototype.  Must have a 'typeName' property,
	 *    should have method definitions, can have event definitions.
	 */
	exports.ActorClass = function (proto) {
	  if (!proto.typeName) {
	    throw Error("Actor prototype must have a typeName member.");
	  }
	  proto.extends = Actor;
	  if (!registeredTypes.has(proto.typeName)) {
	    types.addActorType(proto.typeName);
	  }
	  let cls = Class(actorProto(proto));

	  registeredTypes.get(proto.typeName).actorSpec = proto._actorSpec;
	  return cls;
	};

	/**
	 * Base class for client-side actor fronts.
	 */
	var Front = Class({
	  extends: Pool,

	  actorID: null,

	  /**
	   * The base class for client-side actor fronts.
	   *
	   * @param optional conn
	   *   Either a DebuggerServerConnection or a DebuggerClient.  Must have
	   *   addActorPool, removeActorPool, and poolFor.
	   *   conn can be null if the subclass provides a conn property.
	   * @param optional form
	   *   The json form provided by the server.
	   * @constructor
	   */
	  initialize: function (conn = null, form = null, detail = null, context = null) {
	    Pool.prototype.initialize.call(this, conn);
	    this._requests = [];

	    // protocol.js no longer uses this data in the constructor, only external
	    // uses do.  External usage of manually-constructed fronts will be
	    // drastically reduced if we convert the root and tab actors to
	    // protocol.js, in which case this can probably go away.
	    if (form) {
	      this.actorID = form.actor;
	      form = types.getType(this.typeName).formType(detail).read(form, this, detail);
	      this.form(form, detail, context);
	    }
	  },

	  destroy: function () {
	    // Reject all outstanding requests, they won't make sense after
	    // the front is destroyed.
	    while (this._requests && this._requests.length > 0) {
	      var _requests$shift = this._requests.shift();

	      let deferred = _requests$shift.deferred;
	      let to = _requests$shift.to;
	      let type = _requests$shift.type;
	      let stack = _requests$shift.stack;

	      let msg = "Connection closed, pending request to " + to + ", type " + type + " failed" + "\n\nRequest stack:\n" + stack.formattedStack;
	      deferred.reject(new Error(msg));
	    }
	    Pool.prototype.destroy.call(this);
	    this.actorID = null;
	  },

	  manage: function (front) {
	    if (!front.actorID) {
	      throw new Error("Can't manage front without an actor ID.\n" + "Ensure server supports " + front.typeName + ".");
	    }
	    return Pool.prototype.manage.call(this, front);
	  },

	  /**
	   * @returns a promise that will resolve to the actorID this front
	   * represents.
	   */
	  actor: function () {
	    return promise.resolve(this.actorID);
	  },

	  toString: function () {
	    return "[Front for " + this.typeName + "/" + this.actorID + "]";
	  },

	  /**
	   * Update the actor from its representation.
	   * Subclasses should override this.
	   */
	  form: function (form) {},

	  /**
	   * Send a packet on the connection.
	   */
	  send: function (packet) {
	    var _this2 = this;

	    if (packet.to) {
	      this.conn._transport.send(packet);
	    } else {
	      this.actor().then(function (actorID) {
	        packet.to = actorID;
	        _this2.conn._transport.send(packet);
	      }).then(null, function (e) {
	        return DevToolsUtils.reportException("Front.prototype.send", e);
	      });
	    }
	  },

	  /**
	   * Send a two-way request on the connection.
	   */
	  request: function (packet) {
	    let deferred = promise.defer();
	    // Save packet basics for debugging
	    let to = packet.to;
	    let type = packet.type;

	    this._requests.push({
	      deferred,
	      to: to || this.actorID,
	      type,
	      stack: components.stack
	    });
	    this.send(packet);
	    return deferred.promise;
	  },

	  /**
	   * Handler for incoming packets from the client's actor.
	   */
	  onPacket: function (packet) {
	    var _this3 = this;

	    // Pick off event packets
	    let type = packet.type || undefined;
	    if (this._clientSpec.events && this._clientSpec.events.has(type)) {
	      let event = this._clientSpec.events.get(packet.type);
	      let args;
	      try {
	        args = event.request.read(packet, this);
	      } catch (ex) {
	        console.error("Error reading event: " + packet.type);
	        console.exception(ex);
	        throw ex;
	      }
	      if (event.pre) {
	        let results = event.pre.map(function (pre) {
	          return pre.apply(_this3, args);
	        });

	        // Check to see if any of the preEvents returned a promise -- if so,
	        // wait for their resolution before emitting. Otherwise, emit synchronously.
	        if (results.some(function (result) {
	          return result && typeof result.then === "function";
	        })) {
	          promise.all(results).then(function () {
	            return events.emit.apply(null, [_this3, event.name].concat(args));
	          });
	          return;
	        }
	      }

	      events.emit.apply(null, [this, event.name].concat(args));
	      return;
	    }

	    // Remaining packets must be responses.
	    if (this._requests.length === 0) {
	      let msg = "Unexpected packet " + this.actorID + ", " + JSON.stringify(packet);
	      let err = Error(msg);
	      console.error(err);
	      throw err;
	    }

	    var _requests$shift2 = this._requests.shift();

	    let deferred = _requests$shift2.deferred;
	    let stack = _requests$shift2.stack;

	    Cu.callFunctionWithAsyncStack(function () {
	      if (packet.error) {
	        // "Protocol error" is here to avoid TBPL heuristics. See also
	        // https://mxr.mozilla.org/webtools-central/source/tbpl/php/inc/GeneralErrorFilter.php
	        let message;
	        if (packet.error && packet.message) {
	          message = "Protocol error (" + packet.error + "): " + packet.message;
	        } else {
	          message = packet.error;
	        }
	        deferred.reject(message);
	      } else {
	        deferred.resolve(packet);
	      }
	    }, stack, "DevTools RDP");
	  }
	});
	exports.Front = Front;

	/**
	 * A method tagged with preEvent will be called after recieving a packet
	 * for that event, and before the front emits the event.
	 */
	exports.preEvent = function (eventName, fn) {
	  fn._preEvent = eventName;
	  return fn;
	};

	/**
	 * Mark a method as a custom front implementation, replacing the generated
	 * front method.
	 *
	 * @param function fn
	 *    The front implementation, will be returned.
	 * @param object options
	 *    Options object:
	 *      impl (string): If provided, the generated front method will be
	 *        stored as this property on the prototype.
	 */
	exports.custom = function (fn, options = {}) {
	  fn._customFront = options;
	  return fn;
	};

	function prototypeOf(obj) {
	  return typeof obj === "function" ? obj.prototype : obj;
	}

	/**
	 * Process a front definition from its prototype and generate
	 * request methods.
	 */
	var frontProto = function (proto) {
	  let actorType = prototypeOf(proto.actorType);
	  if (proto._actorSpec) {
	    throw new Error("frontProto called twice on the same front prototype!");
	  }
	  proto._actorSpec = actorType._actorSpec;
	  proto.typeName = actorType.typeName;

	  // Generate request methods.
	  let methods = proto._actorSpec.methods;
	  methods.forEach(function (spec) {
	    let name = spec.name;

	    // If there's already a property by this name in the front, it must
	    // be a custom front method.
	    if (name in proto) {
	      let custom = proto[spec.name]._customFront;
	      if (custom === undefined) {
	        throw Error("Existing method for " + spec.name + " not marked customFront while processing " + actorType.typeName + ".");
	      }
	      // If the user doesn't need the impl don't generate it.
	      if (!custom.impl) {
	        return;
	      }
	      name = custom.impl;
	    }

	    proto[name] = function (...args) {
	      var _this4 = this;

	      let histogram, startTime;
	      if (spec.telemetry) {
	        if (spec.oneway) {
	          // That just doesn't make sense.
	          throw Error("Telemetry specified for a oneway request");
	        }
	        let transportType = this.conn.localTransport ? "LOCAL_" : "REMOTE_";
	        let histogramId = "DEVTOOLS_DEBUGGER_RDP_" + transportType + spec.telemetry + "_MS";
	        try {
	          // histogram = Services.telemetry.getHistogramById(histogramId);
	          startTime = new Date();
	        } catch (ex) {
	          // XXX: Is this expected in xpcshell tests?
	          console.error(ex);
	          spec.telemetry = false;
	        }
	      }

	      let packet;
	      try {
	        packet = spec.request.write(args, this);
	      } catch (ex) {
	        console.error("Error writing request: " + name);
	        throw ex;
	      }
	      if (spec.oneway) {
	        // Fire-and-forget oneway packets.
	        this.send(packet);
	        return undefined;
	      }

	      return this.request(packet).then(function (response) {
	        let ret;
	        try {
	          ret = spec.response.read(response, _this4);
	        } catch (ex) {
	          console.error("Error reading response to: " + name);
	          throw ex;
	        }

	        if (histogram) {
	          histogram.add(+new Date() - startTime);
	        }

	        return ret;
	      });
	    };

	    // Release methods should call the destroy function on return.
	    if (spec.release) {
	      let fn = proto[name];
	      proto[name] = function (...args) {
	        var _this5 = this;

	        return fn.apply(this, args).then(function (result) {
	          _this5.destroy();
	          return result;
	        });
	      };
	    }
	  });

	  // Process event specifications
	  proto._clientSpec = {};

	  let events = proto._actorSpec.events;
	  if (events) {
	    // This actor has events, scan the prototype for preEvent handlers...
	    let preHandlers = new Map();
	    for (let name of Object.getOwnPropertyNames(proto)) {
	      let desc = Object.getOwnPropertyDescriptor(proto, name);
	      if (!desc.value) {
	        continue;
	      }
	      if (desc.value._preEvent) {
	        let preEvent = desc.value._preEvent;
	        if (!events.has(preEvent)) {
	          throw Error("preEvent for event that doesn't exist: " + preEvent);
	        }
	        let handlers = preHandlers.get(preEvent);
	        if (!handlers) {
	          handlers = [];
	          preHandlers.set(preEvent, handlers);
	        }
	        handlers.push(desc.value);
	      }
	    }

	    proto._clientSpec.events = new Map();

	    for (let _ref of events) {
	      var _ref2 = _slicedToArray(_ref, 2);

	      let name = _ref2[0];
	      let request = _ref2[1];

	      proto._clientSpec.events.set(request.type, {
	        name: name,
	        request: request,
	        pre: preHandlers.get(name)
	      });
	    }
	  }
	  return proto;
	};

	/**
	 * Create a front class for the given actor class, with the given prototype.
	 *
	 * @param ActorClass actorType
	 *    The actor class you're creating a front for.
	 * @param object proto
	 *    The object prototype.  Must have a 'typeName' property,
	 *    should have method definitions, can have event definitions.
	 */
	exports.FrontClass = function (actorType, proto) {
	  proto.actorType = actorType;
	  proto.extends = Front;
	  let cls = Class(frontProto(proto));
	  registeredTypes.get(cls.prototype.typeName).frontClass = cls;
	  return cls;
	};

	exports.dumpActorSpec = function (type) {
	  let actorSpec = type.actorSpec;
	  let ret = {
	    category: "actor",
	    typeName: type.name,
	    methods: [],
	    events: {}
	  };

	  for (let method of actorSpec.methods) {
	    ret.methods.push({
	      name: method.name,
	      release: method.release || undefined,
	      oneway: method.oneway || undefined,
	      request: method.request.describe(),
	      response: method.response.describe()
	    });
	  }

	  if (actorSpec.events) {
	    for (let _ref3 of actorSpec.events) {
	      var _ref4 = _slicedToArray(_ref3, 2);

	      let name = _ref4[0];
	      let request = _ref4[1];

	      ret.events[name] = request.describe();
	    }
	  }

	  JSON.stringify(ret);

	  return ret;
	};

	exports.dumpProtocolSpec = function () {
	  let ret = {
	    types: {}
	  };

	  for (let _ref5 of registeredTypes) {
	    var _ref6 = _slicedToArray(_ref5, 2);

	    let name = _ref6[0];
	    let type = _ref6[1];

	    // Force lazy instantiation if needed.
	    type = types.getType(name);
	    let category = type.category || undefined;
	    if (category === "dict") {
	      ret.types[name] = {
	        category: "dict",
	        typeName: name,
	        specializations: type.specializations
	      };
	    } else if (category === "actor") {
	      ret.types[name] = exports.dumpActorSpec(type);
	    }
	  }

	  return ret;
	};

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	'use strict';

	module.metadata = {
	  "stability": "stable"
	};

	var _require = __webpack_require__(25);

	const on = _require.on;
	const once = _require.once;
	const off = _require.off;
	const setListeners = _require.setListeners;

	var _require2 = __webpack_require__(77);

	const method = _require2.method;
	const chainable = _require2.chainable;

	var _require3 = __webpack_require__(64);

	const Class = _require3.Class;

	/**
	 * `EventTarget` is an exemplar for creating an objects that can be used to
	 * add / remove event listeners on them. Events on these objects may be emitted
	 * via `emit` function exported by 'event/core' module.
	 */

	const EventTarget = Class({
	  /**
	   * Method initializes `this` event source. It goes through properties of a
	   * given `options` and registers listeners for the ones that look like an
	   * event listeners.
	   */
	  /**
	   * Method initializes `this` event source. It goes through properties of a
	   * given `options` and registers listeners for the ones that look like an
	   * event listeners.
	   */
	  initialize: function initialize(options) {
	    setListeners(this, options);
	  },
	  /**
	   * Registers an event `listener` that is called every time events of
	   * specified `type` are emitted.
	   * @param {String} type
	   *    The type of event.
	   * @param {Function} listener
	   *    The listener function that processes the event.
	   * @example
	   *      worker.on('message', function (data) {
	   *        console.log('data received: ' + data)
	   *      })
	   */
	  on: chainable(method(on)),
	  /**
	   * Registers an event `listener` that is called once the next time an event
	   * of the specified `type` is emitted.
	   * @param {String} type
	   *    The type of the event.
	   * @param {Function} listener
	   *    The listener function that processes the event.
	   */
	  once: chainable(method(once)),
	  /**
	   * Removes an event `listener` for the given event `type`.
	   * @param {String} type
	   *    The type of event.
	   * @param {Function} listener
	   *    The listener function that processes the event.
	   */
	  removeListener: function removeListener(type, listener) {
	    // Note: We can't just wrap `off` in `method` as we do it for other methods
	    // cause skipping a second or third argument will behave very differently
	    // than intended. This way we make sure all arguments are passed and only
	    // one listener is removed at most.
	    off(this, type, listener);
	    return this;
	  },
	  // but we can wrap `off` here, as the semantics are the same
	  off: chainable(method(off))

	});
	exports.EventTarget = EventTarget;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module)))

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	var _require = __webpack_require__(82);

	const flatten = _require.flatten;

	/**
	 * Merges all the properties of all arguments into first argument. If two or
	 * more argument objects have own properties with the same name, the property
	 * is overridden, with precedence from right to left, implying, that properties
	 * of the object on the left are overridden by a same named property of the
	 * object on the right.
	 *
	 * Any argument given with "falsy" value - commonly `null` and `undefined` in
	 * case of objects - are skipped.
	 *
	 * @examples
	 *    var a = { bar: 0, a: 'a' }
	 *    var b = merge(a, { foo: 'foo', bar: 1 }, { foo: 'bar', name: 'b' });
	 *    b === a   // true
	 *    b.a       // 'a'
	 *    b.foo     // 'bar'
	 *    b.bar     // 1
	 *    b.name    // 'b'
	 */

	function merge(source) {
	  let descriptor = {};

	  // `Boolean` converts the first parameter to a boolean value. Any object is
	  // converted to `true` where `null` and `undefined` becames `false`. Therefore
	  // the `filter` method will keep only objects that are defined and not null.
	  Array.slice(arguments, 1).filter(Boolean).forEach(function onEach(properties) {
	    getOwnPropertyIdentifiers(properties).forEach(function (name) {
	      descriptor[name] = Object.getOwnPropertyDescriptor(properties, name);
	    });
	  });
	  return Object.defineProperties(source, descriptor);
	}
	exports.merge = merge;

	/**
	 * Returns an object that inherits from the first argument and contains all the
	 * properties from all following arguments.
	 * `extend(source1, source2, source3)` is equivalent of
	 * `merge(Object.create(source1), source2, source3)`.
	 */
	function extend(source) {
	  let rest = Array.slice(arguments, 1);
	  rest.unshift(Object.create(source));
	  return merge.apply(null, rest);
	}
	exports.extend = extend;

	function has(obj, key) {
	  return obj.hasOwnProperty(key);
	}
	exports.has = has;

	function each(obj, fn) {
	  for (let key in obj) has(obj, key) && fn(obj[key], key, obj);
	}
	exports.each = each;

	/**
	 * Like `merge`, except no property descriptors are manipulated, for use
	 * with platform objects. Identical to underscore's `extend`. Useful for
	 * merging XPCOM objects
	 */
	function safeMerge(source) {
	  Array.slice(arguments, 1).forEach(function onEach(obj) {
	    for (let prop in obj) source[prop] = obj[prop];
	  });
	  return source;
	}
	exports.safeMerge = safeMerge;

	/*
	 * Returns a copy of the object without omitted properties
	 */
	function omit(source, ...values) {
	  let copy = {};
	  let keys = flatten(values);
	  for (let prop in source) if (! ~keys.indexOf(prop)) copy[prop] = source[prop];
	  return copy;
	}
	exports.omit = omit;

	// get object's own property Symbols and/or Names, including nonEnumerables by default
	function getOwnPropertyIdentifiers(object, options = { names: true, symbols: true, nonEnumerables: true }) {
	  const symbols = !options.symbols ? [] : Object.getOwnPropertySymbols(object);
	  const names = !options.names ? [] : options.nonEnumerables ? Object.getOwnPropertyNames(object) : Object.keys(object);
	  return [...names, ...symbols];
	}
	exports.getOwnPropertyIdentifiers = getOwnPropertyIdentifiers;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module)))

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "experimental"
	};

	/**
	 * Returns `true` if given `array` contain given `element` or `false`
	 * otherwise.
	 * @param {Array} array
	 *    Target array.
	 * @param {Object|String|Number|Boolean} element
	 *    Element being looked up.
	 * @returns {Boolean}
	 */
	var has = exports.has = function has(array, element) {
	  // shorter and faster equivalent of `array.indexOf(element) >= 0`
	  return !! ~array.indexOf(element);
	};
	var hasAny = exports.hasAny = function hasAny(array, elements) {
	  if (arguments.length < 2) return false;
	  if (!Array.isArray(elements)) elements = [elements];
	  return array.some(function (element) {
	    return has(elements, element);
	  });
	};

	/**
	 * Adds given `element` to the given `array` if it does not contain it yet.
	 * `true` is returned if element was added otherwise `false` is returned.
	 * @param {Array} array
	 *    Target array.
	 * @param {Object|String|Number|Boolean} element
	 *    Element to be added.
	 * @returns {Boolean}
	 */
	var add = exports.add = function add(array, element) {
	  var result;
	  if (result = !has(array, element)) array.push(element);

	  return result;
	};

	/**
	 * Removes first occurrence of the given `element` from the given `array`. If
	 * `array` does not contain given `element` `false` is returned otherwise
	 * `true` is returned.
	 * @param {Array} array
	 *    Target array.
	 * @param {Object|String|Number|Boolean} element
	 *    Element to be removed.
	 * @returns {Boolean}
	 */
	exports.remove = function remove(array, element) {
	  var result;
	  if (result = has(array, element)) array.splice(array.indexOf(element), 1);

	  return result;
	};

	/**
	 * Produces a duplicate-free version of the given `array`.
	 * @param {Array} array
	 *    Source array.
	 * @returns {Array}
	 */
	function unique(array) {
	  return array.reduce(function (result, item) {
	    add(result, item);
	    return result;
	  }, []);
	};
	exports.unique = unique;

	/**
	 * Produce an array that contains the union: each distinct element from all
	 * of the passed-in arrays.
	 */
	function union() {
	  return unique(Array.concat.apply(null, arguments));
	};
	exports.union = union;

	exports.flatten = function flatten(array) {
	  var flat = [];
	  for (var i = 0, l = array.length; i < l; i++) {
	    flat = flat.concat(Array.isArray(array[i]) ? flatten(array[i]) : array[i]);
	  }
	  return flat;
	};

	function fromIterator(iterator) {
	  let array = [];
	  if (iterator.__iterator__) {
	    for (let item of iterator) array.push(item);
	  } else {
	    for (let item of iterator) array.push(item);
	  }
	  return array;
	}
	exports.fromIterator = fromIterator;

	function find(array, predicate, fallback) {
	  var index = 0;
	  var count = array.length;
	  while (index < count) {
	    var value = array[index];
	    if (predicate(value)) return value;else index = index + 1;
	  }
	  return fallback;
	}
	exports.find = find;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module)))

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	var Cu = _require.Cu;
	/*var {DebuggerServer} = require("devtools/server/main");*/

	var promise = __webpack_require__(6);

	var _require2 = __webpack_require__(64);

	var Class = _require2.Class;

	var protocol = __webpack_require__(79);
	var method = protocol.method;
	var Arg = protocol.Arg;
	var Option = protocol.Option;
	var RetVal = protocol.RetVal;

	exports.LongStringActor = protocol.ActorClass({
	  typeName: "longstractor",

	  initialize: function (conn, str) {
	    protocol.Actor.prototype.initialize.call(this, conn);
	    this.str = str;
	    this.short = this.str.length < DebuggerServer.LONG_STRING_LENGTH;
	  },

	  destroy: function () {
	    this.str = null;
	    protocol.Actor.prototype.destroy.call(this);
	  },

	  form: function () {
	    if (this.short) {
	      return this.str;
	    }
	    return {
	      type: "longString",
	      actor: this.actorID,
	      length: this.str.length,
	      initial: this.str.substring(0, DebuggerServer.LONG_STRING_INITIAL_LENGTH)
	    };
	  },

	  substring: method(function (start, end) {
	    return promise.resolve(this.str.substring(start, end));
	  }, {
	    request: {
	      start: Arg(0),
	      end: Arg(1)
	    },
	    response: { substring: RetVal() }
	  }),

	  release: method(function () {}, { release: true })
	});

	/**
	 * When a LongString on the server is short enough to be passed
	 * as a full string, the client will get a ShortLongString instead of
	 * a LongStringFront.  Its API should match.
	 *
	 * I'm very proud of this name.
	 */
	exports.ShortLongString = Class({
	  initialize: function (str) {
	    this.str = str;
	  },

	  get length() {
	    return this.str.length;
	  },
	  get initial() {
	    return this.str;
	  },
	  string: function () {
	    return promise.resolve(this.str);
	  },

	  substring: function (start, end) {
	    return promise.resolve(this.str.substring(start, end));
	  },

	  release: function () {
	    this.str = null;
	    return promise.resolve(undefined);
	  }
	});

	exports.LongStringFront = protocol.FrontClass(exports.LongStringActor, {
	  initialize: function (client) {
	    protocol.Front.prototype.initialize.call(this, client);
	  },

	  destroy: function () {
	    this.initial = null;
	    this.length = null;
	    this.strPromise = null;
	    protocol.Front.prototype.destroy.call(this);
	  },

	  form: function (form) {
	    this.actorID = form.actor;
	    this.initial = form.initial;
	    this.length = form.length;
	  },

	  string: function () {
	    var _this = this;

	    if (!this.strPromise) {
	      let promiseRest = function (thusFar) {
	        if (thusFar.length === _this.length) return promise.resolve(thusFar);else {
	          return _this.substring(thusFar.length, thusFar.length + DebuggerServer.LONG_STRING_READ_LENGTH).then(function (next) {
	            return promiseRest(thusFar + next);
	          });
	        }
	      };

	      this.strPromise = promiseRest(this.initial);
	    }
	    return this.strPromise;
	  }
	});

	// The long string actor needs some custom marshalling, because it is sometimes
	// returned as a primitive rather than a complete form.

	var stringActorType = protocol.types.getType("longstractor");
	protocol.types.addType("longstring", {
	  _actor: true,
	  write: function (value, context, detail) {
	    if (!(context instanceof protocol.Actor)) {
	      throw Error("Passing a longstring as an argument isn't supported.");
	    }
	    if (value.short) {
	      return value.str;
	    } else {
	      return stringActorType.write(value, context, detail);
	    }
	  },
	  read: function (value, context, detail) {
	    if (context instanceof protocol.Actor) {
	      throw Error("Passing a longstring as an argument isn't supported.");
	    }
	    if (typeof value === "string") {
	      return exports.ShortLongString(value);
	    }
	    return stringActorType.read(value, context, detail);
	  }
	});

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = {
	  "ToolboxDebugger.label": "Debugger",
	  "ToolboxDebugger.panelLabel": "Debugger Panel",
	  "DebuggerWindowTitle": "Browser Debugger",
	  "DebuggerWindowScriptTitle": "Browser Debugger - %S",
	  "ToolboxDebugger.tooltip2": "JavaScript Debugger (%S)",
	  "debuggerMenu.commandkey": "S",
	  "debuggerMenu.accesskey": "D",
	  "collapsePanes": "Collapse panes",
	  "expandPanes": "Expand panes",
	  "pauseButtonTooltip": "Click to pause (%S)",
	  "pausePendingButtonTooltip": "Waiting for next execution",
	  "resumeButtonTooltip": "Click to resume (%S)",
	  "startTracingTooltip": "Click to start tracing",
	  "stopTracingTooltip": "Click to stop tracing",
	  "stepOverTooltip": "Step Over (%S)",
	  "stepInTooltip": "Step In (%S)",
	  "stepOutTooltip": "Step Out (%S)",
	  "noGlobalsText": "No globals",
	  "noWorkersText": "This page has no workers.",
	  "noSourcesText": "This page has no sources.",
	  "loadingSourcesText": "Waiting for sources…",
	  "noEventListenersText": "No event listeners to display",
	  "noStackFramesText": "No stack frames to display",
	  "noFunctionCallsText": "No function calls to display",
	  "tracingNotStartedText": "Tracing has not started",
	  "eventCheckboxTooltip": "Toggle breaking on this event",
	  "eventOnSelector": "on",
	  "eventInSource": "in",
	  "eventNodes": "%S nodes",
	  "eventNative": "[native code]",
	  "animationEvents": "Animation",
	  "audioEvents": "Audio",
	  "batteryEvents": "Battery",
	  "clipboardEvents": "Clipboard",
	  "compositionEvents": "Composition",
	  "deviceEvents": "Device",
	  "displayEvents": "Display",
	  "dragAndDropEvents": "Drag and Drop",
	  "gamepadEvents": "Gamepad",
	  "indexedDBEvents": "IndexedDB",
	  "interactionEvents": "Interaction",
	  "keyboardEvents": "Keyboard",
	  "mediaEvents": "HTML5 Media",
	  "mouseEvents": "Mouse",
	  "mutationEvents": "Mutation",
	  "navigationEvents": "Navigation",
	  "pointerLockEvents": "Pointer Lock",
	  "sensorEvents": "Sensor",
	  "storageEvents": "Storage",
	  "timeEvents": "Time",
	  "touchEvents": "Touch",
	  "otherEvents": "Other",
	  "blackBoxCheckboxTooltip": "Toggle black boxing",
	  "noMatchingStringsText": "No matches found",
	  "emptySearchText": "Search scripts (%S)",
	  "emptyChromeGlobalsFilterText": "Filter chrome globals (%S)",
	  "emptyVariablesFilterText": "Filter variables",
	  "emptyPropertiesFilterText": "Filter properties",
	  "searchPanelFilter": "Filter scripts (%S)",
	  "searchPanelGlobal": "Search in all files (%S)",
	  "searchPanelFunction": "Search for function definition (%S)",
	  "searchPanelToken": "Find in this file (%S)",
	  "searchPanelGoToLine": "Go to line (%S)",
	  "searchPanelVariable": "Filter variables (%S)",
	  "breakpointMenuItem.setConditional": "Configure conditional breakpoint",
	  "breakpointMenuItem.enableSelf": "Enable breakpoint",
	  "breakpointMenuItem.disableSelf": "Disable breakpoint",
	  "breakpointMenuItem.deleteSelf": "Remove breakpoint",
	  "breakpointMenuItem.enableOthers": "Enable others",
	  "breakpointMenuItem.disableOthers": "Disable others",
	  "breakpointMenuItem.deleteOthers": "Remove others",
	  "breakpointMenuItem.enableAll": "Enable all breakpoints",
	  "breakpointMenuItem.disableAll": "Disable all breakpoints",
	  "breakpointMenuItem.deleteAll": "Remove all breakpoints",
	  "loadingText": "Loading…",
	  "errorLoadingText2": "Error loading this URL: %S",
	  "addWatchExpressionText": "Add watch expression",
	  "addWatchExpressionButton": "Watch",
	  "emptyVariablesText": "No variables to display",
	  "scopeLabel": "%S scope",
	  "watchExpressionsScopeLabel": "Watch expressions",
	  "globalScopeLabel": "Global",
	  "variablesViewErrorStacktrace": "Stack trace:",
	  "variablesViewMoreObjects": "#1 more…;#1 more…",
	  "variablesEditableNameTooltip": "Double click to edit",
	  "variablesEditableValueTooltip": "Click to change value",
	  "variablesCloseButtonTooltip": "Click to remove",
	  "variablesEditButtonTooltip": "Click to set value",
	  "variablesDomNodeValueTooltip": "Click to select the node in the inspector",
	  "configurableTooltip": "configurable",
	  "enumerableTooltip": "enumerable",
	  "writableTooltip": "writable",
	  "frozenTooltip": "frozen",
	  "sealedTooltip": "sealed",
	  "extensibleTooltip": "extensible",
	  "overriddenTooltip": "overridden",
	  "WebIDLTooltip": "WebIDL",
	  "variablesSeparatorLabel": ":",
	  "watchExpressionsSeparatorLabel2": " →",
	  "functionSearchSeparatorLabel": "←",
	  "resumptionOrderPanelTitle": "There are one or more paused debuggers. Please resume the most-recently paused debugger first at: %S",
	  "variablesViewOptimizedOut": "(optimized away)",
	  "variablesViewUninitialized": "(uninitialized)",
	  "variablesViewMissingArgs": "(unavailable)",
	  "anonymousSourcesLabel": "Anonymous Sources"
	}

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	var _Components = Components;
	const Cc = _Components.classes;
	const Ci = _Components.interfaces;
	const Cu = _Components.utils;

	var _require = __webpack_require__(9);

	const Services = _require.Services;

	var _require2 = __webpack_require__(15);

	const XPCOMUtils = _require2.XPCOMUtils;

	var _require3 = __webpack_require__(70);

	const VariablesView = _require3.VariablesView;
	const escapeHTML = _require3.escapeHTML;

	var _require4 = __webpack_require__(60);

	const Heritage = _require4.Heritage;
	const ViewHelpers = _require4.ViewHelpers;
	const WidgetMethods = _require4.WidgetMethods;
	const setNamedTimeout = _require4.setNamedTimeout;
	const clearNamedTimeout = _require4.clearNamedTimeout;
	const setConditionalTimeout = _require4.setConditionalTimeout;
	const clearConditionalTimeout = _require4.clearConditionalTimeout;

	var promise = __webpack_require__(6);

	Object.defineProperty(this, "WebConsoleUtils", {
	  get: function () {
	    return __webpack_require__(72).Utils;
	  },
	  configurable: true,
	  enumerable: true
	});

	XPCOMUtils.defineLazyGetter(this, "VARIABLES_SORTING_ENABLED", function () {
	  return Services.prefs.getBoolPref("devtools.debugger.ui.variables-sorting-enabled");
	});

	const MAX_LONG_STRING_LENGTH = 200000;
	const MAX_PROPERTY_ITEMS = 2000;

	const ELLIPSIS = "…"; // Should be l10n'd

	/**
	 * Controller for a VariablesView that handles interfacing with the debugger
	 * protocol. Is able to populate scopes and variables via the protocol as well
	 * as manage actor lifespans.
	 *
	 * @param VariablesView aView
	 *        The view to attach to.
	 * @param object aOptions [optional]
	 *        Options for configuring the controller. Supported options:
	 *        - getObjectClient: @see this._setClientGetters
	 *        - getLongStringClient: @see this._setClientGetters
	 *        - getEnvironmentClient: @see this._setClientGetters
	 *        - releaseActor: @see this._setClientGetters
	 *        - overrideValueEvalMacro: @see _setEvaluationMacros
	 *        - getterOrSetterEvalMacro: @see _setEvaluationMacros
	 *        - simpleValueEvalMacro: @see _setEvaluationMacros
	 */
	function VariablesViewController(aView, aOptions = {}) {
	  this.addExpander = this.addExpander.bind(this);

	  this._setClientGetters(aOptions);
	  this._setEvaluationMacros(aOptions);

	  this._actors = new Set();
	  this.view = aView;
	  this.view.controller = this;
	}

	VariablesViewController.prototype = {
	  /**
	   * The default getter/setter evaluation macro.
	   */
	  _getterOrSetterEvalMacro: VariablesView.getterOrSetterEvalMacro,

	  /**
	   * The default override value evaluation macro.
	   */
	  _overrideValueEvalMacro: VariablesView.overrideValueEvalMacro,

	  /**
	   * The default simple value evaluation macro.
	   */
	  _simpleValueEvalMacro: VariablesView.simpleValueEvalMacro,

	  /**
	   * Set the functions used to retrieve debugger client grips.
	   *
	   * @param object aOptions
	   *        Options for getting the client grips. Supported options:
	   *        - getObjectClient: callback for creating an object grip client
	   *        - getLongStringClient: callback for creating a long string grip client
	   *        - getEnvironmentClient: callback for creating an environment client
	   *        - releaseActor: callback for releasing an actor when it's no longer needed
	   */
	  _setClientGetters: function (aOptions) {
	    if (aOptions.getObjectClient) {
	      this._getObjectClient = aOptions.getObjectClient;
	    }
	    if (aOptions.getLongStringClient) {
	      this._getLongStringClient = aOptions.getLongStringClient;
	    }
	    if (aOptions.getEnvironmentClient) {
	      this._getEnvironmentClient = aOptions.getEnvironmentClient;
	    }
	    if (aOptions.releaseActor) {
	      this._releaseActor = aOptions.releaseActor;
	    }
	  },

	  /**
	   * Sets the functions used when evaluating strings in the variables view.
	   *
	   * @param object aOptions
	   *        Options for configuring the macros. Supported options:
	   *        - overrideValueEvalMacro: callback for creating an overriding eval macro
	   *        - getterOrSetterEvalMacro: callback for creating a getter/setter eval macro
	   *        - simpleValueEvalMacro: callback for creating a simple value eval macro
	   */
	  _setEvaluationMacros: function (aOptions) {
	    if (aOptions.overrideValueEvalMacro) {
	      this._overrideValueEvalMacro = aOptions.overrideValueEvalMacro;
	    }
	    if (aOptions.getterOrSetterEvalMacro) {
	      this._getterOrSetterEvalMacro = aOptions.getterOrSetterEvalMacro;
	    }
	    if (aOptions.simpleValueEvalMacro) {
	      this._simpleValueEvalMacro = aOptions.simpleValueEvalMacro;
	    }
	  },

	  /**
	   * Populate a long string into a target using a grip.
	   *
	   * @param Variable aTarget
	   *        The target Variable/Property to put the retrieved string into.
	   * @param LongStringActor aGrip
	   *        The long string grip that use to retrieve the full string.
	   * @return Promise
	   *         The promise that will be resolved when the string is retrieved.
	   */
	  _populateFromLongString: function (aTarget, aGrip) {
	    var _this = this;

	    let deferred = promise.defer();

	    let from = aGrip.initial.length;
	    let to = Math.min(aGrip.length, MAX_LONG_STRING_LENGTH);

	    this._getLongStringClient(aGrip).substring(from, to, function (aResponse) {
	      // Stop tracking the actor because it's no longer needed.
	      _this.releaseActor(aGrip);

	      // Replace the preview with the full string and make it non-expandable.
	      aTarget.onexpand = null;
	      aTarget.setGrip(aGrip.initial + aResponse.substring);
	      aTarget.hideArrow();

	      deferred.resolve();
	    });

	    return deferred.promise;
	  },

	  /**
	   * Adds pseudo items in case there is too many properties to display.
	   * Each item can expand into property slices.
	   *
	   * @param Scope aTarget
	   *        The Scope where the properties will be placed into.
	   * @param object aGrip
	   *        The property iterator grip.
	   * @param object aIterator
	   *        The property iterator client.
	   */
	  _populatePropertySlices: function (aTarget, aGrip, aIterator) {
	    var _this2 = this;

	    if (aGrip.count < MAX_PROPERTY_ITEMS) {
	      return this._populateFromPropertyIterator(aTarget, aGrip);
	    }

	    // Divide the keys into quarters.
	    let items = Math.ceil(aGrip.count / 4);

	    let promises = [];
	    for (let i = 0; i < 4; i++) {
	      let start = aGrip.start + i * items;
	      let count = i != 3 ? items : aGrip.count - i * items;

	      // Create a new kind of grip, with additional fields to define the slice
	      let sliceGrip = {
	        type: "property-iterator",
	        propertyIterator: aIterator,
	        start: start,
	        count: count
	      };

	      // Query the name of the first and last items for this slice
	      let deferred = promise.defer();
	      aIterator.names([start, start + count - 1], function ({ names }) {
	        let label = "[" + names[0] + ELLIPSIS + names[1] + "]";
	        let item = aTarget.addItem(label);
	        item.showArrow();
	        _this2.addExpander(item, sliceGrip);
	        deferred.resolve();
	      });
	      promises.push(deferred.promise);
	    }

	    return promise.all(promises);
	  },

	  /**
	   * Adds a property slice for a Variable in the view using the already
	   * property iterator
	   *
	   * @param Scope aTarget
	   *        The Scope where the properties will be placed into.
	   * @param object aGrip
	   *        The property iterator grip.
	   */
	  _populateFromPropertyIterator: function (aTarget, aGrip) {
	    var _this3 = this;

	    if (aGrip.count >= MAX_PROPERTY_ITEMS) {
	      // We already started to split, but there is still too many properties, split again.
	      return this._populatePropertySlices(aTarget, aGrip, aGrip.propertyIterator);
	    }
	    // We started slicing properties, and the slice is now small enough to be displayed
	    let deferred = promise.defer();
	    aGrip.propertyIterator.slice(aGrip.start, aGrip.count, function ({ ownProperties }) {
	      // Add all the variable properties.
	      if (Object.keys(ownProperties).length > 0) {
	        aTarget.addItems(ownProperties, {
	          sorted: true,
	          // Expansion handlers must be set after the properties are added.
	          callback: _this3.addExpander
	        });
	      }
	      deferred.resolve();
	    });
	    return deferred.promise;
	  },

	  /**
	   * Adds the properties for a Variable in the view using a new feature in FF40+
	   * that allows iteration over properties in slices.
	   *
	   * @param Scope aTarget
	   *        The Scope where the properties will be placed into.
	   * @param object aGrip
	   *        The grip to use to populate the target.
	   * @param string aQuery [optional]
	   *        The query string used to fetch only a subset of properties
	   */
	  _populateFromObjectWithIterator: function (aTarget, aGrip, aQuery) {
	    var _this4 = this;

	    // FF40+ starts exposing `ownPropertyLength` on ObjectActor's grip,
	    // as well as `enumProperties` request.
	    let deferred = promise.defer();
	    let objectClient = this._getObjectClient(aGrip);
	    let isArray = aGrip.preview && aGrip.preview.kind === "ArrayLike";
	    if (isArray) {
	      // First enumerate array items, e.g. properties from `0` to `array.length`.
	      let options = {
	        ignoreNonIndexedProperties: true,
	        ignoreSafeGetters: true,
	        query: aQuery
	      };
	      objectClient.enumProperties(options, function ({ iterator }) {
	        let sliceGrip = {
	          type: "property-iterator",
	          propertyIterator: iterator,
	          start: 0,
	          count: iterator.count
	        };
	        _this4._populatePropertySlices(aTarget, sliceGrip, iterator).then(function () {
	          // Then enumerate the rest of the properties, like length, buffer, etc.
	          let options = {
	            ignoreIndexedProperties: true,
	            sort: true,
	            query: aQuery
	          };
	          objectClient.enumProperties(options, function ({ iterator }) {
	            let sliceGrip = {
	              type: "property-iterator",
	              propertyIterator: iterator,
	              start: 0,
	              count: iterator.count
	            };
	            deferred.resolve(_this4._populatePropertySlices(aTarget, sliceGrip, iterator));
	          });
	        });
	      });
	    } else {
	      // For objects, we just enumerate all the properties sorted by name.
	      objectClient.enumProperties({ sort: true, query: aQuery }, function ({ iterator }) {
	        let sliceGrip = {
	          type: "property-iterator",
	          propertyIterator: iterator,
	          start: 0,
	          count: iterator.count
	        };
	        deferred.resolve(_this4._populatePropertySlices(aTarget, sliceGrip, iterator));
	      });
	    }
	    return deferred.promise;
	  },

	  /**
	   * Adds the given prototype in the view.
	   *
	   * @param Scope aTarget
	   *        The Scope where the properties will be placed into.
	   * @param object aProtype
	   *        The prototype grip.
	   */
	  _populateObjectPrototype: function (aTarget, aPrototype) {
	    // Add the variable's __proto__.
	    if (aPrototype && aPrototype.type != "null") {
	      let proto = aTarget.addItem("__proto__", { value: aPrototype });
	      this.addExpander(proto, aPrototype);
	    }
	  },

	  /**
	   * Adds properties to a Scope, Variable, or Property in the view. Triggered
	   * when a scope is expanded or certain variables are hovered.
	   *
	   * @param Scope aTarget
	   *        The Scope where the properties will be placed into.
	   * @param object aGrip
	   *        The grip to use to populate the target.
	   */
	  _populateFromObject: function (aTarget, aGrip) {
	    var _this5 = this;

	    // Fetch properties by slices if there is too many in order to prevent UI freeze.
	    if ("ownPropertyLength" in aGrip && aGrip.ownPropertyLength >= MAX_PROPERTY_ITEMS) {
	      return this._populateFromObjectWithIterator(aTarget, aGrip).then(function () {
	        let deferred = promise.defer();
	        let objectClient = _this5._getObjectClient(aGrip);
	        objectClient.getPrototype(function ({ prototype }) {
	          _this5._populateObjectPrototype(aTarget, prototype);
	          deferred.resolve();
	        });
	        return deferred.promise;
	      });
	    }

	    if (aGrip.class === "Promise" && aGrip.promiseState) {
	      var _aGrip$promiseState = aGrip.promiseState;
	      const state = _aGrip$promiseState.state;
	      const value = _aGrip$promiseState.value;
	      const reason = _aGrip$promiseState.reason;

	      aTarget.addItem("<state>", { value: state });
	      if (state === "fulfilled") {
	        this.addExpander(aTarget.addItem("<value>", { value }), value);
	      } else if (state === "rejected") {
	        this.addExpander(aTarget.addItem("<reason>", { value: reason }), reason);
	      }
	    }
	    return this._populateProperties(aTarget, aGrip);
	  },

	  _populateProperties: function (aTarget, aGrip, aOptions) {
	    var _this6 = this;

	    let deferred = promise.defer();

	    let objectClient = this._getObjectClient(aGrip);
	    objectClient.getPrototypeAndProperties(function (aResponse) {
	      let ownProperties = aResponse.ownProperties || {};
	      let prototype = aResponse.prototype || null;
	      // 'safeGetterValues' is new and isn't necessary defined on old actors.
	      let safeGetterValues = aResponse.safeGetterValues || {};
	      let sortable = VariablesView.isSortable(aGrip.class);

	      // Merge the safe getter values into one object such that we can use it
	      // in VariablesView.
	      for (let name of Object.keys(safeGetterValues)) {
	        if (name in ownProperties) {
	          var _safeGetterValues$nam = safeGetterValues[name];
	          let getterValue = _safeGetterValues$nam.getterValue;
	          let getterPrototypeLevel = _safeGetterValues$nam.getterPrototypeLevel;

	          ownProperties[name].getterValue = getterValue;
	          ownProperties[name].getterPrototypeLevel = getterPrototypeLevel;
	        } else {
	          ownProperties[name] = safeGetterValues[name];
	        }
	      }

	      // Add all the variable properties.
	      aTarget.addItems(ownProperties, {
	        // Not all variables need to force sorted properties.
	        sorted: sortable,
	        // Expansion handlers must be set after the properties are added.
	        callback: _this6.addExpander
	      });

	      // Add the variable's __proto__.
	      _this6._populateObjectPrototype(aTarget, prototype);

	      // If the object is a function we need to fetch its scope chain
	      // to show them as closures for the respective function.
	      if (aGrip.class == "Function") {
	        objectClient.getScope(function (aResponse) {
	          if (aResponse.error) {
	            // This function is bound to a built-in object or it's not present
	            // in the current scope chain. Not necessarily an actual error,
	            // it just means that there's no closure for the function.
	            console.warn(aResponse.error + ": " + aResponse.message);
	            return void deferred.resolve();
	          }
	          _this6._populateWithClosure(aTarget, aResponse.scope).then(deferred.resolve);
	        });
	      } else {
	        deferred.resolve();
	      }
	    });

	    return deferred.promise;
	  },

	  /**
	   * Adds the scope chain elements (closures) of a function variable.
	   *
	   * @param Variable aTarget
	   *        The variable where the properties will be placed into.
	   * @param Scope aScope
	   *        The lexical environment form as specified in the protocol.
	   */
	  _populateWithClosure: function (aTarget, aScope) {
	    var _this7 = this;

	    let objectScopes = [];
	    let environment = aScope;
	    let funcScope = aTarget.addItem("<Closure>");
	    funcScope.target.setAttribute("scope", "");
	    funcScope.showArrow();

	    do {
	      // Create a scope to contain all the inspected variables.
	      let label = StackFrameUtils.getScopeLabel(environment);

	      // Block scopes may have the same label, so make addItem allow duplicates.
	      let closure = funcScope.addItem(label, undefined, true);
	      closure.target.setAttribute("scope", "");
	      closure.showArrow();

	      // Add nodes for every argument and every other variable in scope.
	      if (environment.bindings) {
	        this._populateWithEnvironmentBindings(closure, environment.bindings);
	      } else {
	        let deferred = promise.defer();
	        objectScopes.push(deferred.promise);
	        this._getEnvironmentClient(environment).getBindings(function (response) {
	          _this7._populateWithEnvironmentBindings(closure, response.bindings);
	          deferred.resolve();
	        });
	      }
	    } while (environment = environment.parent);

	    return promise.all(objectScopes).then(function () {
	      // Signal that scopes have been fetched.
	      _this7.view.emit("fetched", "scopes", funcScope);
	    });
	  },

	  /**
	   * Adds nodes for every specified binding to the closure node.
	   *
	   * @param Variable aTarget
	   *        The variable where the bindings will be placed into.
	   * @param object aBindings
	   *        The bindings form as specified in the protocol.
	   */
	  _populateWithEnvironmentBindings: function (aTarget, aBindings) {
	    // Add nodes for every argument in the scope.
	    aTarget.addItems(aBindings.arguments.reduce(function (accumulator, arg) {
	      let name = Object.getOwnPropertyNames(arg)[0];
	      let descriptor = arg[name];
	      accumulator[name] = descriptor;
	      return accumulator;
	    }, {}), {
	      // Arguments aren't sorted.
	      sorted: false,
	      // Expansion handlers must be set after the properties are added.
	      callback: this.addExpander
	    });

	    // Add nodes for every other variable in the scope.
	    aTarget.addItems(aBindings.variables, {
	      // Not all variables need to force sorted properties.
	      sorted: VARIABLES_SORTING_ENABLED,
	      // Expansion handlers must be set after the properties are added.
	      callback: this.addExpander
	    });
	  },

	  /**
	   * Adds an 'onexpand' callback for a variable, lazily handling
	   * the addition of new properties.
	   *
	   * @param Variable aTarget
	   *        The variable where the properties will be placed into.
	   * @param any aSource
	   *        The source to use to populate the target.
	   */
	  addExpander: function (aTarget, aSource) {
	    var _this8 = this;

	    // Attach evaluation macros as necessary.
	    if (aTarget.getter || aTarget.setter) {
	      aTarget.evaluationMacro = this._overrideValueEvalMacro;
	      let getter = aTarget.get("get");
	      if (getter) {
	        getter.evaluationMacro = this._getterOrSetterEvalMacro;
	      }
	      let setter = aTarget.get("set");
	      if (setter) {
	        setter.evaluationMacro = this._getterOrSetterEvalMacro;
	      }
	    } else {
	      aTarget.evaluationMacro = this._simpleValueEvalMacro;
	    }

	    // If the source is primitive then an expander is not needed.
	    if (VariablesView.isPrimitive({ value: aSource })) {
	      return;
	    }

	    // If the source is a long string then show the arrow.
	    if (WebConsoleUtils.isActorGrip(aSource) && aSource.type == "longString") {
	      aTarget.showArrow();
	    }

	    // Make sure that properties are always available on expansion.
	    aTarget.onexpand = function () {
	      return _this8.populate(aTarget, aSource);
	    };

	    // Some variables are likely to contain a very large number of properties.
	    // It's a good idea to be prepared in case of an expansion.
	    if (aTarget.shouldPrefetch) {
	      aTarget.addEventListener("mouseover", aTarget.onexpand, false);
	    }

	    // Register all the actors that this controller now depends on.
	    for (let grip of [aTarget.value, aTarget.getter, aTarget.setter]) {
	      if (WebConsoleUtils.isActorGrip(grip)) {
	        this._actors.add(grip.actor);
	      }
	    }
	  },

	  /**
	   * Adds properties to a Scope, Variable, or Property in the view. Triggered
	   * when a scope is expanded or certain variables are hovered.
	   *
	   * This does not expand the target, it only populates it.
	   *
	   * @param Scope aTarget
	   *        The Scope to be expanded.
	   * @param object aSource
	   *        The source to use to populate the target.
	   * @return Promise
	   *         The promise that is resolved once the target has been expanded.
	   */
	  populate: function (aTarget, aSource) {
	    var _this9 = this;

	    // Fetch the variables only once.
	    if (aTarget._fetched) {
	      return aTarget._fetched;
	    }
	    // Make sure the source grip is available.
	    if (!aSource) {
	      return promise.reject(new Error("No actor grip was given for the variable."));
	    }

	    let deferred = promise.defer();
	    aTarget._fetched = deferred.promise;

	    if (aSource.type === "property-iterator") {
	      return this._populateFromPropertyIterator(aTarget, aSource);
	    }

	    // If the target is a Variable or Property then we're fetching properties.
	    if (VariablesView.isVariable(aTarget)) {
	      this._populateFromObject(aTarget, aSource).then(function () {
	        // Signal that properties have been fetched.
	        _this9.view.emit("fetched", "properties", aTarget);
	        // Commit the hierarchy because new items were added.
	        _this9.view.commitHierarchy();
	        deferred.resolve();
	      });
	      return deferred.promise;
	    }

	    switch (aSource.type) {
	      case "longString":
	        this._populateFromLongString(aTarget, aSource).then(function () {
	          // Signal that a long string has been fetched.
	          _this9.view.emit("fetched", "longString", aTarget);
	          deferred.resolve();
	        });
	        break;
	      case "with":
	      case "object":
	        this._populateFromObject(aTarget, aSource.object).then(function () {
	          // Signal that variables have been fetched.
	          _this9.view.emit("fetched", "variables", aTarget);
	          // Commit the hierarchy because new items were added.
	          _this9.view.commitHierarchy();
	          deferred.resolve();
	        });
	        break;
	      case "block":
	      case "function":
	        this._populateWithEnvironmentBindings(aTarget, aSource.bindings);
	        // No need to signal that variables have been fetched, since
	        // the scope arguments and variables are already attached to the
	        // environment bindings, so pausing the active thread is unnecessary.
	        // Commit the hierarchy because new items were added.
	        this.view.commitHierarchy();
	        deferred.resolve();
	        break;
	      default:
	        let error = "Unknown Debugger.Environment type: " + aSource.type;
	        Cu.reportError(error);
	        deferred.reject(error);
	    }

	    return deferred.promise;
	  },

	  /**
	   * Indicates to the view if the targeted actor supports properties search
	   *
	   * @return boolean True, if the actor supports enumProperty request
	   */
	  supportsSearch: function () {
	    // FF40+ starts exposing ownPropertyLength on object actor's grip
	    // as well as enumProperty which allows to query a subset of properties.
	    return this.objectActor && "ownPropertyLength" in this.objectActor;
	  },

	  /**
	   * Try to use the actor to perform an attribute search.
	   *
	   * @param Scope aScope
	   *        The Scope instance to populate with properties
	   * @param string aToken
	   *        The query string
	   */
	  performSearch: function (aScope, aToken) {
	    var _this10 = this;

	    this._populateFromObjectWithIterator(aScope, this.objectActor, aToken).then(function () {
	      _this10.view.emit("fetched", "search", aScope);
	    });
	  },

	  /**
	   * Release an actor from the controller.
	   *
	   * @param object aActor
	   *        The actor to release.
	   */
	  releaseActor: function (aActor) {
	    if (this._releaseActor) {
	      this._releaseActor(aActor);
	    }
	    this._actors.delete(aActor);
	  },

	  /**
	   * Release all the actors referenced by the controller, optionally filtered.
	   *
	   * @param function aFilter [optional]
	   *        Callback to filter which actors are released.
	   */
	  releaseActors: function (aFilter) {
	    for (let actor of this._actors) {
	      if (!aFilter || aFilter(actor)) {
	        this.releaseActor(actor);
	      }
	    }
	  },

	  /**
	   * Helper function for setting up a single Scope with a single Variable
	   * contained within it.
	   *
	   * This function will empty the variables view.
	   *
	   * @param object aOptions
	   *        Options for the contents of the view:
	   *        - objectActor: the grip of the new ObjectActor to show.
	   *        - rawObject: the raw object to show.
	   *        - label: the label for the inspected object.
	   * @param object aConfiguration
	   *        Additional options for the controller:
	   *        - overrideValueEvalMacro: @see _setEvaluationMacros
	   *        - getterOrSetterEvalMacro: @see _setEvaluationMacros
	   *        - simpleValueEvalMacro: @see _setEvaluationMacros
	   * @return Object
	   *         - variable: the created Variable.
	   *         - expanded: the Promise that resolves when the variable expands.
	   */
	  setSingleVariable: function (aOptions, aConfiguration = {}) {
	    this._setEvaluationMacros(aConfiguration);
	    this.view.empty();

	    let scope = this.view.addScope(aOptions.label);
	    scope.expanded = true; // Expand the scope by default.
	    scope.locked = true; // Prevent collapsing the scope.

	    let variable = scope.addItem("", { enumerable: true });
	    let populated;

	    if (aOptions.objectActor) {
	      // Save objectActor for properties filtering
	      this.objectActor = aOptions.objectActor;
	      populated = this.populate(variable, aOptions.objectActor);
	      variable.expand();
	    } else if (aOptions.rawObject) {
	      variable.populate(aOptions.rawObject, { expanded: true });
	      populated = promise.resolve();
	    }

	    return { variable: variable, expanded: populated };
	  }
	};

	/**
	 * Attaches a VariablesViewController to a VariablesView if it doesn't already
	 * have one.
	 *
	 * @param VariablesView aView
	 *        The view to attach to.
	 * @param object aOptions
	 *        The options to use in creating the controller.
	 * @return VariablesViewController
	 */
	VariablesViewController.attach = function (aView, aOptions) {
	  if (aView.controller) {
	    return aView.controller;
	  }
	  return new VariablesViewController(aView, aOptions);
	};

	/**
	 * Utility functions for handling stackframes.
	 */
	var StackFrameUtils = {
	  /**
	   * Create a textual representation for the specified stack frame
	   * to display in the stackframes container.
	   *
	   * @param object aFrame
	   *        The stack frame to label.
	   */
	  getFrameTitle: function (aFrame) {
	    if (aFrame.type == "call") {
	      let c = aFrame.callee;
	      return c.name || c.userDisplayName || c.displayName || "(anonymous)";
	    }
	    return "(" + aFrame.type + ")";
	  },

	  /**
	   * Constructs a scope label based on its environment.
	   *
	   * @param object aEnv
	   *        The scope's environment.
	   * @return string
	   *         The scope's label.
	   */
	  getScopeLabel: function (aEnv) {
	    let name = "";

	    // Name the outermost scope Global.
	    if (!aEnv.parent) {
	      name = L10N.getStr("globalScopeLabel");
	    }
	    // Otherwise construct the scope name.
	    else {
	        name = aEnv.type.charAt(0).toUpperCase() + aEnv.type.slice(1);
	      }

	    let label = L10N.getFormatStr("scopeLabel", name);
	    switch (aEnv.type) {
	      case "with":
	      case "object":
	        label += " [" + aEnv.object.class + "]";
	        break;
	      case "function":
	        let f = aEnv.function;
	        label += " [" + (f.name || f.userDisplayName || f.displayName || "(anonymous)") + "]";
	        break;
	    }
	    return label;
	  }
	};

	/**
	 * Localization convenience methods.
	 */
	var L10N = new ViewHelpers.L10N(__webpack_require__(84));

	exports.VariablesViewController = this.VariablesViewController;
	exports.StackFrameUtils = this.StackFrameUtils;

/***/ },
/* 86 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict"

	/**
	 * This module contains a small element attribute value parser. It's primary
	 * goal is to extract link information from attribute values (like the href in
	 * <a href="/some/link.html"> for example).
	 *
	 * There are several types of linkable attribute values:
	 * - TYPE_URI: a URI (e.g. <a href="uri">).
	 * - TYPE_URI_LIST: a space separated list of URIs (e.g. <a ping="uri1 uri2">).
	 * - TYPE_IDREF: a reference to an other element in the same document via its id
	 *   (e.g. <label for="input-id"> or <key command="command-id">).
	 * - TYPE_IDREF_LIST: a space separated list of IDREFs (e.g.
	 *   <output for="id1 id2">).
	 * - TYPE_JS_RESOURCE_URI: a URI to a javascript resource that can be opened in
	 *   the devtools (e.g. <script src="uri">).
	 * - TYPE_CSS_RESOURCE_URI: a URI to a css resource that can be opened in the
	 *   devtools (e.g. <link href="uri">).
	 *
	 * parseAttribute is the parser entry function, exported on this module.
	 */

	;
	const TYPE_STRING = "string";
	const TYPE_URI = "uri";
	const TYPE_URI_LIST = "uriList";
	const TYPE_IDREF = "idref";
	const TYPE_IDREF_LIST = "idrefList";
	const TYPE_JS_RESOURCE_URI = "jsresource";
	const TYPE_CSS_RESOURCE_URI = "cssresource";

	const SVG_NS = "http://www.w3.org/2000/svg";
	const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
	const HTML_NS = "http://www.w3.org/1999/xhtml";

	const ATTRIBUTE_TYPES = [{ namespaceURI: HTML_NS, attributeName: "action", tagName: "form", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "background", tagName: "body", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "cite", tagName: "blockquote", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "cite", tagName: "q", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "cite", tagName: "del", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "cite", tagName: "ins", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "classid", tagName: "object", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "codebase", tagName: "object", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "codebase", tagName: "applet", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "command", tagName: "menuitem", type: TYPE_IDREF }, { namespaceURI: "*", attributeName: "contextmenu", tagName: "*", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "data", tagName: "object", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "for", tagName: "label", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "for", tagName: "output", type: TYPE_IDREF_LIST }, { namespaceURI: HTML_NS, attributeName: "form", tagName: "button", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "form", tagName: "fieldset", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "form", tagName: "input", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "form", tagName: "keygen", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "form", tagName: "label", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "form", tagName: "object", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "form", tagName: "output", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "form", tagName: "select", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "form", tagName: "textarea", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "formaction", tagName: "button", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "formaction", tagName: "input", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "headers", tagName: "td", type: TYPE_IDREF_LIST }, { namespaceURI: HTML_NS, attributeName: "headers", tagName: "th", type: TYPE_IDREF_LIST }, { namespaceURI: HTML_NS, attributeName: "href", tagName: "a", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "href", tagName: "area", type: TYPE_URI }, { namespaceURI: "*", attributeName: "href", tagName: "link", type: TYPE_CSS_RESOURCE_URI,
	  isValid: function (namespaceURI, tagName, attributes) {
	    return getAttribute(attributes, "rel") === "stylesheet";
	  } }, { namespaceURI: "*", attributeName: "href", tagName: "link", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "href", tagName: "base", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "icon", tagName: "menuitem", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "list", tagName: "input", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "img", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "frame", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "iframe", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "manifest", tagName: "html", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "menu", tagName: "button", type: TYPE_IDREF }, { namespaceURI: HTML_NS, attributeName: "ping", tagName: "a", type: TYPE_URI_LIST }, { namespaceURI: HTML_NS, attributeName: "ping", tagName: "area", type: TYPE_URI_LIST }, { namespaceURI: HTML_NS, attributeName: "poster", tagName: "video", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "profile", tagName: "head", type: TYPE_URI }, { namespaceURI: "*", attributeName: "src", tagName: "script", type: TYPE_JS_RESOURCE_URI }, { namespaceURI: HTML_NS, attributeName: "src", tagName: "input", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "src", tagName: "frame", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "src", tagName: "iframe", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "src", tagName: "img", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "src", tagName: "audio", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "src", tagName: "embed", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "src", tagName: "source", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "src", tagName: "track", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "src", tagName: "video", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "usemap", tagName: "img", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "usemap", tagName: "input", type: TYPE_URI }, { namespaceURI: HTML_NS, attributeName: "usemap", tagName: "object", type: TYPE_URI }, { namespaceURI: "*", attributeName: "xmlns", tagName: "*", type: TYPE_URI }, { namespaceURI: XUL_NS, attributeName: "command", tagName: "key", type: TYPE_IDREF }, { namespaceURI: XUL_NS, attributeName: "containment", tagName: "*", type: TYPE_URI }, { namespaceURI: XUL_NS, attributeName: "context", tagName: "*", type: TYPE_IDREF }, { namespaceURI: XUL_NS, attributeName: "datasources", tagName: "*", type: TYPE_URI_LIST }, { namespaceURI: XUL_NS, attributeName: "insertafter", tagName: "*", type: TYPE_IDREF }, { namespaceURI: XUL_NS, attributeName: "insertbefore", tagName: "*", type: TYPE_IDREF }, { namespaceURI: XUL_NS, attributeName: "menu", tagName: "*", type: TYPE_IDREF }, { namespaceURI: XUL_NS, attributeName: "observes", tagName: "*", type: TYPE_IDREF }, { namespaceURI: XUL_NS, attributeName: "popup", tagName: "*", type: TYPE_IDREF }, { namespaceURI: XUL_NS, attributeName: "ref", tagName: "*", type: TYPE_URI }, { namespaceURI: XUL_NS, attributeName: "removeelement", tagName: "*", type: TYPE_IDREF }, { namespaceURI: XUL_NS, attributeName: "sortResource", tagName: "*", type: TYPE_URI }, { namespaceURI: XUL_NS, attributeName: "sortResource2", tagName: "*", type: TYPE_URI }, { namespaceURI: XUL_NS, attributeName: "src", tagName: "stringbundle", type: TYPE_URI }, { namespaceURI: XUL_NS, attributeName: "template", tagName: "*", type: TYPE_IDREF }, { namespaceURI: XUL_NS, attributeName: "tooltip", tagName: "*", type: TYPE_IDREF }];

	// SVG links aren't handled yet, see bug 1158831.
	// {namespaceURI: SVG_NS, attributeName: "fill", tagName: "*", type: },
	// {namespaceURI: SVG_NS, attributeName: "stroke", tagName: "*", type: },
	// {namespaceURI: SVG_NS, attributeName: "markerstart", tagName: "*", type: },
	// {namespaceURI: SVG_NS, attributeName: "markermid", tagName: "*", type: },
	// {namespaceURI: SVG_NS, attributeName: "markerend", tagName: "*", type: },
	// {namespaceURI: SVG_NS, attributeName: "xlink:href", tagName: "*", type: }
	var parsers = {
	  [TYPE_URI]: function (attributeValue) {
	    return [{
	      type: TYPE_URI,
	      value: attributeValue
	    }];
	  },
	  [TYPE_URI_LIST]: function (attributeValue) {
	    let data = splitBy(attributeValue, " ");
	    for (let token of data) {
	      if (!token.type) {
	        token.type = TYPE_URI;
	      }
	    }
	    return data;
	  },
	  [TYPE_JS_RESOURCE_URI]: function (attributeValue) {
	    return [{
	      type: TYPE_JS_RESOURCE_URI,
	      value: attributeValue
	    }];
	  },
	  [TYPE_CSS_RESOURCE_URI]: function (attributeValue) {
	    return [{
	      type: TYPE_CSS_RESOURCE_URI,
	      value: attributeValue
	    }];
	  },
	  [TYPE_IDREF]: function (attributeValue) {
	    return [{
	      type: TYPE_IDREF,
	      value: attributeValue
	    }];
	  },
	  [TYPE_IDREF_LIST]: function (attributeValue) {
	    let data = splitBy(attributeValue, " ");
	    for (let token of data) {
	      if (!token.type) {
	        token.type = TYPE_IDREF;
	      }
	    }
	    return data;
	  }
	};

	/**
	 * Parse an attribute value.
	 * @param {String} namespaceURI The namespaceURI of the node that has the
	 * attribute.
	 * @param {String} tagName The tagName of the node that has the attribute.
	 * @param {Array} attributes The list of all attributes of the node. This should
	 * be an array of {name, value} objects.
	 * @param {String} attributeName The name of the attribute to parse.
	 * @return {Array} An array of tokens that represents the value. Each token is
	 * an object {type: [string|uri|jsresource|cssresource|idref], value}.
	 * For instance parsing the ping attribute in <a ping="uri1 uri2"> returns:
	 * [
	 *   {type: "uri", value: "uri2"},
	 *   {type: "string", value: " "},
	 *   {type: "uri", value: "uri1"}
	 * ]
	 */
	function parseAttribute(namespaceURI, tagName, attributes, attributeName) {
	  if (!hasAttribute(attributes, attributeName)) {
	    throw new Error(`Attribute ${ attributeName } isn't part of the provided attributes`);
	  }

	  let type = getType(namespaceURI, tagName, attributes, attributeName);
	  if (!type) {
	    return [{
	      type: TYPE_STRING,
	      value: getAttribute(attributes, attributeName)
	    }];
	  }

	  return parsers[type](getAttribute(attributes, attributeName));
	}

	/**
	 * Get the type for links in this attribute if any.
	 * @param {String} namespaceURI The node's namespaceURI.
	 * @param {String} tagName The node's tagName.
	 * @param {Array} attributes The node's attributes, as a list of {name, value}
	 * objects.
	 * @param {String} attributeName The name of the attribute to get the type for.
	 * @return {Object} null if no type exist for this attribute on this node, the
	 * type object otherwise.
	 */
	function getType(namespaceURI, tagName, attributes, attributeName) {
	  for (let typeData of ATTRIBUTE_TYPES) {
	    let hasAttribute = attributeName === typeData.attributeName || typeData.attributeName === "*";
	    let hasNamespace = namespaceURI === typeData.namespaceURI || typeData.namespaceURI === "*";
	    let hasTagName = tagName.toLowerCase() === typeData.tagName || typeData.tagName === "*";
	    let isValid = typeData.isValid ? typeData.isValid(namespaceURI, tagName, attributes, attributeName) : true;

	    if (hasAttribute && hasNamespace && hasTagName && isValid) {
	      return typeData.type;
	    }
	  }

	  return null;
	}

	function getAttribute(attributes, attributeName) {
	  for (let _ref of attributes) {
	    let name = _ref.name;
	    let value = _ref.value;

	    if (name === attributeName) {
	      return value;
	    }
	  }
	  return null;
	}

	function hasAttribute(attributes, attributeName) {
	  for (let _ref2 of attributes) {
	    let name = _ref2.name;
	    let value = _ref2.value;

	    if (name === attributeName) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Split a string by a given character and return an array of objects parts.
	 * The array will contain objects for the split character too, marked with
	 * TYPE_STRING type.
	 * @param {String} value The string to parse.
	 * @param {String} splitChar A 1 length split character.
	 * @return {Array}
	 */
	function splitBy(value, splitChar) {
	  let data = [],
	      i = 0,
	      buffer = "";
	  while (i <= value.length) {
	    if (i === value.length && buffer) {
	      data.push({ value: buffer });
	    }
	    if (value[i] === splitChar) {
	      if (buffer) {
	        data.push({ value: buffer });
	      }
	      data.push({
	        type: TYPE_STRING,
	        value: splitChar
	      });
	      buffer = "";
	    } else {
	      buffer += value[i];
	    }

	    i++;
	  }
	  return data;
	}

	exports.parseAttribute = parseAttribute;
	// Exported for testing only.
	exports.splitBy = splitBy;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/*
	 * Copyright 2012, Mozilla Foundation and contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	/**
	 * For full documentation, see:
	 * https://github.com/mozilla/domtemplate/blob/master/README.md
	 */

	/**
	 * Begin a new templating process.
	 * @param node A DOM element or string referring to an element's id
	 * @param data Data to use in filling out the template
	 * @param options Options to customize the template processing. One of:
	 * - allowEval: boolean (default false) Basic template interpolations are
	 *   either property paths (e.g. ${a.b.c.d}), or if allowEval=true then we
	 *   allow arbitrary JavaScript
	 * - stack: string or array of strings (default empty array) The template
	 *   engine maintains a stack of tasks to help debug where it is. This allows
	 *   this stack to be prefixed with a template name
	 * - blankNullUndefined: By default DOMTemplate exports null and undefined
	 *   values using the strings 'null' and 'undefined', which can be helpful for
	 *   debugging, but can introduce unnecessary extra logic in a template to
	 *   convert null/undefined to ''. By setting blankNullUndefined:true, this
	 *   conversion is handled by DOMTemplate
	 */
	var template = function (node, data, options) {
	  var state = {
	    options: options || {},
	    // We keep a track of the nodes that we've passed through so we can keep
	    // data.__element pointing to the correct node
	    nodes: []
	  };

	  state.stack = state.options.stack;

	  if (!Array.isArray(state.stack)) {
	    if (typeof state.stack === 'string') {
	      state.stack = [options.stack];
	    } else {
	      state.stack = [];
	    }
	  }

	  processNode(state, node, data);
	};

	if (true) {
	  exports.template = template;
	}
	this.template = template;

	/**
	 * Helper for the places where we need to act asynchronously and keep track of
	 * where we are right now
	 */
	function cloneState(state) {
	  return {
	    options: state.options,
	    stack: state.stack.slice(),
	    nodes: state.nodes.slice()
	  };
	}

	/**
	 * Regex used to find ${...} sections in some text.
	 * Performance note: This regex uses ( and ) to capture the 'script' for
	 * further processing. Not all of the uses of this regex use this feature so
	 * if use of the capturing group is a performance drain then we should split
	 * this regex in two.
	 */
	var TEMPLATE_REGION = /\$\{([^}]*)\}/g;

	/**
	 * Recursive function to walk the tree processing the attributes as it goes.
	 * @param node the node to process. If you pass a string in instead of a DOM
	 * element, it is assumed to be an id for use with document.getElementById()
	 * @param data the data to use for node processing.
	 */
	function processNode(state, node, data) {
	  if (typeof node === 'string') {
	    node = document.getElementById(node);
	  }
	  if (data == null) {
	    data = {};
	  }
	  state.stack.push(node.nodeName + (node.id ? '#' + node.id : ''));
	  var pushedNode = false;
	  try {
	    // Process attributes
	    if (node.attributes && node.attributes.length) {
	      // We need to handle 'foreach' and 'if' first because they might stop
	      // some types of processing from happening, and foreach must come first
	      // because it defines new data on which 'if' might depend.
	      if (node.hasAttribute('foreach')) {
	        processForEach(state, node, data);
	        return;
	      }
	      if (node.hasAttribute('if')) {
	        if (!processIf(state, node, data)) {
	          return;
	        }
	      }
	      // Only make the node available once we know it's not going away
	      state.nodes.push(data.__element);
	      data.__element = node;
	      pushedNode = true;
	      // It's good to clean up the attributes when we've processed them,
	      // but if we do it straight away, we mess up the array index
	      var attrs = Array.prototype.slice.call(node.attributes);
	      for (var i = 0; i < attrs.length; i++) {
	        var value = attrs[i].value;
	        var name = attrs[i].name;

	        state.stack.push(name);
	        try {
	          if (name === 'save') {
	            // Save attributes are a setter using the node
	            value = stripBraces(state, value);
	            property(state, value, data, node);
	            node.removeAttribute('save');
	          } else if (name.substring(0, 2) === 'on') {
	            // If this attribute value contains only an expression
	            if (value.substring(0, 2) === '${' && value.slice(-1) === '}' && value.indexOf('${', 2) === -1) {
	              value = stripBraces(state, value);
	              var func = property(state, value, data);
	              if (typeof func === 'function') {
	                node.removeAttribute(name);
	                var capture = node.hasAttribute('capture' + name.substring(2));
	                node.addEventListener(name.substring(2), func, capture);
	                if (capture) {
	                  node.removeAttribute('capture' + name.substring(2));
	                }
	              } else {
	                // Attribute value is not a function - use as a DOM-L0 string
	                node.setAttribute(name, func);
	              }
	            } else {
	              // Attribute value is not a single expression use as DOM-L0
	              node.setAttribute(name, processString(state, value, data));
	            }
	          } else {
	            node.removeAttribute(name);
	            // Remove '_' prefix of attribute names so the DOM won't try
	            // to use them before we've processed the template
	            if (name.charAt(0) === '_') {
	              name = name.substring(1);
	            }

	            // Async attributes can only work if the whole attribute is async
	            var replacement;
	            if (value.indexOf('${') === 0 && value.charAt(value.length - 1) === '}') {
	              replacement = envEval(state, value.slice(2, -1), data, value);
	              if (replacement && typeof replacement.then === 'function') {
	                node.setAttribute(name, '');
	                /* jshint loopfunc:true */
	                replacement.then(function (newValue) {
	                  node.setAttribute(name, newValue);
	                }).then(null, console.error);
	              } else {
	                if (state.options.blankNullUndefined && replacement == null) {
	                  replacement = '';
	                }
	                node.setAttribute(name, replacement);
	              }
	            } else {
	              node.setAttribute(name, processString(state, value, data));
	            }
	          }
	        } finally {
	          state.stack.pop();
	        }
	      }
	    }

	    // Loop through our children calling processNode. First clone them, so the
	    // set of nodes that we visit will be unaffected by additions or removals.
	    var childNodes = Array.prototype.slice.call(node.childNodes);
	    for (var j = 0; j < childNodes.length; j++) {
	      processNode(state, childNodes[j], data);
	    }

	    if (node.nodeType === 3 /*Node.TEXT_NODE*/) {
	        processTextNode(state, node, data);
	      }
	  } finally {
	    if (pushedNode) {
	      data.__element = state.nodes.pop();
	    }
	    state.stack.pop();
	  }
	}

	/**
	 * Handle attribute values where the output can only be a string
	 */
	function processString(state, value, data) {
	  return value.replace(TEMPLATE_REGION, function (path) {
	    var insert = envEval(state, path.slice(2, -1), data, value);
	    return state.options.blankNullUndefined && insert == null ? '' : insert;
	  });
	}

	/**
	 * Handle <x if="${...}">
	 * @param node An element with an 'if' attribute
	 * @param data The data to use with envEval()
	 * @returns true if processing should continue, false otherwise
	 */
	function processIf(state, node, data) {
	  state.stack.push('if');
	  try {
	    var originalValue = node.getAttribute('if');
	    var value = stripBraces(state, originalValue);
	    var recurse = true;
	    try {
	      var reply = envEval(state, value, data, originalValue);
	      recurse = !!reply;
	    } catch (ex) {
	      handleError(state, 'Error with \'' + value + '\'', ex);
	      recurse = false;
	    }
	    if (!recurse) {
	      node.parentNode.removeChild(node);
	    }
	    node.removeAttribute('if');
	    return recurse;
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Handle <x foreach="param in ${array}"> and the special case of
	 * <loop foreach="param in ${array}">.
	 * This function is responsible for extracting what it has to do from the
	 * attributes, and getting the data to work on (including resolving promises
	 * in getting the array). It delegates to processForEachLoop to actually
	 * unroll the data.
	 * @param node An element with a 'foreach' attribute
	 * @param data The data to use with envEval()
	 */
	function processForEach(state, node, data) {
	  state.stack.push('foreach');
	  try {
	    var originalValue = node.getAttribute('foreach');
	    var value = originalValue;

	    var paramName = 'param';
	    if (value.charAt(0) === '$') {
	      // No custom loop variable name. Use the default: 'param'
	      value = stripBraces(state, value);
	    } else {
	      // Extract the loop variable name from 'NAME in ${ARRAY}'
	      var nameArr = value.split(' in ');
	      paramName = nameArr[0].trim();
	      value = stripBraces(state, nameArr[1].trim());
	    }
	    node.removeAttribute('foreach');
	    try {
	      var evaled = envEval(state, value, data, originalValue);
	      var cState = cloneState(state);
	      handleAsync(evaled, node, function (reply, siblingNode) {
	        processForEachLoop(cState, reply, node, siblingNode, data, paramName);
	      });
	      node.parentNode.removeChild(node);
	    } catch (ex) {
	      handleError(state, 'Error with \'' + value + '\'', ex);
	    }
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Called by processForEach to handle looping over the data in a foreach loop.
	 * This works with both arrays and objects.
	 * Calls processForEachMember() for each member of 'set'
	 * @param set The object containing the data to loop over
	 * @param templNode The node to copy for each set member
	 * @param sibling The sibling node to which we add things
	 * @param data the data to use for node processing
	 * @param paramName foreach loops have a name for the parameter currently being
	 * processed. The default is 'param'. e.g. <loop foreach="param in ${x}">...
	 */
	function processForEachLoop(state, set, templNode, sibling, data, paramName) {
	  if (Array.isArray(set)) {
	    set.forEach(function (member, i) {
	      processForEachMember(state, member, templNode, sibling, data, paramName, '' + i);
	    });
	  } else {
	    for (var member in set) {
	      if (set.hasOwnProperty(member)) {
	        processForEachMember(state, member, templNode, sibling, data, paramName, member);
	      }
	    }
	  }
	}

	/**
	 * Called by processForEachLoop() to resolve any promises in the array (the
	 * array itself can also be a promise, but that is resolved by
	 * processForEach()). Handle <LOOP> elements (which are taken out of the DOM),
	 * clone the template node, and pass the processing on to processNode().
	 * @param member The data item to use in templating
	 * @param templNode The node to copy for each set member
	 * @param siblingNode The parent node to which we add things
	 * @param data the data to use for node processing
	 * @param paramName The name given to 'member' by the foreach attribute
	 * @param frame A name to push on the stack for debugging
	 */
	function processForEachMember(state, member, templNode, siblingNode, data, paramName, frame) {
	  state.stack.push(frame);
	  try {
	    var cState = cloneState(state);
	    handleAsync(member, siblingNode, function (reply, node) {
	      // Clone data because we can't be sure that we can safely mutate it
	      var newData = Object.create(null);
	      Object.keys(data).forEach(function (key) {
	        newData[key] = data[key];
	      });
	      newData[paramName] = reply;
	      if (node.parentNode != null) {
	        var clone;
	        if (templNode.nodeName.toLowerCase() === 'loop') {
	          for (var i = 0; i < templNode.childNodes.length; i++) {
	            clone = templNode.childNodes[i].cloneNode(true);
	            node.parentNode.insertBefore(clone, node);
	            processNode(cState, clone, newData);
	          }
	        } else {
	          clone = templNode.cloneNode(true);
	          clone.removeAttribute('foreach');
	          node.parentNode.insertBefore(clone, node);
	          processNode(cState, clone, newData);
	        }
	      }
	    });
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Take a text node and replace it with another text node with the ${...}
	 * sections parsed out. We replace the node by altering node.parentNode but
	 * we could probably use a DOM Text API to achieve the same thing.
	 * @param node The Text node to work on
	 * @param data The data to use in calls to envEval()
	 */
	function processTextNode(state, node, data) {
	  // Replace references in other attributes
	  var value = node.data;
	  // We can't use the string.replace() with function trick (see generic
	  // attribute processing in processNode()) because we need to support
	  // functions that return DOM nodes, so we can't have the conversion to a
	  // string.
	  // Instead we process the string as an array of parts. In order to split
	  // the string up, we first replace '${' with '\uF001$' and '}' with '\uF002'
	  // We can then split using \uF001 or \uF002 to get an array of strings
	  // where scripts are prefixed with $.
	  // \uF001 and \uF002 are just unicode chars reserved for private use.
	  value = value.replace(TEMPLATE_REGION, '\uF001$$$1\uF002');
	  // Split a string using the unicode chars F001 and F002.
	  var parts = value.split(/\uF001|\uF002/);
	  if (parts.length > 1) {
	    parts.forEach(function (part) {
	      if (part === null || part === undefined || part === '') {
	        return;
	      }
	      if (part.charAt(0) === '$') {
	        part = envEval(state, part.slice(1), data, node.data);
	      }
	      var cState = cloneState(state);
	      handleAsync(part, node, function (reply, siblingNode) {
	        var doc = siblingNode.ownerDocument;
	        if (reply == null) {
	          reply = cState.options.blankNullUndefined ? '' : '' + reply;
	        }
	        if (typeof reply.cloneNode === 'function') {
	          // i.e. if (reply instanceof Element) { ...
	          reply = maybeImportNode(cState, reply, doc);
	          siblingNode.parentNode.insertBefore(reply, siblingNode);
	        } else if (typeof reply.item === 'function' && reply.length) {
	          // NodeLists can be live, in which case maybeImportNode can
	          // remove them from the document, and thus the NodeList, which in
	          // turn breaks iteration. So first we clone the list
	          var list = Array.prototype.slice.call(reply, 0);
	          list.forEach(function (child) {
	            var imported = maybeImportNode(cState, child, doc);
	            siblingNode.parentNode.insertBefore(imported, siblingNode);
	          });
	        } else {
	          // if thing isn't a DOM element then wrap its string value in one
	          reply = doc.createTextNode(reply.toString());
	          siblingNode.parentNode.insertBefore(reply, siblingNode);
	        }
	      });
	    });
	    node.parentNode.removeChild(node);
	  }
	}

	/**
	 * Return node or a import of node, if it's not in the given document
	 * @param node The node that we want to be properly owned
	 * @param doc The document that the given node should belong to
	 * @return A node that belongs to the given document
	 */
	function maybeImportNode(state, node, doc) {
	  return node.ownerDocument === doc ? node : doc.importNode(node, true);
	}

	/**
	 * A function to handle the fact that some nodes can be promises, so we check
	 * and resolve if needed using a marker node to keep our place before calling
	 * an inserter function.
	 * @param thing The object which could be real data or a promise of real data
	 * we use it directly if it's not a promise, or resolve it if it is.
	 * @param siblingNode The element before which we insert new elements.
	 * @param inserter The function to to the insertion. If thing is not a promise
	 * then handleAsync() is just 'inserter(thing, siblingNode)'
	 */
	function handleAsync(thing, siblingNode, inserter) {
	  if (thing != null && typeof thing.then === 'function') {
	    // Placeholder element to be replaced once we have the real data
	    var tempNode = siblingNode.ownerDocument.createElement('span');
	    siblingNode.parentNode.insertBefore(tempNode, siblingNode);
	    thing.then(function (delayed) {
	      inserter(delayed, tempNode);
	      if (tempNode.parentNode != null) {
	        tempNode.parentNode.removeChild(tempNode);
	      }
	    }).then(null, function (error) {
	      console.error(error.stack);
	    });
	  } else {
	    inserter(thing, siblingNode);
	  }
	}

	/**
	 * Warn of string does not begin '${' and end '}'
	 * @param str the string to check.
	 * @return The string stripped of ${ and }, or untouched if it does not match
	 */
	function stripBraces(state, str) {
	  if (!str.match(TEMPLATE_REGION)) {
	    handleError(state, 'Expected ' + str + ' to match ${...}');
	    return str;
	  }
	  return str.slice(2, -1);
	}

	/**
	 * Combined getter and setter that works with a path through some data set.
	 * For example:
	 * <ul>
	 * <li>property(state, 'a.b', { a: { b: 99 }}); // returns 99
	 * <li>property(state, 'a', { a: { b: 99 }}); // returns { b: 99 }
	 * <li>property(state, 'a', { a: { b: 99 }}, 42); // returns 99 and alters the
	 * input data to be { a: { b: 42 }}
	 * </ul>
	 * @param path An array of strings indicating the path through the data, or
	 * a string to be cut into an array using <tt>split('.')</tt>
	 * @param data the data to use for node processing
	 * @param newValue (optional) If defined, this value will replace the
	 * original value for the data at the path specified.
	 * @return The value pointed to by <tt>path</tt> before any
	 * <tt>newValue</tt> is applied.
	 */
	function property(state, path, data, newValue) {
	  try {
	    if (typeof path === 'string') {
	      path = path.split('.');
	    }
	    var value = data[path[0]];
	    if (path.length === 1) {
	      if (newValue !== undefined) {
	        data[path[0]] = newValue;
	      }
	      if (typeof value === 'function') {
	        return value.bind(data);
	      }
	      return value;
	    }
	    if (!value) {
	      handleError(state, '"' + path[0] + '" is undefined');
	      return null;
	    }
	    return property(state, path.slice(1), value, newValue);
	  } catch (ex) {
	    handleError(state, 'Path error with \'' + path + '\'', ex);
	    return '${' + path + '}';
	  }
	}

	/**
	 * Like eval, but that creates a context of the variables in <tt>env</tt> in
	 * which the script is evaluated.
	 * @param script The string to be evaluated.
	 * @param data The environment in which to eval the script.
	 * @param frame Optional debugging string in case of failure.
	 * @return The return value of the script, or the error message if the script
	 * execution failed.
	 */
	function envEval(state, script, data, frame) {
	  try {
	    state.stack.push(frame.replace(/\s+/g, ' '));
	    // Detect if a script is capable of being interpreted using property()
	    if (/^[_a-zA-Z0-9.]*$/.test(script)) {
	      return property(state, script, data);
	    } else {
	      if (!state.options.allowEval) {
	        handleError(state, 'allowEval is not set, however \'' + script + '\'' + ' can not be resolved using a simple property path.');
	        return '${' + script + '}';
	      }

	      // What we're looking to do is basically:
	      //   with(data) { return eval(script); }
	      // except in strict mode where 'with' is banned.
	      // So we create a function which has a parameter list the same as the
	      // keys in 'data' and with 'script' as its function body.
	      // We then call this function with the values in 'data'
	      var keys = allKeys(data);
	      var func = Function.apply(null, keys.concat("return " + script));

	      var values = keys.map(function (key) {
	        return data[key];
	      });
	      return func.apply(null, values);

	      // TODO: The 'with' method is different from the code above in the value
	      // of 'this' when calling functions. For example:
	      //   envEval(state, 'foo()', { foo: function() { return this; } }, ...);
	      // The global for 'foo' when using 'with' is the data object. However the
	      // code above, the global is null. (Using 'func.apply(data, values)'
	      // changes 'this' in the 'foo()' frame, but not in the inside the body
	      // of 'foo', so that wouldn't help)
	    }
	  } catch (ex) {
	    handleError(state, 'Template error evaluating \'' + script + '\'', ex);
	    return '${' + script + '}';
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Object.keys() that respects the prototype chain
	 */
	function allKeys(data) {
	  var keys = [];
	  for (var key in data) {
	    keys.push(key);
	  }
	  return keys;
	}

	/**
	 * A generic way of reporting errors, for easy overloading in different
	 * environments.
	 * @param message the error message to report.
	 * @param ex optional associated exception.
	 */
	function handleError(state, message, ex) {
	  logError(message + ' (In: ' + state.stack.join(' > ') + ')');
	  if (ex) {
	    logError(ex);
	  }
	}

	/**
	 * A generic way of reporting errors, for easy overloading in different
	 * environments.
	 * @param message the error message to report.
	 */
	function logError(message) {
	  console.error(message);
	}

	exports.template = template;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;
	const Ci = _require.Ci;

	var _require2 = __webpack_require__(15);

	const XPCOMUtils = _require2.XPCOMUtils;

	var _require3 = __webpack_require__(9);

	const Services = _require3.Services;

	const promise = __webpack_require__(6);

	const ENSURE_SELECTION_VISIBLE_DELAY = 50; // ms
	const ELLIPSIS = "…"; // Should be l10n'd
	const MAX_LABEL_LENGTH = 40;
	const LOW_PRIORITY_ELEMENTS = {
	  "HEAD": true,
	  "BASE": true,
	  "BASEFONT": true,
	  "ISINDEX": true,
	  "LINK": true,
	  "META": true,
	  "SCRIPT": true,
	  "STYLE": true,
	  "TITLE": true
	};

	/**
	 * Display the ancestors of the current node and its children.
	 * Only one "branch" of children are displayed (only one line).
	 *
	 * FIXME: Bug 822388 - Use the BreadcrumbsWidget in the Inspector.
	 *
	 * Mechanism:
	 * - If no nodes displayed yet:
	 *   then display the ancestor of the selected node and the selected node;
	 *   else select the node;
	 * - If the selected node is the last node displayed, append its first (if any).
	 *
	 * @param {InspectorPanel} inspector The inspector hosting this widget.
	 */
	function HTMLBreadcrumbs(inspector) {
	  this.inspector = inspector;
	  this.selection = this.inspector.selection;
	  this.chromeWin = this.inspector.panelWin;
	  this.chromeDoc = this.inspector.panelDoc;
	  this._init();
	}

	exports.HTMLBreadcrumbs = HTMLBreadcrumbs;

	HTMLBreadcrumbs.prototype = {
	  get walker() {
	    return this.inspector.walker;
	  },

	  _init: function () {
	    var _this = this;

	    this.container = this.chromeDoc.getElementById("inspector-breadcrumbs");

	    // These separators are used for CSS purposes only, and are positioned
	    // off screen, but displayed with -moz-element.
	    this.separators = this.chromeDoc.createElement("box");
	    this.separators.className = "breadcrumb-separator-container";
	    this.separators.innerHTML = "<box id='breadcrumb-separator-before'></box>" + "<box id='breadcrumb-separator-after'></box>" + "<box id='breadcrumb-separator-normal'></box>";
	    this.container.parentNode.appendChild(this.separators);

	    this.container.addEventListener("mousedown", this, true);
	    this.container.addEventListener("keypress", this, true);
	    this.container.addEventListener("mouseover", this, true);
	    this.container.addEventListener("mouseleave", this, true);

	    // We will save a list of already displayed nodes in this array.
	    this.nodeHierarchy = [];

	    // Last selected node in nodeHierarchy.
	    this.currentIndex = -1;

	    // By default, hide the arrows. We let the <scrollbox> show them
	    // in case of overflow.
	    this.container.removeAttribute("overflows");
	    this.container._scrollButtonUp.collapsed = true;
	    this.container._scrollButtonDown.collapsed = true;

	    this.onscrollboxreflow = function () {
	      if (_this.container._scrollButtonDown.collapsed) {
	        _this.container.removeAttribute("overflows");
	      } else {
	        _this.container.setAttribute("overflows", true);
	      }
	    };

	    this.container.addEventListener("underflow", this.onscrollboxreflow, false);
	    this.container.addEventListener("overflow", this.onscrollboxreflow, false);

	    this.update = this.update.bind(this);
	    this.updateSelectors = this.updateSelectors.bind(this);
	    this.selection.on("new-node-front", this.update);
	    this.selection.on("pseudoclass", this.updateSelectors);
	    this.selection.on("attribute-changed", this.updateSelectors);
	    this.inspector.on("markupmutation", this.update);
	    this.update();
	  },

	  /**
	   * Include in a promise's then() chain to reject the chain
	   * when the breadcrumbs' selection has changed while the promise
	   * was outstanding.
	   */
	  selectionGuard: function () {
	    var _this2 = this;

	    let selection = this.selection.nodeFront;
	    return function (result) {
	      if (selection != _this2.selection.nodeFront) {
	        return promise.reject("selection-changed");
	      }
	      return result;
	    };
	  },

	  /**
	   * Warn if rejection was caused by selection change, print an error otherwise.
	   * @param {Error} err
	   */
	  selectionGuardEnd: function (err) {
	    if (err === "selection-changed") {
	      console.warn("Asynchronous operation was aborted as selection changed.");
	    } else {
	      console.error(err);
	    }
	  },

	  /**
	   * Build a string that represents the node: tagName#id.class1.class2.
	   * @param {NodeFront} node The node to pretty-print
	   * @return {String}
	   */
	  prettyPrintNodeAsText: function (node) {
	    let text = node.tagName.toLowerCase();
	    if (node.isPseudoElement) {
	      text = node.isBeforePseudoElement ? "::before" : "::after";
	    }

	    if (node.id) {
	      text += "#" + node.id;
	    }

	    if (node.className) {
	      let classList = node.className.split(/\s+/);
	      for (let i = 0; i < classList.length; i++) {
	        text += "." + classList[i];
	      }
	    }

	    for (let pseudo of node.pseudoClassLocks) {
	      text += pseudo;
	    }

	    return text;
	  },

	  /**
	   * Build <label>s that represent the node:
	   *   <label class="breadcrumbs-widget-item-tag">tagName</label>
	   *   <label class="breadcrumbs-widget-item-id">#id</label>
	   *   <label class="breadcrumbs-widget-item-classes">.class1.class2</label>
	   * @param {NodeFront} node The node to pretty-print
	   * @returns {DocumentFragment}
	   */
	  prettyPrintNodeAsXUL: function (node) {
	    let fragment = this.chromeDoc.createDocumentFragment();

	    let tagLabel = this.chromeDoc.createElement("label");
	    tagLabel.className = "breadcrumbs-widget-item-tag plain";

	    let idLabel = this.chromeDoc.createElement("label");
	    idLabel.className = "breadcrumbs-widget-item-id plain";

	    let classesLabel = this.chromeDoc.createElement("label");
	    classesLabel.className = "breadcrumbs-widget-item-classes plain";

	    let pseudosLabel = this.chromeDoc.createElement("label");
	    pseudosLabel.className = "breadcrumbs-widget-item-pseudo-classes plain";

	    let tagText = node.tagName.toLowerCase();
	    if (node.isPseudoElement) {
	      tagText = node.isBeforePseudoElement ? "::before" : "::after";
	    }
	    let idText = node.id ? "#" + node.id : "";
	    let classesText = "";

	    if (node.className) {
	      let classList = node.className.split(/\s+/);
	      for (let i = 0; i < classList.length; i++) {
	        classesText += "." + classList[i];
	      }
	    }

	    // Figure out which element (if any) needs ellipsing.
	    // Substring for that element, then clear out any extras
	    // (except for pseudo elements).
	    let maxTagLength = MAX_LABEL_LENGTH;
	    let maxIdLength = MAX_LABEL_LENGTH - tagText.length;
	    let maxClassLength = MAX_LABEL_LENGTH - tagText.length - idText.length;

	    if (tagText.length > maxTagLength) {
	      tagText = tagText.substr(0, maxTagLength) + ELLIPSIS;
	      idText = classesText = "";
	    } else if (idText.length > maxIdLength) {
	      idText = idText.substr(0, maxIdLength) + ELLIPSIS;
	      classesText = "";
	    } else if (classesText.length > maxClassLength) {
	      classesText = classesText.substr(0, maxClassLength) + ELLIPSIS;
	    }

	    tagLabel.textContent = tagText;
	    idLabel.textContent = idText;
	    classesLabel.textContent = classesText;
	    pseudosLabel.textContent = node.pseudoClassLocks.join("");

	    fragment.appendChild(tagLabel);
	    fragment.appendChild(idLabel);
	    fragment.appendChild(classesLabel);
	    fragment.appendChild(pseudosLabel);

	    return fragment;
	  },

	  /**
	   * Open the sibling menu.
	   * @param {DOMNode} button the button representing the node.
	   * @param {NodeFront} node the node we want the siblings from.
	   */
	  openSiblingMenu: function (button, node) {
	    var _this3 = this;

	    // We make sure that the targeted node is selected
	    // because we want to use the nodemenu that only works
	    // for inspector.selection
	    this.navigateTo(node);

	    // Build a list of extra menu items that will be appended at the end of the
	    // inspector node context menu.
	    let items = [this.chromeDoc.createElement("menuseparator")];

	    this.walker.siblings(node, {
	      whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
	    }).then(function (siblings) {
	      let nodes = siblings.nodes;
	      for (let i = 0; i < nodes.length; i++) {
	        // Skip siblings of the documentElement node.
	        if (nodes[i].nodeType !== Ci.nsIDOMNode.ELEMENT_NODE) {
	          continue;
	        }

	        let item = _this3.chromeDoc.createElement("menuitem");
	        if (nodes[i] === node) {
	          item.setAttribute("disabled", "true");
	          item.setAttribute("checked", "true");
	        }

	        item.setAttribute("type", "radio");
	        item.setAttribute("label", _this3.prettyPrintNodeAsText(nodes[i]));

	        let self = _this3;
	        item.onmouseup = (function (node) {
	          return function () {
	            self.navigateTo(node);
	          };
	        })(nodes[i]);

	        items.push(item);
	      }

	      // Append the items to the inspector node context menu and show the menu.
	      _this3.inspector.showNodeMenu(button, "before_start", items);
	    });
	  },

	  /**
	   * Generic event handler.
	   * @param {DOMEvent} event.
	   */
	  handleEvent: function (event) {
	    if (event.type == "mousedown" && event.button == 0) {
	      this.handleMouseDown(event);
	    } else if (event.type == "keypress" && this.selection.isElementNode()) {
	      this.handleKeyPress(event);
	    } else if (event.type == "mouseover") {
	      this.handleMouseOver(event);
	    } else if (event.type == "mouseleave") {
	      this.handleMouseLeave(event);
	    }
	  },

	  /**
	   * On click and hold, open the siblings menu.
	   * @param {DOMEvent} event.
	   */
	  handleMouseDown: function (event) {
	    let timer;
	    let container = this.container;

	    function openMenu(event) {
	      cancelHold();
	      let target = event.originalTarget;
	      if (target.tagName == "button") {
	        target.onBreadcrumbsHold();
	      }
	    }

	    function handleClick(event) {
	      cancelHold();
	      let target = event.originalTarget;
	      if (target.tagName == "button") {
	        target.onBreadcrumbsClick();
	      }
	    }

	    let window = this.chromeWin;
	    function cancelHold(event) {
	      window.clearTimeout(timer);
	      container.removeEventListener("mouseout", cancelHold, false);
	      container.removeEventListener("mouseup", handleClick, false);
	    }

	    container.addEventListener("mouseout", cancelHold, false);
	    container.addEventListener("mouseup", handleClick, false);
	    timer = window.setTimeout(openMenu, 500, event);
	  },

	  /**
	   * On mouse over, highlight the corresponding content DOM Node.
	   * @param {DOMEvent} event.
	   */
	  handleMouseOver: function (event) {
	    let target = event.originalTarget;
	    if (target.tagName == "button") {
	      target.onBreadcrumbsHover();
	    }
	  },

	  /**
	   * On mouse leave, make sure to unhighlight.
	   * @param {DOMEvent} event.
	   */
	  handleMouseLeave: function (event) {
	    this.inspector.toolbox.highlighterUtils.unhighlight();
	  },

	  /**
	   * On key press, navigate the node hierarchy.
	   * @param {DOMEvent} event.
	   */
	  handleKeyPress: function (event) {
	    var _this4 = this;

	    let navigate = promise.resolve(null);

	    this._keyPromise = (this._keyPromise || promise.resolve(null)).then(function () {
	      switch (event.keyCode) {
	        case _this4.chromeWin.KeyEvent.DOM_VK_LEFT:
	          if (_this4.currentIndex != 0) {
	            navigate = promise.resolve(_this4.nodeHierarchy[_this4.currentIndex - 1].node);
	          }
	          break;
	        case _this4.chromeWin.KeyEvent.DOM_VK_RIGHT:
	          if (_this4.currentIndex < _this4.nodeHierarchy.length - 1) {
	            navigate = promise.resolve(_this4.nodeHierarchy[_this4.currentIndex + 1].node);
	          }
	          break;
	        case _this4.chromeWin.KeyEvent.DOM_VK_UP:
	          navigate = _this4.walker.previousSibling(_this4.selection.nodeFront, {
	            whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
	          });
	          break;
	        case _this4.chromeWin.KeyEvent.DOM_VK_DOWN:
	          navigate = _this4.walker.nextSibling(_this4.selection.nodeFront, {
	            whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
	          });
	          break;
	      }

	      return navigate.then(function (node) {
	        return _this4.navigateTo(node);
	      });
	    });

	    event.preventDefault();
	    event.stopPropagation();
	  },

	  /**
	   * Remove nodes and clean up.
	   */
	  destroy: function () {
	    this.selection.off("new-node-front", this.update);
	    this.selection.off("pseudoclass", this.updateSelectors);
	    this.selection.off("attribute-changed", this.updateSelectors);
	    this.inspector.off("markupmutation", this.update);

	    this.container.removeEventListener("underflow", this.onscrollboxreflow, false);
	    this.container.removeEventListener("overflow", this.onscrollboxreflow, false);
	    this.container.removeEventListener("mousedown", this, true);
	    this.container.removeEventListener("keypress", this, true);
	    this.container.removeEventListener("mouseover", this, true);
	    this.container.removeEventListener("mouseleave", this, true);

	    this.empty();
	    this.separators.remove();

	    this.onscrollboxreflow = null;
	    this.container = null;
	    this.separators = null;
	    this.nodeHierarchy = null;

	    this.isDestroyed = true;
	  },

	  /**
	   * Empty the breadcrumbs container.
	   */
	  empty: function () {
	    while (this.container.hasChildNodes()) {
	      this.container.firstChild.remove();
	    }
	  },

	  /**
	   * Set which button represent the selected node.
	   * @param {Number} index Index of the displayed-button to select.
	   */
	  setCursor: function (index) {
	    // Unselect the previously selected button
	    if (this.currentIndex > -1 && this.currentIndex < this.nodeHierarchy.length) {
	      this.nodeHierarchy[this.currentIndex].button.removeAttribute("checked");
	    }
	    if (index > -1) {
	      this.nodeHierarchy[index].button.setAttribute("checked", "true");
	      if (this.hadFocus) {
	        this.nodeHierarchy[index].button.focus();
	      }
	    }
	    this.currentIndex = index;
	  },

	  /**
	   * Get the index of the node in the cache.
	   * @param {NodeFront} node.
	   * @returns {Number} The index for this node or -1 if not found.
	   */
	  indexOf: function (node) {
	    for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
	      if (this.nodeHierarchy[i].node === node) {
	        return i;
	      }
	    }
	    return -1;
	  },

	  /**
	   * Remove all the buttons and their references in the cache after a given
	   * index.
	   * @param {Number} index.
	   */
	  cutAfter: function (index) {
	    while (this.nodeHierarchy.length > index + 1) {
	      let toRemove = this.nodeHierarchy.pop();
	      this.container.removeChild(toRemove.button);
	    }
	  },

	  navigateTo: function (node) {
	    if (node) {
	      this.selection.setNodeFront(node, "breadcrumbs");
	    } else {
	      this.inspector.emit("breadcrumbs-navigation-cancelled");
	    }
	  },

	  /**
	   * Build a button representing the node.
	   * @param {NodeFront} node The node from the page.
	   * @return {DOMNode} The <button> for this node.
	   */
	  buildButton: function (node) {
	    var _this5 = this;

	    let button = this.chromeDoc.createElement("button");
	    button.appendChild(this.prettyPrintNodeAsXUL(node));
	    button.className = "breadcrumbs-widget-item";

	    button.setAttribute("tooltiptext", this.prettyPrintNodeAsText(node));

	    button.onkeypress = function onBreadcrumbsKeypress(e) {
	      if (e.charCode == Ci.nsIDOMKeyEvent.DOM_VK_SPACE || e.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_RETURN) {
	        button.click();
	      }
	    };

	    button.onBreadcrumbsClick = function () {
	      _this5.navigateTo(node);
	    };

	    button.onBreadcrumbsHover = function () {
	      _this5.inspector.toolbox.highlighterUtils.highlightNodeFront(node);
	    };

	    button.onclick = (function _onBreadcrumbsRightClick(event) {
	      button.focus();
	      if (event.button == 2) {
	        this.openSiblingMenu(button, node);
	      }
	    }).bind(this);

	    button.onBreadcrumbsHold = (function _onBreadcrumbsHold() {
	      this.openSiblingMenu(button, node);
	    }).bind(this);
	    return button;
	  },

	  /**
	   * Connecting the end of the breadcrumbs to a node.
	   * @param {NodeFront} node The node to reach.
	   */
	  expand: function (node) {
	    let fragment = this.chromeDoc.createDocumentFragment();
	    let lastButtonInserted = null;
	    let originalLength = this.nodeHierarchy.length;
	    let stopNode = null;
	    if (originalLength > 0) {
	      stopNode = this.nodeHierarchy[originalLength - 1].node;
	    }
	    while (node && node != stopNode) {
	      if (node.tagName) {
	        let button = this.buildButton(node);
	        fragment.insertBefore(button, lastButtonInserted);
	        lastButtonInserted = button;
	        this.nodeHierarchy.splice(originalLength, 0, {
	          node,
	          button,
	          currentPrettyPrintText: this.prettyPrintNodeAsText(node)
	        });
	      }
	      node = node.parentNode();
	    }
	    this.container.appendChild(fragment, this.container.firstChild);
	  },

	  /**
	   * Get a child of a node that can be displayed in the breadcrumbs and that is
	   * probably visible. See LOW_PRIORITY_ELEMENTS.
	   * @param {NodeFront} node The parent node.
	   * @return {Promise} Resolves to the NodeFront.
	   */
	  getInterestingFirstNode: function (node) {
	    var _this6 = this;

	    let deferred = promise.defer();

	    let fallback = null;
	    let lastNode = null;

	    let moreChildren = function () {
	      _this6.walker.children(node, {
	        start: lastNode,
	        maxNodes: 10,
	        whatToShow: Ci.nsIDOMNodeFilter.SHOW_ELEMENT
	      }).then(_this6.selectionGuard()).then(function (response) {
	        for (let node of response.nodes) {
	          if (!(node.tagName in LOW_PRIORITY_ELEMENTS)) {
	            deferred.resolve(node);
	            return;
	          }
	          if (!fallback) {
	            fallback = node;
	          }
	          lastNode = node;
	        }
	        if (response.hasLast) {
	          deferred.resolve(fallback);
	          return;
	        }
	        moreChildren();
	      }).then(null, _this6.selectionGuardEnd);
	    };

	    moreChildren();
	    return deferred.promise;
	  },

	  /**
	   * Find the "youngest" ancestor of a node which is already in the breadcrumbs.
	   * @param {NodeFront} node.
	   * @return {Number} Index of the ancestor in the cache, or -1 if not found.
	   */
	  getCommonAncestor: function (node) {
	    while (node) {
	      let idx = this.indexOf(node);
	      if (idx > -1) {
	        return idx;
	      }
	      node = node.parentNode();
	    }
	    return -1;
	  },

	  /**
	   * Make sure that the latest node in the breadcrumbs is not the selected node
	   * if the selected node still has children.
	   * @return {Promise}
	   */
	  ensureFirstChild: function () {
	    var _this7 = this;

	    // If the last displayed node is the selected node
	    if (this.currentIndex == this.nodeHierarchy.length - 1) {
	      let node = this.nodeHierarchy[this.currentIndex].node;
	      return this.getInterestingFirstNode(node).then(function (child) {
	        // If the node has a child and we've not been destroyed in the meantime
	        if (child && !_this7.isDestroyed) {
	          // Show this child
	          _this7.expand(child);
	        }
	      });
	    }

	    return resolveNextTick(true);
	  },

	  /**
	   * Ensure the selected node is visible.
	   */
	  scroll: function () {
	    // FIXME bug 684352: make sure its immediate neighbors are visible too.

	    let scrollbox = this.container;
	    let element = this.nodeHierarchy[this.currentIndex].button;

	    // Repeated calls to ensureElementIsVisible would interfere with each other
	    // and may sometimes result in incorrect scroll positions.
	    this.chromeWin.clearTimeout(this._ensureVisibleTimeout);
	    this._ensureVisibleTimeout = this.chromeWin.setTimeout(function () {
	      scrollbox.ensureElementIsVisible(element);
	    }, ENSURE_SELECTION_VISIBLE_DELAY);
	  },

	  /**
	   * Update all button outputs.
	   */
	  updateSelectors: function () {
	    if (this.isDestroyed) {
	      return;
	    }

	    for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
	      var _nodeHierarchy$i = this.nodeHierarchy[i];
	      let node = _nodeHierarchy$i.node;
	      let button = _nodeHierarchy$i.button;
	      let currentPrettyPrintText = _nodeHierarchy$i.currentPrettyPrintText;

	      // If the output of the node doesn't change, skip the update.

	      let textOutput = this.prettyPrintNodeAsText(node);
	      if (currentPrettyPrintText === textOutput) {
	        continue;
	      }

	      // Otherwise, update the whole markup for the button.
	      while (button.hasChildNodes()) {
	        button.firstChild.remove();
	      }
	      button.appendChild(this.prettyPrintNodeAsXUL(node));
	      button.setAttribute("tooltiptext", textOutput);

	      this.nodeHierarchy[i].currentPrettyPrintText = textOutput;
	    }
	  },

	  /**
	   * Given a list of mutation changes (passed by the markupmutation event),
	   * decide whether or not they are "interesting" to the current state of the
	   * breadcrumbs widget, i.e. at least one of them should cause part of the
	   * widget to be updated.
	   * @param {Array} mutations The mutations array.
	   * @return {Boolean}
	   */
	  _hasInterestingMutations: function (mutations) {
	    var _this8 = this;

	    if (!mutations || !mutations.length) {
	      return false;
	    }

	    for (let _ref of mutations) {
	      let type = _ref.type;
	      let added = _ref.added;
	      let removed = _ref.removed;
	      let target = _ref.target;
	      let attributeName = _ref.attributeName;

	      if (type === "childList") {
	        // Only interested in childList mutations if the added or removed
	        // nodes are currently displayed, or if it impacts the last element in
	        // the breadcrumbs.
	        return added.some(function (node) {
	          return _this8.indexOf(node) > -1;
	        }) || removed.some(function (node) {
	          return _this8.indexOf(node) > -1;
	        }) || this.indexOf(target) === this.nodeHierarchy.length - 1;
	      } else if (type === "attributes" && this.indexOf(target) > -1) {
	        // Only interested in attributes mutations if the target is
	        // currently displayed, and the attribute is either id or class.
	        return attributeName === "class" || attributeName === "id";
	      }
	    }

	    // Catch all return in case the mutations array was empty, or in case none
	    // of the changes iterated above were interesting.
	    return false;
	  },

	  /**
	   * Update the breadcrumbs display when a new node is selected.
	   * @param {String} reason The reason for the update, if any.
	   * @param {Array} mutations An array of mutations in case this was called as
	   * the "markupmutation" event listener.
	   */
	  update: function (reason, mutations) {
	    var _this9 = this;

	    if (this.isDestroyed) {
	      return;
	    }

	    if (reason !== "markupmutation") {
	      this.inspector.hideNodeMenu();
	    }

	    let hasInterestingMutations = this._hasInterestingMutations(mutations);
	    if (reason === "markupmutation" && !hasInterestingMutations) {
	      return;
	    }

	    let cmdDispatcher = this.chromeDoc.commandDispatcher;
	    this.hadFocus = cmdDispatcher.focusedElement && cmdDispatcher.focusedElement.parentNode == this.container;

	    if (!this.selection.isConnected()) {
	      // remove all the crumbs
	      this.cutAfter(-1);
	      return;
	    }

	    if (!this.selection.isElementNode()) {
	      // no selection
	      this.setCursor(-1);
	      return;
	    }

	    let idx = this.indexOf(this.selection.nodeFront);

	    // Is the node already displayed in the breadcrumbs?
	    // (and there are no mutations that need re-display of the crumbs)
	    if (idx > -1 && !hasInterestingMutations) {
	      // Yes. We select it.
	      this.setCursor(idx);
	    } else {
	      // No. Is the breadcrumbs display empty?
	      if (this.nodeHierarchy.length > 0) {
	        // No. We drop all the element that are not direct ancestors
	        // of the selection
	        let parent = this.selection.nodeFront.parentNode();
	        let idx = this.getCommonAncestor(parent);
	        this.cutAfter(idx);
	      }
	      // we append the missing button between the end of the breadcrumbs display
	      // and the current node.
	      this.expand(this.selection.nodeFront);

	      // we select the current node button
	      idx = this.indexOf(this.selection.nodeFront);
	      this.setCursor(idx);
	    }

	    let doneUpdating = this.inspector.updating("breadcrumbs");
	    // Add the first child of the very last node of the breadcrumbs if possible.
	    this.ensureFirstChild().then(this.selectionGuard()).then(function () {
	      if (_this9.isDestroyed) {
	        return;
	      }

	      _this9.updateSelectors();

	      // Make sure the selected node and its neighbours are visible.
	      _this9.scroll();
	      return resolveNextTick().then(function () {
	        _this9.inspector.emit("breadcrumbs-updated", _this9.selection.nodeFront);
	        doneUpdating();
	      });
	    }).then(null, function (err) {
	      doneUpdating(_this9.selection.nodeFront);
	      _this9.selectionGuardEnd(err);
	    });
	  }
	};

	/**
	 * Returns a promise that resolves at the next main thread tick.
	 */
	function resolveNextTick(value) {
	  let deferred = promise.defer();
	  Services.tm.mainThread.dispatch(function () {
	    try {
	      deferred.resolve(value);
	    } catch (e) {
	      deferred.reject(e);
	    }
	  }, Ci.nsIThread.DISPATCH_NORMAL);
	  return deferred.promise;
	}

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;

	var _require2 = __webpack_require__(15);

	const XPCOMUtils = _require2.XPCOMUtils;

	var _require3 = __webpack_require__(9);

	const Services = _require3.Services;

	var _require4 = __webpack_require__(38);

	const Task = _require4.Task;

	var EventEmitter = __webpack_require__(7);
	var Telemetry = __webpack_require__(8);

	const XULNS = "http://www.w3.org/1999/xhtml";

	/**
	 * ToolSidebar provides methods to register tabs in the sidebar.
	 * It's assumed that the sidebar contains a xul:tabbox.
	 * Typically, you'll want the tabbox parameter to be a XUL tabbox like this:
	 *
	 * <tabbox id="inspector-sidebar" handleCtrlTab="false" class="devtools-sidebar-tabs">
	 *   <tabs/>
	 *   <tabpanels flex="1"/>
	 * </tabbox>
	 *
	 * The ToolSidebar API has a method to add new tabs, so the tabs and tabpanels
	 * nodes can be empty. But they can also already contain items before the
	 * ToolSidebar is created.
	 *
	 * Tabs added through the addTab method are only identified by an ID and a URL
	 * which is used as the href of an iframe node that is inserted in the newly
	 * created tabpanel.
	 * Tabs already present before the ToolSidebar is created may contain anything.
	 * However, these tabs must have ID attributes if it is required for the various
	 * methods that accept an ID as argument to work here.
	 *
	 * @param {Node} tabbox
	 *  <tabbox> node;
	 * @param {ToolPanel} panel
	 *  Related ToolPanel instance;
	 * @param {String} uid
	 *  Unique ID
	 * @param {Object} options
	 *  - hideTabstripe: Should the tabs be hidden. Defaults to false
	 *  - showAllTabsMenu: Should a drop-down menu be displayed in case tabs
	 *    become hidden. Defaults to false.
	 *  - disableTelemetry: By default, switching tabs on and off in the sidebar
	 *    will record tool usage in telemetry, pass this option to true to avoid it.
	 *
	 * Events raised:
	 * - new-tab-registered : After a tab has been added via addTab. The tab ID
	 *   is passed with the event. This however, is raised before the tab iframe
	 *   is fully loaded.
	 * - <tabid>-ready : After the tab iframe has been loaded
	 * - <tabid>-selected : After tab <tabid> was selected
	 * - select : Same as above, but for any tab, the ID is passed with the event
	 * - <tabid>-unselected : After tab <tabid> is unselected
	 */
	function ToolSidebar(tabbox, panel, uid, options = {}) {
	  EventEmitter.decorate(this);

	  this._tabbox = tabbox;
	  this._tabboxTabs = tabbox.querySelector("tabs");
	  this._tabboxTabpanels = tabbox.querySelector("tabpanels");
	  this._uid = uid;
	  this._panelDoc = this._tabbox.ownerDocument;
	  this._toolPanel = panel;
	  this._options = options;

	  this._onTabBoxOverflow = this._onTabBoxOverflow.bind(this);
	  this._onTabBoxUnderflow = this._onTabBoxUnderflow.bind(this);

	  try {
	    this._width = Services.prefs.getIntPref("devtools.toolsidebar-width." + this._uid);
	  } catch (e) {}

	  if (!options.disableTelemetry) {
	    this._telemetry = new Telemetry();
	  }

	  this._tabbox.addEventListener("select", this, true);

	  this._tabs = new Map();

	  // Check for existing tabs in the DOM and add them.
	  this.addExistingTabs();

	  if (this._options.hideTabstripe) {
	    this._tabbox.setAttribute("hidetabs", "true");
	  }

	  if (this._options.showAllTabsMenu) {
	    this.addAllTabsMenu();
	  }

	  this._toolPanel.emit("sidebar-created", this);
	}

	exports.ToolSidebar = ToolSidebar;

	ToolSidebar.prototype = {
	  TAB_ID_PREFIX: "sidebar-tab-",

	  TABPANEL_ID_PREFIX: "sidebar-panel-",

	  /**
	   * Add a "…" button at the end of the tabstripe that toggles a dropdown menu
	   * containing the list of all tabs if any become hidden due to lack of room.
	   *
	   * If the ToolSidebar was created with the "showAllTabsMenu" option set to
	   * true, this is already done automatically. If not, you may call this
	   * function at any time to add the menu.
	   */
	  addAllTabsMenu: function () {
	    // XXX: Don't mess with this yet.. Hopefully the widget would handle this
	    return;
	    if (this._allTabsBtn) {
	      return;
	    }

	    let tabs = this._tabboxTabs;

	    // Create a container and insert it first in the tabbox
	    let allTabsContainer = this._panelDoc.createElementNS(XULNS, "stack");
	    this._tabbox.insertBefore(allTabsContainer, tabs);

	    // Move the tabs inside and make them flex
	    allTabsContainer.appendChild(tabs);
	    tabs.setAttribute("flex", "1");

	    // Create the dropdown menu next to the tabs
	    this._allTabsBtn = this._panelDoc.createElementNS(XULNS, "toolbarbutton");
	    this._allTabsBtn.setAttribute("class", "devtools-sidebar-alltabs");
	    this._allTabsBtn.setAttribute("right", "0");
	    this._allTabsBtn.setAttribute("top", "0");
	    this._allTabsBtn.setAttribute("width", "15");
	    this._allTabsBtn.setAttribute("type", "menu");
	    this._allTabsBtn.setAttribute("tooltiptext", l10n("sidebar.showAllTabs.tooltip"));
	    this._allTabsBtn.setAttribute("hidden", "true");
	    allTabsContainer.appendChild(this._allTabsBtn);

	    let menuPopup = this._panelDoc.createElementNS(XULNS, "menupopup");
	    this._allTabsBtn.appendChild(menuPopup);

	    // Listening to tabs overflow event to toggle the alltabs button
	    tabs.addEventListener("overflow", this._onTabBoxOverflow, false);
	    tabs.addEventListener("underflow", this._onTabBoxUnderflow, false);

	    // Add menuitems to the alltabs menu if there are already tabs in the
	    // sidebar
	    for (let _ref of this._tabs) {
	      var _ref2 = _slicedToArray(_ref, 2);

	      let id = _ref2[0];
	      let tab = _ref2[1];

	      this._addItemToAllTabsMenu(id, tab, tab.hasAttribute("selected"));
	    }
	  },

	  removeAllTabsMenu: function () {
	    // XXX: Don't mess with this yet.. Hopefully the widget would handle this
	    return;

	    if (!this._allTabsBtn) {
	      return;
	    }

	    let tabs = this._tabboxTabs;

	    tabs.removeEventListener("overflow", this._onTabBoxOverflow, false);
	    tabs.removeEventListener("underflow", this._onTabBoxUnderflow, false);

	    // Moving back the tabs as a first child of the tabbox
	    this._tabbox.insertBefore(tabs, this._tabboxTabpanels);
	    this._tabbox.querySelector("stack").remove();

	    this._allTabsBtn = null;
	  },

	  _onTabBoxOverflow: function () {
	    this._allTabsBtn.removeAttribute("hidden");
	  },

	  _onTabBoxUnderflow: function () {
	    this._allTabsBtn.setAttribute("hidden", "true");
	  },

	  /**
	   * Add an item in the allTabs menu for a given tab.
	   */
	  _addItemToAllTabsMenu: function (id, tab, selected = false) {
	    var _this = this;

	    if (!this._allTabsBtn) {
	      return;
	    }

	    let item = this._panelDoc.createElementNS(XULNS, "menuitem");
	    item.setAttribute("id", "sidebar-alltabs-item-" + id);
	    item.setAttribute("label", tab.getAttribute("label"));
	    item.setAttribute("type", "checkbox");
	    if (selected) {
	      item.setAttribute("checked", true);
	    }
	    // The auto-checking of menuitems in this menu doesn't work, so let's do
	    // it manually
	    item.setAttribute("autocheck", false);

	    this._allTabsBtn.querySelector("menupopup").appendChild(item);

	    item.addEventListener("click", function () {
	      _this._tabboxSelectedTab = tab;
	    }, false);

	    tab.allTabsMenuItem = item;

	    return item;
	  },

	  /**
	   * Register a tab. A tab is a document.
	   * The document must have a title, which will be used as the name of the tab.
	   *
	   * @param {string} tab uniq id
	   * @param {string} url
	   */
	  addTab: function (id, url, selected = false) {
	    var _this2 = this;

	    let iframe = this._panelDoc.createElement("iframe");
	    iframe.className = "iframe-" + id;
	    iframe.setAttribute("flex", "1");
	    iframe.setAttribute("src", url);
	    iframe.tooltip = "aHTMLTooltip";

	    // Creating the tab and adding it to the tabbox
	    let tab = this._panelDoc.createElement("tab");
	    this._tabboxTabs.appendChild(tab);
	    // tab.setAttribute("label", ""); // Avoid showing "undefined" while the tab is loading
	    tab.setAttribute("id", this.TAB_ID_PREFIX + id);
	    tab.setAttribute("crop", "end");

	    // Add the tab to the allTabs menu if exists
	    let allTabsItem = this._addItemToAllTabsMenu(id, tab, selected);

	    let onIFrameLoaded = function (event) {
	      let win = iframe.contentWindow;
	      let doc = win.document;
	      tab.textContent = doc.title;

	      if (allTabsItem) {
	        allTabsItem.setAttribute("label", doc.title);
	      }

	      iframe.removeEventListener("load", onIFrameLoaded, true);

	      if ("setPanel" in win) {
	        win.setPanel(_this2._toolPanel, iframe);
	      }
	      _this2.emit(id + "-ready");
	    };

	    iframe.addEventListener("load", onIFrameLoaded, true);

	    let tabpanel = this._panelDoc.createElementNS(XULNS, "tabpanel");
	    tabpanel.setAttribute("id", this.TABPANEL_ID_PREFIX + id);
	    tabpanel.setAttribute("flex", 1);
	    tabpanel.appendChild(iframe);
	    tabpanel.hidden = true;
	    this._tabboxTabpanels.appendChild(tabpanel);

	    this._tooltip = this._panelDoc.createElementNS(XULNS, "tooltip");
	    this._tooltip.id = "aHTMLTooltip";
	    tabpanel.appendChild(this._tooltip);
	    this._tooltip.page = true;

	    tab.linkedPanel = this.TABPANEL_ID_PREFIX + id;

	    // We store the index of this tab.
	    this._tabs.set(id, tab);
	    tab.addEventListener("click", function () {
	      _this2.select(id);
	    });

	    if (selected) {
	      // For some reason I don't understand, if we call this.select in this
	      // event loop (after inserting the tab), the tab will never get the
	      // the "selected" attribute set to true.
	      this._panelDoc.defaultView.setTimeout(function () {
	        _this2.select(id);
	      }, 10);
	    }

	    this.emit("new-tab-registered", id);
	  },

	  untitledTabsIndex: 0,

	  /**
	   * Search for existing tabs in the markup that aren't know yet and add them.
	   */
	  addExistingTabs: function () {
	    let knownTabs = [...this._tabs.values()];

	    for (let tab of this._tabboxTabs.querySelectorAll("tab")) {
	      if (knownTabs.indexOf(tab) !== -1) {
	        continue;
	      }

	      // Find an ID for this unknown tab
	      let id = tab.getAttribute("id") || "untitled-tab-" + this.untitledTabsIndex++;

	      // Register the tab
	      this._tabs.set(id, tab);
	      this.emit("new-tab-registered", id);
	    }
	  },

	  /**
	   * Remove an existing tab.
	   * @param {String} tabId The ID of the tab that was used to register it, or
	   * the tab id attribute value if the tab existed before the sidebar got created.
	   * @param {String} tabPanelId Optional. If provided, this ID will be used
	   * instead of the tabId to retrieve and remove the corresponding <tabpanel>
	   */
	  removeTab: Task.async(function* (tabId, tabPanelId) {
	    // Remove the tab if it can be found
	    let tab = this.getTab(tabId);
	    if (!tab) {
	      return;
	    }

	    let win = this.getWindowForTab(tabId);
	    if (win && "destroy" in win) {
	      yield win.destroy();
	    }

	    tab.remove();

	    // Also remove the tabpanel
	    let panel = this.getTabPanel(tabPanelId || tabId);
	    if (panel) {
	      panel.remove();
	    }

	    this._tabs.delete(tabId);
	    this.emit("tab-unregistered", tabId);
	  }),

	  /**
	   * Show or hide a specific tab.
	   * @param {Boolean} isVisible True to show the tab/tabpanel, False to hide it.
	   * @param {String} id The ID of the tab to be hidden.
	   */
	  toggleTab: function (isVisible, id) {
	    // Toggle the tab.
	    let tab = this.getTab(id);
	    if (!tab) {
	      return;
	    }
	    tab.hidden = !isVisible;

	    // Toggle the item in the allTabs menu.
	    if (this._allTabsBtn) {
	      this._allTabsBtn.querySelector("#sidebar-alltabs-item-" + id).hidden = !isVisible;
	    }
	  },

	  /**
	   * Select a specific tab.
	   */
	  select: function (id) {
	    let tab = this.getTab(id);
	    if (tab) {
	      this._tabboxSelectedTab = tab;
	      // Hack to trigger event, since tabbox.selectedTab doesn't actually do anything
	      this.handleEvent({ type: "select" });
	    }
	  },

	  /**
	   * Return the id of the selected tab.
	   */
	  getCurrentTabID: function () {
	    let currentID = null;
	    for (let _ref3 of this._tabs) {
	      var _ref4 = _slicedToArray(_ref3, 2);

	      let id = _ref4[0];
	      let tab = _ref4[1];

	      if (this._tabboxSelectedTab == tab) {
	        currentID = id;
	        break;
	      }
	    }
	    return currentID;
	  },

	  /**
	   * Returns the requested tab panel based on the id.
	   * @param {String} id
	   * @return {DOMNode}
	   */
	  getTabPanel: function (id) {
	    // Search with and without the ID prefix as there might have been existing
	    // tabpanels by the time the sidebar got created
	    return this._tabboxTabpanels.querySelector("#" + this.TABPANEL_ID_PREFIX + id + ", #" + id);
	  },

	  /**
	   * Return the tab based on the provided id, if one was registered with this id.
	   * @param {String} id
	   * @return {DOMNode}
	   */
	  getTab: function (id) {
	    return this._tabs.get(id);
	  },

	  /**
	   * Event handler.
	   */
	  handleEvent: function (event) {
	    if (event.type !== "select" || this._destroyed) {
	      return;
	    }

	    if (this._currentTool == this.getCurrentTabID()) {
	      // Tool hasn't changed.
	      return;
	    }

	    let previousTool = this._currentTool;
	    this._currentTool = this.getCurrentTabID();
	    if (previousTool) {
	      // Hack to hide tab panel until we have a different widget.
	      this._tabboxTabpanels.querySelector("#" + this._tabs.get(previousTool).linkedPanel).hidden = true;

	      if (this._telemetry) {
	        this._telemetry.toolClosed(previousTool);
	      }
	      this.emit(previousTool + "-unselected");
	    }

	    if (this._telemetry) {
	      this._telemetry.toolOpened(this._currentTool);
	    }

	    // Hack to show tab panel until we have a different widget.
	    this._tabboxTabpanels.querySelector("#" + this._tabs.get(this._currentTool).linkedPanel).hidden = false;
	    this.emit(this._currentTool + "-selected");
	    this.emit("select", this._currentTool);

	    // Handlers for "select"/"...-selected"/"...-unselected" events might have
	    // destroyed the sidebar in the meantime.
	    if (this._destroyed) {
	      return;
	    }

	    // Handle menuitem selection if the allTabsMenu is there by unchecking all
	    // items except the selected one.
	    let tab = this._tabboxSelectedTab;
	    if (tab.allTabsMenuItem) {
	      for (let otherItem of this._allTabsBtn.querySelectorAll("menuitem")) {
	        otherItem.removeAttribute("checked");
	      }
	      tab.allTabsMenuItem.setAttribute("checked", true);
	    }
	  },

	  /**
	   * Toggle sidebar's visibility state.
	   */
	  toggle: function () {
	    if (this._tabbox.hasAttribute("hidden")) {
	      this.show();
	    } else {
	      this.hide();
	    }
	  },

	  /**
	   * Show the sidebar.
	   */
	  show: function () {
	    if (this._width) {
	      this._tabbox.width = this._width;
	    }
	    this._tabbox.removeAttribute("hidden");

	    this.emit("show");
	  },

	  /**
	   * Show the sidebar.
	   */
	  hide: function () {
	    Services.prefs.setIntPref("devtools.toolsidebar-width." + this._uid, this._tabbox.width);
	    this._tabbox.setAttribute("hidden", "true");

	    this.emit("hide");
	  },

	  /**
	   * Return the window containing the tab content.
	   */
	  getWindowForTab: function (id) {
	    if (!this._tabs.has(id)) {
	      return null;
	    }

	    // Get the tabpanel and make sure it contains an iframe
	    let panel = this.getTabPanel(id);
	    if (!panel || !panel.firstChild || !panel.firstChild.contentWindow) {
	      return;
	    }
	    return panel.firstChild.contentWindow;
	  },

	  /**
	   * Clean-up.
	   */
	  destroy: Task.async(function* () {
	    if (this._destroyed) {
	      return;
	    }
	    this._destroyed = true;

	    Services.prefs.setIntPref("devtools.toolsidebar-width." + this._uid, this._tabbox.width);

	    if (this._allTabsBtn) {
	      this.removeAllTabsMenu();
	    }

	    this._tabbox.removeEventListener("select", this, true);

	    // Note that we check for the existence of this._tabboxTabpanels at each
	    // step as the container window may have been closed by the time one of the
	    // panel's destroy promise resolves.
	    while (this._tabboxTabpanels && this._tabboxTabpanels.hasChildNodes()) {
	      let panel = this._tabboxTabpanels.firstChild;
	      let win = panel.firstChild.contentWindow;
	      if (win && "destroy" in win) {
	        yield win.destroy();
	      }
	      panel.remove();
	    }

	    while (this._tabboxTabs && this._tabboxTabs.hasChildNodes()) {
	      this._tabboxTabs.removeChild(this._tabboxTabs.firstChild);
	    }

	    if (this._currentTool && this._telemetry) {
	      this._telemetry.toolClosed(this._currentTool);
	    }

	    this._toolPanel.emit("sidebar-destroyed", this);

	    this._tabs = null;
	    this._tabbox = null;
	    this._panelDoc = null;
	    this._toolPanel = null;
	  })
	};

	XPCOMUtils.defineLazyGetter(this, "l10n", function () {
	  let bundle = Services.strings.createBundle("chrome://devtools/locale/toolbox.properties");
	  let l10n = function (aName, ...aArgs) {
	    try {
	      if (aArgs.length == 0) {
	        return bundle.GetStringFromName(aName);
	      } else {
	        return bundle.formatStringFromName(aName, aArgs, aArgs.length);
	      }
	    } catch (ex) {
	      Services.console.logStringMessage("Error reading '" + aName + "'");
	    }
	  };
	  return l10n;
	});

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;
	const Ci = _require.Ci;

	var _require2 = __webpack_require__(38);

	const Task = _require2.Task;

	const promise = __webpack_require__(6);
	const EventEmitter = __webpack_require__(7);

	var _require3 = __webpack_require__(44);

	const AutocompletePopup = _require3.AutocompletePopup;

	// Maximum number of selector suggestions shown in the panel.

	const MAX_SUGGESTIONS = 15;

	/**
	 * Converts any input field into a document search box.
	 *
	 * @param {InspectorPanel} inspector The InspectorPanel whose `walker` attribute
	 * should be used for document traversal.
	 * @param {DOMNode} input The input element to which the panel will be attached
	 * and from where search input will be taken.
	 *
	 * Emits the following events:
	 * - search-cleared: when the search box is emptied
	 * - search-result: when a search is made and a result is selected
	 */
	function InspectorSearch(inspector, input) {
	  this.inspector = inspector;
	  this.searchBox = input;
	  this._lastSearched = null;

	  this._onKeyDown = this._onKeyDown.bind(this);
	  this._onCommand = this._onCommand.bind(this);
	  this.searchBox.addEventListener("keydown", this._onKeyDown, true);
	  this.searchBox.addEventListener("command", this._onCommand, true);

	  // For testing, we need to be able to wait for the most recent node request
	  // to finish.  Tests can watch this promise for that.
	  this._lastQuery = promise.resolve(null);

	  this.autocompleter = new SelectorAutocompleter(inspector, input);
	  EventEmitter.decorate(this);
	}

	exports.InspectorSearch = InspectorSearch;

	InspectorSearch.prototype = {
	  get walker() {
	    return this.inspector.walker;
	  },

	  destroy: function () {
	    this.searchBox.removeEventListener("keydown", this._onKeyDown, true);
	    this.searchBox.removeEventListener("command", this._onCommand, true);
	    this.searchBox = null;
	    this.autocompleter.destroy();
	  },

	  _onSearch: function (reverse = false) {
	    this.doFullTextSearch(this.searchBox.value, reverse).catch(function (e) {
	      return console.error(e);
	    });
	  },

	  doFullTextSearch: Task.async(function* (query, reverse) {
	    let lastSearched = this._lastSearched;
	    this._lastSearched = query;

	    if (query.length === 0) {
	      this.searchBox.classList.remove("devtools-no-search-result");
	      if (!lastSearched || lastSearched.length > 0) {
	        this.emit("search-cleared");
	      }
	      return;
	    }

	    let res = yield this.walker.search(query, { reverse });

	    // Value has changed since we started this request, we're done.
	    if (query != this.searchBox.value) {
	      return;
	    }

	    if (res) {
	      this.inspector.selection.setNodeFront(res.node, "inspectorsearch");
	      this.searchBox.classList.remove("devtools-no-search-result");

	      res.query = query;
	      this.emit("search-result", res);
	    } else {
	      this.searchBox.classList.add("devtools-no-search-result");
	      this.emit("search-result");
	    }
	  }),

	  _onCommand: function () {
	    if (this.searchBox.value.length === 0) {
	      this._onSearch();
	    }
	  },

	  _onKeyDown: function (event) {
	    if (this.searchBox.value.length === 0) {
	      this.searchBox.removeAttribute("filled");
	    } else {
	      this.searchBox.setAttribute("filled", true);
	    }
	    if (event.keyCode === event.DOM_VK_RETURN) {
	      this._onSearch();
	    }if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_G && event.metaKey) {
	      this._onSearch(event.shiftKey);
	      event.preventDefault();
	    }
	  }
	};

	/**
	 * Converts any input box on a page to a CSS selector search and suggestion box.
	 *
	 * Emits 'processing-done' event when it is done processing the current
	 * keypress, search request or selection from the list, whether that led to a
	 * search or not.
	 *
	 * @constructor
	 * @param InspectorPanel inspector
	 *        The InspectorPanel whose `walker` attribute should be used for
	 *        document traversal.
	 * @param nsiInputElement inputNode
	 *        The input element to which the panel will be attached and from where
	 *        search input will be taken.
	 */
	function SelectorAutocompleter(inspector, inputNode) {
	  this.inspector = inspector;
	  this.searchBox = inputNode;
	  this.panelDoc = this.searchBox.ownerDocument;

	  this.showSuggestions = this.showSuggestions.bind(this);
	  this._onSearchKeypress = this._onSearchKeypress.bind(this);
	  this._onListBoxKeypress = this._onListBoxKeypress.bind(this);
	  this._onMarkupMutation = this._onMarkupMutation.bind(this);

	  // Options for the AutocompletePopup.
	  let options = {
	    panelId: "inspector-searchbox-panel",
	    listBoxId: "searchbox-panel-listbox",
	    autoSelect: true,
	    position: "before_start",
	    direction: "ltr",
	    theme: "auto",
	    onClick: this._onListBoxKeypress,
	    onKeypress: this._onListBoxKeypress
	  };
	  this.searchPopup = new AutocompletePopup(this.panelDoc, options);

	  this.searchBox.addEventListener("input", this.showSuggestions, true);
	  this.searchBox.addEventListener("keypress", this._onSearchKeypress, true);
	  this.inspector.on("markupmutation", this._onMarkupMutation);

	  // For testing, we need to be able to wait for the most recent node request
	  // to finish.  Tests can watch this promise for that.
	  this._lastQuery = promise.resolve(null);
	  EventEmitter.decorate(this);
	}

	exports.SelectorAutocompleter = SelectorAutocompleter;

	SelectorAutocompleter.prototype = {
	  get walker() {
	    return this.inspector.walker;
	  },

	  // The possible states of the query.
	  States: {
	    CLASS: "class",
	    ID: "id",
	    TAG: "tag"
	  },

	  // The current state of the query.
	  _state: null,

	  // The query corresponding to last state computation.
	  _lastStateCheckAt: null,

	  /**
	   * Computes the state of the query. State refers to whether the query
	   * currently requires a class suggestion, or a tag, or an Id suggestion.
	   * This getter will effectively compute the state by traversing the query
	   * character by character each time the query changes.
	   *
	   * @example
	   *        '#f' requires an Id suggestion, so the state is States.ID
	   *        'div > .foo' requires class suggestion, so state is States.CLASS
	   */
	  get state() {
	    if (!this.searchBox || !this.searchBox.value) {
	      return null;
	    }

	    let query = this.searchBox.value;
	    if (this._lastStateCheckAt == query) {
	      // If query is the same, return early.
	      return this._state;
	    }
	    this._lastStateCheckAt = query;

	    this._state = null;
	    let subQuery = "";
	    // Now we iterate over the query and decide the state character by character.
	    // The logic here is that while iterating, the state can go from one to
	    // another with some restrictions. Like, if the state is Class, then it can
	    // never go to Tag state without a space or '>' character; Or like, a Class
	    // state with only '.' cannot go to an Id state without any [a-zA-Z] after
	    // the '.' which means that '.#' is a selector matching a class name '#'.
	    // Similarily for '#.' which means a selctor matching an id '.'.
	    for (let i = 1; i <= query.length; i++) {
	      // Calculate the state.
	      subQuery = query.slice(0, i);

	      var _subQuery$slice = subQuery.slice(-2);

	      var _subQuery$slice2 = _slicedToArray(_subQuery$slice, 2);

	      let secondLastChar = _subQuery$slice2[0];
	      let lastChar = _subQuery$slice2[1];

	      switch (this._state) {
	        case null:
	          // This will happen only in the first iteration of the for loop.
	          lastChar = secondLastChar;
	        case this.States.TAG:
	          this._state = lastChar == "." ? this.States.CLASS : lastChar == "#" ? this.States.ID : this.States.TAG;
	          break;

	        case this.States.CLASS:
	          if (subQuery.match(/[\.]+[^\.]*$/)[0].length > 2) {
	            // Checks whether the subQuery has atleast one [a-zA-Z] after the '.'.
	            this._state = lastChar == " " || lastChar == ">" ? this.States.TAG : lastChar == "#" ? this.States.ID : this.States.CLASS;
	          }
	          break;

	        case this.States.ID:
	          if (subQuery.match(/[#]+[^#]*$/)[0].length > 2) {
	            // Checks whether the subQuery has atleast one [a-zA-Z] after the '#'.
	            this._state = lastChar == " " || lastChar == ">" ? this.States.TAG : lastChar == "." ? this.States.CLASS : this.States.ID;
	          }
	          break;
	      }
	    }
	    return this._state;
	  },

	  /**
	   * Removes event listeners and cleans up references.
	   */
	  destroy: function () {
	    this.searchBox.removeEventListener("input", this.showSuggestions, true);
	    this.searchBox.removeEventListener("keypress", this._onSearchKeypress, true);
	    this.inspector.off("markupmutation", this._onMarkupMutation);
	    this.searchPopup.destroy();
	    this.searchPopup = null;
	    this.searchBox = null;
	    this.panelDoc = null;
	  },

	  /**
	   * Handles keypresses inside the input box.
	   */
	  _onSearchKeypress: function (event) {
	    let query = this.searchBox.value;
	    switch (event.keyCode) {
	      case event.DOM_VK_RETURN:
	      case event.DOM_VK_TAB:
	        if (this.searchPopup.isOpen && this.searchPopup.getItemAtIndex(this.searchPopup.itemCount - 1).preLabel == query) {
	          this.searchPopup.selectedIndex = this.searchPopup.itemCount - 1;
	          this.searchBox.value = this.searchPopup.selectedItem.label;
	          this.hidePopup();
	        }
	        break;

	      case event.DOM_VK_UP:
	        if (this.searchPopup.isOpen && this.searchPopup.itemCount > 0) {
	          this.searchPopup.focus();
	          if (this.searchPopup.selectedIndex == this.searchPopup.itemCount - 1) {
	            this.searchPopup.selectedIndex = Math.max(0, this.searchPopup.itemCount - 2);
	          } else {
	            this.searchPopup.selectedIndex = this.searchPopup.itemCount - 1;
	          }
	          this.searchBox.value = this.searchPopup.selectedItem.label;
	        }
	        break;

	      case event.DOM_VK_DOWN:
	        if (this.searchPopup.isOpen && this.searchPopup.itemCount > 0) {
	          this.searchPopup.focus();
	          this.searchPopup.selectedIndex = 0;
	          this.searchBox.value = this.searchPopup.selectedItem.label;
	        }
	        break;

	      default:
	        return;
	    }

	    event.preventDefault();
	    event.stopPropagation();
	    this.emit("processing-done");
	  },

	  /**
	   * Handles keypress and mouse click on the suggestions richlistbox.
	   */
	  _onListBoxKeypress: function (event) {
	    switch (event.keyCode || event.button) {
	      case event.DOM_VK_RETURN:
	      case event.DOM_VK_TAB:
	      case 0:
	        // left mouse button
	        event.stopPropagation();
	        event.preventDefault();
	        this.searchBox.value = this.searchPopup.selectedItem.label;
	        this.searchBox.focus();
	        this.hidePopup();
	        break;

	      case event.DOM_VK_UP:
	        if (this.searchPopup.selectedIndex == 0) {
	          this.searchPopup.selectedIndex = -1;
	          event.stopPropagation();
	          event.preventDefault();
	          this.searchBox.focus();
	        } else {
	          let index = this.searchPopup.selectedIndex;
	          this.searchBox.value = this.searchPopup.getItemAtIndex(index - 1).label;
	        }
	        break;

	      case event.DOM_VK_DOWN:
	        if (this.searchPopup.selectedIndex == this.searchPopup.itemCount - 1) {
	          this.searchPopup.selectedIndex = -1;
	          event.stopPropagation();
	          event.preventDefault();
	          this.searchBox.focus();
	        } else {
	          let index = this.searchPopup.selectedIndex;
	          this.searchBox.value = this.searchPopup.getItemAtIndex(index + 1).label;
	        }
	        break;

	      case event.DOM_VK_BACK_SPACE:
	        event.stopPropagation();
	        event.preventDefault();
	        this.searchBox.focus();
	        if (this.searchBox.selectionStart > 0) {
	          this.searchBox.value = this.searchBox.value.substring(0, this.searchBox.selectionStart - 1);
	        }
	        this.hidePopup();
	        break;
	    }
	    this.emit("processing-done");
	  },

	  /**
	   * Reset previous search results on markup-mutations to make sure we search
	   * again after nodes have been added/removed/changed.
	   */
	  _onMarkupMutation: function () {
	    this._searchResults = null;
	    this._lastSearched = null;
	  },

	  /**
	   * Populates the suggestions list and show the suggestion popup.
	   */
	  _showPopup: function (list, firstPart, aState) {
	    let total = 0;
	    let query = this.searchBox.value;
	    let items = [];

	    for (let _ref of list) {
	      var _ref2 = _slicedToArray(_ref, 3);

	      let value = _ref2[0];
	      let /*count*/state = _ref2[2];

	      // for cases like 'div ' or 'div >' or 'div+'
	      if (query.match(/[\s>+]$/)) {
	        value = query + value;
	      }
	      // for cases like 'div #a' or 'div .a' or 'div > d' and likewise
	      else if (query.match(/[\s>+][\.#a-zA-Z][^\s>+\.#]*$/)) {
	          let lastPart = query.match(/[\s>+][\.#a-zA-Z][^>\s+\.#]*$/)[0];
	          value = query.slice(0, -1 * lastPart.length + 1) + value;
	        }
	        // for cases like 'div.class' or '#foo.bar' and likewise
	        else if (query.match(/[a-zA-Z][#\.][^#\.\s+>]*$/)) {
	            let lastPart = query.match(/[a-zA-Z][#\.][^#\.\s>+]*$/)[0];
	            value = query.slice(0, -1 * lastPart.length + 1) + value;
	          }

	      let item = {
	        preLabel: query,
	        label: value
	      };

	      // In case of tagNames, change the case to small
	      if (value.match(/.*[\.#][^\.#]{0,}$/) == null) {
	        item.label = value.toLowerCase();
	      }

	      // In case the query's state is tag and the item's state is id or class
	      // adjust the preLabel
	      if (aState === this.States.TAG && state === this.States.CLASS) {
	        item.preLabel = "." + item.preLabel;
	      }
	      if (aState === this.States.TAG && state === this.States.ID) {
	        item.preLabel = "#" + item.preLabel;
	      }

	      items.unshift(item);
	      if (++total > MAX_SUGGESTIONS - 1) {
	        break;
	      }
	    }
	    if (total > 0) {
	      this.searchPopup.setItems(items);
	      this.searchPopup.openPopup(this.searchBox);
	    } else {
	      this.hidePopup();
	    }
	  },

	  /**
	   * Hide the suggestion popup if necessary.
	   */
	  hidePopup: function () {
	    if (this.searchPopup.isOpen) {
	      this.searchPopup.hidePopup();
	    }
	  },

	  /**
	   * Suggests classes,ids and tags based on the user input as user types in the
	   * searchbox.
	   */
	  showSuggestions: function () {
	    var _this = this;

	    let query = this.searchBox.value;
	    let state = this.state;
	    let firstPart = "";

	    if (state === this.States.TAG) {
	      // gets the tag that is being completed. For ex. 'div.foo > s' returns 's',
	      // 'di' returns 'di' and likewise.
	      firstPart = (query.match(/[\s>+]?([a-zA-Z]*)$/) || ["", query])[1];
	      query = query.slice(0, query.length - firstPart.length);
	    } else if (state === this.States.CLASS) {
	      // gets the class that is being completed. For ex. '.foo.b' returns 'b'
	      firstPart = query.match(/\.([^\.]*)$/)[1];
	      query = query.slice(0, query.length - firstPart.length - 1);
	    } else if (state === this.States.ID) {
	      // gets the id that is being completed. For ex. '.foo#b' returns 'b'
	      firstPart = query.match(/#([^#]*)$/)[1];
	      query = query.slice(0, query.length - firstPart.length - 1);
	    }
	    // TODO: implement some caching so that over the wire request is not made
	    // everytime.
	    if (/[\s+>~]$/.test(query)) {
	      query += "*";
	    }

	    this._lastQuery = this.walker.getSuggestionsForQuery(query, firstPart, state).then(function (result) {
	      _this.emit("processing-done");
	      if (result.query !== query) {
	        // This means that this response is for a previous request and the user
	        // as since typed something extra leading to a new request.
	        return;
	      }

	      if (state === _this.States.CLASS) {
	        firstPart = "." + firstPart;
	      } else if (state === _this.States.ID) {
	        firstPart = "#" + firstPart;
	      }

	      // If there is a single tag match and it's what the user typed, then
	      // don't need to show a popup.
	      if (result.suggestions.length === 1 && result.suggestions[0][0] === firstPart) {
	        result.suggestions = [];
	      }

	      _this._showPopup(result.suggestions, firstPart, state);
	    });

	    return this._lastQuery;
	  }
	};

/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports = {
	  "confirmNavigationAway.message2": "If you leave this page, the changes you have made will be lost.",
	  "confirmNavigationAway.buttonLeave": "Leave Page",
	  "confirmNavigationAway.buttonLeaveAccesskey": "L",
	  "confirmNavigationAway.buttonStay": "Stay on Page",
	  "confirmNavigationAway.buttonStayAccesskey": "S",
	  "breadcrumbs.siblings": "Siblings",
	  "debuggerPausedWarning.message": "Debugger is paused. Some features like mouse selection will not work.",
	  "nodeMenu.tooltiptext": "Node operations",
	  "inspector.label": "Inspector",
	  "inspector.commandkey": "C",
	  "inspector.accesskey": "I",
	  "inspector.panelLabel": "Inspector Panel",
	  "inspector.panelLabel.markupView": "Markup View",
	  "markupView.more.showing": "Some nodes were hidden.",
	  "markupView.more.showAll": "Show All %S Nodes",
	  "inspector.tooltip2": "DOM and Style Inspector (%S)",
	  "previewTooltip.image.brokenImage": "Could not load the image",
	  "eventsTooltip.openInDebugger": "Open in Debugger",
	  "docsTooltip.visitMDN": "Visit MDN page",
	  "docsTooltip.loadDocsError": "Could not load docs page.",
	  "inspector.collapsePane": "Collapse pane",
	  "inspector.expandPane": "Expand pane",
	  "inspector.searchResultsCount2": "%1$S of %2$S",
	  "inspector.searchResultsNone": "No matches",
	  "inspector.menu.openUrlInNewTab.label": "Open Link in New Tab",
	  "inspector.menu.copyUrlToClipboard.label": "Copy Link Address",
	  "inspector.menu.selectElement.label": "Select Element #%S",
	  "inspector.menu.editAttribute.label": "Edit Attribute %S",
	  "inspector.menu.removeAttribute.label": "Remove Attribute %S"
	}

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = {
	  "toolboxDockButtons.bottom.tooltip": "Dock to bottom of browser window",
	  "toolboxDockButtons.side.tooltip": "Dock to side of browser window",
	  "toolboxDockButtons.window.tooltip": "Show in separate window",
	  "toolboxDockButtons.bottom.minimize": "Minimize the toolbox",
	  "toolboxDockButtons.bottom.maximize": "Maximize the toolbox",
	  "toolboxToggleButton.errors": "#1 error;#1 errors",
	  "toolboxToggleButton.warnings": "#1 warning;#1 warnings",
	  "toolboxToggleButton.tooltip": "%1$S, %2$S\nClick to toggle the developer tools.",
	  "toolbox.titleTemplate": "%1$S - %2$S",
	  "toolbox.defaultTitle": "Developer Tools",
	  "toolbox.label": "Developer Tools",
	  "optionsButton.tooltip": "Toolbox Options",
	  "options.label": "Options",
	  "options.panelLabel": "Toolbox Options Panel",
	  "options.toolNotSupportedMarker": "%1$S *",
	  "scratchpad.keycode": "VK_F4",
	  "browserConsoleCmd.commandkey": "j",
	  "pickButton.tooltip": "Pick an element from the page",
	  "sidebar.showAllTabs.tooltip": "All tabs",
	  "options.darkTheme.label": "Dark theme",
	  "options.lightTheme.label": "Light theme",
	  "toolbox.noContentProcess.message": "No content process running.",
	  "toolbox.viewCssSourceInStyleEditor.label": "Open File in Style-Editor",
	  "toolbox.viewJsSourceInDebugger.label": "Open File in Debugger"
	}

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;
	const Cr = _require.Cr;

	const promise = __webpack_require__(6);
	const EventEmitter = __webpack_require__(7);
	const DevToolsUtils = __webpack_require__(19);

	function DebuggerPanel(iframeWindow, toolbox) {
	  this.panelWin = iframeWindow;
	  this._toolbox = toolbox;
	  // this._destroyer = null;

	  // this._view = this.panelWin.DebuggerView;
	  // this._controller = this.panelWin.DebuggerController;
	  // this._view._hostType = this._toolbox.hostType;
	  // this._controller._target = this.target;
	  // this._controller._toolbox = this._toolbox;

	  // this.handleHostChanged = this.handleHostChanged.bind(this);
	  // this.highlightWhenPaused = this.highlightWhenPaused.bind(this);
	  // this.unhighlightWhenResumed = this.unhighlightWhenResumed.bind(this);

	  // EventEmitter.decorate(this);
	}

	exports.DebuggerPanel = DebuggerPanel;

	DebuggerPanel.prototype = {
	  /**
	   * Open is effectively an asynchronous constructor.
	   *
	   * @return object
	   *         A promise that is resolved when the Debugger completes opening.
	   */
	  open: function () {
	    return this.panelWin.connect(this.target);

	    // Local debugging needs to make the target remote.
	    // if (!this.target.isRemote) {
	    //   targetPromise = this.target.makeRemote();
	    //   // Listen for tab switching events to manage focus when the content window
	    //   // is paused and events suppressed.
	    //   this.target.tab.addEventListener('TabSelect', this);
	    // } else {
	    //   targetPromise = promise.resolve(this.target);
	    // }

	    // return targetPromise
	    //   .then(() => this._controller.startupDebugger())
	    //   .then(() => this._controller.connect())
	    //   .then(() => {
	    //     this._toolbox.on("host-changed", this.handleHostChanged);
	    //     this.target.on("thread-paused", this.highlightWhenPaused);
	    //     this.target.on("thread-resumed", this.unhighlightWhenResumed);
	    //     // Add keys from this document's keyset to the toolbox, so they
	    //     // can work when the split console is focused.
	    //     let keysToClone = ["resumeKey", "resumeKey2", "stepOverKey",
	    //                       "stepOverKey2", "stepInKey", "stepInKey2",
	    //                       "stepOutKey", "stepOutKey2"];
	    //     for (let key of keysToClone) {
	    //       let elm = this.panelWin.document.getElementById(key);
	    //       this._toolbox.useKeyWithSplitConsole(elm, "jsdebugger");
	    //     }
	    //     this.isReady = true;
	    //     this.emit("ready");
	    //     return this;
	    //   })
	    //   .then(null, function onError(aReason) {
	    //     DevToolsUtils.reportException("DebuggerPanel.prototype.open", aReason);
	    //   });
	  },

	  // DevToolPanel API

	  get target() {
	    return this._toolbox.target;
	  },

	  destroy: function () {
	    // Make sure this panel is not already destroyed.
	    // if (this._destroyer) {
	    //   return this._destroyer;
	    // }

	    // this.target.off("thread-paused", this.highlightWhenPaused);
	    // this.target.off("thread-resumed", this.unhighlightWhenResumed);

	    // if (!this.target.isRemote) {
	    //   this.target.tab.removeEventListener('TabSelect', this);
	    // }

	    // return this._destroyer = this._controller.shutdownDebugger().then(() => {
	    //   this.emit("destroyed");
	    // });
	  },

	  // DebuggerPanel API

	  addBreakpoint: function (location) {
	    const actions = this.panelWin.actions;
	    const dispatch = this._controller.dispatch;

	    return dispatch(actions.addBreakpoint(location));
	  },

	  removeBreakpoint: function (location) {
	    const actions = this.panelWin.actions;
	    const dispatch = this._controller.dispatch;

	    return dispatch(actions.removeBreakpoint(location));
	  },

	  blackbox: function (source, flag) {
	    const actions = this.panelWin.actions;
	    const dispatch = this._controller.dispatch;

	    return dispatch(actions.blackbox(source, flag));
	  },

	  handleHostChanged: function () {
	    // this._view.handleHostChanged(this._toolbox.hostType);
	  },

	  highlightWhenPaused: function () {
	    this._toolbox.highlightTool("jsdebugger");

	    // Also raise the toolbox window if it is undocked or select the
	    // corresponding tab when toolbox is docked.
	    this._toolbox.raise();
	  },

	  unhighlightWhenResumed: function () {
	    this._toolbox.unhighlightTool("jsdebugger");
	  },

	  // nsIDOMEventListener API

	  handleEvent: function (aEvent) {
	    var _this = this;

	    if (aEvent.target == this.target.tab && this._controller.activeThread.state == "paused") {
	      // Wait a tick for the content focus event to be delivered.
	      DevToolsUtils.executeSoon(function () {
	        return _this._toolbox.focusTool("jsdebugger");
	      });
	    }
	  }
	};

/***/ },
/* 94 */
/***/ function(module, exports) {

	module.exports = {
	  "typeError": "Error:",
	  "typeWarning": "Warning:",
	  "typeNetwork": "Network:",
	  "typeException": "Exception:",
	  "typeCssParser": "CSS Parser:",
	  "typeStrict": "Strict Warning:",
	  "msgCategory": "Category:",
	  "errLine": "Line: %S",
	  "btnHide": "Hide",
	  "btnPrefs": "Preferences",
	  "categoryPage": "Page:",
	  "categoryConsole": "Console:",
	  "btnMutation": "DOM Mutation",
	  "tipMutation": "Toggle DOM Mutation event logging",
	  "btnGlobal": "Global Messages",
	  "tipGlobal": "Toggle Global Message logging",
	  "localConsole": "Local Console",
	  "clearConsoleCmd.label": "Clear Console",
	  "clearConsoleCmd.accesskey": "e",
	  "close.button": "Close",
	  "close.accesskey": "C",
	  "update.button": "Update",
	  "update.accesskey": "U",
	  "cmd.commandkey": "K",
	  "webConsoleCmd.accesskey": "W",
	  "timestampFormat": "%02S:%02S:%02S.%03S",
	  "helperFuncUnsupportedTypeError": "Can't call pprint on this type of object.",
	  "NetworkPanel.durationMS": "%Sms",
	  "ConsoleAPIDisabled": "The Web Console logging API (console.log, console.info, console.warn, console.error) has been disabled by a script on this page.",
	  "webConsoleWindowTitleAndURL": "Web Console - %S",
	  "webConsoleXhrIndicator": "XHR",
	  "webConsoleMixedContentWarning": "Mixed Content",
	  "webConsoleMoreInfoLabel": "Learn More",
	  "scratchpad.linkText": "Shift+RETURN - Open in Scratchpad",
	  "gcliterm.instanceLabel": "Instance of %S",
	  "reflow.messageWithNoLink": "reflow: %Sms",
	  "reflow.messageWithLink": "reflow: %Sms ",
	  "reflow.messageLinkText": "function %1$S, %2$S line %3$S",
	  "stacktrace.anonymousFunction": "<anonymous>",
	  "stacktrace.asyncStack": "(Async: %S)",
	  "unknownLocation": "<unknown>",
	  "timerStarted": "%S: timer started",
	  "timeEnd": "%1$S: %2$Sms",
	  "noCounterLabel": "<no label>",
	  "Autocomplete.blank": "<- no result",
	  "maxTimersExceeded": "The maximum allowed number of timers in this page was exceeded.",
	  "maxCountersExceeded": "The maximum allowed number of counters in this page was exceeded.",
	  "JSTerm.updateNotInspectable": "After your input has been re-evaluated the result is no longer inspectable.",
	  "remoteWebConsolePromptTitle": "Remote Connection",
	  "remoteWebConsolePromptMessage": "Enter hostname and port number (host:port)",
	  "remoteWebConsoleSelectTabTitle": "Tab list - Remote Connection",
	  "remoteWebConsoleSelectTabMessage": "Select one of the tabs you want to attach to, or select the global console.",
	  "listTabs.globalConsoleActor": "*Global Console*",
	  "MenuWebconsole.label": "Web Console",
	  "ToolboxTabWebconsole.label": "Console",
	  "ToolboxWebConsole.panelLabel": "Console Panel",
	  "ToolboxWebconsole.tooltip2": "Web Console (%S)",
	  "longStringEllipsis": "[…]",
	  "longStringTooLong": "The string you are trying to view is too long to be displayed by the Web Console.",
	  "NetworkPanel.fetchRemainingResponseContentLink": "Fetch the remaining %S bytes",
	  "NetworkPanel.fetchRemainingRequestContentLink": "Fetch the request body (%S bytes)",
	  "connectionTimeout": "Connection timeout. Check the Error Console on both ends for potential error messages. Reopen the Web Console to try again.",
	  "propertiesFilterPlaceholder": "Filter properties",
	  "emptyPropertiesList": "No properties to display",
	  "messageRepeats.tooltip2": "#1 repeat;#1 repeats",
	  "openNodeInInspector": "Click to select the node in the inspector",
	  "cdFunctionInvalidArgument": "Cannot cd() to the given window. Invalid argument.",
	  "selfxss.msg": "Scam Warning: Take care when pasting things you don't understand. This could allow attackers to steal your identity or take control of your computer. Please type '%S' below (no need to press enter) to allow pasting.",
	  "selfxss.okstring": "allow pasting",
	  "messageToggleDetails": "Show/hide message details.",
	  "emptySlotLabel": "#1 empty slot;#1 empty slots",
	  "table.index": "(index)",
	  "table.iterationIndex": "(iteration index)",
	  "table.key": "Key",
	  "table.value": "Values",
	  "severity.error": "Error",
	  "severity.warn": "Warning",
	  "severity.info": "Info",
	  "severity.log": "Log"
	}

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	const promise = __webpack_require__(6);

	var _require2 = __webpack_require__(38);

	const Task = _require2.Task;

	const DevToolsUtils = __webpack_require__(19);

	/**
	 * Client-side highlighter shared module.
	 * To be used by toolbox panels that need to highlight DOM elements.
	 *
	 * Highlighting and selecting elements is common enough that it needs to be at
	 * toolbox level, accessible by any panel that needs it.
	 * That's why the toolbox is the one that initializes the inspector and
	 * highlighter. It's also why the API returned by this module needs a reference
	 * to the toolbox which should be set once only.
	 */

	/**
	 * Get the highighterUtils instance for a given toolbox.
	 * This should be done once only by the toolbox itself and stored there so that
	 * panels can get it from there. That's because the API returned has a stateful
	 * scope that would be different for another instance returned by this function.
	 *
	 * @param {Toolbox} toolbox
	 * @return {Object} the highlighterUtils public API
	 */
	exports.getHighlighterUtils = function (toolbox) {
	  if (!toolbox || !toolbox.target) {
	    throw new Error("Missing or invalid toolbox passed to getHighlighterUtils");
	    return;
	  }

	  // Exported API properties will go here
	  let exported = {};

	  // The current toolbox target
	  let target = toolbox.target;

	  // Is the highlighter currently in pick mode
	  let isPicking = false;

	  // Is the box model already displayed, used to prevent dispatching
	  // unnecessary requests, especially during toolbox shutdown
	  let isNodeFrontHighlighted = false;

	  /**
	   * Release this utils, nullifying the references to the toolbox
	   */
	  exported.release = function () {
	    toolbox = target = null;
	  };

	  /**
	   * Does the target have the highlighter actor.
	   * The devtools must be backwards compatible with at least B2G 1.3 (28),
	   * which doesn't have the highlighter actor. This can be removed as soon as
	   * the minimal supported version becomes 1.4 (29)
	   */
	  let isRemoteHighlightable = exported.isRemoteHighlightable = function () {
	    return target.client.traits.highlightable;
	  };

	  /**
	   * Does the target support custom highlighters.
	   */
	  let supportsCustomHighlighters = exported.supportsCustomHighlighters = function () {
	    return !!target.client.traits.customHighlighters;
	  };

	  /**
	   * Make a function that initializes the inspector before it runs.
	   * Since the init of the inspector is asynchronous, the return value will be
	   * produced by Task.async and the argument should be a generator
	   * @param {Function*} generator A generator function
	   * @return {Function} A function
	   */
	  let isInspectorInitialized = false;
	  let requireInspector = function (generator) {
	    return Task.async(function* (...args) {
	      if (!isInspectorInitialized) {
	        yield toolbox.initInspector();
	        isInspectorInitialized = true;
	      }
	      return yield generator.apply(null, args);
	    });
	  };

	  /**
	   * Start/stop the element picker on the debuggee target.
	   * @return A promise that resolves when done
	   */
	  let togglePicker = exported.togglePicker = function () {
	    if (isPicking) {
	      return stopPicker();
	    } else {
	      return startPicker();
	    }
	  };

	  /**
	   * Start the element picker on the debuggee target.
	   * This will request the inspector actor to start listening for mouse events
	   * on the target page to highlight the hovered/picked element.
	   * Depending on the server-side capabilities, this may fire events when nodes
	   * are hovered.
	   * @return A promise that resolves when the picker has started or immediately
	   * if it is already started
	   */
	  let startPicker = exported.startPicker = requireInspector(function* () {
	    if (isPicking) {
	      return;
	    }
	    isPicking = true;

	    toolbox.pickerButtonChecked = true;
	    yield toolbox.selectTool("inspector");
	    toolbox.on("select", stopPicker);

	    if (isRemoteHighlightable()) {
	      toolbox.walker.on("picker-node-hovered", onPickerNodeHovered);
	      toolbox.walker.on("picker-node-picked", onPickerNodePicked);
	      toolbox.walker.on("picker-node-canceled", onPickerNodeCanceled);

	      yield toolbox.highlighter.pick();
	      toolbox.emit("picker-started");
	    } else {
	      // If the target doesn't have the highlighter actor, we can use the
	      // walker's pick method instead, knowing that it only responds when a node
	      // is picked (instead of emitting events)
	      toolbox.emit("picker-started");
	      let node = yield toolbox.walker.pick();
	      onPickerNodePicked({ node: node });
	    }
	  });

	  /**
	   * Stop the element picker. Note that the picker is automatically stopped when
	   * an element is picked
	   * @return A promise that resolves when the picker has stopped or immediately
	   * if it is already stopped
	   */
	  let stopPicker = exported.stopPicker = requireInspector(function* () {
	    if (!isPicking) {
	      return;
	    }
	    isPicking = false;

	    toolbox.pickerButtonChecked = false;

	    if (isRemoteHighlightable()) {
	      yield toolbox.highlighter.cancelPick();
	      toolbox.walker.off("picker-node-hovered", onPickerNodeHovered);
	      toolbox.walker.off("picker-node-picked", onPickerNodePicked);
	      toolbox.walker.off("picker-node-canceled", onPickerNodeCanceled);
	    } else {
	      // If the target doesn't have the highlighter actor, use the walker's
	      // cancelPick method instead
	      yield toolbox.walker.cancelPick();
	    }

	    toolbox.off("select", stopPicker);
	    toolbox.emit("picker-stopped");
	  });

	  /**
	   * When a node is hovered by the mouse when the highlighter is in picker mode
	   * @param {Object} data Information about the node being hovered
	   */
	  function onPickerNodeHovered(data) {
	    toolbox.emit("picker-node-hovered", data.node);
	  }

	  /**
	   * When a node has been picked while the highlighter is in picker mode
	   * @param {Object} data Information about the picked node
	   */
	  function onPickerNodePicked(data) {
	    toolbox.selection.setNodeFront(data.node, "picker-node-picked");
	    stopPicker();
	  }

	  /**
	   * When the picker is canceled, stop the picker, and make sure the toolbox
	   * gets the focus.
	   */
	  function onPickerNodeCanceled() {
	    stopPicker();
	    toolbox.frame.focus();
	  }

	  /**
	   * Show the box model highlighter on a node in the content page.
	   * The node needs to be a NodeFront, as defined by the inspector actor
	   * @see devtools/server/actors/inspector.js
	   * @param {NodeFront} nodeFront The node to highlight
	   * @param {Object} options
	   * @return A promise that resolves when the node has been highlighted
	   */
	  let highlightNodeFront = exported.highlightNodeFront = requireInspector(function* (nodeFront, options = {}) {
	    if (!nodeFront) {
	      return;
	    }

	    isNodeFrontHighlighted = true;
	    if (isRemoteHighlightable()) {
	      yield toolbox.highlighter.showBoxModel(nodeFront, options);
	    } else {
	      // If the target doesn't have the highlighter actor, revert to the
	      // walker's highlight method, which draws a simple outline
	      yield toolbox.walker.highlight(nodeFront);
	    }

	    toolbox.emit("node-highlight", nodeFront, options.toSource());
	  });

	  /**
	   * This is a convenience method in case you don't have a nodeFront but a
	   * valueGrip. This is often the case with VariablesView properties.
	   * This method will simply translate the grip into a nodeFront and call
	   * highlightNodeFront, so it has the same signature.
	   * @see highlightNodeFront
	   */
	  let highlightDomValueGrip = exported.highlightDomValueGrip = requireInspector(function* (valueGrip, options = {}) {
	    let nodeFront = yield gripToNodeFront(valueGrip);
	    if (nodeFront) {
	      yield highlightNodeFront(nodeFront, options);
	    } else {
	      throw new Error("The ValueGrip passed could not be translated to a NodeFront");
	    }
	  });

	  /**
	   * Translate a debugger value grip into a node front usable by the inspector
	   * @param {ValueGrip}
	   * @return a promise that resolves to the node front when done
	   */
	  let gripToNodeFront = exported.gripToNodeFront = requireInspector(function* (grip) {
	    return yield toolbox.walker.getNodeActorFromObjectActor(grip.actor);
	  });

	  /**
	   * Hide the highlighter.
	   * @param {Boolean} forceHide Only really matters in test mode (when
	   * DevToolsUtils.testing is true). In test mode, hovering over several nodes
	   * in the markup view doesn't hide/show the highlighter to ease testing. The
	   * highlighter stays visible at all times, except when the mouse leaves the
	   * markup view, which is when this param is passed to true
	   * @return a promise that resolves when the highlighter is hidden
	   */
	  let unhighlight = exported.unhighlight = Task.async(function* (forceHide = false) {
	    forceHide = forceHide || !DevToolsUtils.testing;

	    // Note that if isRemoteHighlightable is true, there's no need to hide the
	    // highlighter as the walker uses setTimeout to hide it after some time
	    if (isNodeFrontHighlighted && forceHide && toolbox.highlighter && isRemoteHighlightable()) {
	      isNodeFrontHighlighted = false;
	      yield toolbox.highlighter.hideBoxModel();
	    }

	    toolbox.emit("node-unhighlight");
	  });

	  /**
	   * If the main, box-model, highlighter isn't enough, or if multiple
	   * highlighters are needed in parallel, this method can be used to return a
	   * new instance of a highlighter actor, given a type.
	   * The type of the highlighter passed must be known by the server.
	   * The highlighter actor returned will have the show(nodeFront) and hide()
	   * methods and needs to be released by the consumer when not needed anymore.
	   * @return a promise that resolves to the highlighter
	   */
	  let getHighlighterByType = exported.getHighlighterByType = requireInspector(function* (typeName) {
	    let highlighter = null;

	    if (supportsCustomHighlighters()) {
	      highlighter = yield toolbox.inspector.getHighlighterByType(typeName);
	    }

	    return highlighter || promise.reject("The target doesn't support " + `creating highlighters by types or ${ typeName } is unknown`);
	  });

	  // Return the public API
	  return exported;
	};

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;

	const EventEmitter = __webpack_require__(7);
	const promise = __webpack_require__(6);

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	var _require3 = __webpack_require__(97);

	const DOMHelpers = _require3.DOMHelpers;

	/* A host should always allow this much space for the page to be displayed.
	 * There is also a min-height on the browser, but we still don't want to set
	 * frame.height to be larger than that, since it can cause problems with
	 * resizing the toolbox and panel layout. */

	const MIN_PAGE_SIZE = 25;

	/**
	 * A toolbox host represents an object that contains a toolbox (e.g. the
	 * sidebar or a separate window). Any host object should implement the
	 * following functions:
	 *
	 * create() - create the UI and emit a 'ready' event when the UI is ready to use
	 * destroy() - destroy the host's UI
	 */

	exports.Hosts = {
	  "bottom": BottomHost,
	  "side": SidebarHost,
	  "window": WindowHost,
	  "custom": CustomHost
	};

	/**
	 * Host object for the dock on the bottom of the browser
	 */
	function BottomHost(hostTab) {
	  this.hostTab = hostTab;

	  EventEmitter.decorate(this);
	}

	BottomHost.prototype = {
	  type: "bottom",

	  heightPref: "devtools.toolbox.footer.height",

	  /**
	   * Create a box at the bottom of the host tab.
	   */
	  create: function () {
	    var _this = this;

	    return new Promise(function (resolve) {
	      _this.frame = document.createElement("iframe");
	      _this.frame.src = "data:text/html,";
	      _this.frame.className = "devtools-toolbox-bottom-iframe";

	      document.body.appendChild(_this.frame);
	      _this.emit("ready", _this.frame);
	      resolve(_this.frame);
	    });

	    // let deferred = promise.defer();

	    // let gBrowser = this.hostTab.ownerDocument.defaultView.gBrowser;
	    // let ownerDocument = gBrowser.ownerDocument;
	    // this._nbox = gBrowser.getNotificationBox(this.hostTab.linkedBrowser);

	    // this._splitter = ownerDocument.createElement("splitter");
	    // this._splitter.setAttribute("class", "devtools-horizontal-splitter");

	    // this.frame = ownerDocument.createElement("iframe");
	    // this.frame.className = "devtools-toolbox-bottom-iframe";
	    // this.frame.height = Math.min(
	    //   Services.prefs.getIntPref(this.heightPref),
	    //   this._nbox.clientHeight - MIN_PAGE_SIZE
	    // );

	    // this._nbox.appendChild(this._splitter);
	    // this._nbox.appendChild(this.frame);

	    // let frameLoad = () => {
	    //   this.emit("ready", this.frame);
	    //   deferred.resolve(this.frame);
	    // };

	    // this.frame.tooltip = "aHTMLTooltip";

	    // // we have to load something so we can switch documents if we have to
	    // this.frame.setAttribute("src", "about:blank");

	    // let domHelper = new DOMHelpers(this.frame.contentWindow);
	    // domHelper.onceDOMReady(frameLoad);

	    // focusTab(this.hostTab);

	    // return deferred.promise;
	  },

	  /**
	   * Raise the host.
	   */
	  raise: function () {
	    // focusTab(this.hostTab);
	  },

	  /**
	   * Minimize this host so that only the toolbox tabbar remains visible.
	   * @param {Number} height The height to minimize to. Defaults to 0, which
	   * means that the toolbox won't be visible at all once minimized.
	   */
	  minimize: function (height = 0) {
	    // if (this.isMinimized) {
	    //   return;
	    // }
	    // this.isMinimized = true;

	    // let onTransitionEnd = event => {
	    //   if (event.propertyName !== "margin-bottom") {
	    //     // Ignore transitionend on unrelated properties.
	    //     return;
	    //   }

	    //   this.frame.removeEventListener("transitionend", onTransitionEnd);
	    //   this.emit("minimized");
	    // };
	    // this.frame.addEventListener("transitionend", onTransitionEnd);
	    // this.frame.style.marginBottom = -this.frame.height + height + "px";
	    // this._splitter.classList.add("disabled");
	  },

	  /**
	   * If the host was minimized before, maximize it again (the host will be
	   * maximized to the height it previously had).
	   */
	  maximize: function () {
	    // if (!this.isMinimized) {
	    //   return;
	    // }
	    // this.isMinimized = false;

	    // let onTransitionEnd = event => {
	    //   if (event.propertyName !== "margin-bottom") {
	    //     // Ignore transitionend on unrelated properties.
	    //     return;
	    //   }

	    //   this.frame.removeEventListener("transitionend", onTransitionEnd);
	    //   this.emit("maximized");
	    // };
	    // this.frame.addEventListener("transitionend", onTransitionEnd);
	    // this.frame.style.marginBottom = "0";
	    // this._splitter.classList.remove("disabled");
	  },

	  /**
	   * Toggle the minimize mode.
	   * @param {Number} minHeight The height to minimize to.
	   */
	  toggleMinimizeMode: function (minHeight) {
	    // this.isMinimized ? this.maximize() : this.minimize(minHeight);
	  },

	  /**
	   * Set the toolbox title.
	   * Nothing to do for this host type.
	   */
	  setTitle: function () {},

	  /**
	   * Destroy the bottom dock.
	   */
	  destroy: function () {
	    // if (!this._destroyed) {
	    //   this._destroyed = true;

	    //   Services.prefs.setIntPref(this.heightPref, this.frame.height);
	    //   this._nbox.removeChild(this._splitter);
	    //   this._nbox.removeChild(this.frame);
	    // }

	    return promise.resolve(null);
	  }
	};

	/**
	 * Host object for the in-browser sidebar
	 */
	function SidebarHost(hostTab) {
	  this.hostTab = hostTab;

	  EventEmitter.decorate(this);
	}

	SidebarHost.prototype = {
	  type: "side",

	  widthPref: "devtools.toolbox.sidebar.width",

	  /**
	   * Create a box in the sidebar of the host tab.
	   */
	  create: function () {
	    var _this2 = this;

	    let deferred = promise.defer();

	    let gBrowser = this.hostTab.ownerDocument.defaultView.gBrowser;
	    let ownerDocument = gBrowser.ownerDocument;
	    this._sidebar = gBrowser.getSidebarContainer(this.hostTab.linkedBrowser);

	    this._splitter = ownerDocument.createElement("splitter");
	    this._splitter.setAttribute("class", "devtools-side-splitter");

	    this.frame = ownerDocument.createElement("iframe");
	    this.frame.className = "devtools-toolbox-side-iframe";

	    this.frame.width = Math.min(Services.prefs.getIntPref(this.widthPref), this._sidebar.clientWidth - MIN_PAGE_SIZE);

	    this._sidebar.appendChild(this._splitter);
	    this._sidebar.appendChild(this.frame);

	    let frameLoad = function () {
	      _this2.emit("ready", _this2.frame);
	      deferred.resolve(_this2.frame);
	    };

	    this.frame.tooltip = "aHTMLTooltip";
	    this.frame.setAttribute("src", "about:blank");

	    let domHelper = new DOMHelpers(this.frame.contentWindow);
	    domHelper.onceDOMReady(frameLoad);

	    focusTab(this.hostTab);

	    return deferred.promise;
	  },

	  /**
	   * Raise the host.
	   */
	  raise: function () {
	    focusTab(this.hostTab);
	  },

	  /**
	   * Set the toolbox title.
	   * Nothing to do for this host type.
	   */
	  setTitle: function () {},

	  /**
	   * Destroy the sidebar.
	   */
	  destroy: function () {
	    if (!this._destroyed) {
	      this._destroyed = true;

	      Services.prefs.setIntPref(this.widthPref, this.frame.width);
	      this._sidebar.removeChild(this._splitter);
	      this._sidebar.removeChild(this.frame);
	    }

	    return promise.resolve(null);
	  }
	};

	/**
	 * Host object for the toolbox in a separate window
	 */
	function WindowHost() {
	  this._boundUnload = this._boundUnload.bind(this);

	  EventEmitter.decorate(this);
	}

	WindowHost.prototype = {
	  type: "window",

	  WINDOW_URL: "chrome://devtools/content/framework/toolbox-window.xul",

	  /**
	   * Create a new xul window to contain the toolbox.
	   */
	  create: function () {
	    var _this3 = this;

	    let deferred = promise.defer();

	    let flags = "chrome,centerscreen,resizable,dialog=no";
	    let win = Services.ww.openWindow(null, this.WINDOW_URL, "_blank", flags, null);

	    let frameLoad = function () {
	      win.removeEventListener("load", frameLoad, true);
	      win.focus();
	      _this3.frame = win.document.getElementById("toolbox-iframe");
	      _this3.emit("ready", _this3.frame);

	      deferred.resolve(_this3.frame);
	    };

	    win.addEventListener("load", frameLoad, true);
	    win.addEventListener("unload", this._boundUnload);

	    this._window = win;

	    return deferred.promise;
	  },

	  /**
	   * Catch the user closing the window.
	   */
	  _boundUnload: function (event) {
	    if (event.target.location != this.WINDOW_URL) {
	      return;
	    }
	    this._window.removeEventListener("unload", this._boundUnload);

	    this.emit("window-closed");
	  },

	  /**
	   * Raise the host.
	   */
	  raise: function () {
	    this._window.focus();
	  },

	  /**
	   * Set the toolbox title.
	   */
	  setTitle: function (title) {
	    this._window.document.title = title;
	  },

	  /**
	   * Destroy the window.
	   */
	  destroy: function () {
	    if (!this._destroyed) {
	      this._destroyed = true;

	      this._window.removeEventListener("unload", this._boundUnload);
	      this._window.close();
	    }

	    return promise.resolve(null);
	  }
	};

	/**
	 * Host object for the toolbox in its own tab
	 */
	function CustomHost(hostTab, options) {
	  this.frame = options.customIframe;
	  this.uid = options.uid;
	  EventEmitter.decorate(this);
	}

	CustomHost.prototype = {
	  type: "custom",

	  _sendMessageToTopWindow: function (msg, data) {
	    // It's up to the custom frame owner (parent window) to honor
	    // "close" or "raise" instructions.
	    let topWindow = this.frame.ownerDocument.defaultView;
	    if (!topWindow) {
	      return;
	    }
	    let json = { name: "toolbox-" + msg, uid: this.uid };
	    if (data) {
	      json.data = data;
	    }
	    topWindow.postMessage(JSON.stringify(json), "*");
	  },

	  /**
	   * Create a new xul window to contain the toolbox.
	   */
	  create: function () {
	    return promise.resolve(this.frame);
	  },

	  /**
	   * Raise the host.
	   */
	  raise: function () {
	    this._sendMessageToTopWindow("raise");
	  },

	  /**
	   * Set the toolbox title.
	   */
	  setTitle: function (title) {
	    this._sendMessageToTopWindow("title", { value: title });
	  },

	  /**
	   * Destroy the window.
	   */
	  destroy: function () {
	    if (!this._destroyed) {
	      this._destroyed = true;
	      this._sendMessageToTopWindow("close");
	    }
	    return promise.resolve(null);
	  }
	};

	/**
	 *  Switch to the given tab in a browser and focus the browser window
	 */
	function focusTab(tab) {
	  let browserWindow = tab.ownerDocument.defaultView;
	  browserWindow.focus();
	  browserWindow.gBrowser.selectedTab = tab;
	}

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(9);

	const Services = _require.Services;

	/**
	 * DOMHelpers
	 * Makes DOM traversal easier. Goes through iframes.
	 *
	 * @constructor
	 * @param nsIDOMWindow aWindow
	 *        The content window, owning the document to traverse.
	 */

	var DOMHelpers = function DOMHelpers(aWindow) {
	  if (!aWindow) {
	    throw new Error("window can't be null or undefined");
	  }
	  this.window = aWindow;
	};

	DOMHelpers.prototype = {
	  getParentObject: function Helpers_getParentObject(node) {
	    let parentNode = node ? node.parentNode : null;

	    if (!parentNode) {
	      // Documents have no parentNode; Attr, Document, DocumentFragment, Entity,
	      // and Notation. top level windows have no parentNode
	      if (node && node == this.window.Node.DOCUMENT_NODE) {
	        // document type
	        if (node.defaultView) {
	          let embeddingFrame = node.defaultView.frameElement;
	          if (embeddingFrame) return embeddingFrame.parentNode;
	        }
	      }
	      // a Document object without a parentNode or window
	      return null; // top level has no parent
	    }

	    if (parentNode.nodeType == this.window.Node.DOCUMENT_NODE) {
	      if (parentNode.defaultView) {
	        return parentNode.defaultView.frameElement;
	      }
	      // parent is document element, but no window at defaultView.
	      return null;
	    }

	    if (!parentNode.localName) return null;

	    return parentNode;
	  },

	  getChildObject: function Helpers_getChildObject(node, index, previousSibling, showTextNodesWithWhitespace) {
	    if (!node) return null;

	    if (node.contentDocument) {
	      // then the node is a frame
	      if (index == 0) {
	        return node.contentDocument.documentElement; // the node's HTMLElement
	      }
	      return null;
	    }

	    if (node.getSVGDocument) {
	      let svgDocument = node.getSVGDocument();
	      if (svgDocument) {
	        // then the node is a frame
	        if (index == 0) {
	          return svgDocument.documentElement; // the node's SVGElement
	        }
	        return null;
	      }
	    }

	    let child = null;
	    if (previousSibling) // then we are walking
	      child = this.getNextSibling(previousSibling);else child = this.getFirstChild(node);

	    if (showTextNodesWithWhitespace) return child;

	    for (; child; child = this.getNextSibling(child)) {
	      if (!this.isWhitespaceText(child)) return child;
	    }

	    return null; // we have no children worth showing.
	  },

	  getFirstChild: function Helpers_getFirstChild(node) {
	    let SHOW_ALL = Components.interfaces.nsIDOMNodeFilter.SHOW_ALL;
	    this.treeWalker = node.ownerDocument.createTreeWalker(node, SHOW_ALL, null);
	    return this.treeWalker.firstChild();
	  },

	  getNextSibling: function Helpers_getNextSibling(node) {
	    let next = this.treeWalker.nextSibling();

	    if (!next) delete this.treeWalker;

	    return next;
	  },

	  isWhitespaceText: function Helpers_isWhitespaceText(node) {
	    return node.nodeType == this.window.Node.TEXT_NODE && !/[^\s]/.exec(node.nodeValue);
	  },

	  destroy: function Helpers_destroy() {
	    delete this.window;
	    delete this.treeWalker;
	  },

	  /**
	   * A simple way to be notified (once) when a window becomes
	   * interactive (DOMContentLoaded).
	   *
	   * It is based on the chromeEventHandler. This is useful when
	   * chrome iframes are loaded in content docshells (in Firefox
	   * tabs for example).
	   */
	  onceDOMReady: function (callback) {
	    let window = this.window;
	    if (window.document.readyState === "complete") {
	      callback();
	    } else {
	      window.document.addEventListener("DOMContentLoaded", function () {
	        callback();
	      });
	    }
	    // let docShell = window.QueryInterface(Ci.nsIInterfaceRequestor)
	    //                      .getInterface(Ci.nsIWebNavigation)
	    //                      .QueryInterface(Ci.nsIDocShell);
	    // let onReady = function(event) {
	    //   if (event.target == window.document) {
	    //     docShell.chromeEventHandler.removeEventListener("DOMContentLoaded", onReady, false);
	    //     // If in `callback` the URL of the window is changed and a listener to DOMContentLoaded
	    //     // is attached, the event we just received will be also be caught by the new listener.
	    //     // We want to avoid that so we execute the callback in the next queue.
	    //     Services.tm.mainThread.dispatch(callback, 0);
	    //   }
	    // }
	    // docShell.chromeEventHandler.addEventListener("DOMContentLoaded", onReady, false);
	  }
	};

	exports.DOMHelpers = DOMHelpers;

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Cu = _require.Cu;
	const Ci = _require.Ci;

	var _require2 = __webpack_require__(73);

	const getRootBindingParent = _require2.getRootBindingParent;

	var EventEmitter = __webpack_require__(7);

	/**
	 * API
	 *
	 *   new Selection(walker=null, node=null, track={attributes,detached});
	 *   destroy()
	 *   node (readonly)
	 *   setNode(node, origin="unknown")
	 *
	 * Helpers:
	 *
	 *   window
	 *   document
	 *   isRoot()
	 *   isNode()
	 *   isHTMLNode()
	 *
	 * Check the nature of the node:
	 *
	 *   isElementNode()
	 *   isAttributeNode()
	 *   isTextNode()
	 *   isCDATANode()
	 *   isEntityRefNode()
	 *   isEntityNode()
	 *   isProcessingInstructionNode()
	 *   isCommentNode()
	 *   isDocumentNode()
	 *   isDocumentTypeNode()
	 *   isDocumentFragmentNode()
	 *   isNotationNode()
	 *
	 * Events:
	 *   "new-node" when the inner node changed
	 *   "before-new-node" when the inner node is set to change
	 *   "attribute-changed" when an attribute is changed (only if tracked)
	 *   "detached" when the node (or one of its parents) is removed from the document (only if tracked)
	 *   "reparented" when the node (or one of its parents) is moved under a different node (only if tracked)
	 */

	/**
	 * A Selection object. Hold a reference to a node.
	 * Includes some helpers, fire some helpful events.
	 *
	 * @param node Inner node.
	 *    Can be null. Can be (un)set in the future via the "node" property;
	 * @param trackAttribute Tell if events should be fired when the attributes of
	 *    the node change.
	 *
	 */
	function Selection(walker, node = null, track = { attributes: true, detached: true }) {
	  EventEmitter.decorate(this);

	  this._onMutations = this._onMutations.bind(this);
	  this.track = track;
	  this.setWalker(walker);
	  this.setNode(node);
	}

	exports.Selection = Selection;

	Selection.prototype = {
	  _walker: null,
	  _node: null,

	  _onMutations: function (mutations) {
	    let attributeChange = false;
	    let pseudoChange = false;
	    let detached = false;
	    let parentNode = null;

	    for (let m of mutations) {
	      if (!attributeChange && m.type == "attributes") {
	        attributeChange = true;
	      }
	      if (m.type == "childList") {
	        if (!detached && !this.isConnected()) {
	          if (this.isNode()) {
	            parentNode = m.target;
	          }
	          detached = true;
	        }
	      }
	      if (m.type == "pseudoClassLock") {
	        pseudoChange = true;
	      }
	    }

	    // Fire our events depending on what changed in the mutations array
	    if (attributeChange) {
	      this.emit("attribute-changed");
	    }
	    if (pseudoChange) {
	      this.emit("pseudoclass");
	    }
	    if (detached) {
	      let rawNode = null;
	      if (parentNode && parentNode.isLocal_toBeDeprecated()) {
	        rawNode = parentNode.rawNode();
	      }

	      this.emit("detached", rawNode, null);
	      this.emit("detached-front", parentNode);
	    }
	  },

	  destroy: function () {
	    this.setNode(null);
	    this.setWalker(null);
	  },

	  setWalker: function (walker) {
	    if (this._walker) {
	      this._walker.off("mutations", this._onMutations);
	    }
	    this._walker = walker;
	    if (this._walker) {
	      this._walker.on("mutations", this._onMutations);
	    }
	  },

	  // Not remote-safe
	  setNode: function (value, reason = "unknown") {
	    if (value) {
	      value = this._walker.frontForRawNode(value);
	    }
	    this.setNodeFront(value, reason);
	  },

	  // Not remote-safe
	  get node() {
	    return this._node;
	  },

	  // Not remote-safe
	  get window() {
	    if (this.isNode()) {
	      return this.node.ownerDocument.defaultView;
	    }
	    return null;
	  },

	  // Not remote-safe
	  get document() {
	    if (this.isNode()) {
	      return this.node.ownerDocument;
	    }
	    return null;
	  },

	  setNodeFront: function (value, reason = "unknown") {
	    this.reason = reason;

	    // If a singleTextChild text node is being set, then set it's parent instead.
	    let parentNode = value && value.parentNode();
	    if (value && parentNode && parentNode.singleTextChild === value) {
	      value = parentNode;
	    }

	    // We used to return here if the node had not changed but we now need to
	    // set the node even if it is already set otherwise it is not possible to
	    // e.g. highlight the same node twice.
	    let rawValue = null;
	    if (value && value.isLocal_toBeDeprecated()) {
	      rawValue = value.rawNode();
	    }
	    this.emit("before-new-node", rawValue, reason);
	    this.emit("before-new-node-front", value, reason);
	    let previousNode = this._node;
	    let previousFront = this._nodeFront;
	    this._node = rawValue;
	    this._nodeFront = value;
	    this.emit("new-node", previousNode, this.reason);
	    this.emit("new-node-front", value, this.reason);
	  },

	  get documentFront() {
	    return this._walker.document(this._nodeFront);
	  },

	  get nodeFront() {
	    return this._nodeFront;
	  },

	  isRoot: function () {
	    return this.isNode() && this.isConnected() && this._nodeFront.isDocumentElement;
	  },

	  isNode: function () {
	    if (!this._nodeFront) {
	      return false;
	    }

	    // As long as tools are still accessing node.rawNode(),
	    // this needs to stay here.
	    if (this._node && Cu.isDeadWrapper(this._node)) {
	      return false;
	    }

	    return true;
	  },

	  isLocal: function () {
	    return !!this._node;
	  },

	  isConnected: function () {
	    let node = this._nodeFront;
	    if (!node || !node.actorID) {
	      return false;
	    }

	    // As long as there are still tools going around
	    // accessing node.rawNode, this needs to stay.
	    let rawNode = null;
	    if (node.isLocal_toBeDeprecated()) {
	      rawNode = node.rawNode();
	    }
	    if (rawNode) {
	      try {
	        let doc = this.document;
	        if (doc && doc.defaultView) {
	          let docEl = doc.documentElement;
	          let bindingParent = getRootBindingParent(rawNode);

	          if (docEl.contains(bindingParent)) {
	            return true;
	          }
	        }
	      } catch (e) {
	        // "can't access dead object" error
	      }
	      return false;
	    }

	    while (node) {
	      if (node === this._walker.rootNode) {
	        return true;
	      }
	      node = node.parentNode();
	    };
	    return false;
	  },

	  isHTMLNode: function () {
	    let xhtml_ns = "http://www.w3.org/1999/xhtml";
	    return this.isNode() && this.nodeFront.namespaceURI == xhtml_ns;
	  },

	  // Node type

	  isElementNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ELEMENT_NODE;
	  },

	  isPseudoElementNode: function () {
	    return this.isNode() && this.nodeFront.isPseudoElement;
	  },

	  isAnonymousNode: function () {
	    return this.isNode() && this.nodeFront.isAnonymous;
	  },

	  isAttributeNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ATTRIBUTE_NODE;
	  },

	  isTextNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.TEXT_NODE;
	  },

	  isCDATANode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.CDATA_SECTION_NODE;
	  },

	  isEntityRefNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ENTITY_REFERENCE_NODE;
	  },

	  isEntityNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ENTITY_NODE;
	  },

	  isProcessingInstructionNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.PROCESSING_INSTRUCTION_NODE;
	  },

	  isCommentNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.PROCESSING_INSTRUCTION_NODE;
	  },

	  isDocumentNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE;
	  },

	  /**
	   * @returns true if the selection is the <body> HTML element.
	   */
	  isBodyNode: function () {
	    return this.isHTMLNode() && this.isConnected() && this.nodeFront.nodeName === "BODY";
	  },

	  /**
	   * @returns true if the selection is the <head> HTML element.
	   */
	  isHeadNode: function () {
	    return this.isHTMLNode() && this.isConnected() && this.nodeFront.nodeName === "HEAD";
	  },

	  isDocumentTypeNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE;
	  },

	  isDocumentFragmentNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.DOCUMENT_FRAGMENT_NODE;
	  },

	  isNotationNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.NOTATION_NODE;
	  }
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */"use strict" /**
	 * Here's the server side of the remote inspector.
	 *
	 * The WalkerActor is the client's view of the debuggee's DOM.  It's gives
	 * the client a tree of NodeActor objects.
	 *
	 * The walker presents the DOM tree mostly unmodified from the source DOM
	 * tree, but with a few key differences:
	 *
	 *  - Empty text nodes are ignored.  This is pretty typical of developer
	 *    tools, but maybe we should reconsider that on the server side.
	 *  - iframes with documents loaded have the loaded document as the child,
	 *    the walker provides one big tree for the whole document tree.
	 *
	 * There are a few ways to get references to NodeActors:
	 *
	 *   - When you first get a WalkerActor reference, it comes with a free
	 *     reference to the root document's node.
	 *   - Given a node, you can ask for children, siblings, and parents.
	 *   - You can issue querySelector and querySelectorAll requests to find
	 *     other elements.
	 *   - Requests that return arbitrary nodes from the tree (like querySelector
	 *     and querySelectorAll) will also return any nodes the client hasn't
	 *     seen in order to have a complete set of parents.
	 *
	 * Once you have a NodeFront, you should be able to answer a few questions
	 * without further round trips, like the node's name, namespace/tagName,
	 * attributes, etc.  Other questions (like a text node's full nodeValue)
	 * might require another round trip.
	 *
	 * The protocol guarantees that the client will always know the parent of
	 * any node that is returned by the server.  This means that some requests
	 * (like querySelector) will include the extra nodes needed to satisfy this
	 * requirement.  The client keeps track of this parent relationship, so the
	 * node fronts form a tree that is a subset of the actual DOM tree.
	 *
	 *
	 * We maintain this guarantee to support the ability to release subtrees on
	 * the client - when a node is disconnected from the DOM tree we want to be
	 * able to free the client objects for all the children nodes.
	 *
	 * So to be able to answer "all the children of a given node that we have
	 * seen on the client side", we guarantee that every time we've seen a node,
	 * we connect it up through its parents.
	 */;var _slicedToArray=(function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n = (_s = _i.next()).done);_n = true) {_arr.push(_s.value);if(i && _arr.length === i)break;}}catch(err) {_d = true;_e = err;}finally {try{if(!_n && _i["return"])_i["return"]();}finally {if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else {throw new TypeError("Invalid attempt to destructure non-iterable instance");}};})();var _require=__webpack_require__(1);const Cc=_require.Cc;const Ci=_require.Ci;const Cu=_require.Cu;const Cr=_require.Cr;const Services=__webpack_require__(9);const protocol=__webpack_require__(79);const Arg=protocol.Arg;const Option=protocol.Option;const method=protocol.method;const RetVal=protocol.RetVal;const types=protocol.types;var _require2=__webpack_require__(83);const LongStringActor=_require2.LongStringActor;const ShortLongString=_require2.ShortLongString;const promise=__webpack_require__(6);var _require3=__webpack_require__(38);const Task=_require3.Task;const object=__webpack_require__(81);const events=__webpack_require__(25);var _require4=__webpack_require__(64);const Class=_require4.Class; /*const {WalkerSearch} = require("devtools/server/actors/utils/walker-search");*/var _require5=__webpack_require__(100);const PageStyleActor=_require5.PageStyleActor;const getFontPreviewData=_require5.getFontPreviewData;var _require6=__webpack_require__(105);const HighlighterActor=_require6.HighlighterActor;const CustomHighlighterActor=_require6.CustomHighlighterActor;const isTypeRegistered=_require6.isTypeRegistered;var _require7=__webpack_require__(73);const isAnonymous=_require7.isAnonymous;const isNativeAnonymous=_require7.isNativeAnonymous;const isXBLAnonymous=_require7.isXBLAnonymous;const isShadowAnonymous=_require7.isShadowAnonymous;const getFrameElement=_require7.getFrameElement;var _require8=__webpack_require__(78);const getLayoutChangesObserver=_require8.getLayoutChangesObserver;const releaseLayoutChangesObserver=_require8.releaseLayoutChangesObserver; /*let CSS = require("CSS");*/var _require9=__webpack_require__(106);const EventParsers=_require9.EventParsers;const FONT_FAMILY_PREVIEW_TEXT="The quick brown fox jumps over the lazy dog";const FONT_FAMILY_PREVIEW_TEXT_SIZE=20;const PSEUDO_CLASSES=[":hover",":active",":focus"];const HIDDEN_CLASS="__fx-devtools-hide-shortcut__";const XHTML_NS="http://www.w3.org/1999/xhtml";const XUL_NS='http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul';const IMAGE_FETCHING_TIMEOUT=500; // The possible completions to a ':' with added score to give certain values
	// some preference.
	const PSEUDO_SELECTORS=[[":active",1],[":hover",1],[":focus",1],[":visited",0],[":link",0],[":first-letter",0],[":first-child",2],[":before",2],[":after",2],[":lang(",0],[":not(",3],[":first-of-type",0],[":last-of-type",0],[":only-of-type",0],[":only-child",2],[":nth-child(",3],[":nth-last-child(",0],[":nth-of-type(",0],[":nth-last-of-type(",0],[":last-child",2],[":root",0],[":empty",0],[":target",0],[":enabled",0],[":disabled",0],[":checked",1],["::selection",0]];var HELPER_SHEET=".__fx-devtools-hide-shortcut__ { visibility: hidden !important } ";HELPER_SHEET += ":-moz-devtools-highlighted { outline: 2px dashed #F06!important; outline-offset: -2px!important } ";let DevToolsUtils=__webpack_require__(19);let AsyncUtils=__webpack_require__(104); /*loader.lazyGetter(this, "DOMParser", function() {
	  return Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
	});

	loader.lazyGetter(this, "eventListenerService", function() {
	  return Cc["@mozilla.org/eventlistenerservice;1"]
	           .getService(Ci.nsIEventListenerService);
	});

	loader.lazyGetter(this, "CssLogic", () => require("devtools/shared/styleinspector/css-logic").CssLogic);*/ // XXX: A poor man's makeInfallible until we move it out of transport.js
	// Which should be very soon.
	function makeInfallible(handler){return function(...args){try{return handler.apply(this,args);}catch(ex) {console.error(ex);}return undefined;};} // A resolve that hits the main loop first.
	function delayedResolve(value){let deferred=promise.defer();Services.tm.mainThread.dispatch(makeInfallible(function delayedResolveHandler(){deferred.resolve(value);}),0);return deferred.promise;}types.addDictType("imageData",{ // The image data
	data:"nullable:longstring", // The original image dimensions
	size:"json"}); /**
	 * We only send nodeValue up to a certain size by default.  This stuff
	 * controls that size.
	 */exports.DEFAULT_VALUE_SUMMARY_LENGTH = 50;var gValueSummaryLength=exports.DEFAULT_VALUE_SUMMARY_LENGTH;exports.getValueSummaryLength = function(){return gValueSummaryLength;};exports.setValueSummaryLength = function(val){gValueSummaryLength = val;}; // When the user selects a node to inspect in e10s, the parent process
	// has a CPOW that wraps the node being inspected.  It uses the
	// message manager to send this node to the child, which stores the
	// node in gInspectingNode. Then a findInspectingNode request is sent
	// over the remote debugging protocol, and gInspectingNode is returned
	// to the parent as a NodeFront.
	var gInspectingNode=null; // We expect this function to be called from the child.js frame script
	// when it receives the node to be inspected over the message manager.
	exports.setInspectingNode = function(val){gInspectingNode = val;}; /**
	 * Server side of the node actor.
	 */var NodeActor=exports.NodeActor = protocol.ActorClass({typeName:"domnode",initialize:function(walker,node){protocol.Actor.prototype.initialize.call(this,null);this.walker = walker;this.rawNode = node;this._eventParsers = new EventParsers().parsers; // Storing the original display of the node, to track changes when reflows
	// occur
	this.wasDisplayed = this.isDisplayed;},toString:function(){return "[NodeActor " + this.actorID + " for " + this.rawNode.toString() + "]";}, /**
	   * Instead of storing a connection object, the NodeActor gets its connection
	   * from its associated walker.
	   */get conn(){return this.walker.conn;},isDocumentElement:function(){return this.rawNode.ownerDocument && this.rawNode.ownerDocument.documentElement === this.rawNode;},destroy:function(){protocol.Actor.prototype.destroy.call(this);if(this.mutationObserver){if(!Cu.isDeadWrapper(this.mutationObserver)){this.mutationObserver.disconnect();}this.mutationObserver = null;}this.rawNode = null;this.walker = null;}, // Returns the JSON representation of this object over the wire.
	form:function(detail){if(detail === "actorid"){return this.actorID;}let parentNode=this.walker.parentNode(this);let singleTextChild=this.walker.singleTextChild(this);let form={actor:this.actorID,baseURI:this.rawNode.baseURI,parent:parentNode?parentNode.actorID:undefined,nodeType:this.rawNode.nodeType,namespaceURI:this.rawNode.namespaceURI,nodeName:this.rawNode.nodeName,numChildren:this.numChildren,singleTextChild:singleTextChild?singleTextChild.form():undefined, // doctype attributes
	name:this.rawNode.name,publicId:this.rawNode.publicId,systemId:this.rawNode.systemId,attrs:this.writeAttrs(),isBeforePseudoElement:this.isBeforePseudoElement,isAfterPseudoElement:this.isAfterPseudoElement,isAnonymous:isAnonymous(this.rawNode),isNativeAnonymous:isNativeAnonymous(this.rawNode),isXBLAnonymous:isXBLAnonymous(this.rawNode),isShadowAnonymous:isShadowAnonymous(this.rawNode),pseudoClassLocks:this.writePseudoClassLocks(),isDisplayed:this.isDisplayed,hasEventListeners:this._hasEventListeners};if(this.isDocumentElement()){form.isDocumentElement = true;}if(this.rawNode.nodeValue){ // We only include a short version of the value if it's longer than
	// gValueSummaryLength
	if(this.rawNode.nodeValue.length > gValueSummaryLength){form.shortValue = this.rawNode.nodeValue.substring(0,gValueSummaryLength);form.incompleteValue = true;}else {form.shortValue = this.rawNode.nodeValue;}} // Add an extra API for custom properties added by other
	// modules/extensions.
	form.setFormProperty = function(name,value){if(!form.props){form.props = {};}form.props[name] = value;}; // Fire an event so, other modules can create its own properties
	// that should be passed to the client (within the form.props field).
	events.emit(NodeActor,"form",{target:this,data:form});return form;}, /**
	   * Watch the given document node for mutations using the DOM observer
	   * API.
	   */watchDocument:function(callback){let node=this.rawNode; // Create the observer on the node's actor.  The node will make sure
	// the observer is cleaned up when the actor is released.
	let observer=new node.defaultView.MutationObserver(callback);observer.mergeAttributeRecords = true;observer.observe(node,{nativeAnonymousChildList:true,attributes:true,characterData:true,childList:true,subtree:true});this.mutationObserver = observer;},get isBeforePseudoElement(){return this.rawNode.nodeName === "_moz_generated_content_before";},get isAfterPseudoElement(){return this.rawNode.nodeName === "_moz_generated_content_after";}, // Estimate the number of children that the walker will return without making
	// a call to children() if possible.
	get numChildren(){ // For pseudo elements, childNodes.length returns 1, but the walker
	// will return 0.
	if(this.isBeforePseudoElement || this.isAfterPseudoElement){return 0;}let rawNode=this.rawNode;let numChildren=rawNode.childNodes.length;let hasAnonChildren=rawNode.nodeType === Ci.nsIDOMNode.ELEMENT_NODE && rawNode.ownerDocument.getAnonymousNodes(rawNode);if(numChildren === 0 && (rawNode.contentDocument || rawNode.getSVGDocument)){ // This might be an iframe with virtual children.
	numChildren = 1;} // Normal counting misses ::before/::after.  Also, some anonymous children
	// may ultimately be skipped, so we have to consult with the walker.
	if(numChildren === 0 || hasAnonChildren){numChildren = this.walker.children(this).nodes.length;}return numChildren;},get computedStyle(){return CssLogic.getComputedStyle(this.rawNode);}, /**
	   * Is the node's display computed style value other than "none"
	   */get isDisplayed(){ // Consider all non-element nodes as displayed.
	if(isNodeDead(this) || this.rawNode.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE || this.isAfterPseudoElement || this.isBeforePseudoElement){return true;}let style=this.computedStyle;if(!style){return true;}else {return style.display !== "none";}}, /**
	   * Are there event listeners that are listening on this node? This method
	   * uses all parsers registered via event-parsers.js.registerEventParser() to
	   * check if there are any event listeners.
	   */get _hasEventListeners(){let parsers=this._eventParsers;for(let _ref of parsers) {var _ref2=_slicedToArray(_ref,2);let hasListeners=_ref2[1].hasListeners;try{if(hasListeners && hasListeners(this.rawNode)){return true;}}catch(e) { // An object attached to the node looked like a listener but wasn't...
	// do nothing.
	}}return false;},writeAttrs:function(){if(!this.rawNode.attributes){return undefined;}return [...this.rawNode.attributes].map(function(attr){return {namespace:attr.namespace,name:attr.name,value:attr.value};});},writePseudoClassLocks:function(){if(this.rawNode.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE){return undefined;}let ret=undefined;for(let pseudo of PSEUDO_CLASSES) {if(DOMUtils.hasPseudoClassLock(this.rawNode,pseudo)){ret = ret || [];ret.push(pseudo);}}return ret;}, /**
	   * Gets event listeners and adds their information to the events array.
	   *
	   * @param  {Node} node
	   *         Node for which we are to get listeners.
	   */getEventListeners:function(node){let parsers=this._eventParsers;let dbg=this.parent().tabActor.makeDebugger();let events=[];for(let _ref3 of parsers) {var _ref4=_slicedToArray(_ref3,2);var _ref4$=_ref4[1];let getListeners=_ref4$.getListeners;let normalizeHandler=_ref4$.normalizeHandler;try{let eventInfos=getListeners(node);if(!eventInfos){continue;}for(let eventInfo of eventInfos) {if(normalizeHandler){eventInfo.normalizeHandler = normalizeHandler;}this.processHandlerForEvent(node,events,dbg,eventInfo);}}catch(e) { // An object attached to the node looked like a listener but wasn't...
	// do nothing.
	}}events.sort(function(a,b){return a.type.localeCompare(b.type);});return events;}, /**
	   * Process a handler
	   *
	   * @param  {Node} node
	   *         The node for which we want information.
	   * @param  {Array} events
	   *         The events array contains all event objects that we have gathered
	   *         so far.
	   * @param  {Debugger} dbg
	   *         JSDebugger instance.
	   * @param  {Object} eventInfo
	   *         See event-parsers.js.registerEventParser() for a description of the
	   *         eventInfo object.
	   *
	   * @return {Array}
	   *         An array of objects where a typical object looks like this:
	   *           {
	   *             type: "click",
	   *             handler: function() { doSomething() },
	   *             origin: "http://www.mozilla.com",
	   *             searchString: 'onclick="doSomething()"',
	   *             tags: tags,
	   *             DOM0: true,
	   *             capturing: true,
	   *             hide: {
	   *               dom0: true
	   *             }
	   *           }
	   */processHandlerForEvent:function(node,events,dbg,eventInfo){let type=eventInfo.type || "";let handler=eventInfo.handler;let tags=eventInfo.tags || "";let hide=eventInfo.hide || {};let override=eventInfo.override || {};let global=Cu.getGlobalForObject(handler);let globalDO=dbg.addDebuggee(global);let listenerDO=globalDO.makeDebuggeeValue(handler);if(eventInfo.normalizeHandler){listenerDO = eventInfo.normalizeHandler(listenerDO);} // If the listener is an object with a 'handleEvent' method, use that.
	if(listenerDO.class === "Object" || listenerDO.class === "XULElement"){let desc;while(!desc && listenerDO) {desc = listenerDO.getOwnPropertyDescriptor("handleEvent");listenerDO = listenerDO.proto;}if(desc && desc.value){listenerDO = desc.value;}}if(listenerDO.isBoundFunction){listenerDO = listenerDO.boundTargetFunction;}let script=listenerDO.script;let scriptSource=script.source.text;let functionSource=scriptSource.substr(script.sourceStart,script.sourceLength); /*
	    The script returned is the whole script and
	    scriptSource.substr(script.sourceStart, script.sourceLength) returns
	    something like:
	      () { doSomething(); }

	    So we need to work back to the preceeding \n, ; or } so we can get the
	      appropriate function info e.g.:
	      () => { doSomething(); }
	      function doit() { doSomething(); }
	      doit: function() { doSomething(); }
	    */let scriptBeforeFunc=scriptSource.substr(0,script.sourceStart);let lastEnding=Math.max(scriptBeforeFunc.lastIndexOf(";"),scriptBeforeFunc.lastIndexOf("}"),scriptBeforeFunc.lastIndexOf("{"),scriptBeforeFunc.lastIndexOf("("),scriptBeforeFunc.lastIndexOf(","),scriptBeforeFunc.lastIndexOf("!"));if(lastEnding !== -1){let functionPrefix=scriptBeforeFunc.substr(lastEnding + 1);functionSource = functionPrefix + functionSource;}let dom0=false;if(typeof node.hasAttribute !== "undefined"){dom0 = !!node.hasAttribute("on" + type);}else {dom0 = !!node["on" + type];}let line=script.startLine;let url=script.url;let origin=url + (dom0?"":":" + line);let searchString;if(dom0){searchString = "on" + type + "=\"" + script.source.text + "\"";}else {scriptSource = "    " + scriptSource;}let eventObj={type:typeof override.type !== "undefined"?override.type:type,handler:functionSource.trim(),origin:typeof override.origin !== "undefined"?override.origin:origin,searchString:typeof override.searchString !== "undefined"?override.searchString:searchString,tags:tags,DOM0:typeof override.dom0 !== "undefined"?override.dom0:dom0,capturing:typeof override.capturing !== "undefined"?override.capturing:eventInfo.capturing,hide:hide};events.push(eventObj);dbg.removeDebuggee(globalDO);}, /**
	   * Returns a LongStringActor with the node's value.
	   */getNodeValue:method(function(){return new LongStringActor(this.conn,this.rawNode.nodeValue || "");},{request:{},response:{value:RetVal("longstring")}}), /**
	   * Set the node's value to a given string.
	   */setNodeValue:method(function(value){this.rawNode.nodeValue = value;},{request:{value:Arg(0)},response:{}}), /**
	   * Get a unique selector string for this node.
	   */getUniqueSelector:method(function(){return CssLogic.findCssSelector(this.rawNode);},{request:{},response:{value:RetVal("string")}}), /**
	   * Scroll the selected node into view.
	   */scrollIntoView:method(function(){this.rawNode.scrollIntoView(true);},{request:{},response:{}}), /**
	   * Get the node's image data if any (for canvas and img nodes).
	   * Returns an imageData object with the actual data being a LongStringActor
	   * and a size json object.
	   * The image data is transmitted as a base64 encoded png data-uri.
	   * The method rejects if the node isn't an image or if the image is missing
	   *
	   * Accepts a maxDim request parameter to resize images that are larger. This
	   * is important as the resizing occurs server-side so that image-data being
	   * transfered in the longstring back to the client will be that much smaller
	   */getImageData:method(function(maxDim){var _this=this;return imageToImageData(this.rawNode,maxDim).then(function(imageData){return {data:LongStringActor(_this.conn,imageData.data),size:imageData.size};});},{request:{maxDim:Arg(0,"nullable:number")},response:RetVal("imageData")}), /**
	   * Get all event listeners that are listening on this node.
	   */getEventListenerInfo:method(function(){if(this.rawNode.nodeName.toLowerCase() === "html"){return this.getEventListeners(this.rawNode.ownerGlobal);}return this.getEventListeners(this.rawNode);},{request:{},response:{events:RetVal("json")}}), /**
	   * Modify a node's attributes.  Passed an array of modifications
	   * similar in format to "attributes" mutations.
	   * {
	   *   attributeName: <string>
	   *   attributeNamespace: <optional string>
	   *   newValue: <optional string> - If null or undefined, the attribute
	   *     will be removed.
	   * }
	   *
	   * Returns when the modifications have been made.  Mutations will
	   * be queued for any changes made.
	   */modifyAttributes:method(function(modifications){let rawNode=this.rawNode;for(let change of modifications) {if(change.newValue == null){if(change.attributeNamespace){rawNode.removeAttributeNS(change.attributeNamespace,change.attributeName);}else {rawNode.removeAttribute(change.attributeName);}}else {if(change.attributeNamespace){rawNode.setAttributeNS(change.attributeNamespace,change.attributeName,change.newValue);}else {rawNode.setAttribute(change.attributeName,change.newValue);}}}},{request:{modifications:Arg(0,"array:json")},response:{}}), /**
	   * Given the font and fill style, get the image data of a canvas with the
	   * preview text and font.
	   * Returns an imageData object with the actual data being a LongStringActor
	   * and the width of the text as a string.
	   * The image data is transmitted as a base64 encoded png data-uri.
	   */getFontFamilyDataURL:method(function(font,fillStyle = "black"){let doc=this.rawNode.ownerDocument;let options={previewText:FONT_FAMILY_PREVIEW_TEXT,previewFontSize:FONT_FAMILY_PREVIEW_TEXT_SIZE,fillStyle:fillStyle};var _getFontPreviewData=getFontPreviewData(font,doc,options);let dataURL=_getFontPreviewData.dataURL;let size=_getFontPreviewData.size;return {data:LongStringActor(this.conn,dataURL),size:size};},{request:{font:Arg(0,"string"),fillStyle:Arg(1,"nullable:string")},response:RetVal("imageData")})}); /**
	 * Client side of the node actor.
	 *
	 * Node fronts are strored in a tree that mirrors the DOM tree on the
	 * server, but with a few key differences:
	 *  - Not all children will be necessary loaded for each node.
	 *  - The order of children isn't guaranteed to be the same as the DOM.
	 * Children are stored in a doubly-linked list, to make addition/removal
	 * and traversal quick.
	 *
	 * Due to the order/incompleteness of the child list, it is safe to use
	 * the parent node from clients, but the `children` request should be used
	 * to traverse children.
	 */var NodeFront=protocol.FrontClass(NodeActor,{initialize:function(conn,form,detail,ctx){this._parent = null; // The parent node
	this._child = null; // The first child of this node.
	this._next = null; // The next sibling of this node.
	this._prev = null; // The previous sibling of this node.
	protocol.Front.prototype.initialize.call(this,conn,form,detail,ctx);}, /**
	   * Destroy a node front.  The node must have been removed from the
	   * ownership tree before this is called, unless the whole walker front
	   * is being destroyed.
	   */destroy:function(){protocol.Front.prototype.destroy.call(this);}, // Update the object given a form representation off the wire.
	form:function(form,detail,ctx){if(detail === "actorid"){this.actorID = form;return;} // Shallow copy of the form.  We could just store a reference, but
	// eventually we'll want to update some of the data.
	this._form = object.merge(form);this._form.attrs = this._form.attrs?this._form.attrs.slice():[];if(form.parent){ // Get the owner actor for this actor (the walker), and find the
	// parent node of this actor from it, creating a standin node if
	// necessary.
	let parentNodeFront=ctx.marshallPool().ensureParentFront(form.parent);this.reparent(parentNodeFront);}if(form.singleTextChild){this.singleTextChild = types.getType("domnode").read(form.singleTextChild,ctx);}else {this.singleTextChild = undefined;}}, /**
	   * Returns the parent NodeFront for this NodeFront.
	   */parentNode:function(){return this._parent;}, /**
	   * Process a mutation entry as returned from the walker's `getMutations`
	   * request.  Only tries to handle changes of the node's contents
	   * themselves (character data and attribute changes), the walker itself
	   * will keep the ownership tree up to date.
	   */updateMutation:function(change){if(change.type === "attributes"){ // We'll need to lazily reparse the attributes after this change.
	this._attrMap = undefined; // Update any already-existing attributes.
	let found=false;for(let i=0;i < this.attributes.length;i++) {let attr=this.attributes[i];if(attr.name == change.attributeName && attr.namespace == change.attributeNamespace){if(change.newValue !== null){attr.value = change.newValue;}else {this.attributes.splice(i,1);}found = true;break;}} // This is a new attribute. The null check is because of Bug 1192270,
	// in the case of a newly added then removed attribute
	if(!found && change.newValue !== null){this.attributes.push({name:change.attributeName,namespace:change.attributeNamespace,value:change.newValue});}}else if(change.type === "characterData"){this._form.shortValue = change.newValue;this._form.incompleteValue = change.incompleteValue;}else if(change.type === "pseudoClassLock"){this._form.pseudoClassLocks = change.pseudoClassLocks;}}, // Some accessors to make NodeFront feel more like an nsIDOMNode
	get id(){return this.getAttribute("id");},get nodeType(){return this._form.nodeType;},get namespaceURI(){return this._form.namespaceURI;},get nodeName(){return this._form.nodeName;},get doctypeString(){return '<!DOCTYPE ' + this._form.name + (this._form.publicId?' PUBLIC "' + this._form.publicId + '"':'') + (this._form.systemId?' "' + this._form.systemId + '"':'') + '>';},get baseURI(){return this._form.baseURI;},get className(){return this.getAttribute("class") || '';},get hasChildren(){return this._form.numChildren > 0;},get numChildren(){return this._form.numChildren;},get hasEventListeners(){return this._form.hasEventListeners;},get isBeforePseudoElement(){return this._form.isBeforePseudoElement;},get isAfterPseudoElement(){return this._form.isAfterPseudoElement;},get isPseudoElement(){return this.isBeforePseudoElement || this.isAfterPseudoElement;},get isAnonymous(){return this._form.isAnonymous;},get tagName(){return this.nodeType === Ci.nsIDOMNode.ELEMENT_NODE?this.nodeName:null;},get shortValue(){return this._form.shortValue;},get incompleteValue(){return !!this._form.incompleteValue;},get isDocumentElement(){return !!this._form.isDocumentElement;}, // doctype properties
	get name(){return this._form.name;},get publicId(){return this._form.publicId;},get systemId(){return this._form.systemId;},getAttribute:function(name){let attr=this._getAttribute(name);return attr?attr.value:null;},hasAttribute:function(name){this._cacheAttributes();return name in this._attrMap;},get hidden(){let cls=this.getAttribute("class");return cls && cls.indexOf(HIDDEN_CLASS) > -1;},get attributes(){return this._form.attrs;},get pseudoClassLocks(){return this._form.pseudoClassLocks || [];},hasPseudoClassLock:function(pseudo){return this.pseudoClassLocks.some(function(locked){return locked === pseudo;});},get isDisplayed(){ // The NodeActor's form contains the isDisplayed information as a boolean
	// starting from FF32. Before that, the property is missing
	return "isDisplayed" in this._form?this._form.isDisplayed:true;},get isTreeDisplayed(){let parent=this;while(parent) {if(!parent.isDisplayed){return false;}parent = parent.parentNode();}return true;},getNodeValue:protocol.custom(function(){if(!this.incompleteValue){return delayedResolve(new ShortLongString(this.shortValue));}else {return this._getNodeValue();}},{impl:"_getNodeValue"}), // Accessors for custom form properties.
	getFormProperty:function(name){return this._form.props?this._form.props[name]:null;},hasFormProperty:function(name){return this._form.props?name in this._form.props:null;},get formProperties(){return this._form.props;}, /**
	   * Return a new AttributeModificationList for this node.
	   */startModifyingAttributes:function(){return AttributeModificationList(this);},_cacheAttributes:function(){if(typeof this._attrMap != "undefined"){return;}this._attrMap = {};for(let attr of this.attributes) {this._attrMap[attr.name] = attr;}},_getAttribute:function(name){this._cacheAttributes();return this._attrMap[name] || undefined;}, /**
	   * Set this node's parent.  Note that the children saved in
	   * this tree are unordered and incomplete, so shouldn't be used
	   * instead of a `children` request.
	   */reparent:function(parent){if(this._parent === parent){return;}if(this._parent && this._parent._child === this){this._parent._child = this._next;}if(this._prev){this._prev._next = this._next;}if(this._next){this._next._prev = this._prev;}this._next = null;this._prev = null;this._parent = parent;if(!parent){ // Subtree is disconnected, we're done
	return;}this._next = parent._child;if(this._next){this._next._prev = this;}parent._child = this;}, /**
	   * Return all the known children of this node.
	   */treeChildren:function(){let ret=[];for(let child=this._child;child != null;child = child._next) {ret.push(child);}return ret;}, /**
	   * Do we use a local target?
	   * Useful to know if a rawNode is available or not.
	   *
	   * This will, one day, be removed. External code should
	   * not need to know if the target is remote or not.
	   */isLocal_toBeDeprecated:function(){return !!this.conn._transport._serverConnection;}, /**
	   * Get an nsIDOMNode for the given node front.  This only works locally,
	   * and is only intended as a stopgap during the transition to the remote
	   * protocol.  If you depend on this you're likely to break soon.
	   */rawNode:function(rawNode){if(!this.conn._transport._serverConnection){console.warn("Tried to use rawNode on a remote connection.");return null;}let actor=this.conn._transport._serverConnection.getActor(this.actorID);if(!actor){ // Can happen if we try to get the raw node for an already-expired
	// actor.
	return null;}return actor.rawNode;}}); /**
	 * Returned from any call that might return a node that isn't connected to root by
	 * nodes the child has seen, such as querySelector.
	 */types.addDictType("disconnectedNode",{ // The actual node to return
	node:"domnode", // Nodes that are needed to connect the node to a node the client has already seen
	newParents:"array:domnode"});types.addDictType("disconnectedNodeArray",{ // The actual node list to return
	nodes:"array:domnode", // Nodes that are needed to connect those nodes to the root.
	newParents:"array:domnode"});types.addDictType("dommutation",{});types.addDictType("searchresult",{list:"domnodelist", // Right now there is isn't anything required for metadata,
	// but it's json so it can be extended with extra data.
	metadata:"array:json"}); /**
	 * Server side of a node list as returned by querySelectorAll()
	 */var NodeListActor=exports.NodeListActor = protocol.ActorClass({typeName:"domnodelist",initialize:function(walker,nodeList){protocol.Actor.prototype.initialize.call(this);this.walker = walker;this.nodeList = nodeList || [];},destroy:function(){protocol.Actor.prototype.destroy.call(this);}, /**
	   * Instead of storing a connection object, the NodeActor gets its connection
	   * from its associated walker.
	   */get conn(){return this.walker.conn;}, /**
	   * Items returned by this actor should belong to the parent walker.
	   */marshallPool:function(){return this.walker;}, // Returns the JSON representation of this object over the wire.
	form:function(){return {actor:this.actorID,length:this.nodeList?this.nodeList.length:0};}, /**
	   * Get a single node from the node list.
	   */item:method(function(index){return this.walker.attachElement(this.nodeList[index]);},{request:{item:Arg(0)},response:RetVal("disconnectedNode")}), /**
	   * Get a range of the items from the node list.
	   */items:method(function(start = 0,end = this.nodeList.length){var _this2=this;let items=Array.prototype.slice.call(this.nodeList,start,end).map(function(item){return _this2.walker._ref(item);});return this.walker.attachElements(items);},{request:{start:Arg(0,"nullable:number"),end:Arg(1,"nullable:number")},response:RetVal("disconnectedNodeArray")}),release:method(function(){},{release:true})}); /**
	 * Client side of a node list as returned by querySelectorAll()
	 */var NodeListFront=exports.NodeListFront = protocol.FrontClass(NodeListActor,{initialize:function(client,form){protocol.Front.prototype.initialize.call(this,client,form);},destroy:function(){protocol.Front.prototype.destroy.call(this);},marshallPool:function(){return this.parent();}, // Update the object given a form representation off the wire.
	form:function(json){this.length = json.length;},item:protocol.custom(function(index){return this._item(index).then(function(response){return response.node;});},{impl:"_item"}),items:protocol.custom(function(start,end){return this._items(start,end).then(function(response){return response.nodes;});},{impl:"_items"})}); // Some common request/response templates for the dom walker
	var nodeArrayMethod={request:{node:Arg(0,"domnode"),maxNodes:Option(1),center:Option(1,"domnode"),start:Option(1,"domnode"),whatToShow:Option(1)},response:RetVal(types.addDictType("domtraversalarray",{nodes:"array:domnode"}))};var traversalMethod={request:{node:Arg(0,"domnode"),whatToShow:Option(1)},response:{node:RetVal("nullable:domnode")}}; /**
	 * Server side of the DOM walker.
	 */var WalkerActor=protocol.ActorClass({typeName:"domwalker",events:{"new-mutations":{type:"newMutations"},"picker-node-picked":{type:"pickerNodePicked",node:Arg(0,"disconnectedNode")},"picker-node-hovered":{type:"pickerNodeHovered",node:Arg(0,"disconnectedNode")},"picker-node-canceled":{type:"pickerNodeCanceled"},"highlighter-ready":{type:"highlighter-ready"},"highlighter-hide":{type:"highlighter-hide"},"display-change":{type:"display-change",nodes:Arg(0,"array:domnode")}}, /**
	   * Create the WalkerActor
	   * @param DebuggerServerConnection conn
	   *    The server connection.
	   */initialize:function(conn,tabActor,options){protocol.Actor.prototype.initialize.call(this,conn);this.tabActor = tabActor;this.rootWin = tabActor.window;this.rootDoc = this.rootWin.document;this._refMap = new Map();this._pendingMutations = [];this._activePseudoClassLocks = new Set();this.showAllAnonymousContent = options.showAllAnonymousContent;this.walkerSearch = new WalkerSearch(this); // Nodes which have been removed from the client's known
	// ownership tree are considered "orphaned", and stored in
	// this set.
	this._orphaned = new Set(); // The client can tell the walker that it is interested in a node
	// even when it is orphaned with the `retainNode` method.  This
	// list contains orphaned nodes that were so retained.
	this._retainedOrphans = new Set();this.onMutations = this.onMutations.bind(this);this.onFrameLoad = this.onFrameLoad.bind(this);this.onFrameUnload = this.onFrameUnload.bind(this);events.on(tabActor,"will-navigate",this.onFrameUnload);events.on(tabActor,"navigate",this.onFrameLoad); // Ensure that the root document node actor is ready and
	// managed.
	this.rootNode = this.document();this.reflowObserver = getLayoutChangesObserver(this.tabActor);this._onReflows = this._onReflows.bind(this);this.reflowObserver.on("reflows",this._onReflows);}, // Returns the JSON representation of this object over the wire.
	form:function(){return {actor:this.actorID,root:this.rootNode.form(),traits:{ // FF42+ Inspector starts managing the Walker, while the inspector also
	// starts cleaning itself up automatically on client disconnection.
	// So that there is no need to manually release the walker anymore.
	autoReleased:true, // XXX: It seems silly that we need to tell the front which capabilities
	// its actor has in this way when the target can use actorHasMethod.  If
	// this was ported to the protocol (Bug 1157048) we could call that inside
	// of custom front methods and not need to do traits for this.
	multiFrameQuerySelectorAll:true,textSearch:true}};},toString:function(){return "[WalkerActor " + this.actorID + "]";},getDocumentWalker:function(node,whatToShow){ // Allow native anon content (like <video> controls) if preffed on
	let nodeFilter=this.showAllAnonymousContent?allAnonymousContentTreeWalkerFilter:standardTreeWalkerFilter;return new DocumentWalker(node,this.rootWin,whatToShow,nodeFilter);},destroy:function(){if(this._destroyed){return;}this._destroyed = true;protocol.Actor.prototype.destroy.call(this);try{this.clearPseudoClassLocks();this._activePseudoClassLocks = null;this._hoveredNode = null;this.rootWin = null;this.rootDoc = null;this.rootNode = null;this.layoutHelpers = null;this._orphaned = null;this._retainedOrphans = null;this._refMap = null;events.off(this.tabActor,"will-navigate",this.onFrameUnload);events.off(this.tabActor,"navigate",this.onFrameLoad);this.onFrameLoad = null;this.onFrameUnload = null;this.walkerSearch.destroy();this.reflowObserver.off("reflows",this._onReflows);this.reflowObserver = null;this._onReflows = null;releaseLayoutChangesObserver(this.tabActor);this.onMutations = null;this.tabActor = null;events.emit(this,"destroyed");}catch(e) {console.error(e);}},release:method(function(){},{release:true}),unmanage:function(actor){if(actor instanceof NodeActor){if(this._activePseudoClassLocks && this._activePseudoClassLocks.has(actor)){this.clearPseudoClassLocks(actor);}this._refMap.delete(actor.rawNode);}protocol.Actor.prototype.unmanage.call(this,actor);},hasNode:function(node){return this._refMap.has(node);},_ref:function(node){let actor=this._refMap.get(node);if(actor)return actor;actor = new NodeActor(this,node); // Add the node actor as a child of this walker actor, assigning
	// it an actorID.
	this.manage(actor);this._refMap.set(node,actor);if(node.nodeType === Ci.nsIDOMNode.DOCUMENT_NODE){actor.watchDocument(this.onMutations);}return actor;},_onReflows:function(reflows){ // Going through the nodes the walker knows about, see which ones have
	// had their display changed and send a display-change event if any
	let changes=[];for(let _ref5 of this._refMap) {var _ref6=_slicedToArray(_ref5,2);let node=_ref6[0];let actor=_ref6[1];if(Cu.isDeadWrapper(node)){continue;}let isDisplayed=actor.isDisplayed;if(isDisplayed !== actor.wasDisplayed){changes.push(actor); // Updating the original value
	actor.wasDisplayed = isDisplayed;}}if(changes.length){events.emit(this,"display-change",changes);}}, /**
	   * This is kept for backward-compatibility reasons with older remote targets.
	   * Targets prior to bug 916443.
	   *
	   * pick/cancelPick are used to pick a node on click on the content
	   * document. But in their implementation prior to bug 916443, they don't allow
	   * highlighting on hover.
	   * The client-side now uses the highlighter actor's pick and cancelPick
	   * methods instead. The client-side uses the the highlightable trait found in
	   * the root actor to determine which version of pick to use.
	   *
	   * As for highlight, the new highlighter actor is used instead of the walker's
	   * highlight method. Same here though, the client-side uses the highlightable
	   * trait to dertermine which to use.
	   *
	   * Keeping these actor methods for now allows newer client-side debuggers to
	   * inspect fxos 1.2 remote targets or older firefox desktop remote targets.
	   */pick:method(function(){},{request:{},response:RetVal("disconnectedNode")}),cancelPick:method(function(){}),highlight:method(function(node){},{request:{node:Arg(0,"nullable:domnode")}}), /**
	   * Ensures that the node is attached and it can be accessed from the root.
	   *
	   * @param {(Node|NodeActor)} nodes The nodes
	   * @return {Object} An object compatible with the disconnectedNode type.
	   */attachElement:function(node){var _attachElements=this.attachElements([node]);let nodes=_attachElements.nodes;let newParents=_attachElements.newParents;return {node:nodes[0],newParents:newParents};}, /**
	   * Ensures that the nodes are attached and they can be accessed from the root.
	   *
	   * @param {(Node[]|NodeActor[])} nodes The nodes
	   * @return {Object} An object compatible with the disconnectedNodeArray type.
	   */attachElements:function(nodes){let nodeActors=[];let newParents=new Set();for(let node of nodes) {if(!(node instanceof NodeActor)){ // If an anonymous node was passed in and we aren't supposed to know
	// about it, then consult with the document walker as the source of
	// truth about which elements exist.
	if(!this.showAllAnonymousContent && isAnonymous(node)){node = this.getDocumentWalker(node).currentNode;}node = this._ref(node);}this.ensurePathToRoot(node,newParents); // If nodes may be an array of raw nodes, we're sure to only have
	// NodeActors with the following array.
	nodeActors.push(node);}return {nodes:nodeActors,newParents:[...newParents]};}, /**
	   * Return the document node that contains the given node,
	   * or the root node if no node is specified.
	   * @param NodeActor node
	   *        The node whose document is needed, or null to
	   *        return the root.
	   */document:method(function(node){let doc=isNodeDead(node)?this.rootDoc:nodeDocument(node.rawNode);return this._ref(doc);},{request:{node:Arg(0,"nullable:domnode")},response:{node:RetVal("domnode")}}), /**
	   * Return the documentElement for the document containing the
	   * given node.
	   * @param NodeActor node
	   *        The node whose documentElement is requested, or null
	   *        to use the root document.
	   */documentElement:method(function(node){let elt=isNodeDead(node)?this.rootDoc.documentElement:nodeDocument(node.rawNode).documentElement;return this._ref(elt);},{request:{node:Arg(0,"nullable:domnode")},response:{node:RetVal("domnode")}}), /**
	   * Return all parents of the given node, ordered from immediate parent
	   * to root.
	   * @param NodeActor node
	   *    The node whose parents are requested.
	   * @param object options
	   *    Named options, including:
	   *    `sameDocument`: If true, parents will be restricted to the same
	   *      document as the node.
	   *    `sameTypeRootTreeItem`: If true, this will not traverse across
	   *     different types of docshells.
	   */parents:method(function(node,options = {}){if(isNodeDead(node)){return [];}let walker=this.getDocumentWalker(node.rawNode);let parents=[];let cur;while(cur = walker.parentNode()) {if(options.sameDocument && nodeDocument(cur) != nodeDocument(node.rawNode)){break;}if(options.sameTypeRootTreeItem && nodeDocshell(cur).sameTypeRootTreeItem != nodeDocshell(node.rawNode).sameTypeRootTreeItem){break;}parents.push(this._ref(cur));}return parents;},{request:{node:Arg(0,"domnode"),sameDocument:Option(1),sameTypeRootTreeItem:Option(1)},response:{nodes:RetVal("array:domnode")}}),parentNode:function(node){let walker=this.getDocumentWalker(node.rawNode);let parent=walker.parentNode();if(parent){return this._ref(parent);}return null;}, /**
	   * If the given NodeActor only has a single text node as a child,
	   * return that child's NodeActor.
	   *
	   * @param NodeActor node
	   */singleTextChild:function(node){ // Quick checks to prevent creating a new walker if possible.
	if(node.isBeforePseudoElement || node.isAfterPseudoElement || node.rawNode.nodeType != Ci.nsIDOMNode.ELEMENT_NODE || node.rawNode.children.length > 0){return undefined;}let docWalker=this.getDocumentWalker(node.rawNode);let firstChild=docWalker.firstChild(); // If the first child isn't a text node, or there are multiple children
	// then bail out
	if(!firstChild || firstChild.nodeType !== Ci.nsIDOMNode.TEXT_NODE || docWalker.nextSibling()){return undefined;}return this._ref(firstChild);}, /**
	   * Mark a node as 'retained'.
	   *
	   * A retained node is not released when `releaseNode` is called on its
	   * parent, or when a parent is released with the `cleanup` option to
	   * `getMutations`.
	   *
	   * When a retained node's parent is released, a retained mode is added to
	   * the walker's "retained orphans" list.
	   *
	   * Retained nodes can be deleted by providing the `force` option to
	   * `releaseNode`.  They will also be released when their document
	   * has been destroyed.
	   *
	   * Retaining a node makes no promise about its children;  They can
	   * still be removed by normal means.
	   */retainNode:method(function(node){node.retained = true;},{request:{node:Arg(0,"domnode")},response:{}}), /**
	   * Remove the 'retained' mark from a node.  If the node was a
	   * retained orphan, release it.
	   */unretainNode:method(function(node){node.retained = false;if(this._retainedOrphans.has(node)){this._retainedOrphans.delete(node);this.releaseNode(node);}},{request:{node:Arg(0,"domnode")},response:{}}), /**
	   * Release actors for a node and all child nodes.
	   */releaseNode:method(function(node,options = {}){if(isNodeDead(node)){return;}if(node.retained && !options.force){this._retainedOrphans.add(node);return;}if(node.retained){ // Forcing a retained node to go away.
	this._retainedOrphans.delete(node);}let walker=this.getDocumentWalker(node.rawNode);let child=walker.firstChild();while(child) {let childActor=this._refMap.get(child);if(childActor){this.releaseNode(childActor,options);}child = walker.nextSibling();}node.destroy();},{request:{node:Arg(0,"domnode"),force:Option(1)}}), /**
	   * Add any nodes between `node` and the walker's root node that have not
	   * yet been seen by the client.
	   */ensurePathToRoot:function(node,newParents = new Set()){if(!node){return newParents;}let walker=this.getDocumentWalker(node.rawNode);let cur;while(cur = walker.parentNode()) {let parent=this._refMap.get(cur);if(!parent){ // This parent didn't exist, so hasn't been seen by the client yet.
	newParents.add(this._ref(cur));}else { // This parent did exist, so the client knows about it.
	return newParents;}}return newParents;}, /**
	   * Return children of the given node.  By default this method will return
	   * all children of the node, but there are options that can restrict this
	   * to a more manageable subset.
	   *
	   * @param NodeActor node
	   *    The node whose children you're curious about.
	   * @param object options
	   *    Named options:
	   *    `maxNodes`: The set of nodes returned by the method will be no longer
	   *       than maxNodes.
	   *    `start`: If a node is specified, the list of nodes will start
	   *       with the given child.  Mutally exclusive with `center`.
	   *    `center`: If a node is specified, the given node will be as centered
	   *       as possible in the list, given how close to the ends of the child
	   *       list it is.  Mutually exclusive with `start`.
	   *    `whatToShow`: A bitmask of node types that should be included.  See
	   *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
	   *
	   * @returns an object with three items:
	   *    hasFirst: true if the first child of the node is included in the list.
	   *    hasLast: true if the last child of the node is included in the list.
	   *    nodes: Child nodes returned by the request.
	   */children:method(function(node,options = {}){var _this3=this;if(isNodeDead(node)){return {hasFirst:true,hasLast:true,nodes:[]};}if(options.center && options.start){throw Error("Can't specify both 'center' and 'start' options.");}let maxNodes=options.maxNodes || -1;if(maxNodes == -1){maxNodes = Number.MAX_VALUE;} // We're going to create a few document walkers with the same filter,
	// make it easier.
	let getFilteredWalker=function(node){return _this3.getDocumentWalker(node,options.whatToShow);}; // Need to know the first and last child.
	let rawNode=node.rawNode;let firstChild=getFilteredWalker(rawNode).firstChild();let lastChild=getFilteredWalker(rawNode).lastChild();if(!firstChild){ // No children, we're done.
	return {hasFirst:true,hasLast:true,nodes:[]};}let start;if(options.center){start = options.center.rawNode;}else if(options.start){start = options.start.rawNode;}else {start = firstChild;}let nodes=[]; // Start by reading backward from the starting point if we're centering...
	let backwardWalker=getFilteredWalker(start);if(start != firstChild && options.center){backwardWalker.previousSibling();let backwardCount=Math.floor(maxNodes / 2);let backwardNodes=this._readBackward(backwardWalker,backwardCount);nodes = backwardNodes;} // Then read forward by any slack left in the max children...
	let forwardWalker=getFilteredWalker(start);let forwardCount=maxNodes - nodes.length;nodes = nodes.concat(this._readForward(forwardWalker,forwardCount)); // If there's any room left, it means we've run all the way to the end.
	// If we're centering, check if there are more items to read at the front.
	let remaining=maxNodes - nodes.length;if(options.center && remaining > 0 && nodes[0].rawNode != firstChild){let firstNodes=this._readBackward(backwardWalker,remaining); // Then put it all back together.
	nodes = firstNodes.concat(nodes);}return {hasFirst:nodes[0].rawNode == firstChild,hasLast:nodes[nodes.length - 1].rawNode == lastChild,nodes:nodes};},nodeArrayMethod), /**
	   * Return siblings of the given node.  By default this method will return
	   * all siblings of the node, but there are options that can restrict this
	   * to a more manageable subset.
	   *
	   * If `start` or `center` are not specified, this method will center on the
	   * node whose siblings are requested.
	   *
	   * @param NodeActor node
	   *    The node whose children you're curious about.
	   * @param object options
	   *    Named options:
	   *    `maxNodes`: The set of nodes returned by the method will be no longer
	   *       than maxNodes.
	   *    `start`: If a node is specified, the list of nodes will start
	   *       with the given child.  Mutally exclusive with `center`.
	   *    `center`: If a node is specified, the given node will be as centered
	   *       as possible in the list, given how close to the ends of the child
	   *       list it is.  Mutually exclusive with `start`.
	   *    `whatToShow`: A bitmask of node types that should be included.  See
	   *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
	   *
	   * @returns an object with three items:
	   *    hasFirst: true if the first child of the node is included in the list.
	   *    hasLast: true if the last child of the node is included in the list.
	   *    nodes: Child nodes returned by the request.
	   */siblings:method(function(node,options = {}){if(isNodeDead(node)){return {hasFirst:true,hasLast:true,nodes:[]};}let parentNode=this.getDocumentWalker(node.rawNode,options.whatToShow).parentNode();if(!parentNode){return {hasFirst:true,hasLast:true,nodes:[node]};}if(!(options.start || options.center)){options.center = node;}return this.children(this._ref(parentNode),options);},nodeArrayMethod), /**
	   * Get the next sibling of a given node.  Getting nodes one at a time
	   * might be inefficient, be careful.
	   *
	   * @param object options
	   *    Named options:
	   *    `whatToShow`: A bitmask of node types that should be included.  See
	   *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
	   */nextSibling:method(function(node,options = {}){if(isNodeDead(node)){return null;}let walker=this.getDocumentWalker(node.rawNode,options.whatToShow);let sibling=walker.nextSibling();return sibling?this._ref(sibling):null;},traversalMethod), /**
	   * Get the previous sibling of a given node.  Getting nodes one at a time
	   * might be inefficient, be careful.
	   *
	   * @param object options
	   *    Named options:
	   *    `whatToShow`: A bitmask of node types that should be included.  See
	   *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
	   */previousSibling:method(function(node,options = {}){if(isNodeDead(node)){return null;}let walker=this.getDocumentWalker(node.rawNode,options.whatToShow);let sibling=walker.previousSibling();return sibling?this._ref(sibling):null;},traversalMethod), /**
	   * Helper function for the `children` method: Read forward in the sibling
	   * list into an array with `count` items, including the current node.
	   */_readForward:function(walker,count){let ret=[];let node=walker.currentNode;do {ret.push(this._ref(node));node = walker.nextSibling();}while(node && --count);return ret;}, /**
	   * Helper function for the `children` method: Read backward in the sibling
	   * list into an array with `count` items, including the current node.
	   */_readBackward:function(walker,count){let ret=[];let node=walker.currentNode;do {ret.push(this._ref(node));node = walker.previousSibling();}while(node && --count);ret.reverse();return ret;}, /**
	   * Return the node that the parent process has asked to
	   * inspect. This node is expected to be stored in gInspectingNode
	   * (which is set by a message manager message to the child.js frame
	   * script). The node is returned over the remote debugging protocol
	   * as a NodeFront.
	   */findInspectingNode:method(function(){let node=gInspectingNode;if(!node){return {};};return this.attachElement(node);},{request:{},response:RetVal("disconnectedNode")}), /**
	   * Return the first node in the document that matches the given selector.
	   * See https://developer.mozilla.org/en-US/docs/Web/API/Element.querySelector
	   *
	   * @param NodeActor baseNode
	   * @param string selector
	   */querySelector:method(function(baseNode,selector){if(isNodeDead(baseNode)){return {};}let node=baseNode.rawNode.querySelector(selector);if(!node){return {};};return this.attachElement(node);},{request:{node:Arg(0,"domnode"),selector:Arg(1)},response:RetVal("disconnectedNode")}), /**
	   * Return a NodeListActor with all nodes that match the given selector.
	   * See https://developer.mozilla.org/en-US/docs/Web/API/Element.querySelectorAll
	   *
	   * @param NodeActor baseNode
	   * @param string selector
	   */querySelectorAll:method(function(baseNode,selector){let nodeList=null;try{nodeList = baseNode.rawNode.querySelectorAll(selector);}catch(e) { // Bad selector. Do nothing as the selector can come from a searchbox.
	}return new NodeListActor(this,nodeList);},{request:{node:Arg(0,"domnode"),selector:Arg(1)},response:{list:RetVal("domnodelist")}}), /**
	   * Get a list of nodes that match the given selector in all known frames of
	   * the current content page.
	   * @param {String} selector.
	   * @return {Array}
	   */_multiFrameQuerySelectorAll:function(selector){let nodes=[];for(let _ref7 of this.tabActor.windows) {let document=_ref7.document;try{nodes = [...nodes,...document.querySelectorAll(selector)];}catch(e) { // Bad selector. Do nothing as the selector can come from a searchbox.
	}}return nodes;}, /**
	   * Return a NodeListActor with all nodes that match the given selector in all
	   * frames of the current content page.
	   * @param {String} selector
	   */multiFrameQuerySelectorAll:method(function(selector){return new NodeListActor(this,this._multiFrameQuerySelectorAll(selector));},{request:{selector:Arg(0)},response:{list:RetVal("domnodelist")}}), /**
	   * Search the document for a given string.
	   * Results will be searched with the walker-search module (searches through
	   * tag names, attribute names and values, and text contents).
	   *
	   * @returns {searchresult}
	   *            - {NodeList} list
	   *            - {Array<Object>} metadata. Extra information with indices that
	   *                              match up with node list.
	   */search:method(function(query){let results=this.walkerSearch.search(query);let nodeList=new NodeListActor(this,results.map(function(r){return r.node;}));return {list:nodeList,metadata:[]};},{request:{query:Arg(0)},response:{list:RetVal("searchresult")}}), /**
	   * Returns a list of matching results for CSS selector autocompletion.
	   *
	   * @param string query
	   *        The selector query being completed
	   * @param string completing
	   *        The exact token being completed out of the query
	   * @param string selectorState
	   *        One of "pseudo", "id", "tag", "class", "null"
	   */getSuggestionsForQuery:method(function(query,completing,selectorState){let sugs={classes:new Map(),tags:new Map(),ids:new Map()};let result=[];let nodes=null; // Filtering and sorting the results so that protocol transfer is miminal.
	switch(selectorState){case "pseudo":result = PSEUDO_SELECTORS.filter(function(item){return item[0].startsWith(":" + completing);});break;case "class":if(!query){nodes = this._multiFrameQuerySelectorAll("[class]");}else {nodes = this._multiFrameQuerySelectorAll(query);}for(let node of nodes) {for(let className of node.className.split(" ")) {sugs.classes.set(className,(sugs.classes.get(className) | 0) + 1);}}sugs.classes.delete(""); // Editing the style editor may make the stylesheet have errors and
	// thus the page's elements' styles start changing with a transition.
	// That transition comes from the `moz-styleeditor-transitioning` class.
	sugs.classes.delete("moz-styleeditor-transitioning");sugs.classes.delete(HIDDEN_CLASS);for(let _ref8 of sugs.classes) {var _ref9=_slicedToArray(_ref8,2);let className=_ref9[0];let count=_ref9[1];if(className.startsWith(completing)){result.push(["." + CSS.escape(className),count,selectorState]);}}break;case "id":if(!query){nodes = this._multiFrameQuerySelectorAll("[id]");}else {nodes = this._multiFrameQuerySelectorAll(query);}for(let node of nodes) {sugs.ids.set(node.id,(sugs.ids.get(node.id) | 0) + 1);}for(let _ref10 of sugs.ids) {var _ref11=_slicedToArray(_ref10,2);let id=_ref11[0];let count=_ref11[1];if(id.startsWith(completing)){result.push(["#" + CSS.escape(id),count,selectorState]);}}break;case "tag":if(!query){nodes = this._multiFrameQuerySelectorAll("*");}else {nodes = this._multiFrameQuerySelectorAll(query);}for(let node of nodes) {let tag=node.tagName.toLowerCase();sugs.tags.set(tag,(sugs.tags.get(tag) | 0) + 1);}for(let _ref12 of sugs.tags) {var _ref13=_slicedToArray(_ref12,2);let tag=_ref13[0];let count=_ref13[1];if(new RegExp("^" + completing + ".*","i").test(tag)){result.push([tag,count,selectorState]);}} // For state 'tag' (no preceding # or .) and when there's no query (i.e.
	// only one word) then search for the matching classes and ids
	if(!query){result = [...result,...this.getSuggestionsForQuery(null,completing,"class").suggestions,...this.getSuggestionsForQuery(null,completing,"id").suggestions];}break;case "null":nodes = this._multiFrameQuerySelectorAll(query);for(let node of nodes) {sugs.ids.set(node.id,(sugs.ids.get(node.id) | 0) + 1);let tag=node.tagName.toLowerCase();sugs.tags.set(tag,(sugs.tags.get(tag) | 0) + 1);for(let className of node.className.split(" ")) {sugs.classes.set(className,(sugs.classes.get(className) | 0) + 1);}}for(let _ref14 of sugs.tags) {var _ref15=_slicedToArray(_ref14,2);let tag=_ref15[0];let count=_ref15[1];tag && result.push([tag,count]);}for(let _ref16 of sugs.ids) {var _ref17=_slicedToArray(_ref16,2);let id=_ref17[0];let count=_ref17[1];id && result.push(["#" + id,count]);}sugs.classes.delete(""); // Editing the style editor may make the stylesheet have errors and
	// thus the page's elements' styles start changing with a transition.
	// That transition comes from the `moz-styleeditor-transitioning` class.
	sugs.classes.delete("moz-styleeditor-transitioning");sugs.classes.delete(HIDDEN_CLASS);for(let _ref18 of sugs.classes) {var _ref19=_slicedToArray(_ref18,2);let className=_ref19[0];let count=_ref19[1];className && result.push(["." + className,count]);}} // Sort by count (desc) and name (asc)
	result = result.sort(function(a,b){ // Computed a sortable string with first the inverted count, then the name
	let sortA=10000 - a[1] + a[0];let sortB=10000 - b[1] + b[0]; // Prefixing ids, classes and tags, to group results
	let firstA=a[0].substring(0,1);let firstB=b[0].substring(0,1);if(firstA === "#"){sortA = "2" + sortA;}else if(firstA === "."){sortA = "1" + sortA;}else {sortA = "0" + sortA;}if(firstB === "#"){sortB = "2" + sortB;}else if(firstB === "."){sortB = "1" + sortB;}else {sortB = "0" + sortB;} // String compare
	return sortA.localeCompare(sortB);});result.slice(0,25);return {query:query,suggestions:result};},{request:{query:Arg(0),completing:Arg(1),selectorState:Arg(2)},response:{list:RetVal("array:array:string")}}), /**
	   * Add a pseudo-class lock to a node.
	   *
	   * @param NodeActor node
	   * @param string pseudo
	   *    A pseudoclass: ':hover', ':active', ':focus'
	   * @param options
	   *    Options object:
	   *    `parents`: True if the pseudo-class should be added
	   *      to parent nodes.
	   *
	   * @returns An empty packet.  A "pseudoClassLock" mutation will
	   *    be queued for any changed nodes.
	   */addPseudoClassLock:method(function(node,pseudo,options = {}){if(isNodeDead(node)){return;}this._addPseudoClassLock(node,pseudo);if(!options.parents){return;}let walker=this.getDocumentWalker(node.rawNode);let cur;while(cur = walker.parentNode()) {let curNode=this._ref(cur);this._addPseudoClassLock(curNode,pseudo);}},{request:{node:Arg(0,"domnode"),pseudoClass:Arg(1),parents:Option(2)},response:{}}),_queuePseudoClassMutation:function(node){this.queueMutation({target:node.actorID,type:"pseudoClassLock",pseudoClassLocks:node.writePseudoClassLocks()});},_addPseudoClassLock:function(node,pseudo){if(node.rawNode.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE){return false;}DOMUtils.addPseudoClassLock(node.rawNode,pseudo);this._activePseudoClassLocks.add(node);this._queuePseudoClassMutation(node);return true;},_installHelperSheet:function(node){if(!this.installedHelpers){this.installedHelpers = new WeakMap();}let win=node.rawNode.ownerDocument.defaultView;if(!this.installedHelpers.has(win)){ /*let { Style } = require("sdk/stylesheet/style");*/ /*let { attach } = require("sdk/content/mod");*/let style=Style({source:HELPER_SHEET,type:"agent"});attach(style,win);this.installedHelpers.set(win,style);}},hideNode:method(function(node){if(isNodeDead(node)){return;}this._installHelperSheet(node);node.rawNode.classList.add(HIDDEN_CLASS);},{request:{node:Arg(0,"domnode")}}),unhideNode:method(function(node){if(isNodeDead(node)){return;}node.rawNode.classList.remove(HIDDEN_CLASS);},{request:{node:Arg(0,"domnode")}}), /**
	   * Remove a pseudo-class lock from a node.
	   *
	   * @param NodeActor node
	   * @param string pseudo
	   *    A pseudoclass: ':hover', ':active', ':focus'
	   * @param options
	   *    Options object:
	   *    `parents`: True if the pseudo-class should be removed
	   *      from parent nodes.
	   *
	   * @returns An empty response.  "pseudoClassLock" mutations
	   *    will be emitted for any changed nodes.
	   */removePseudoClassLock:method(function(node,pseudo,options = {}){if(isNodeDead(node)){return;}this._removePseudoClassLock(node,pseudo);if(!options.parents){return;}let walker=this.getDocumentWalker(node.rawNode);let cur;while(cur = walker.parentNode()) {let curNode=this._ref(cur);this._removePseudoClassLock(curNode,pseudo);}},{request:{node:Arg(0,"domnode"),pseudoClass:Arg(1),parents:Option(2)},response:{}}),_removePseudoClassLock:function(node,pseudo){if(node.rawNode.nodeType != Ci.nsIDOMNode.ELEMENT_NODE){return false;}DOMUtils.removePseudoClassLock(node.rawNode,pseudo);if(!node.writePseudoClassLocks()){this._activePseudoClassLocks.delete(node);}this._queuePseudoClassMutation(node);return true;}, /**
	   * Clear all the pseudo-classes on a given node or all nodes.
	   * @param {NodeActor} node Optional node to clear pseudo-classes on
	   */clearPseudoClassLocks:method(function(node){if(node && isNodeDead(node)){return;}if(node){DOMUtils.clearPseudoClassLocks(node.rawNode);this._activePseudoClassLocks.delete(node);this._queuePseudoClassMutation(node);}else {for(let locked of this._activePseudoClassLocks) {DOMUtils.clearPseudoClassLocks(locked.rawNode);this._activePseudoClassLocks.delete(locked);this._queuePseudoClassMutation(locked);}}},{request:{node:Arg(0,"nullable:domnode")},response:{}}), /**
	   * Get a node's innerHTML property.
	   */innerHTML:method(function(node){let html="";if(!isNodeDead(node)){html = node.rawNode.innerHTML;}return LongStringActor(this.conn,html);},{request:{node:Arg(0,"domnode")},response:{value:RetVal("longstring")}}), /**
	   * Set a node's innerHTML property.
	   *
	   * @param {NodeActor} node The node.
	   * @param {string} value The piece of HTML content.
	   */setInnerHTML:method(function(node,value){if(isNodeDead(node)){return;}let rawNode=node.rawNode;if(rawNode.nodeType !== rawNode.ownerDocument.ELEMENT_NODE)throw new Error("Can only change innerHTML to element nodes");rawNode.innerHTML = value;},{request:{node:Arg(0,"domnode"),value:Arg(1,"string")},response:{}}), /**
	   * Get a node's outerHTML property.
	   *
	   * @param {NodeActor} node The node.
	   */outerHTML:method(function(node){let outerHTML="";if(!isNodeDead(node)){outerHTML = node.rawNode.outerHTML;}return LongStringActor(this.conn,outerHTML);},{request:{node:Arg(0,"domnode")},response:{value:RetVal("longstring")}}), /**
	   * Set a node's outerHTML property.
	   *
	   * @param {NodeActor} node The node.
	   * @param {string} value The piece of HTML content.
	   */setOuterHTML:method(function(node,value){if(isNodeDead(node)){return;}let parsedDOM=DOMParser.parseFromString(value,"text/html");let rawNode=node.rawNode;let parentNode=rawNode.parentNode; // Special case for head and body.  Setting document.body.outerHTML
	// creates an extra <head> tag, and document.head.outerHTML creates
	// an extra <body>.  So instead we will call replaceChild with the
	// parsed DOM, assuming that they aren't trying to set both tags at once.
	if(rawNode.tagName === "BODY"){if(parsedDOM.head.innerHTML === ""){parentNode.replaceChild(parsedDOM.body,rawNode);}else {rawNode.outerHTML = value;}}else if(rawNode.tagName === "HEAD"){if(parsedDOM.body.innerHTML === ""){parentNode.replaceChild(parsedDOM.head,rawNode);}else {rawNode.outerHTML = value;}}else if(node.isDocumentElement()){ // Unable to set outerHTML on the document element.  Fall back by
	// setting attributes manually, then replace the body and head elements.
	let finalAttributeModifications=[];let attributeModifications={};for(let attribute of rawNode.attributes) {attributeModifications[attribute.name] = null;}for(let attribute of parsedDOM.documentElement.attributes) {attributeModifications[attribute.name] = attribute.value;}for(let key in attributeModifications) {finalAttributeModifications.push({attributeName:key,newValue:attributeModifications[key]});}node.modifyAttributes(finalAttributeModifications);rawNode.replaceChild(parsedDOM.head,rawNode.querySelector("head"));rawNode.replaceChild(parsedDOM.body,rawNode.querySelector("body"));}else {rawNode.outerHTML = value;}},{request:{node:Arg(0,"domnode"),value:Arg(1,"string")},response:{}}), /**
	   * Insert adjacent HTML to a node.
	   *
	   * @param {Node} node
	   * @param {string} position One of "beforeBegin", "afterBegin", "beforeEnd",
	   *                          "afterEnd" (see Element.insertAdjacentHTML).
	   * @param {string} value The HTML content.
	   */insertAdjacentHTML:method(function(node,position,value){if(isNodeDead(node)){return {node:[],newParents:[]};}let rawNode=node.rawNode; // Don't insert anything adjacent to the document element,
	// the head or the body.
	if(node.isDocumentElement()){throw new Error("Can't insert adjacent element to the root.");}let isInsertAsSibling=position === "beforeBegin" || position === "afterEnd";if((rawNode.tagName === "BODY" || rawNode.tagName === "HEAD") && isInsertAsSibling){throw new Error("Can't insert element before or after the body " + "or the head.");}let rawParentNode=rawNode.parentNode;if(!rawParentNode && isInsertAsSibling){throw new Error("Can't insert as sibling without parent node.");} // We can't use insertAdjacentHTML, because we want to return the nodes
	// being created (so the front can remove them if the user undoes
	// the change). So instead, use Range.createContextualFragment().
	let range=rawNode.ownerDocument.createRange();if(position === "beforeBegin" || position === "afterEnd"){range.selectNode(rawNode);}else {range.selectNodeContents(rawNode);}let docFrag=range.createContextualFragment(value);let newRawNodes=Array.from(docFrag.childNodes);switch(position){case "beforeBegin":rawParentNode.insertBefore(docFrag,rawNode);break;case "afterEnd": // Note: if the second argument is null, rawParentNode.insertBefore
	// behaves like rawParentNode.appendChild.
	rawParentNode.insertBefore(docFrag,rawNode.nextSibling);case "afterBegin":rawNode.insertBefore(docFrag,rawNode.firstChild);break;case "beforeEnd":rawNode.appendChild(docFrag);break;default:throw new Error('Invalid position value. Must be either ' + '"beforeBegin", "beforeEnd", "afterBegin" or "afterEnd".');}return this.attachElements(newRawNodes);},{request:{node:Arg(0,"domnode"),position:Arg(1,"string"),value:Arg(2,"string")},response:RetVal("disconnectedNodeArray")}), /**
	   * Duplicate a specified node
	   *
	   * @param {NodeActor} node The node to duplicate.
	   */duplicateNode:method(function({rawNode}){let clonedNode=rawNode.cloneNode(true);rawNode.parentNode.insertBefore(clonedNode,rawNode.nextSibling);},{request:{node:Arg(0,"domnode")},response:{}}), /**
	   * Test whether a node is a document or a document element.
	   *
	   * @param {NodeActor} node The node to remove.
	   * @return {boolean} True if the node is a document or a document element.
	   */isDocumentOrDocumentElementNode:function(node){return node.rawNode.ownerDocument && node.rawNode.ownerDocument.documentElement === this.rawNode || node.rawNode.nodeType === Ci.nsIDOMNode.DOCUMENT_NODE;}, /**
	   * Removes a node from its parent node.
	   *
	   * @param {NodeActor} node The node to remove.
	   * @returns The node's nextSibling before it was removed.
	   */removeNode:method(function(node){if(isNodeDead(node) || this.isDocumentOrDocumentElementNode(node)){throw Error("Cannot remove document, document elements or dead nodes.");}let nextSibling=this.nextSibling(node);node.rawNode.remove(); // Mutation events will take care of the rest.
	return nextSibling;},{request:{node:Arg(0,"domnode")},response:{nextSibling:RetVal("nullable:domnode")}}), /**
	   * Removes an array of nodes from their parent node.
	   *
	   * @param {NodeActor[]} nodes The nodes to remove.
	   */removeNodes:method(function(nodes){ // Check that all nodes are valid before processing the removals.
	for(let node of nodes) {if(isNodeDead(node) || this.isDocumentOrDocumentElementNode(node)){throw Error("Cannot remove document, document elements or dead nodes");}}for(let node of nodes) {node.rawNode.remove(); // Mutation events will take care of the rest.
	}},{request:{node:Arg(0,"array:domnode")},response:{}}), /**
	   * Insert a node into the DOM.
	   */insertBefore:method(function(node,parent,sibling){if(isNodeDead(node) || isNodeDead(parent) || sibling && isNodeDead(sibling)){return null;}let rawNode=node.rawNode;let rawParent=parent.rawNode;let rawSibling=sibling?sibling.rawNode:null; // Don't bother inserting a node if the document position isn't going
	// to change. This prevents needless iframes reloading and mutations.
	if(rawNode.parentNode === rawParent){let currentNextSibling=this.nextSibling(node);currentNextSibling = currentNextSibling?currentNextSibling.rawNode:null;if(rawNode === rawSibling || currentNextSibling === rawSibling){return;}}rawParent.insertBefore(rawNode,rawSibling);},{request:{node:Arg(0,"domnode"),parent:Arg(1,"domnode"),sibling:Arg(2,"nullable:domnode")},response:{}}), /**
	   * Editing a node's tagname actually means creating a new node with the same
	   * attributes, removing the node and inserting the new one instead.
	   * This method does not return anything as mutation events are taking care of
	   * informing the consumers about changes.
	   */editTagName:method(function(node,tagName){if(isNodeDead(node)){return;}let oldNode=node.rawNode; // Create a new element with the same attributes as the current element and
	// prepare to replace the current node with it.
	let newNode;try{newNode = nodeDocument(oldNode).createElement(tagName);}catch(x) { // Failed to create a new element with that tag name, ignore the change,
	// and signal the error to the front.
	return Promise.reject(new Error("Could not change node's tagName to " + tagName));}let attrs=oldNode.attributes;for(let i=0;i < attrs.length;i++) {newNode.setAttribute(attrs[i].name,attrs[i].value);} // Insert the new node, and transfer the old node's children.
	oldNode.parentNode.insertBefore(newNode,oldNode);while(oldNode.firstChild) {newNode.appendChild(oldNode.firstChild);}oldNode.remove();},{request:{node:Arg(0,"domnode"),tagName:Arg(1,"string")},response:{}}), /**
	   * Get any pending mutation records.  Must be called by the client after
	   * the `new-mutations` notification is received.  Returns an array of
	   * mutation records.
	   *
	   * Mutation records have a basic structure:
	   *
	   * {
	   *   type: attributes|characterData|childList,
	   *   target: <domnode actor ID>,
	   * }
	   *
	   * And additional attributes based on the mutation type:
	   *
	   * `attributes` type:
	   *   attributeName: <string> - the attribute that changed
	   *   attributeNamespace: <string> - the attribute's namespace URI, if any.
	   *   newValue: <string> - The new value of the attribute, if any.
	   *
	   * `characterData` type:
	   *   newValue: <string> - the new shortValue for the node
	   *   [incompleteValue: true] - True if the shortValue was truncated.
	   *
	   * `childList` type is returned when the set of children for a node
	   * has changed.  Includes extra data, which can be used by the client to
	   * maintain its ownership subtree.
	   *
	   *   added: array of <domnode actor ID> - The list of actors *previously
	   *     seen by the client* that were added to the target node.
	   *   removed: array of <domnode actor ID> The list of actors *previously
	   *     seen by the client* that were removed from the target node.
	   *   singleTextChild: If the node now has a single text child, it will
	   *     be sent here.
	   *
	   * Actors that are included in a MutationRecord's `removed` but
	   * not in an `added` have been removed from the client's ownership
	   * tree (either by being moved under a node the client has seen yet
	   * or by being removed from the tree entirely), and is considered
	   * 'orphaned'.
	   *
	   * Keep in mind that if a node that the client hasn't seen is moved
	   * into or out of the target node, it will not be included in the
	   * removedNodes and addedNodes list, so if the client is interested
	   * in the new set of children it needs to issue a `children` request.
	   */getMutations:method(function(options = {}){let pending=this._pendingMutations || [];this._pendingMutations = [];if(options.cleanup){for(let node of this._orphaned) { // Release the orphaned node.  Nodes or children that have been
	// retained will be moved to this._retainedOrphans.
	this.releaseNode(node);}this._orphaned = new Set();}return pending;},{request:{cleanup:Option(0)},response:{mutations:RetVal("array:dommutation")}}),queueMutation:function(mutation){if(!this.actorID || this._destroyed){ // We've been destroyed, don't bother queueing this mutation.
	return;} // We only send the `new-mutations` notification once, until the client
	// fetches mutations with the `getMutations` packet.
	let needEvent=this._pendingMutations.length === 0;this._pendingMutations.push(mutation);if(needEvent){events.emit(this,"new-mutations");}}, /**
	   * Handles mutations from the DOM mutation observer API.
	   *
	   * @param array[MutationRecord] mutations
	   *    See https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#MutationRecord
	   */onMutations:function(mutations){ // Notify any observers that want *all* mutations (even on nodes that aren't
	// referenced).  This is not sent over the protocol so can only be used by
	// scripts running in the server process.
	events.emit(this,"any-mutation");for(let change of mutations) {let targetActor=this._refMap.get(change.target);if(!targetActor){continue;}let targetNode=change.target;let type=change.type;let mutation={type:type,target:targetActor.actorID};if(type === "attributes"){mutation.attributeName = change.attributeName;mutation.attributeNamespace = change.attributeNamespace || undefined;mutation.newValue = targetNode.hasAttribute(mutation.attributeName)?targetNode.getAttribute(mutation.attributeName):null;}else if(type === "characterData"){if(targetNode.nodeValue.length > gValueSummaryLength){mutation.newValue = targetNode.nodeValue.substring(0,gValueSummaryLength);mutation.incompleteValue = true;}else {mutation.newValue = targetNode.nodeValue;}}else if(type === "childList" || type === "nativeAnonymousChildList"){ // Get the list of removed and added actors that the client has seen
	// so that it can keep its ownership tree up to date.
	let removedActors=[];let addedActors=[];for(let removed of change.removedNodes) {let removedActor=this._refMap.get(removed);if(!removedActor){ // If the client never encountered this actor we don't need to
	// mention that it was removed.
	continue;} // While removed from the tree, nodes are saved as orphaned.
	this._orphaned.add(removedActor);removedActors.push(removedActor.actorID);}for(let added of change.addedNodes) {let addedActor=this._refMap.get(added);if(!addedActor){ // If the client never encounted this actor we don't need to tell
	// it about its addition for ownership tree purposes - if the
	// client wants to see the new nodes it can ask for children.
	continue;} // The actor is reconnected to the ownership tree, unorphan
	// it and let the client know so that its ownership tree is up
	// to date.
	this._orphaned.delete(addedActor);addedActors.push(addedActor.actorID);}mutation.numChildren = targetActor.numChildren;mutation.removed = removedActors;mutation.added = addedActors;let singleTextChild=this.singleTextChild(targetActor);if(singleTextChild){mutation.singleTextChild = singleTextChild.form();}}this.queueMutation(mutation);}},onFrameLoad:function({window,isTopLevel}){if(!this.rootDoc && isTopLevel){this.rootDoc = window.document;this.rootNode = this.document();this.queueMutation({type:"newRoot",target:this.rootNode.form()});return;}let frame=getFrameElement(window);let frameActor=this._refMap.get(frame);if(!frameActor){return;}this.queueMutation({type:"frameLoad",target:frameActor.actorID}); // Send a childList mutation on the frame.
	this.queueMutation({type:"childList",target:frameActor.actorID,added:[],removed:[]});}, // Returns true if domNode is in window or a subframe.
	_childOfWindow:function(window,domNode){let win=nodeDocument(domNode).defaultView;while(win) {if(win === window){return true;}win = getFrameElement(win);}return false;},onFrameUnload:function({window}){ // Any retained orphans that belong to this document
	// or its children need to be released, and a mutation sent
	// to notify of that.
	let releasedOrphans=[];for(let retained of this._retainedOrphans) {if(Cu.isDeadWrapper(retained.rawNode) || this._childOfWindow(window,retained.rawNode)){this._retainedOrphans.delete(retained);releasedOrphans.push(retained.actorID);this.releaseNode(retained,{force:true});}}if(releasedOrphans.length > 0){this.queueMutation({target:this.rootNode.actorID,type:"unretained",nodes:releasedOrphans});}let doc=window.document;let documentActor=this._refMap.get(doc);if(!documentActor){return;}if(this.rootDoc === doc){this.rootDoc = null;this.rootNode = null;}this.queueMutation({type:"documentUnload",target:documentActor.actorID});let walker=this.getDocumentWalker(doc);let parentNode=walker.parentNode();if(parentNode){ // Send a childList mutation on the frame so that clients know
	// they should reread the children list.
	this.queueMutation({type:"childList",target:this._refMap.get(parentNode).actorID,added:[],removed:[]});} // Need to force a release of this node, because those nodes can't
	// be accessed anymore.
	this.releaseNode(documentActor,{force:true});}, /**
	   * Check if a node is attached to the DOM tree of the current page.
	   * @param {nsIDomNode} rawNode
	   * @return {Boolean} false if the node is removed from the tree or within a
	   * document fragment
	   */_isInDOMTree:function(rawNode){let walker=this.getDocumentWalker(rawNode);let current=walker.currentNode; // Reaching the top of tree
	while(walker.parentNode()) {current = walker.currentNode;} // The top of the tree is a fragment or is not rootDoc, hence rawNode isn't
	// attached
	if(current.nodeType === Ci.nsIDOMNode.DOCUMENT_FRAGMENT_NODE || current !== this.rootDoc){return false;} // Otherwise the top of the tree is rootDoc, hence rawNode is in rootDoc
	return true;}, /**
	   * @see _isInDomTree
	   */isInDOMTree:method(function(node){if(isNodeDead(node)){return false;}return this._isInDOMTree(node.rawNode);},{request:{node:Arg(0,"domnode")},response:{attached:RetVal("boolean")}}), /**
	   * Given an ObjectActor (identified by its ID), commonly used in the debugger,
	   * webconsole and variablesView, return the corresponding inspector's NodeActor
	   */getNodeActorFromObjectActor:method(function(objectActorID){let actor=this.conn.getActor(objectActorID);if(!actor){return null;}let debuggerObject=this.conn.getActor(objectActorID).obj;let rawNode=debuggerObject.unsafeDereference();if(!this._isInDOMTree(rawNode)){return null;} // This is a special case for the document object whereby it is considered
	// as document.documentElement (the <html> node)
	if(rawNode.defaultView && rawNode === rawNode.defaultView.document){rawNode = rawNode.documentElement;}return this.attachElement(rawNode);},{request:{objectActorID:Arg(0,"string")},response:{nodeFront:RetVal("nullable:disconnectedNode")}}), /**
	   * Given a StyleSheetActor (identified by its ID), commonly used in the
	   * style-editor, get its ownerNode and return the corresponding walker's
	   * NodeActor.
	   * Note that getNodeFromActor was added later and can now be used instead.
	   */getStyleSheetOwnerNode:method(function(styleSheetActorID){return this.getNodeFromActor(styleSheetActorID,["ownerNode"]);},{request:{styleSheetActorID:Arg(0,"string")},response:{ownerNode:RetVal("nullable:disconnectedNode")}}), /**
	   * This method can be used to retrieve NodeActor for DOM nodes from other
	   * actors in a way that they can later be highlighted in the page, or
	   * selected in the inspector.
	   * If an actor has a reference to a DOM node, and the UI needs to know about
	   * this DOM node (and possibly select it in the inspector), the UI should
	   * first retrieve a reference to the walkerFront:
	   *
	   * // Make sure the inspector/walker have been initialized first.
	   * toolbox.initInspector().then(() => {
	   *  // Retrieve the walker.
	   *  let walker = toolbox.walker;
	   * });
	   *
	   * And then call this method:
	   *
	   * // Get the nodeFront from my actor, passing the ID and properties path.
	   * walker.getNodeFromActor(myActorID, ["element"]).then(nodeFront => {
	   *   // Use the nodeFront, e.g. select the node in the inspector.
	   *   toolbox.getPanel("inspector").selection.setNodeFront(nodeFront);
	   * });
	   *
	   * @param {String} actorID The ID for the actor that has a reference to the
	   * DOM node.
	   * @param {Array} path Where, on the actor, is the DOM node stored. If in the
	   * scope of the actor, the node is available as `this.data.node`, then this
	   * should be ["data", "node"].
	   * @return {NodeActor} The attached NodeActor, or null if it couldn't be found.
	   */getNodeFromActor:method(function(actorID,path){let actor=this.conn.getActor(actorID);if(!actor){return null;}let obj=actor;for(let name of path) {if(!(name in obj)){return null;}obj = obj[name];}return this.attachElement(obj);},{request:{actorID:Arg(0,"string"),path:Arg(1,"array:string")},response:{node:RetVal("nullable:disconnectedNode")}})}); /**
	 * Client side of the DOM walker.
	 */var WalkerFront=exports.WalkerFront = protocol.FrontClass(WalkerActor,{ // Set to true if cleanup should be requested after every mutation list.
	autoCleanup:true, /**
	   * This is kept for backward-compatibility reasons with older remote target.
	   * Targets previous to bug 916443
	   */pick:protocol.custom(function(){return this._pick().then(function(response){return response.node;});},{impl:"_pick"}),initialize:function(client,form){this._createRootNodePromise();protocol.Front.prototype.initialize.call(this,client,form);this._orphaned = new Set();this._retainedOrphans = new Set();},destroy:function(){protocol.Front.prototype.destroy.call(this);}, // Update the object given a form representation off the wire.
	form:function(json){this.actorID = json.actor;this.rootNode = types.getType("domnode").read(json.root,this);this._rootNodeDeferred.resolve(this.rootNode); // FF42+ the actor starts exposing traits
	this.traits = json.traits || {};}, /**
	   * Clients can use walker.rootNode to get the current root node of the
	   * walker, but during a reload the root node might be null.  This
	   * method returns a promise that will resolve to the root node when it is
	   * set.
	   */getRootNode:function(){return this._rootNodeDeferred.promise;}, /**
	   * Create the root node promise, triggering the "new-root" notification
	   * on resolution.
	   */_createRootNodePromise:function(){var _this4=this;this._rootNodeDeferred = promise.defer();this._rootNodeDeferred.promise.then(function(){events.emit(_this4,"new-root");});}, /**
	   * When reading an actor form off the wire, we want to hook it up to its
	   * parent front.  The protocol guarantees that the parent will be seen
	   * by the client in either a previous or the current request.
	   * So if we've already seen this parent return it, otherwise create
	   * a bare-bones stand-in node.  The stand-in node will be updated
	   * with a real form by the end of the deserialization.
	   */ensureParentFront:function(id){let front=this.get(id);if(front){return front;}return types.getType("domnode").read({actor:id},this,"standin");}, /**
	   * See the documentation for WalkerActor.prototype.retainNode for
	   * information on retained nodes.
	   *
	   * From the client's perspective, `retainNode` can fail if the node in
	   * question is removed from the ownership tree before the `retainNode`
	   * request reaches the server.  This can only happen if the client has
	   * asked the server to release nodes but hasn't gotten a response
	   * yet: Either a `releaseNode` request or a `getMutations` with `cleanup`
	   * set is outstanding.
	   *
	   * If either of those requests is outstanding AND releases the retained
	   * node, this request will fail with noSuchActor, but the ownership tree
	   * will stay in a consistent state.
	   *
	   * Because the protocol guarantees that requests will be processed and
	   * responses received in the order they were sent, we get the right
	   * semantics by setting our local retained flag on the node only AFTER
	   * a SUCCESSFUL retainNode call.
	   */retainNode:protocol.custom(function(node){return this._retainNode(node).then(function(){node.retained = true;});},{impl:"_retainNode"}),unretainNode:protocol.custom(function(node){var _this5=this;return this._unretainNode(node).then(function(){node.retained = false;if(_this5._retainedOrphans.has(node)){_this5._retainedOrphans.delete(node);_this5._releaseFront(node);}});},{impl:"_unretainNode"}),releaseNode:protocol.custom(function(node,options = {}){ // NodeFront.destroy will destroy children in the ownership tree too,
	// mimicking what the server will do here.
	let actorID=node.actorID;this._releaseFront(node,!!options.force);return this._releaseNode({actorID:actorID});},{impl:"_releaseNode"}),findInspectingNode:protocol.custom(function(){return this._findInspectingNode().then(function(response){return response.node;});},{impl:"_findInspectingNode"}),querySelector:protocol.custom(function(queryNode,selector){return this._querySelector(queryNode,selector).then(function(response){return response.node;});},{impl:"_querySelector"}),getNodeActorFromObjectActor:protocol.custom(function(objectActorID){return this._getNodeActorFromObjectActor(objectActorID).then(function(response){return response?response.node:null;});},{impl:"_getNodeActorFromObjectActor"}),getStyleSheetOwnerNode:protocol.custom(function(styleSheetActorID){return this._getStyleSheetOwnerNode(styleSheetActorID).then(function(response){return response?response.node:null;});},{impl:"_getStyleSheetOwnerNode"}),getNodeFromActor:protocol.custom(function(actorID,path){return this._getNodeFromActor(actorID,path).then(function(response){return response?response.node:null;});},{impl:"_getNodeFromActor"}), /*
	   * Incrementally search the document for a given string.
	   * For modern servers, results will be searched with using the WalkerActor
	   * `search` function (includes tag names, attributes, and text contents).
	   * Only 1 result is sent back, and calling the method again with the same
	   * query will send the next result. When there are no more results to be sent
	   * back, null is sent.
	   * @param {String} query
	   * @param {Object} options
	   *    - "reverse": search backwards
	   *    - "selectorOnly": treat input as a selector string (don't search text
	   *                      tags, attributes, etc)
	   */search:protocol.custom(Task.async(function*(query,options = {}){let nodeList;let searchType;let searchData=this.searchData = this.searchData || {};let selectorOnly=!!options.selectorOnly; // Backwards compat.  Use selector only search if the new
	// search functionality isn't implemented, or if the caller (tests)
	// want it.
	if(selectorOnly || !this.traits.textSearch){searchType = "selector";if(this.traits.multiFrameQuerySelectorAll){nodeList = yield this.multiFrameQuerySelectorAll(query);}else {nodeList = yield this.querySelectorAll(this.rootNode,query);}}else {searchType = "search";let result=yield this._search(query,options);nodeList = result.list;} // If this is a new search, start at the beginning.
	if(searchData.query !== query || searchData.selectorOnly !== selectorOnly){searchData.selectorOnly = selectorOnly;searchData.query = query;searchData.index = -1;}if(!nodeList.length){return null;} // Move search result cursor and cycle if necessary.
	searchData.index = options.reverse?searchData.index - 1:searchData.index + 1;if(searchData.index >= nodeList.length){searchData.index = 0;}if(searchData.index < 0){searchData.index = nodeList.length - 1;} // Send back the single node, along with any relevant search data
	let node=yield nodeList.item(searchData.index);return {type:searchType,node:node,resultsLength:nodeList.length,resultsIndex:searchData.index};}),{impl:"_search"}),_releaseFront:function(node,force){if(node.retained && !force){node.reparent(null);this._retainedOrphans.add(node);return;}if(node.retained){ // Forcing a removal.
	this._retainedOrphans.delete(node);} // Release any children
	for(let child of node.treeChildren()) {this._releaseFront(child,force);} // All children will have been removed from the node by this point.
	node.reparent(null);node.destroy();}, /**
	   * Get any unprocessed mutation records and process them.
	   */getMutations:protocol.custom(function(options = {}){var _this6=this;return this._getMutations(options).then(function(mutations){let emitMutations=[];for(let change of mutations) { // The target is only an actorID, get the associated front.
	let targetID;let targetFront;if(change.type === "newRoot"){_this6.rootNode = types.getType("domnode").read(change.target,_this6);_this6._rootNodeDeferred.resolve(_this6.rootNode);targetID = _this6.rootNode.actorID;targetFront = _this6.rootNode;}else {targetID = change.target;targetFront = _this6.get(targetID);}if(!targetFront){console.trace("Got a mutation for an unexpected actor: " + targetID + ", please file a bug on bugzilla.mozilla.org!");continue;}let emittedMutation=object.merge(change,{target:targetFront});if(change.type === "childList" || change.type === "nativeAnonymousChildList"){ // Update the ownership tree according to the mutation record.
	let addedFronts=[];let removedFronts=[];for(let removed of change.removed) {let removedFront=_this6.get(removed);if(!removedFront){console.error("Got a removal of an actor we didn't know about: " + removed);continue;} // Remove from the ownership tree
	removedFront.reparent(null); // This node is orphaned unless we get it in the 'added' list
	// eventually.
	_this6._orphaned.add(removedFront);removedFronts.push(removedFront);}for(let added of change.added) {let addedFront=_this6.get(added);if(!addedFront){console.error("Got an addition of an actor we didn't know about: " + added);continue;}addedFront.reparent(targetFront); // The actor is reconnected to the ownership tree, unorphan
	// it.
	_this6._orphaned.delete(addedFront);addedFronts.push(addedFront);}if(change.singleTextChild){targetFront.singleTextChild = types.getType("domnode").read(change.singleTextChild,_this6);}else {targetFront.singleTextChild = undefined;} // Before passing to users, replace the added and removed actor
	// ids with front in the mutation record.
	emittedMutation.added = addedFronts;emittedMutation.removed = removedFronts; // If this is coming from a DOM mutation, the actor's numChildren
	// was passed in. Otherwise, it is simulated from a frame load or
	// unload, so don't change the front's form.
	if('numChildren' in change){targetFront._form.numChildren = change.numChildren;}}else if(change.type === "frameLoad"){ // Nothing we need to do here, except verify that we don't have any
	// document children, because we should have gotten a documentUnload
	// first.
	for(let child of targetFront.treeChildren()) {if(child.nodeType === Ci.nsIDOMNode.DOCUMENT_NODE){console.trace("Got an unexpected frameLoad in the inspector, please file a bug on bugzilla.mozilla.org!");}}}else if(change.type === "documentUnload"){if(targetFront === _this6.rootNode){_this6._createRootNodePromise();} // We try to give fronts instead of actorIDs, but these fronts need
	// to be destroyed now.
	emittedMutation.target = targetFront.actorID;emittedMutation.targetParent = targetFront.parentNode(); // Release the document node and all of its children, even retained.
	_this6._releaseFront(targetFront,true);}else if(change.type === "unretained"){ // Retained orphans were force-released without the intervention of
	// client (probably a navigated frame).
	for(let released of change.nodes) {let releasedFront=_this6.get(released);_this6._retainedOrphans.delete(released);_this6._releaseFront(releasedFront,true);}}else {targetFront.updateMutation(change);}emitMutations.push(emittedMutation);}if(options.cleanup){for(let node of _this6._orphaned) { // This will move retained nodes to this._retainedOrphans.
	_this6._releaseFront(node);}_this6._orphaned = new Set();}events.emit(_this6,"mutations",emitMutations);});},{impl:"_getMutations"}), /**
	   * Handle the `new-mutations` notification by fetching the
	   * available mutation records.
	   */onMutations:protocol.preEvent("new-mutations",function(){ // Fetch and process the mutations.
	this.getMutations({cleanup:this.autoCleanup}).catch(function(){});}),isLocal:function(){return !!this.conn._transport._serverConnection;}, // XXX hack during transition to remote inspector: get a proper NodeFront
	// for a given local node.  Only works locally.
	frontForRawNode:function(rawNode){if(!this.isLocal()){console.warn("Tried to use frontForRawNode on a remote connection.");return null;}let walkerActor=this.conn._transport._serverConnection.getActor(this.actorID);if(!walkerActor){throw Error("Could not find client side for actor " + this.actorID);}let nodeActor=walkerActor._ref(rawNode); // Pass the node through a read/write pair to create the client side actor.
	let nodeType=types.getType("domnode");let returnNode=nodeType.read(nodeType.write(nodeActor,walkerActor),this);let top=returnNode;let extras=walkerActor.parents(nodeActor,{sameTypeRootTreeItem:true});for(let extraActor of extras) {top = nodeType.read(nodeType.write(extraActor,walkerActor),this);}if(top !== this.rootNode){ // Imported an already-orphaned node.
	this._orphaned.add(top);walkerActor._orphaned.add(this.conn._transport._serverConnection.getActor(top.actorID));}return returnNode;},removeNode:protocol.custom(Task.async(function*(node){let previousSibling=yield this.previousSibling(node);let nextSibling=yield this._removeNode(node);return {previousSibling:previousSibling,nextSibling:nextSibling};}),{impl:"_removeNode"})}); /**
	 * Convenience API for building a list of attribute modifications
	 * for the `modifyAttributes` request.
	 */var AttributeModificationList=Class({initialize:function(node){this.node = node;this.modifications = [];},apply:function(){let ret=this.node.modifyAttributes(this.modifications);return ret;},destroy:function(){this.node = null;this.modification = null;},setAttributeNS:function(ns,name,value){this.modifications.push({attributeNamespace:ns,attributeName:name,newValue:value});},setAttribute:function(name,value){this.setAttributeNS(undefined,name,value);},removeAttributeNS:function(ns,name){this.setAttributeNS(ns,name,undefined);},removeAttribute:function(name){this.setAttributeNS(undefined,name,undefined);}}); /**
	 * Server side of the inspector actor, which is used to create
	 * inspector-related actors, including the walker.
	 */var InspectorActor=exports.InspectorActor = protocol.ActorClass({typeName:"inspector",initialize:function(conn,tabActor){protocol.Actor.prototype.initialize.call(this,conn);this.tabActor = tabActor;},destroy:function(){protocol.Actor.prototype.destroy.call(this);this._highlighterPromise = null;this._pageStylePromise = null;this._walkerPromise = null;this.walker = null;this.tabActor = null;}, // Forces destruction of the actor and all its children
	// like highlighter, walker and style actors.
	disconnect:function(){this.destroy();},get window(){return this.tabActor.window;},getWalker:method(function(options = {}){var _this7=this;if(this._walkerPromise){return this._walkerPromise;}let deferred=promise.defer();this._walkerPromise = deferred.promise;let window=this.window;var domReady=function(){let tabActor=_this7.tabActor;window.removeEventListener("DOMContentLoaded",domReady,true);_this7.walker = WalkerActor(_this7.conn,tabActor,options);_this7.manage(_this7.walker);events.once(_this7.walker,"destroyed",function(){_this7._walkerPromise = null;_this7._pageStylePromise = null;});deferred.resolve(_this7.walker);};if(window.document.readyState === "loading"){window.addEventListener("DOMContentLoaded",domReady,true);}else {domReady();}return this._walkerPromise;},{request:{options:Arg(0,"nullable:json")},response:{walker:RetVal("domwalker")}}),getPageStyle:method(function(){var _this8=this;if(this._pageStylePromise){return this._pageStylePromise;}this._pageStylePromise = this.getWalker().then(function(walker){let pageStyle=PageStyleActor(_this8);_this8.manage(pageStyle);return pageStyle;});return this._pageStylePromise;},{request:{},response:{pageStyle:RetVal("pagestyle")}}), /**
	   * The most used highlighter actor is the HighlighterActor which can be
	   * conveniently retrieved by this method.
	   * The same instance will always be returned by this method when called
	   * several times.
	   * The highlighter actor returned here is used to highlighter elements's
	   * box-models from the markup-view, layout-view, console, debugger, ... as
	   * well as select elements with the pointer (pick).
	   *
	   * @param {Boolean} autohide Optionally autohide the highlighter after an
	   * element has been picked
	   * @return {HighlighterActor}
	   */getHighlighter:method(function(autohide){var _this9=this;if(this._highlighterPromise){return this._highlighterPromise;}this._highlighterPromise = this.getWalker().then(function(walker){let highlighter=HighlighterActor(_this9,autohide);_this9.manage(highlighter);return highlighter;});return this._highlighterPromise;},{request:{autohide:Arg(0,"boolean")},response:{highligter:RetVal("highlighter")}}), /**
	   * If consumers need to display several highlighters at the same time or
	   * different types of highlighters, then this method should be used, passing
	   * the type name of the highlighter needed as argument.
	   * A new instance will be created everytime the method is called, so it's up
	   * to the consumer to release it when it is not needed anymore
	   *
	   * @param {String} type The type of highlighter to create
	   * @return {Highlighter} The highlighter actor instance or null if the
	   * typeName passed doesn't match any available highlighter
	   */getHighlighterByType:method(function(typeName){if(isTypeRegistered(typeName)){return CustomHighlighterActor(this,typeName);}else {return null;}},{request:{typeName:Arg(0)},response:{highlighter:RetVal("nullable:customhighlighter")}}), /**
	   * Get the node's image data if any (for canvas and img nodes).
	   * Returns an imageData object with the actual data being a LongStringActor
	   * and a size json object.
	   * The image data is transmitted as a base64 encoded png data-uri.
	   * The method rejects if the node isn't an image or if the image is missing
	   *
	   * Accepts a maxDim request parameter to resize images that are larger. This
	   * is important as the resizing occurs server-side so that image-data being
	   * transfered in the longstring back to the client will be that much smaller
	   */getImageDataFromURL:method(function(url,maxDim){var _this10=this;let img=new this.window.Image();img.src = url; // imageToImageData waits for the image to load.
	return imageToImageData(img,maxDim).then(function(imageData){return {data:LongStringActor(_this10.conn,imageData.data),size:imageData.size};});},{request:{url:Arg(0),maxDim:Arg(1,"nullable:number")},response:RetVal("imageData")}), /**
	   * Resolve a URL to its absolute form, in the scope of a given content window.
	   * @param {String} url.
	   * @param {NodeActor} node If provided, the owner window of this node will be
	   * used to resolve the URL. Otherwise, the top-level content window will be
	   * used instead.
	   * @return {String} url.
	   */resolveRelativeURL:method(function(url,node){let document=isNodeDead(node)?this.window.document:nodeDocument(node.rawNode);if(!document){return url;}else {let baseURI=Services.io.newURI(document.location.href,null,null);return Services.io.newURI(url,null,baseURI).spec;}},{request:{url:Arg(0,"string"),node:Arg(1,"nullable:domnode")},response:{value:RetVal("string")}})}); /**
	 * Client side of the inspector actor, which is used to create
	 * inspector-related actors, including the walker.
	 */var InspectorFront=exports.InspectorFront = protocol.FrontClass(InspectorActor,{initialize:function(client,tabForm){protocol.Front.prototype.initialize.call(this,client);this.actorID = tabForm.inspectorActor; // XXX: This is the first actor type in its hierarchy to use the protocol
	// library, so we're going to self-own on the client side for now.
	this.manage(this);},destroy:function(){delete this.walker;protocol.Front.prototype.destroy.call(this);},getWalker:protocol.custom(function(options = {}){var _this11=this;return this._getWalker(options).then(function(walker){_this11.walker = walker;return walker;});},{impl:"_getWalker"}),getPageStyle:protocol.custom(function(){var _this12=this;return this._getPageStyle().then(function(pageStyle){ // We need a walker to understand node references from the
	// node style.
	if(_this12.walker){return pageStyle;}return _this12.getWalker().then(function(){return pageStyle;});});},{impl:"_getPageStyle"})}); // Exported for test purposes.
	exports._documentWalker = DocumentWalker;function nodeDocument(node){if(Cu.isDeadWrapper(node)){return null;}return node.ownerDocument || (node.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE?node:null);}function nodeDocshell(node){let doc=node?nodeDocument(node):null;let win=doc?doc.defaultView:null;if(win){return win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDocShell);}}function isNodeDead(node){return !node || !node.rawNode || Cu.isDeadWrapper(node.rawNode);} /**
	 * Wrapper for inDeepTreeWalker.  Adds filtering to the traversal methods.
	 * See inDeepTreeWalker for more information about the methods.
	 *
	 * @param {DOMNode} node
	 * @param {Window} rootWin
	 * @param {Int} whatToShow See Ci.nsIDOMNodeFilter / inIDeepTreeWalker for options.
	 * @param {Function} filter A custom filter function Taking in a DOMNode
	 *        and returning an Int. See WalkerActor.nodeFilter for an example.
	 */function DocumentWalker(node,rootWin,whatToShow = Ci.nsIDOMNodeFilter.SHOW_ALL,filter = standardTreeWalkerFilter){if(!rootWin.location){throw new Error("Got an invalid root window in DocumentWalker");}this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);this.walker.showAnonymousContent = true;this.walker.showSubDocuments = true;this.walker.showDocumentsAsNodes = true;this.walker.init(rootWin.document,whatToShow);this.filter = filter; // Make sure that the walker knows about the initial node (which could
	// be skipped due to a filter).  Note that simply calling parentNode()
	// causes currentNode to be updated.
	this.walker.currentNode = node;while(node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {node = this.walker.parentNode();}}DocumentWalker.prototype = {get node(){return this.walker.node;},get whatToShow(){return this.walker.whatToShow;},get currentNode(){return this.walker.currentNode;},set currentNode(aVal){this.walker.currentNode = aVal;},parentNode:function(){return this.walker.parentNode();},nextNode:function(){let node=this.walker.currentNode;if(!node){return null;}let nextNode=this.walker.nextNode();while(nextNode && this.filter(nextNode) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {nextNode = this.walker.nextNode();}return nextNode;},firstChild:function(){let node=this.walker.currentNode;if(!node){return null;}let firstChild=this.walker.firstChild();while(firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {firstChild = this.walker.nextSibling();}return firstChild;},lastChild:function(){let node=this.walker.currentNode;if(!node){return null;}let lastChild=this.walker.lastChild();while(lastChild && this.filter(lastChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {lastChild = this.walker.previousSibling();}return lastChild;},previousSibling:function(){let node=this.walker.previousSibling();while(node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {node = this.walker.previousSibling();}return node;},nextSibling:function(){let node=this.walker.nextSibling();while(node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {node = this.walker.nextSibling();}return node;}};function isInXULDocument(el){let doc=nodeDocument(el);return doc && doc.documentElement && doc.documentElement.namespaceURI === XUL_NS;} /**
	 * This DeepTreeWalker filter skips whitespace text nodes and anonymous
	 * content with the exception of ::before and ::after and anonymous content
	 * in XUL document (needed to show all elements in the browser toolbox).
	 */function standardTreeWalkerFilter(aNode){ // ::before and ::after are native anonymous content, but we always
	// want to show them
	if(aNode.nodeName === "_moz_generated_content_before" || aNode.nodeName === "_moz_generated_content_after"){return Ci.nsIDOMNodeFilter.FILTER_ACCEPT;} // Ignore empty whitespace text nodes.
	if(aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE && !/[^\s]/.exec(aNode.nodeValue)){return Ci.nsIDOMNodeFilter.FILTER_SKIP;} // Ignore all native and XBL anonymous content inside a non-XUL document
	if(!isInXULDocument(aNode) && (isXBLAnonymous(aNode) || isNativeAnonymous(aNode))){ // Note: this will skip inspecting the contents of feedSubscribeLine since
	// that's XUL content injected in an HTML document, but we need to because
	// this also skips many other elements that need to be skipped - like form
	// controls, scrollbars, video controls, etc (see bug 1187482).
	return Ci.nsIDOMNodeFilter.FILTER_SKIP;}return Ci.nsIDOMNodeFilter.FILTER_ACCEPT;} /**
	 * This DeepTreeWalker filter is like standardTreeWalkerFilter except that
	 * it also includes all anonymous content (like internal form controls).
	 */function allAnonymousContentTreeWalkerFilter(aNode){ // Ignore empty whitespace text nodes.
	if(aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE && !/[^\s]/.exec(aNode.nodeValue)){return Ci.nsIDOMNodeFilter.FILTER_SKIP;}return Ci.nsIDOMNodeFilter.FILTER_ACCEPT;} /**
	 * Returns a promise that is settled once the given HTMLImageElement has
	 * finished loading.
	 *
	 * @param {HTMLImageElement} image - The image element.
	 * @param {Number} timeout - Maximum amount of time the image is allowed to load
	 * before the waiting is aborted. Ignored if DevToolsUtils.testing is set.
	 *
	 * @return {Promise} that is fulfilled once the image has loaded. If the image
	 * fails to load or the load takes too long, the promise is rejected.
	 */function ensureImageLoaded(image,timeout){let HTMLImageElement=image.ownerDocument.defaultView.HTMLImageElement;if(!(image instanceof HTMLImageElement)){return promise.reject("image must be an HTMLImageELement");}if(image.complete){ // The image has already finished loading.
	return promise.resolve();} // This image is still loading.
	let onLoad=AsyncUtils.listenOnce(image,"load"); // Reject if loading fails.
	let onError=AsyncUtils.listenOnce(image,"error").then(function(){return promise.reject("Image '" + image.src + "' failed to load.");}); // Don't timeout when testing. This is never settled.
	let onAbort=new promise(function(){});if(!DevToolsUtils.testing){ // Tests are not running. Reject the promise after given timeout.
	onAbort = DevToolsUtils.waitForTime(timeout).then(function(){return promise.reject("Image '" + image.src + "' took too long to load.");});} // See which happens first.
	return promise.race([onLoad,onError,onAbort]);} /**
	 * Given an <img> or <canvas> element, return the image data-uri. If @param node
	 * is an <img> element, the method waits a while for the image to load before
	 * the data is generated. If the image does not finish loading in a reasonable
	 * time (IMAGE_FETCHING_TIMEOUT milliseconds) the process aborts.
	 *
	 * @param {HTMLImageElement|HTMLCanvasElement} node - The <img> or <canvas>
	 * element, or Image() object. Other types cause the method to reject.
	 * @param {Number} maxDim - Optionally pass a maximum size you want the longest
	 * side of the image to be resized to before getting the image data.

	 * @return {Promise} A promise that is fulfilled with an object containing the
	 * data-uri and size-related information:
	 * { data: "...",
	 *   size: {
	 *     naturalWidth: 400,
	 *     naturalHeight: 300,
	 *     resized: true }
	 *  }.
	 *
	 * If something goes wrong, the promise is rejected.
	 */var imageToImageData=Task.async(function*(node,maxDim){var _node$ownerDocument$d=node.ownerDocument.defaultView;let HTMLCanvasElement=_node$ownerDocument$d.HTMLCanvasElement;let HTMLImageElement=_node$ownerDocument$d.HTMLImageElement;let isImg=node instanceof HTMLImageElement;let isCanvas=node instanceof HTMLCanvasElement;if(!isImg && !isCanvas){throw "node is not a <canvas> or <img> element.";}if(isImg){ // Ensure that the image is ready.
	yield ensureImageLoaded(node,IMAGE_FETCHING_TIMEOUT);} // Get the image resize ratio if a maxDim was provided
	let resizeRatio=1;let imgWidth=node.naturalWidth || node.width;let imgHeight=node.naturalHeight || node.height;let imgMax=Math.max(imgWidth,imgHeight);if(maxDim && imgMax > maxDim){resizeRatio = maxDim / imgMax;} // Extract the image data
	let imageData; // The image may already be a data-uri, in which case, save ourselves the
	// trouble of converting via the canvas.drawImage.toDataURL method
	if(isImg && node.src.startsWith("data:")){imageData = node.src;}else { // Create a canvas to copy the rawNode into and get the imageData from
	let canvas=node.ownerDocument.createElementNS(XHTML_NS,"canvas");canvas.width = imgWidth * resizeRatio;canvas.height = imgHeight * resizeRatio;let ctx=canvas.getContext("2d"); // Copy the rawNode image or canvas in the new canvas and extract data
	ctx.drawImage(node,0,0,canvas.width,canvas.height);imageData = canvas.toDataURL("image/png");}return {data:imageData,size:{naturalWidth:imgWidth,naturalHeight:imgHeight,resized:resizeRatio !== 1}};}); /*loader.lazyGetter(this, "DOMUtils", function () {
	  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
	});*/

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	const promise = __webpack_require__(6);
	const protocol = __webpack_require__(79);

	var _require2 = __webpack_require__(38);

	const Task = _require2.Task;
	const Arg = protocol.Arg;
	const Option = protocol.Option;
	const method = protocol.method;
	const RetVal = protocol.RetVal;
	const types = protocol.types;

	const events = __webpack_require__(25);

	var _require3 = __webpack_require__(64);

	const Class = _require3.Class;

	var _require4 = __webpack_require__(83);

	const LongStringActor = _require4.LongStringActor;

	var _require5 = __webpack_require__(101);

	const PSEUDO_ELEMENT_SET = _require5.PSEUDO_ELEMENT_SET;

	// This will also add the "stylesheet" actor type for protocol.js to recognize

	var _require6 = __webpack_require__(103);

	const UPDATE_PRESERVING_RULES = _require6.UPDATE_PRESERVING_RULES;
	const UPDATE_GENERAL = _require6.UPDATE_GENERAL;

	/*let CSS = require("CSS");*/

	/*loader.lazyGetter(this, "CssLogic", () => {
	  return require("devtools/shared/styleinspector/css-logic").CssLogic;
	});
	loader.lazyGetter(this, "DOMUtils", () => {
	  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
	});

	loader.lazyGetter(this, "RuleRewriter", () => {
	  return require("devtools/client/shared/css-parsing-utils").RuleRewriter;
	});*/

	// The PageStyle actor flattens the DOM CSS objects a little bit, merging
	// Rules and their Styles into one actor.  For elements (which have a style
	// but no associated rule) we fake a rule with the following style id.

	const ELEMENT_STYLE = 100;
	exports.ELEMENT_STYLE = ELEMENT_STYLE;

	// Not included since these are uneditable by the user.
	// See https://hg.mozilla.org/mozilla-central/file/696a4ad5d011/layout/style/nsCSSPseudoElementList.h#l74
	PSEUDO_ELEMENT_SET.delete(":-moz-meter-bar");
	PSEUDO_ELEMENT_SET.delete(":-moz-list-bullet");
	PSEUDO_ELEMENT_SET.delete(":-moz-list-number");
	PSEUDO_ELEMENT_SET.delete(":-moz-focus-inner");
	PSEUDO_ELEMENT_SET.delete(":-moz-focus-outer");
	PSEUDO_ELEMENT_SET.delete(":-moz-math-anonymous");
	PSEUDO_ELEMENT_SET.delete(":-moz-math-stretchy");

	const PSEUDO_ELEMENTS = Array.from(PSEUDO_ELEMENT_SET);

	exports.PSEUDO_ELEMENTS = PSEUDO_ELEMENTS;

	// When gathering rules to read for pseudo elements, we will skip
	// :before and :after, which are handled as a special case.
	const PSEUDO_ELEMENTS_TO_READ = PSEUDO_ELEMENTS.filter(function (pseudo) {
	  return pseudo !== ":before" && pseudo !== ":after";
	});

	const XHTML_NS = "http://www.w3.org/1999/xhtml";
	const FONT_PREVIEW_TEXT = "Abc";
	const FONT_PREVIEW_FONT_SIZE = 40;
	const FONT_PREVIEW_FILLSTYLE = "black";
	const NORMAL_FONT_WEIGHT = 400;
	const BOLD_FONT_WEIGHT = 700;
	// Offset (in px) to avoid cutting off text edges of italic fonts.
	const FONT_PREVIEW_OFFSET = 4;

	// Predeclare the domnode actor type for use in requests.
	types.addActorType("domnode");

	// Predeclare the domstylerule actor type
	types.addActorType("domstylerule");

	/**
	 * DOM Nodes returned by the style actor will be owned by the DOM walker
	 * for the connection.
	  */
	types.addLifetime("walker", "walker");

	/**
	 * When asking for the styles applied to a node, we return a list of
	 * appliedstyle json objects that lists the rules that apply to the node
	 * and which element they were inherited from (if any).
	 *
	 * Note appliedstyle only sends the list of actorIDs and is not a valid return
	 * value on its own. appliedstyle should be returned with the actual list of
	 * StyleRuleActor and StyleSheetActor. See appliedStylesReturn.
	 */
	types.addDictType("appliedstyle", {
	  rule: "domstylerule#actorid",
	  inherited: "nullable:domnode#actorid",
	  keyframes: "nullable:domstylerule#actorid"
	});

	types.addDictType("matchedselector", {
	  rule: "domstylerule#actorid",
	  selector: "string",
	  value: "string",
	  status: "number"
	});

	types.addDictType("appliedStylesReturn", {
	  entries: "array:appliedstyle",
	  rules: "array:domstylerule",
	  sheets: "array:stylesheet"
	});

	types.addDictType("modifiedStylesReturn", {
	  isMatching: RetVal("boolean"),
	  ruleProps: RetVal("nullable:appliedStylesReturn")
	});

	types.addDictType("fontpreview", {
	  data: "nullable:longstring",
	  size: "json"
	});

	types.addDictType("fontface", {
	  name: "string",
	  CSSFamilyName: "string",
	  rule: "nullable:domstylerule",
	  srcIndex: "number",
	  URI: "string",
	  format: "string",
	  preview: "nullable:fontpreview",
	  localName: "string",
	  metadata: "string"
	});

	/**
	 * The PageStyle actor lets the client look at the styles on a page, as
	 * they are applied to a given node.
	 */
	var PageStyleActor = protocol.ActorClass({
	  typeName: "pagestyle",

	  events: {
	    "stylesheet-updated": {
	      type: "styleSheetUpdated",
	      styleSheet: Arg(0, "stylesheet")
	    }
	  },

	  /**
	   * Create a PageStyleActor.
	   *
	   * @param inspector
	   *    The InspectorActor that owns this PageStyleActor.
	   *
	   * @constructor
	   */
	  initialize: function (inspector) {
	    protocol.Actor.prototype.initialize.call(this, null);
	    this.inspector = inspector;
	    if (!this.inspector.walker) {
	      throw Error("The inspector's WalkerActor must be created before " + "creating a PageStyleActor.");
	    }
	    this.walker = inspector.walker;
	    this.cssLogic = new CssLogic();

	    // Stores the association of DOM objects -> actors
	    this.refMap = new Map();

	    this.onFrameUnload = this.onFrameUnload.bind(this);
	    events.on(this.inspector.tabActor, "will-navigate", this.onFrameUnload);

	    this._styleApplied = this._styleApplied.bind(this);
	    this._watchedSheets = new Set();
	  },

	  destroy: function () {
	    if (!this.walker) {
	      return;
	    }
	    protocol.Actor.prototype.destroy.call(this);
	    events.off(this.inspector.tabActor, "will-navigate", this.onFrameUnload);
	    this.inspector = null;
	    this.walker = null;
	    this.refMap = null;
	    this.cssLogic = null;
	    this._styleElement = null;

	    for (let sheet of this._watchedSheets) {
	      sheet.off("style-applied", this._styleApplied);
	    }
	    this._watchedSheets.clear();
	  },

	  get conn() {
	    return this.inspector.conn;
	  },

	  form: function (detail) {
	    if (detail === "actorid") {
	      return this.actorID;
	    }

	    return {
	      actor: this.actorID,
	      traits: {
	        // Whether the actor has had bug 1103993 fixed, which means that the
	        // getApplied method calls cssLogic.highlight(node) to recreate the
	        // style cache. Clients requesting getApplied from actors that have not
	        // been fixed must make sure cssLogic.highlight(node) was called before.
	        getAppliedCreatesStyleCache: true,
	        // Whether addNewRule accepts the editAuthored argument.
	        authoredStyles: true
	      }
	    };
	  },

	  /**
	   * Called when a style sheet is updated.
	   */
	  _styleApplied: function (kind, styleSheet) {
	    // No matter what kind of update is done, we need to invalidate
	    // the keyframe cache.
	    this.cssLogic.reset();
	    if (kind === UPDATE_GENERAL) {
	      events.emit(this, "stylesheet-updated", styleSheet);
	    }
	  },

	  /**
	   * Return or create a StyleRuleActor for the given item.
	   * @param item Either a CSSStyleRule or a DOM element.
	   */
	  _styleRef: function (item) {
	    if (this.refMap.has(item)) {
	      return this.refMap.get(item);
	    }
	    let actor = StyleRuleActor(this, item);
	    this.manage(actor);
	    this.refMap.set(item, actor);

	    return actor;
	  },

	  /**
	   * Update the association between a StyleRuleActor and its
	   * corresponding item.  This is used when a StyleRuleActor updates
	   * as style sheet and starts using a new rule.
	   *
	   * @param oldItem The old association; either a CSSStyleRule or a
	   *                DOM element.
	   * @param item Either a CSSStyleRule or a DOM element.
	   * @param actor a StyleRuleActor
	   */
	  updateStyleRef: function (oldItem, item, actor) {
	    this.refMap.delete(oldItem);
	    this.refMap.set(item, actor);
	  },

	  /**
	   * Return or create a StyleSheetActor for the given nsIDOMCSSStyleSheet.
	   * @param  {DOMStyleSheet} sheet
	   *         The style sheet to create an actor for.
	   * @return {StyleSheetActor}
	   *         The actor for this style sheet
	   */
	  _sheetRef: function (sheet) {
	    let tabActor = this.inspector.tabActor;
	    let actor = tabActor.createStyleSheetActor(sheet);
	    if (!this._watchedSheets.has(actor)) {
	      this._watchedSheets.add(actor);
	      actor.on("style-applied", this._styleApplied);
	    }
	    return actor;
	  },

	  /**
	   * Get the computed style for a node.
	   *
	   * @param NodeActor node
	   * @param object options
	   *   `filter`: A string filter that affects the "matched" handling.
	   *     'user': Include properties from user style sheets.
	   *     'ua': Include properties from user and user-agent sheets.
	   *     Default value is 'ua'
	   *   `markMatched`: true if you want the 'matched' property to be added
	   *     when a computed property has been modified by a style included
	   *     by `filter`.
	   *   `onlyMatched`: true if unmatched properties shouldn't be included.
	   *
	   * @returns a JSON blob with the following form:
	   *   {
	   *     "property-name": {
	   *       value: "property-value",
	   *       priority: "!important" <optional>
	   *       matched: <true if there are matched selectors for this value>
	   *     },
	   *     ...
	   *   }
	   */
	  getComputed: method(function (node, options) {
	    let ret = Object.create(null);

	    this.cssLogic.sourceFilter = options.filter || CssLogic.FILTER.UA;
	    this.cssLogic.highlight(node.rawNode);
	    let computed = this.cssLogic.computedStyle || [];

	    Array.prototype.forEach.call(computed, function (name) {
	      ret[name] = {
	        value: computed.getPropertyValue(name),
	        priority: computed.getPropertyPriority(name) || undefined
	      };
	    });

	    if (options.markMatched || options.onlyMatched) {
	      let matched = this.cssLogic.hasMatchedSelectors(Object.keys(ret));
	      for (let key in ret) {
	        if (matched[key]) {
	          ret[key].matched = options.markMatched ? true : undefined;
	        } else if (options.onlyMatched) {
	          delete ret[key];
	        }
	      }
	    }

	    return ret;
	  }, {
	    request: {
	      node: Arg(0, "domnode"),
	      markMatched: Option(1, "boolean"),
	      onlyMatched: Option(1, "boolean"),
	      filter: Option(1, "string")
	    },
	    response: {
	      computed: RetVal("json")
	    }
	  }),

	  /**
	   * Get all the fonts from a page.
	   *
	   * @param object options
	   *   `includePreviews`: Whether to also return image previews of the fonts.
	   *   `previewText`: The text to display in the previews.
	   *   `previewFontSize`: The font size of the text in the previews.
	   *
	   * @returns object
	   *   object with 'fontFaces', a list of fonts that apply to this node.
	   */
	  getAllUsedFontFaces: method(function (options) {
	    let windows = this.inspector.tabActor.windows;
	    let fontsList = [];
	    for (let win of windows) {
	      fontsList = [...fontsList, ...this.getUsedFontFaces(win.document.body, options)];
	    }
	    return fontsList;
	  }, {
	    request: {
	      includePreviews: Option(0, "boolean"),
	      previewText: Option(0, "string"),
	      previewFontSize: Option(0, "string"),
	      previewFillStyle: Option(0, "string")
	    },
	    response: {
	      fontFaces: RetVal("array:fontface")
	    }
	  }),

	  /**
	   * Get the font faces used in an element.
	   *
	   * @param NodeActor node / actual DOM node
	   *    The node to get fonts from.
	   * @param object options
	   *   `includePreviews`: Whether to also return image previews of the fonts.
	   *   `previewText`: The text to display in the previews.
	   *   `previewFontSize`: The font size of the text in the previews.
	   *
	   * @returns object
	   *   object with 'fontFaces', a list of fonts that apply to this node.
	   */
	  getUsedFontFaces: method(function (node, options) {
	    // node.rawNode is defined for NodeActor objects
	    let actualNode = node.rawNode || node;
	    let contentDocument = actualNode.ownerDocument;
	    // We don't get fonts for a node, but for a range
	    let rng = contentDocument.createRange();
	    rng.selectNodeContents(actualNode);
	    let fonts = DOMUtils.getUsedFontFaces(rng);
	    let fontsArray = [];

	    for (let i = 0; i < fonts.length; i++) {
	      let font = fonts.item(i);
	      let fontFace = {
	        name: font.name,
	        CSSFamilyName: font.CSSFamilyName,
	        srcIndex: font.srcIndex,
	        URI: font.URI,
	        format: font.format,
	        localName: font.localName,
	        metadata: font.metadata
	      };

	      // If this font comes from a @font-face rule
	      if (font.rule) {
	        let styleActor = StyleRuleActor(this, font.rule);
	        this.manage(styleActor);
	        fontFace.rule = styleActor;
	        fontFace.ruleText = font.rule.cssText;
	      }

	      // Get the weight and style of this font for the preview and sort order
	      let weight = NORMAL_FONT_WEIGHT,
	          style = "";
	      if (font.rule) {
	        weight = font.rule.style.getPropertyValue("font-weight") || NORMAL_FONT_WEIGHT;
	        if (weight == "bold") {
	          weight = BOLD_FONT_WEIGHT;
	        } else if (weight == "normal") {
	          weight = NORMAL_FONT_WEIGHT;
	        }
	        style = font.rule.style.getPropertyValue("font-style") || "";
	      }
	      fontFace.weight = weight;
	      fontFace.style = style;

	      if (options.includePreviews) {
	        let opts = {
	          previewText: options.previewText,
	          previewFontSize: options.previewFontSize,
	          fontStyle: weight + " " + style,
	          fillStyle: options.previewFillStyle
	        };

	        var _getFontPreviewData = getFontPreviewData(font.CSSFamilyName, contentDocument, opts);

	        let dataURL = _getFontPreviewData.dataURL;
	        let size = _getFontPreviewData.size;

	        fontFace.preview = {
	          data: LongStringActor(this.conn, dataURL),
	          size: size
	        };
	      }
	      fontsArray.push(fontFace);
	    }

	    // @font-face fonts at the top, then alphabetically, then by weight
	    fontsArray.sort(function (a, b) {
	      return a.weight > b.weight ? 1 : -1;
	    });
	    fontsArray.sort(function (a, b) {
	      if (a.CSSFamilyName == b.CSSFamilyName) {
	        return 0;
	      }
	      return a.CSSFamilyName > b.CSSFamilyName ? 1 : -1;
	    });
	    fontsArray.sort(function (a, b) {
	      if (a.rule && b.rule || !a.rule && !b.rule) {
	        return 0;
	      }
	      return !a.rule && b.rule ? 1 : -1;
	    });

	    return fontsArray;
	  }, {
	    request: {
	      node: Arg(0, "domnode"),
	      includePreviews: Option(1, "boolean"),
	      previewText: Option(1, "string"),
	      previewFontSize: Option(1, "string"),
	      previewFillStyle: Option(1, "string")
	    },
	    response: {
	      fontFaces: RetVal("array:fontface")
	    }
	  }),

	  /**
	   * Get a list of selectors that match a given property for a node.
	   *
	   * @param NodeActor node
	   * @param string property
	   * @param object options
	   *   `filter`: A string filter that affects the "matched" handling.
	   *     'user': Include properties from user style sheets.
	   *     'ua': Include properties from user and user-agent sheets.
	   *     Default value is 'ua'
	   *
	   * @returns a JSON object with the following form:
	   *   {
	   *     // An ordered list of rules that apply
	   *     matched: [{
	   *       rule: <rule actorid>,
	   *       sourceText: <string>, // The source of the selector, relative
	   *                             // to the node in question.
	   *       selector: <string>, // the selector ID that matched
	   *       value: <string>, // the value of the property
	   *       status: <int>,
	   *         // The status of the match - high numbers are better placed
	   *         // to provide styling information:
	   *         // 3: Best match, was used.
	   *         // 2: Matched, but was overridden.
	   *         // 1: Rule from a parent matched.
	   *         // 0: Unmatched (never returned in this API)
	   *     }, ...],
	   *
	   *     // The full form of any domrule referenced.
	   *     rules: [ <domrule>, ... ], // The full form of any domrule referenced
	   *
	   *     // The full form of any sheets referenced.
	   *     sheets: [ <domsheet>, ... ]
	   *  }
	   */
	  getMatchedSelectors: method(function (node, property, options) {
	    this.cssLogic.sourceFilter = options.filter || CssLogic.FILTER.UA;
	    this.cssLogic.highlight(node.rawNode);

	    let rules = new Set();
	    let sheets = new Set();

	    let matched = [];
	    let propInfo = this.cssLogic.getPropertyInfo(property);
	    for (let selectorInfo of propInfo.matchedSelectors) {
	      let cssRule = selectorInfo.selector.cssRule;
	      let domRule = cssRule.sourceElement || cssRule.domRule;

	      let rule = this._styleRef(domRule);
	      rules.add(rule);

	      matched.push({
	        rule: rule,
	        sourceText: this.getSelectorSource(selectorInfo, node.rawNode),
	        selector: selectorInfo.selector.text,
	        name: selectorInfo.property,
	        value: selectorInfo.value,
	        status: selectorInfo.status
	      });
	    }

	    this.expandSets(rules, sheets);

	    return {
	      matched: matched,
	      rules: [...rules],
	      sheets: [...sheets]
	    };
	  }, {
	    request: {
	      node: Arg(0, "domnode"),
	      property: Arg(1, "string"),
	      filter: Option(2, "string")
	    },
	    response: RetVal(types.addDictType("matchedselectorresponse", {
	      rules: "array:domstylerule",
	      sheets: "array:stylesheet",
	      matched: "array:matchedselector"
	    }))
	  }),

	  // Get a selector source for a CssSelectorInfo relative to a given
	  // node.
	  getSelectorSource: function (selectorInfo, relativeTo) {
	    let result = selectorInfo.selector.text;
	    if (selectorInfo.elementStyle) {
	      let source = selectorInfo.sourceElement;
	      if (source === relativeTo) {
	        result = "this";
	      } else {
	        result = CssLogic.getShortName(source);
	      }
	      result += ".style";
	    }
	    return result;
	  },

	  /**
	   * Get the set of styles that apply to a given node.
	   * @param NodeActor node
	   * @param object options
	   *   `filter`: A string filter that affects the "matched" handling.
	   *     'user': Include properties from user style sheets.
	   *     'ua': Include properties from user and user-agent sheets.
	   *     Default value is 'ua'
	   *   `inherited`: Include styles inherited from parent nodes.
	   *   `matchedSelectors`: Include an array of specific selectors that
	   *     caused this rule to match its node.
	   */
	  getApplied: method(Task.async(function* (node, options) {
	    if (!node) {
	      return { entries: [], rules: [], sheets: [] };
	    }

	    this.cssLogic.highlight(node.rawNode);
	    let entries = [];
	    entries = entries.concat(this._getAllElementRules(node, undefined, options));

	    let result = this.getAppliedProps(node, entries, options);
	    for (let rule of result.rules) {
	      // See the comment in |form| to understand this.
	      yield rule.getAuthoredCssText();
	    }
	    return result;
	  }), {
	    request: {
	      node: Arg(0, "domnode"),
	      inherited: Option(1, "boolean"),
	      matchedSelectors: Option(1, "boolean"),
	      filter: Option(1, "string")
	    },
	    response: RetVal("appliedStylesReturn")
	  }),

	  _hasInheritedProps: function (style) {
	    return Array.prototype.some.call(style, function (prop) {
	      return DOMUtils.isInheritedProperty(prop);
	    });
	  },

	  /**
	   * Helper function for getApplied, gets all the rules from a given
	   * element. See getApplied for documentation on parameters.
	   * @param NodeActor node
	   * @param bool inherited
	   * @param object options
	    * @return Array The rules for a given element. Each item in the
	   *               array has the following signature:
	   *                - rule RuleActor
	   *                - isSystem Boolean
	   *                - inherited Boolean
	   *                - pseudoElement String
	   */
	  _getAllElementRules: function (node, inherited, options) {
	    var _CssLogic$getBindingE = CssLogic.getBindingElementAndPseudo(node.rawNode);

	    let bindingElement = _CssLogic$getBindingE.bindingElement;
	    let pseudo = _CssLogic$getBindingE.pseudo;

	    let rules = [];

	    if (!bindingElement || !bindingElement.style) {
	      return rules;
	    }

	    let elementStyle = this._styleRef(bindingElement);
	    let showElementStyles = !inherited && !pseudo;
	    let showInheritedStyles = inherited && this._hasInheritedProps(bindingElement.style);

	    let rule = {
	      rule: elementStyle,
	      pseudoElement: null,
	      isSystem: false,
	      inherited: false
	    };

	    // First any inline styles
	    if (showElementStyles) {
	      rules.push(rule);
	    }

	    // Now any inherited styles
	    if (showInheritedStyles) {
	      rule.inherited = inherited;
	      rules.push(rule);
	    }

	    // Add normal rules.  Typically this is passing in the node passed into the
	    // function, unless if that node was ::before/::after.  In which case,
	    // it will pass in the parentNode along with "::before"/"::after".
	    this._getElementRules(bindingElement, pseudo, inherited, options).forEach(function (rule) {
	      // The only case when there would be a pseudo here is ::before/::after,
	      // and in this case we want to tell the view that it belongs to the
	      // element (which is a _moz_generated_content native anonymous element).
	      rule.pseudoElement = null;
	      rules.push(rule);
	    });

	    // Now any pseudos (except for ::before / ::after, which was handled as
	    // a 'normal rule' above.
	    if (showElementStyles) {
	      for (let pseudo of PSEUDO_ELEMENTS_TO_READ) {
	        this._getElementRules(bindingElement, pseudo, inherited, options).forEach(function (rule) {
	          rules.push(rule);
	        });
	      }
	    }

	    return rules;
	  },

	  /**
	   * Helper function for _getAllElementRules, returns the rules from a given
	   * element. See getApplied for documentation on parameters.
	   * @param DOMNode node
	   * @param string pseudo
	   * @param DOMNode inherited
	   * @param object options
	   *
	   * @returns Array
	   */
	  _getElementRules: function (node, pseudo, inherited, options) {
	    let domRules = DOMUtils.getCSSStyleRules(node, pseudo);
	    if (!domRules) {
	      return [];
	    }

	    let rules = [];

	    // getCSSStyleRules returns ordered from least-specific to
	    // most-specific.
	    for (let i = domRules.Count() - 1; i >= 0; i--) {
	      let domRule = domRules.GetElementAt(i);

	      let isSystem = !CssLogic.isContentStylesheet(domRule.parentStyleSheet);

	      if (isSystem && options.filter != CssLogic.FILTER.UA) {
	        continue;
	      }

	      if (inherited) {
	        // Don't include inherited rules if none of its properties
	        // are inheritable.
	        let hasInherited = [...domRule.style].some(function (prop) {
	          return DOMUtils.isInheritedProperty(prop);
	        });
	        if (!hasInherited) {
	          continue;
	        }
	      }

	      let ruleActor = this._styleRef(domRule);
	      rules.push({
	        rule: ruleActor,
	        inherited: inherited,
	        isSystem: isSystem,
	        pseudoElement: pseudo
	      });
	    }
	    return rules;
	  },

	  /**
	   * Helper function for getApplied that fetches a set of style properties that
	   * apply to the given node and associated rules
	   * @param NodeActor node
	   * @param object options
	   *   `filter`: A string filter that affects the "matched" handling.
	   *     'user': Include properties from user style sheets.
	   *     'ua': Include properties from user and user-agent sheets.
	   *     Default value is 'ua'
	   *   `inherited`: Include styles inherited from parent nodes.
	   *   `matchedSeletors`: Include an array of specific selectors that
	   *     caused this rule to match its node.
	   * @param array entries
	   *   List of appliedstyle objects that lists the rules that apply to the
	   *   node. If adding a new rule to the stylesheet, only the new rule entry
	   *   is provided and only the style properties that apply to the new
	   *   rule is fetched.
	   * @returns Object containing the list of rule entries, rule actors and
	   *   stylesheet actors that applies to the given node and its associated
	   *   rules.
	   */
	  getAppliedProps: function (node, entries, options) {
	    if (options.inherited) {
	      let parent = this.walker.parentNode(node);
	      while (parent && parent.rawNode.nodeType != Ci.nsIDOMNode.DOCUMENT_NODE) {
	        entries = entries.concat(this._getAllElementRules(parent, parent, options));
	        parent = this.walker.parentNode(parent);
	      }
	    }

	    if (options.matchedSelectors) {
	      for (let entry of entries) {
	        if (entry.rule.type === ELEMENT_STYLE) {
	          continue;
	        }

	        let domRule = entry.rule.rawRule;
	        let selectors = CssLogic.getSelectors(domRule);
	        let element = entry.inherited ? entry.inherited.rawNode : node.rawNode;

	        var _CssLogic$getBindingE2 = CssLogic.getBindingElementAndPseudo(element);

	        let bindingElement = _CssLogic$getBindingE2.bindingElement;
	        let pseudo = _CssLogic$getBindingE2.pseudo;

	        entry.matchedSelectors = [];
	        for (let i = 0; i < selectors.length; i++) {
	          if (DOMUtils.selectorMatchesElement(bindingElement, domRule, i, pseudo)) {
	            entry.matchedSelectors.push(selectors[i]);
	          }
	        }
	      }
	    }

	    // Add all the keyframes rule associated with the element
	    let computedStyle = this.cssLogic.computedStyle;
	    if (computedStyle) {
	      let animationNames = computedStyle.animationName.split(",");
	      animationNames = animationNames.map(function (name) {
	        return name.trim();
	      });

	      if (animationNames) {
	        // Traverse through all the available keyframes rule and add
	        // the keyframes rule that matches the computed animation name
	        for (let keyframesRule of this.cssLogic.keyframesRules) {
	          if (animationNames.indexOf(keyframesRule.name) > -1) {
	            for (let rule of keyframesRule.cssRules) {
	              entries.push({
	                rule: this._styleRef(rule),
	                keyframes: this._styleRef(keyframesRule)
	              });
	            }
	          }
	        }
	      }
	    }

	    let rules = new Set();
	    let sheets = new Set();
	    entries.forEach(function (entry) {
	      return rules.add(entry.rule);
	    });
	    this.expandSets(rules, sheets);

	    return {
	      entries: entries,
	      rules: [...rules],
	      sheets: [...sheets]
	    };
	  },

	  /**
	   * Expand Sets of rules and sheets to include all parent rules and sheets.
	   */
	  expandSets: function (ruleSet, sheetSet) {
	    // Sets include new items in their iteration
	    for (let rule of ruleSet) {
	      if (rule.rawRule.parentRule) {
	        let parent = this._styleRef(rule.rawRule.parentRule);
	        if (!ruleSet.has(parent)) {
	          ruleSet.add(parent);
	        }
	      }
	      if (rule.rawRule.parentStyleSheet) {
	        let parent = this._sheetRef(rule.rawRule.parentStyleSheet);
	        if (!sheetSet.has(parent)) {
	          sheetSet.add(parent);
	        }
	      }
	    }

	    for (let sheet of sheetSet) {
	      if (sheet.rawSheet.parentStyleSheet) {
	        let parent = this._sheetRef(sheet.rawSheet.parentStyleSheet);
	        if (!sheetSet.has(parent)) {
	          sheetSet.add(parent);
	        }
	      }
	    }
	  },

	  /**
	   * Get layout-related information about a node.
	   * This method returns an object with properties giving information about
	   * the node's margin, border, padding and content region sizes, as well
	   * as information about the type of box, its position, z-index, etc...
	   * @param {NodeActor} node
	   * @param {Object} options The only available option is autoMargins.
	   * If set to true, the element's margins will receive an extra check to see
	   * whether they are set to "auto" (knowing that the computed-style in this
	   * case would return "0px").
	   * The returned object will contain an extra property (autoMargins) listing
	   * all margins that are set to auto, e.g. {top: "auto", left: "auto"}.
	   * @return {Object}
	   */
	  getLayout: method(function (node, options) {
	    this.cssLogic.highlight(node.rawNode);

	    let layout = {};

	    // First, we update the first part of the layout view, with
	    // the size of the element.

	    let clientRect = node.rawNode.getBoundingClientRect();
	    layout.width = parseFloat(clientRect.width.toPrecision(6));
	    layout.height = parseFloat(clientRect.height.toPrecision(6));

	    // We compute and update the values of margins & co.
	    let style = CssLogic.getComputedStyle(node.rawNode);
	    for (let prop of ["position", "margin-top", "margin-right", "margin-bottom", "margin-left", "padding-top", "padding-right", "padding-bottom", "padding-left", "border-top-width", "border-right-width", "border-bottom-width", "border-left-width", "z-index", "box-sizing", "display"]) {
	      layout[prop] = style.getPropertyValue(prop);
	    }

	    if (options.autoMargins) {
	      layout.autoMargins = this.processMargins(this.cssLogic);
	    }

	    for (let i in this.map) {
	      let property = this.map[i].property;
	      this.map[i].value = parseFloat(style.getPropertyValue(property));
	    }

	    return layout;
	  }, {
	    request: {
	      node: Arg(0, "domnode"),
	      autoMargins: Option(1, "boolean")
	    },
	    response: RetVal("json")
	  }),

	  /**
	   * Find 'auto' margin properties.
	   */
	  processMargins: function (cssLogic) {
	    let margins = {};

	    for (let prop of ["top", "bottom", "left", "right"]) {
	      let info = cssLogic.getPropertyInfo("margin-" + prop);
	      let selectors = info.matchedSelectors;
	      if (selectors && selectors.length > 0 && selectors[0].value == "auto") {
	        margins[prop] = "auto";
	      }
	    }

	    return margins;
	  },

	  /**
	   * On page navigation, tidy up remaining objects.
	   */
	  onFrameUnload: function () {
	    this._styleElement = null;
	  },

	  /**
	   * Helper function to addNewRule to construct a new style tag in the document.
	   * @returns DOMElement of the style tag
	   */
	  get styleElement() {
	    if (!this._styleElement) {
	      let document = this.inspector.window.document;
	      let style = document.createElementNS(XHTML_NS, "style");
	      style.setAttribute("type", "text/css");
	      document.documentElement.appendChild(style);
	      this._styleElement = style;
	    }

	    return this._styleElement;
	  },

	  /**
	   * Helper function for adding a new rule and getting its applied style
	   * properties
	   * @param NodeActor node
	   * @param CSSStyleRUle rule
	   * @returns Object containing its applied style properties
	   */
	  getNewAppliedProps: function (node, rule) {
	    let ruleActor = this._styleRef(rule);
	    return this.getAppliedProps(node, [{ rule: ruleActor }], { matchedSelectors: true });
	  },

	  /**
	   * Adds a new rule, and returns the new StyleRuleActor.
	   * @param {NodeActor} node
	   * @param {String} pseudoClasses The list of pseudo classes to append to the
	   *        new selector.
	   * @param {Boolean} editAuthored
	   *        True if the selector should be updated by editing the
	   *        authored text; false if the selector should be updated via
	   *        CSSOM.
	   * @returns {StyleRuleActor} the new rule
	   */
	  addNewRule: method(Task.async(function* (node, pseudoClasses, editAuthored = false) {
	    let style = this.styleElement;
	    let sheet = style.sheet;
	    let cssRules = sheet.cssRules;
	    let rawNode = node.rawNode;

	    let selector;
	    if (rawNode.id) {
	      selector = "#" + CSS.escape(rawNode.id);
	    } else if (rawNode.className) {
	      selector = "." + [...rawNode.classList].map(function (c) {
	        return CSS.escape(c);
	      }).join(".");
	    } else {
	      selector = rawNode.tagName.toLowerCase();
	    }

	    if (pseudoClasses && pseudoClasses.length > 0) {
	      selector += pseudoClasses.join("");
	    }

	    let index = sheet.insertRule(selector + " {}", cssRules.length);

	    // If inserting the rule succeeded, go ahead and edit the source
	    // text if requested.
	    if (editAuthored) {
	      let sheetActor = this._sheetRef(sheet);

	      var _ref = yield sheetActor.getText();

	      let authoredText = _ref.str;

	      authoredText += "\n" + selector + " {\n" + "}";
	      yield sheetActor.update(authoredText, false);
	    }

	    return this.getNewAppliedProps(node, sheet.cssRules.item(index));
	  }), {
	    request: {
	      node: Arg(0, "domnode"),
	      pseudoClasses: Arg(1, "nullable:array:string"),
	      editAuthored: Arg(2, "boolean")
	    },
	    response: RetVal("appliedStylesReturn")
	  })
	});
	exports.PageStyleActor = PageStyleActor;

	/**
	 * Front object for the PageStyleActor
	 */
	var PageStyleFront = protocol.FrontClass(PageStyleActor, {
	  initialize: function (conn, form, ctx, detail) {
	    protocol.Front.prototype.initialize.call(this, conn, form, ctx, detail);
	    this.inspector = this.parent();
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this._form = form;
	  },

	  destroy: function () {
	    protocol.Front.prototype.destroy.call(this);
	  },

	  get walker() {
	    return this.inspector.walker;
	  },

	  get supportsAuthoredStyles() {
	    return this._form.traits && this._form.traits.authoredStyles;
	  },

	  getMatchedSelectors: protocol.custom(function (node, property, options) {
	    return this._getMatchedSelectors(node, property, options).then(function (ret) {
	      return ret.matched;
	    });
	  }, {
	    impl: "_getMatchedSelectors"
	  }),

	  getApplied: protocol.custom(Task.async(function* (node, options = {}) {
	    // If the getApplied method doesn't recreate the style cache itself, this
	    // means a call to cssLogic.highlight is required before trying to access
	    // the applied rules. Issue a request to getLayout if this is the case.
	    // See https://bugzilla.mozilla.org/show_bug.cgi?id=1103993#c16.
	    if (!this._form.traits || !this._form.traits.getAppliedCreatesStyleCache) {
	      yield this.getLayout(node);
	    }
	    let ret = yield this._getApplied(node, options);
	    return ret.entries;
	  }), {
	    impl: "_getApplied"
	  }),

	  addNewRule: protocol.custom(function (node, pseudoClasses) {
	    let addPromise;
	    if (this.supportsAuthoredStyles) {
	      addPromise = this._addNewRule(node, pseudoClasses, true);
	    } else {
	      addPromise = this._addNewRule(node, pseudoClasses);
	    }
	    return addPromise.then(function (ret) {
	      return ret.entries[0];
	    });
	  }, {
	    impl: "_addNewRule"
	  })
	});

	/**
	 * An actor that represents a CSS style object on the protocol.
	 *
	 * We slightly flatten the CSSOM for this actor, it represents
	 * both the CSSRule and CSSStyle objects in one actor.  For nodes
	 * (which have a CSSStyle but no CSSRule) we create a StyleRuleActor
	 * with a special rule type (100).
	 */
	var StyleRuleActor = protocol.ActorClass({
	  typeName: "domstylerule",

	  events: {
	    "location-changed": {
	      type: "locationChanged",
	      line: Arg(0, "number"),
	      column: Arg(1, "number")
	    }
	  },

	  initialize: function (pageStyle, item) {
	    protocol.Actor.prototype.initialize.call(this, null);
	    this.pageStyle = pageStyle;
	    this.rawStyle = item.style;
	    this._parentSheet = null;
	    this._onStyleApplied = this._onStyleApplied.bind(this);

	    if (item instanceof Ci.nsIDOMCSSRule) {
	      this.type = item.type;
	      this.rawRule = item;
	      if ((this.type === Ci.nsIDOMCSSRule.STYLE_RULE || this.type === Ci.nsIDOMCSSRule.KEYFRAME_RULE) && this.rawRule.parentStyleSheet) {
	        this.line = DOMUtils.getRelativeRuleLine(this.rawRule);
	        this.column = DOMUtils.getRuleColumn(this.rawRule);
	        this._parentSheet = this.rawRule.parentStyleSheet;
	        this._computeRuleIndex();
	        this.sheetActor = this.pageStyle._sheetRef(this._parentSheet);
	        this.sheetActor.on("style-applied", this._onStyleApplied);
	      }
	    } else {
	      // Fake a rule
	      this.type = ELEMENT_STYLE;
	      this.rawNode = item;
	      this.rawRule = {
	        style: item.style,
	        toString: function () {
	          return "[element rule " + this.style + "]";
	        }
	      };
	    }
	  },

	  get conn() {
	    return this.pageStyle.conn;
	  },

	  destroy: function () {
	    if (!this.rawStyle) {
	      return;
	    }
	    protocol.Actor.prototype.destroy.call(this);
	    this.rawStyle = null;
	    this.pageStyle = null;
	    this.rawNode = null;
	    this.rawRule = null;
	    if (this.sheetActor) {
	      this.sheetActor.off("style-applied", this._onStyleApplied);
	    }
	  },

	  // Objects returned by this actor are owned by the PageStyleActor
	  // to which this rule belongs.
	  get marshallPool() {
	    return this.pageStyle;
	  },

	  // True if this rule supports as-authored styles, meaning that the
	  // rule text can be rewritten using setRuleText.
	  get canSetRuleText() {
	    // Special case about:PreferenceStyleSheet, as it is
	    // generated on the fly and the URI is not registered with the
	    // about: handler.
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=935803#c37
	    return !!(this._parentSheet && this._parentSheet.href !== "about:PreferenceStyleSheet");
	  },

	  getDocument: function (sheet) {
	    let document;

	    if (sheet.ownerNode instanceof Ci.nsIDOMHTMLDocument) {
	      document = sheet.ownerNode;
	    } else {
	      document = sheet.ownerNode.ownerDocument;
	    }

	    return document;
	  },

	  toString: function () {
	    return "[StyleRuleActor for " + this.rawRule + "]";
	  },

	  form: function (detail) {
	    if (detail === "actorid") {
	      return this.actorID;
	    }

	    let form = {
	      actor: this.actorID,
	      type: this.type,
	      line: this.line || undefined,
	      column: this.column,
	      traits: {
	        // Whether the style rule actor implements the modifySelector2 method
	        // that allows for unmatched rule to be added
	        modifySelectorUnmatched: true,
	        // Whether the style rule actor implements the setRuleText
	        // method.
	        canSetRuleText: this.canSetRuleText
	      }
	    };

	    if (this.rawRule.parentRule) {
	      form.parentRule = this.pageStyle._styleRef(this.rawRule.parentRule).actorID;

	      // CSS rules that we call media rules are STYLE_RULES that are children
	      // of MEDIA_RULEs. We need to check the parentRule to check if a rule is
	      // a media rule so we do this here instead of in the switch statement
	      // below.
	      if (this.rawRule.parentRule.type === Ci.nsIDOMCSSRule.MEDIA_RULE) {
	        form.media = [];
	        for (let i = 0, n = this.rawRule.parentRule.media.length; i < n; i++) {
	          form.media.push(this.rawRule.parentRule.media.item(i));
	        }
	      }
	    }
	    if (this._parentSheet) {
	      form.parentStyleSheet = this.pageStyle._sheetRef(this._parentSheet).actorID;
	    }

	    // One tricky thing here is that other methods in this actor must
	    // ensure that authoredText has been set before |form| is called.
	    // This has to be treated specially, for now, because we cannot
	    // synchronously compute the authored text, but |form| also cannot
	    // return a promise.  See bug 1205868.
	    form.authoredText = this.authoredText;

	    switch (this.type) {
	      case Ci.nsIDOMCSSRule.STYLE_RULE:
	        form.selectors = CssLogic.getSelectors(this.rawRule);
	        form.cssText = this.rawStyle.cssText || "";
	        break;
	      case ELEMENT_STYLE:
	        // Elements don't have a parent stylesheet, and therefore
	        // don't have an associated URI.  Provide a URI for
	        // those.
	        let doc = this.rawNode.ownerDocument;
	        form.href = doc.location ? doc.location.href : "";
	        form.cssText = this.rawStyle.cssText || "";
	        break;
	      case Ci.nsIDOMCSSRule.CHARSET_RULE:
	        form.encoding = this.rawRule.encoding;
	        break;
	      case Ci.nsIDOMCSSRule.IMPORT_RULE:
	        form.href = this.rawRule.href;
	        break;
	      case Ci.nsIDOMCSSRule.KEYFRAMES_RULE:
	        form.cssText = this.rawRule.cssText;
	        form.name = this.rawRule.name;
	        break;
	      case Ci.nsIDOMCSSRule.KEYFRAME_RULE:
	        form.cssText = this.rawStyle.cssText || "";
	        form.keyText = this.rawRule.keyText || "";
	        break;
	    }

	    return form;
	  },

	  /**
	   * Send an event notifying that the location of the rule has
	   * changed.
	   *
	   * @param {Number} line the new line number
	   * @param {Number} column the new column number
	   */
	  _notifyLocationChanged: function (line, column) {
	    events.emit(this, "location-changed", line, column);
	  },

	  /**
	   * Compute the index of this actor's raw rule in its parent style
	   * sheet.  The index is a vector where each element is the index of
	   * a given CSS rule in its parent.  A vector is used to support
	   * nested rules.
	   */
	  _computeRuleIndex: function () {
	    let rule = this.rawRule;
	    let result = [];

	    while (rule) {
	      let cssRules;
	      if (rule.parentRule) {
	        cssRules = rule.parentRule.cssRules;
	      } else {
	        cssRules = rule.parentStyleSheet.cssRules;
	      }

	      let found = false;
	      for (let i = 0; i < cssRules.length; i++) {
	        if (rule === cssRules.item(i)) {
	          found = true;
	          result.unshift(i);
	          break;
	        }
	      }

	      if (!found) {
	        this._ruleIndex = null;
	        return;
	      }

	      rule = rule.parentRule;
	    }

	    this._ruleIndex = result;
	  },

	  /**
	   * Get the rule corresponding to |this._ruleIndex| from the given
	   * style sheet.
	   *
	   * @param  {DOMStyleSheet} sheet
	   *         The style sheet.
	   * @return {CSSStyleRule} the rule corresponding to
	   * |this._ruleIndex|
	   */
	  _getRuleFromIndex: function (parentSheet) {
	    let currentRule = null;
	    for (let i of this._ruleIndex) {
	      if (currentRule === null) {
	        currentRule = parentSheet.cssRules[i];
	      } else {
	        currentRule = currentRule.cssRules.item(i);
	      }
	    }
	    return currentRule;
	  },

	  /**
	   * This is attached to the parent style sheet actor's
	   * "style-applied" event.
	   */
	  _onStyleApplied: function (kind) {
	    if (kind === UPDATE_GENERAL) {
	      // A general change means that the rule actors are invalidated,
	      // so stop listening to events now.
	      if (this.sheetActor) {
	        this.sheetActor.off("style-applied", this._onStyleApplied);
	      }
	    } else if (this._ruleIndex) {
	      // The sheet was updated by this actor, in a way that preserves
	      // the rules.  Now, recompute our new rule from the style sheet,
	      // so that we aren't left with a reference to a dangling rule.
	      let oldRule = this.rawRule;
	      this.rawRule = this._getRuleFromIndex(this._parentSheet);
	      // Also tell the page style so that future calls to _styleRef
	      // return the same StyleRuleActor.
	      this.pageStyle.updateStyleRef(oldRule, this.rawRule, this);
	      let line = DOMUtils.getRelativeRuleLine(this.rawRule);
	      let column = DOMUtils.getRuleColumn(this.rawRule);
	      if (line !== this.line || column !== this.column) {
	        this._notifyLocationChanged(line, column);
	      }
	      this.line = line;
	      this.column = column;
	    }
	  },

	  /**
	   * Return a promise that resolves to the authored form of a rule's
	   * text, if available.  If the authored form is not available, the
	   * returned promise simply resolves to the empty string.  If the
	   * authored form is available, this also sets |this.authoredText|.
	   * The authored text will include invalid and otherwise ignored
	   * properties.
	   */
	  getAuthoredCssText: function () {
	    var _this = this;

	    if (!this.canSetRuleText || this.type !== Ci.nsIDOMCSSRule.STYLE_RULE && this.type !== Ci.nsIDOMCSSRule.KEYFRAME_RULE) {
	      return promise.resolve("");
	    }

	    if (typeof this.authoredText === "string") {
	      return promise.resolve(this.authoredText);
	    }

	    let parentStyleSheet = this.pageStyle._sheetRef(this._parentSheet);
	    return parentStyleSheet.getText().then(function (longStr) {
	      let cssText = longStr.str;

	      var _getRuleText = getRuleText(cssText, _this.line, _this.column);

	      let text = _getRuleText.text;

	      // Cache the result on the rule actor to avoid parsing again next time

	      _this.authoredText = text;
	      return _this.authoredText;
	    });
	  },

	  /**
	   * Set the contents of the rule.  This rewrites the rule in the
	   * stylesheet and causes it to be re-evaluated.
	   *
	   * @param {String} newText the new text of the rule
	   * @returns the rule with updated properties
	   */
	  setRuleText: method(Task.async(function* (newText) {
	    if (!this.canSetRuleText || this.type !== Ci.nsIDOMCSSRule.STYLE_RULE && this.type !== Ci.nsIDOMCSSRule.KEYFRAME_RULE) {
	      throw new Error("invalid call to setRuleText");
	    }

	    let parentStyleSheet = this.pageStyle._sheetRef(this._parentSheet);

	    var _ref2 = yield parentStyleSheet.getText();

	    let cssText = _ref2.str;

	    var _getRuleText2 = getRuleText(cssText, this.line, this.column);

	    let offset = _getRuleText2.offset;
	    let text = _getRuleText2.text;

	    cssText = cssText.substring(0, offset) + newText + cssText.substring(offset + text.length);

	    this.authoredText = newText;
	    yield parentStyleSheet.update(cssText, false, UPDATE_PRESERVING_RULES);

	    return this;
	  }), {
	    request: { modification: Arg(0, "string") },
	    response: { rule: RetVal("domstylerule") }
	  }),

	  /**
	   * Modify a rule's properties. Passed an array of modifications:
	   * {
	   *   type: "set",
	   *   name: <string>,
	   *   value: <string>,
	   *   priority: <optional string>
	   * }
	   *  or
	   * {
	   *   type: "remove",
	   *   name: <string>,
	   * }
	   *
	   * @returns the rule with updated properties
	   */
	  modifyProperties: method(function (modifications) {
	    // Use a fresh element for each call to this function to prevent side
	    // effects that pop up based on property values that were already set on the
	    // element.

	    let document;
	    if (this.rawNode) {
	      document = this.rawNode.ownerDocument;
	    } else {
	      let parentStyleSheet = this._parentSheet;
	      while (parentStyleSheet.ownerRule && parentStyleSheet.ownerRule instanceof Ci.nsIDOMCSSImportRule) {
	        parentStyleSheet = parentStyleSheet.ownerRule.parentStyleSheet;
	      }

	      document = this.getDocument(parentStyleSheet);
	    }

	    let tempElement = document.createElementNS(XHTML_NS, "div");

	    for (let mod of modifications) {
	      if (mod.type === "set") {
	        tempElement.style.setProperty(mod.name, mod.value, mod.priority || "");
	        this.rawStyle.setProperty(mod.name, tempElement.style.getPropertyValue(mod.name), mod.priority || "");
	      } else if (mod.type === "remove") {
	        this.rawStyle.removeProperty(mod.name);
	      }
	    }

	    return this;
	  }, {
	    request: { modifications: Arg(0, "array:json") },
	    response: { rule: RetVal("domstylerule") }
	  }),

	  /**
	   * Helper function for modifySelector and modifySelector2, inserts the new
	   * rule with the new selector into the parent style sheet and removes the
	   * current rule. Returns the newly inserted css rule or null if the rule is
	   * unsuccessfully inserted to the parent style sheet.
	   *
	   * @param {String} value
	   *        The new selector value
	   * @param {Boolean} editAuthored
	   *        True if the selector should be updated by editing the
	   *        authored text; false if the selector should be updated via
	   *        CSSOM.
	   *
	   * @returns {CSSRule}
	   *        The new CSS rule added
	   */
	  _addNewSelector: Task.async(function* (value, editAuthored) {
	    let rule = this.rawRule;
	    let parentStyleSheet = this._parentSheet;

	    // We know the selector modification is ok, so if the client asked
	    // for the authored text to be edited, do it now.
	    if (editAuthored) {
	      let document = this.getDocument(this._parentSheet);
	      try {
	        document.querySelector(value);
	      } catch (e) {
	        return null;
	      }

	      let sheetActor = this.pageStyle._sheetRef(parentStyleSheet);

	      var _ref3 = yield sheetActor.getText();

	      let authoredText = _ref3.str;

	      var _getSelectorOffsets = getSelectorOffsets(authoredText, this.line, this.column);

	      var _getSelectorOffsets2 = _slicedToArray(_getSelectorOffsets, 2);

	      let startOffset = _getSelectorOffsets2[0];
	      let endOffset = _getSelectorOffsets2[1];

	      authoredText = authoredText.substring(0, startOffset) + value + authoredText.substring(endOffset);
	      yield sheetActor.update(authoredText, false, UPDATE_PRESERVING_RULES);
	    } else {
	      let cssRules = parentStyleSheet.cssRules;
	      let cssText = rule.cssText;
	      let selectorText = rule.selectorText;

	      for (let i = 0; i < cssRules.length; i++) {
	        if (rule === cssRules.item(i)) {
	          try {
	            // Inserts the new style rule into the current style sheet and
	            // delete the current rule
	            let ruleText = cssText.slice(selectorText.length).trim();
	            parentStyleSheet.insertRule(value + " " + ruleText, i);
	            parentStyleSheet.deleteRule(i + 1);
	            break;
	          } catch (e) {
	            // The selector could be invalid, or the rule could fail to insert.
	            return null;
	          }
	        }
	      }
	    }

	    return this._getRuleFromIndex(parentStyleSheet);
	  }),

	  /**
	   * Modify the current rule's selector by inserting a new rule with the new
	   * selector value and removing the current rule.
	   *
	   * Note this method was kept for backward compatibility, but unmatched rules
	   * support was added in FF41.
	   *
	   * @param string value
	   *        The new selector value
	   * @returns boolean
	   *        Returns a boolean if the selector in the stylesheet was modified,
	   *        and false otherwise
	   */
	  modifySelector: method(Task.async(function* (value) {
	    if (this.type === ELEMENT_STYLE) {
	      return false;
	    }

	    let document = this.getDocument(this._parentSheet);
	    // Extract the selector, and pseudo elements and classes

	    var _value$split = value.split(/(:{1,2}.+$)/);

	    var _value$split2 = _slicedToArray(_value$split, 2);

	    let selector = _value$split2[0];
	    let pseudoProp = _value$split2[1];

	    let selectorElement;

	    try {
	      selectorElement = document.querySelector(selector);
	    } catch (e) {
	      return false;
	    }

	    // Check if the selector is valid and not the same as the original
	    // selector
	    if (selectorElement && this.rawRule.selectorText !== value) {
	      yield this._addNewSelector(value, false);
	      return true;
	    }
	    return false;
	  }), {
	    request: { selector: Arg(0, "string") },
	    response: { isModified: RetVal("boolean") }
	  }),

	  /**
	   * Modify the current rule's selector by inserting a new rule with the new
	   * selector value and removing the current rule.
	   *
	   * In contrast with the modifySelector method which was used before FF41,
	   * this method also returns information about the new rule and applied style
	   * so that consumers can immediately display the new rule, whether or not the
	   * selector matches the current element without having to refresh the whole
	   * list.
	   *
	   * @param {DOMNode} node
	   *        The current selected element
	   * @param {String} value
	   *        The new selector value
	   * @param {Boolean} editAuthored
	   *        True if the selector should be updated by editing the
	   *        authored text; false if the selector should be updated via
	   *        CSSOM.
	   * @returns {Object}
	   *        Returns an object that contains the applied style properties of the
	   *        new rule and a boolean indicating whether or not the new selector
	   *        matches the current selected element
	   */
	  modifySelector2: method(function (node, value, editAuthored = false) {
	    var _this2 = this;

	    let ruleProps = null;

	    if (this.type === ELEMENT_STYLE || this.rawRule.selectorText === value) {
	      return { ruleProps, isMatching: true };
	    }

	    let selectorPromise = this._addNewSelector(value, editAuthored);

	    if (editAuthored) {
	      selectorPromise = selectorPromise.then(function (newCssRule) {
	        if (newCssRule) {
	          let style = _this2.pageStyle._styleRef(newCssRule);
	          // See the comment in |form| to understand this.
	          return style.getAuthoredCssText().then(function () {
	            return newCssRule;
	          });
	        }
	        return newCssRule;
	      });
	    }

	    return selectorPromise.then(function (newCssRule) {
	      if (newCssRule) {
	        ruleProps = _this2.pageStyle.getNewAppliedProps(node, newCssRule);
	      }

	      // Determine if the new selector value matches the current
	      // selected element
	      let isMatching = false;
	      try {
	        isMatching = node.rawNode.matches(value);
	      } catch (e) {
	        // This fails when value is an invalid selector.
	      }

	      return { ruleProps, isMatching };
	    });
	  }, {
	    request: {
	      node: Arg(0, "domnode"),
	      value: Arg(1, "string"),
	      editAuthored: Arg(2, "boolean")
	    },
	    response: RetVal("modifiedStylesReturn")
	  })
	});

	/**
	 * Front for the StyleRule actor.
	 */
	var StyleRuleFront = protocol.FrontClass(StyleRuleActor, {
	  initialize: function (client, form, ctx, detail) {
	    protocol.Front.prototype.initialize.call(this, client, form, ctx, detail);
	  },

	  destroy: function () {
	    protocol.Front.prototype.destroy.call(this);
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	    if (this._mediaText) {
	      this._mediaText = null;
	    }
	  },

	  /**
	   * Ensure _form is updated when location-changed is emitted.
	   */
	  _locationChangedPre: protocol.preEvent("location-changed", function (line, column) {
	    this._clearOriginalLocation();
	    this._form.line = line;
	    this._form.column = column;
	  }),

	  /**
	   * Return a new RuleModificationList or RuleRewriter for this node.
	   * A RuleRewriter will be returned when the rule's canSetRuleText
	   * trait is true; otherwise a RuleModificationList will be
	   * returned.
	   */
	  startModifyingProperties: function () {
	    if (this.canSetRuleText) {
	      return new RuleRewriter(this, this.authoredText);
	    }
	    return new RuleModificationList(this);
	  },

	  get type() {
	    return this._form.type;
	  },
	  get line() {
	    return this._form.line || -1;
	  },
	  get column() {
	    return this._form.column || -1;
	  },
	  get cssText() {
	    return this._form.cssText;
	  },
	  get authoredText() {
	    return this._form.authoredText || this._form.cssText;
	  },
	  get keyText() {
	    return this._form.keyText;
	  },
	  get name() {
	    return this._form.name;
	  },
	  get selectors() {
	    return this._form.selectors;
	  },
	  get media() {
	    return this._form.media;
	  },
	  get mediaText() {
	    if (!this._form.media) {
	      return null;
	    }
	    if (this._mediaText) {
	      return this._mediaText;
	    }
	    this._mediaText = this.media.join(", ");
	    return this._mediaText;
	  },

	  get parentRule() {
	    return this.conn.getActor(this._form.parentRule);
	  },

	  get parentStyleSheet() {
	    return this.conn.getActor(this._form.parentStyleSheet);
	  },

	  get element() {
	    return this.conn.getActor(this._form.element);
	  },

	  get href() {
	    if (this._form.href) {
	      return this._form.href;
	    }
	    let sheet = this.parentStyleSheet;
	    return sheet ? sheet.href : "";
	  },

	  get nodeHref() {
	    let sheet = this.parentStyleSheet;
	    return sheet ? sheet.nodeHref : "";
	  },

	  get supportsModifySelectorUnmatched() {
	    return this._form.traits && this._form.traits.modifySelectorUnmatched;
	  },

	  get canSetRuleText() {
	    return this._form.traits && this._form.traits.canSetRuleText;
	  },

	  get location() {
	    return {
	      source: this.parentStyleSheet,
	      href: this.href,
	      line: this.line,
	      column: this.column
	    };
	  },

	  _clearOriginalLocation: function () {
	    this._originalLocation = null;
	  },

	  getOriginalLocation: function () {
	    var _this3 = this;

	    if (this._originalLocation) {
	      return promise.resolve(this._originalLocation);
	    }
	    let parentSheet = this.parentStyleSheet;
	    if (!parentSheet) {
	      // This rule doesn't belong to a stylesheet so it is an inline style.
	      // Inline styles do not have any mediaText so we can return early.
	      return promise.resolve(this.location);
	    }
	    return parentSheet.getOriginalLocation(this.line, this.column).then(function ({ fromSourceMap, source, line, column }) {
	      let location = {
	        href: source,
	        line: line,
	        column: column,
	        mediaText: _this3.mediaText
	      };
	      if (fromSourceMap === false) {
	        location.source = _this3.parentStyleSheet;
	      }
	      if (!source) {
	        location.href = _this3.href;
	      }
	      _this3._originalLocation = location;
	      return location;
	    });
	  },

	  modifySelector: protocol.custom(Task.async(function* (node, value) {
	    let response;
	    if (this.supportsModifySelectorUnmatched) {
	      // If the debugee supports adding unmatched rules (post FF41)
	      if (this.canSetRuleText) {
	        response = yield this.modifySelector2(node, value, true);
	      } else {
	        response = yield this.modifySelector2(node, value);
	      }
	    } else {
	      response = yield this._modifySelector(value);
	    }

	    if (response.ruleProps) {
	      response.ruleProps = response.ruleProps.entries[0];
	    }
	    return response;
	  }), {
	    impl: "_modifySelector"
	  }),

	  setRuleText: protocol.custom(function (newText) {
	    this._form.authoredText = newText;
	    return this._setRuleText(newText);
	  }, {
	    impl: "_setRuleText"
	  })
	});

	/**
	 * Convenience API for building a list of attribute modifications
	 * for the `modifyProperties` request.  A RuleModificationList holds a
	 * list of modifications that will be applied to a StyleRuleActor.
	 * The modifications are processed in the order in which they are
	 * added to the RuleModificationList.
	 *
	 * Objects of this type expose the same API as @see RuleRewriter.
	 * This lets the inspector use (mostly) the same code, regardless of
	 * whether the server implements setRuleText.
	 */
	var RuleModificationList = Class({
	  /**
	   * Initialize a RuleModificationList.
	   * @param {StyleRuleFront} rule the associated rule
	   */
	  initialize: function (rule) {
	    this.rule = rule;
	    this.modifications = [];
	  },

	  /**
	   * Apply the modifications in this object to the associated rule.
	   *
	   * @return {Promise} A promise which will be resolved when the modifications
	   *         are complete; @see StyleRuleActor.modifyProperties.
	   */
	  apply: function () {
	    return this.rule.modifyProperties(this.modifications);
	  },

	  /**
	   * Add a "set" entry to the modification list.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name the property's name
	   * @param {String} value the property's value
	   * @param {String} priority the property's priority, either the empty
	   *                          string or "important"
	   */
	  setProperty: function (index, name, value, priority) {
	    this.modifications.push({
	      type: "set",
	      name: name,
	      value: value,
	      priority: priority
	    });
	  },

	  /**
	   * Add a "remove" entry to the modification list.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name the name of the property to remove
	   */
	  removeProperty: function (index, name) {
	    this.modifications.push({
	      type: "remove",
	      name: name
	    });
	  },

	  /**
	   * Rename a property.  This implementation acts like
	   * |removeProperty|, because |setRuleText| is not available.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name current name of the property
	   * @param {String} newName new name of the property
	   */
	  renameProperty: function (index, name, newName) {
	    this.removeProperty(index, name);
	  },

	  /**
	   * Enable or disable a property.  This implementation acts like
	   * |removeProperty| when disabling, or a no-op when enabling,
	   * because |setRuleText| is not available.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name current name of the property
	   * @param {Boolean} isEnabled true if the property should be enabled;
	   *                        false if it should be disabled
	   */
	  setPropertyEnabled: function (index, name, isEnabled) {
	    if (!isEnabled) {
	      this.removeProperty(index, name);
	    }
	  },

	  /**
	   * Create a new property.  This implementation does nothing, because
	   * |setRuleText| is not available.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name name of the new property
	   * @param {String} value value of the new property
	   * @param {String} priority priority of the new property; either
	   *                          the empty string or "important"
	   */
	  createProperty: function (index, name, value, priority) {
	    // Nothing.
	  }
	});

	/**
	 * Helper function for getting an image preview of the given font.
	 *
	 * @param font {string}
	 *        Name of font to preview
	 * @param doc {Document}
	 *        Document to use to render font
	 * @param options {object}
	 *        Object with options 'previewText' and 'previewFontSize'
	 *
	 * @return dataUrl
	 *         The data URI of the font preview image
	 */
	function getFontPreviewData(font, doc, options) {
	  options = options || {};
	  let previewText = options.previewText || FONT_PREVIEW_TEXT;
	  let previewFontSize = options.previewFontSize || FONT_PREVIEW_FONT_SIZE;
	  let fillStyle = options.fillStyle || FONT_PREVIEW_FILLSTYLE;
	  let fontStyle = options.fontStyle || "";

	  let canvas = doc.createElementNS(XHTML_NS, "canvas");
	  let ctx = canvas.getContext("2d");
	  let fontValue = fontStyle + " " + previewFontSize + "px " + font + ", serif";

	  // Get the correct preview text measurements and set the canvas dimensions
	  ctx.font = fontValue;
	  ctx.fillStyle = fillStyle;
	  let textWidth = ctx.measureText(previewText).width;

	  canvas.width = textWidth * 2 + FONT_PREVIEW_OFFSET * 2;
	  canvas.height = previewFontSize * 3;

	  // we have to reset these after changing the canvas size
	  ctx.font = fontValue;
	  ctx.fillStyle = fillStyle;

	  // Oversample the canvas for better text quality
	  ctx.textBaseline = "top";
	  ctx.scale(2, 2);
	  ctx.fillText(previewText, FONT_PREVIEW_OFFSET, Math.round(previewFontSize / 3));

	  let dataURL = canvas.toDataURL("image/png");

	  return {
	    dataURL: dataURL,
	    size: textWidth + FONT_PREVIEW_OFFSET * 2
	  };
	}

	exports.getFontPreviewData = getFontPreviewData;

	/**
	 * Get the text content of a rule given some CSS text, a line and a column
	 * Consider the following example:
	 * body {
	 *  color: red;
	 * }
	 * p {
	 *  line-height: 2em;
	 *  color: blue;
	 * }
	 * Calling the function with the whole text above and line=4 and column=1 would
	 * return "line-height: 2em; color: blue;"
	 * @param {String} initialText
	 * @param {Number} line (1-indexed)
	 * @param {Number} column (1-indexed)
	 * @return {object} An object of the form {offset: number, text: string}
	 *                  The offset is the index into the input string where
	 *                  the rule text started.  The text is the content of
	 *                  the rule.
	 */
	function getRuleText(initialText, line, column) {
	  if (typeof line === "undefined" || typeof column === "undefined") {
	    throw new Error("Location information is missing");
	  }

	  var _getTextAtLineColumn = getTextAtLineColumn(initialText, line, column);

	  let textOffset = _getTextAtLineColumn.offset;
	  let text = _getTextAtLineColumn.text;

	  let lexer = DOMUtils.getCSSLexer(text);

	  // Search forward for the opening brace.
	  while (true) {
	    let token = lexer.nextToken();
	    if (!token) {
	      throw new Error("couldn't find start of the rule");
	    }
	    if (token.tokenType === "symbol" && token.text === "{") {
	      break;
	    }
	  }

	  // Now collect text until we see the matching close brace.
	  let braceDepth = 1;
	  let startOffset, endOffset;
	  while (true) {
	    let token = lexer.nextToken();
	    if (!token) {
	      break;
	    }
	    if (startOffset === undefined) {
	      startOffset = token.startOffset;
	    }
	    if (token.tokenType === "symbol") {
	      if (token.text === "{") {
	        ++braceDepth;
	      } else if (token.text === "}") {
	        --braceDepth;
	        if (braceDepth == 0) {
	          break;
	        }
	      }
	    }
	    endOffset = token.endOffset;
	  }

	  // If the rule was of the form "selector {" with no closing brace
	  // and no properties, just return an empty string.
	  if (startOffset === undefined) {
	    return { offset: 0, text: "" };
	  }
	  // If the input didn't have any tokens between the braces (e.g.,
	  // "div {}"), then the endOffset won't have been set yet; so account
	  // for that here.
	  if (endOffset === undefined) {
	    endOffset = startOffset;
	  }

	  // Note that this approach will preserve comments, despite the fact
	  // that cssTokenizer skips them.
	  return { offset: textOffset + startOffset,
	    text: text.substring(startOffset, endOffset) };
	}

	exports.getRuleText = getRuleText;

	/**
	 * Compute the start and end offsets of a rule's selector text, given
	 * the CSS text and the line and column at which the rule begins.
	 * @param {String} initialText
	 * @param {Number} line (1-indexed)
	 * @param {Number} column (1-indexed)
	 * @return {array} An array with two elements: [startOffset, endOffset].
	 *                 The elements mark the bounds in |initialText| of
	 *                 the CSS rule's selector.
	 */
	function getSelectorOffsets(initialText, line, column) {
	  if (typeof line === "undefined" || typeof column === "undefined") {
	    throw new Error("Location information is missing");
	  }

	  var _getTextAtLineColumn2 = getTextAtLineColumn(initialText, line, column);

	  let textOffset = _getTextAtLineColumn2.offset;
	  let text = _getTextAtLineColumn2.text;

	  let lexer = DOMUtils.getCSSLexer(text);

	  // Search forward for the opening brace.
	  let endOffset;
	  while (true) {
	    let token = lexer.nextToken();
	    if (!token) {
	      break;
	    }
	    if (token.tokenType === "symbol" && token.text === "{") {
	      if (endOffset === undefined) {
	        break;
	      }
	      return [textOffset, textOffset + endOffset];
	    }
	    // Preserve comments and whitespace just before the "{".
	    if (token.tokenType !== "comment" && token.tokenType !== "whitespace") {
	      endOffset = token.endOffset;
	    }
	  }

	  throw new Error("could not find bounds of rule");
	}

	/**
	 * Return the offset and substring of |text| that starts at the given
	 * line and column.
	 * @param {String} text
	 * @param {Number} line (1-indexed)
	 * @param {Number} column (1-indexed)
	 * @return {object} An object of the form {offset: number, text: string},
	 *                  where the offset is the offset into the input string
	 *                  where the text starts, and where text is the text.
	 */
	function getTextAtLineColumn(text, line, column) {
	  let offset;
	  if (line > 1) {
	    let rx = new RegExp("(?:.*(?:\\r\\n|\\n|\\r|\\f)){" + (line - 1) + "}");
	    offset = rx.exec(text)[0].length;
	  } else {
	    offset = 0;
	  }
	  offset += column - 1;
	  return { offset: offset, text: text.substr(offset) };
	}

	exports.getTextAtLineColumn = getTextAtLineColumn;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/*
	 * About the objects defined in this file:
	 * - CssLogic contains style information about a view context. It provides
	 *   access to 2 sets of objects: Css[Sheet|Rule|Selector] provide access to
	 *   information that does not change when the selected element changes while
	 *   Css[Property|Selector]Info provide information that is dependent on the
	 *   selected element.
	 *   Its key methods are highlight(), getPropertyInfo() and forEachSheet(), etc
	 *   It also contains a number of static methods for l10n, naming, etc
	 *
	 * - CssSheet provides a more useful API to a DOM CSSSheet for our purposes,
	 *   including shortSource and href.
	 * - CssRule a more useful API to a nsIDOMCSSRule including access to the group
	 *   of CssSelectors that the rule provides properties for
	 * - CssSelector A single selector - i.e. not a selector group. In other words
	 *   a CssSelector does not contain ','. This terminology is different from the
	 *   standard DOM API, but more inline with the definition in the spec.
	 *
	 * - CssPropertyInfo contains style information for a single property for the
	 *   highlighted element.
	 * - CssSelectorInfo is a wrapper around CssSelector, which adds sorting with
	 *   reference to the selected element.
	 */

	/**
	 * Provide access to the style information in a page.
	 * CssLogic uses the standard DOM API, and the Gecko inIDOMUtils API to access
	 * styling information in the page, and present this to the user in a way that
	 * helps them understand:
	 * - why their expectations may not have been fulfilled
	 * - how browsers process CSS
	 * @constructor
	 */

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	var _require2 = __webpack_require__(9);

	const Services = _require2.Services;

	const DevToolsUtils = __webpack_require__(19);

	var _require3 = __webpack_require__(73);

	const getRootBindingParent = _require3.getRootBindingParent;

	var pseudos = new Set([":after", ":before", ":first-letter", ":first-line", ":selection", ":-moz-color-swatch", ":-moz-focus-inner", ":-moz-focus-outer", ":-moz-list-bullet", ":-moz-list-number", ":-moz-math-anonymous", ":-moz-math-stretchy", ":-moz-meter-bar", ":-moz-number-spin-box", ":-moz-number-spin-down", ":-moz-number-spin-up", ":-moz-number-text", ":-moz-number-wrapper", ":-moz-placeholder", ":-moz-progress-bar", ":-moz-range-progress", ":-moz-range-thumb", ":-moz-range-track", ":-moz-selection"]);

	const PSEUDO_ELEMENT_SET = pseudos;
	exports.PSEUDO_ELEMENT_SET = PSEUDO_ELEMENT_SET;

	// This should be ok because none of the functions that use this should be used
	// on the worker thread, where Cu is not available.
	/*const CSS = require("CSS");*/

	function CssLogic() {
	  // The cache of examined CSS properties.
	  _propertyInfos: {};
	}

	exports.CssLogic = CssLogic;

	/**
	 * Special values for filter, in addition to an href these values can be used
	 */
	CssLogic.FILTER = {
	  USER: "user", // show properties for all user style sheets.
	  UA: "ua" };

	/**
	 * Known media values. To distinguish "all" stylesheets (above) from "all" media
	 * The full list includes braille, embossed, handheld, print, projection,
	 * speech, tty, and tv, but this is only a hack because these are not defined
	 * in the DOM at all.
	 * @see http://www.w3.org/TR/CSS21/media.html#media-types
	 */
	// USER, plus user-agent (i.e. browser) style sheets
	CssLogic.MEDIA = {
	  ALL: "all",
	  SCREEN: "screen"
	};

	/**
	 * Each rule has a status, the bigger the number, the better placed it is to
	 * provide styling information.
	 *
	 * These statuses are localized inside the styleinspector.properties string bundle.
	 * @see csshtmltree.js RuleView._cacheStatusNames()
	 */
	CssLogic.STATUS = {
	  BEST: 3,
	  MATCHED: 2,
	  PARENT_MATCH: 1,
	  UNMATCHED: 0,
	  UNKNOWN: -1
	};

	CssLogic.prototype = {
	  // Both setup by highlight().
	  viewedElement: null,
	  viewedDocument: null,

	  // The cache of the known sheets.
	  _sheets: null,

	  // Have the sheets been cached?
	  _sheetsCached: false,

	  // The total number of rules, in all stylesheets, after filtering.
	  _ruleCount: 0,

	  // The computed styles for the viewedElement.
	  _computedStyle: null,

	  // Source filter. Only display properties coming from the given source
	  _sourceFilter: CssLogic.FILTER.USER,

	  // Used for tracking unique CssSheet/CssRule/CssSelector objects, in a run of
	  // processMatchedSelectors().
	  _passId: 0,

	  // Used for tracking matched CssSelector objects.
	  _matchId: 0,

	  _matchedRules: null,
	  _matchedSelectors: null,

	  // Cached keyframes rules in all stylesheets
	  _keyframesRules: null,

	  /**
	   * Reset various properties
	   */
	  reset: function CssLogic_reset() {
	    this._propertyInfos = {};
	    this._ruleCount = 0;
	    this._sheetIndex = 0;
	    this._sheets = {};
	    this._sheetsCached = false;
	    this._matchedRules = null;
	    this._matchedSelectors = null;
	    this._keyframesRules = [];
	  },

	  /**
	   * Focus on a new element - remove the style caches.
	   *
	   * @param {nsIDOMElement} aViewedElement the element the user has highlighted
	   * in the Inspector.
	   */
	  highlight: function CssLogic_highlight(aViewedElement) {
	    if (!aViewedElement) {
	      this.viewedElement = null;
	      this.viewedDocument = null;
	      this._computedStyle = null;
	      this.reset();
	      return;
	    }

	    if (aViewedElement === this.viewedElement) {
	      return;
	    }

	    this.viewedElement = aViewedElement;

	    let doc = this.viewedElement.ownerDocument;
	    if (doc != this.viewedDocument) {
	      // New document: clear/rebuild the cache.
	      this.viewedDocument = doc;

	      // Hunt down top level stylesheets, and cache them.
	      this._cacheSheets();
	    } else {
	      // Clear cached data in the CssPropertyInfo objects.
	      this._propertyInfos = {};
	    }

	    this._matchedRules = null;
	    this._matchedSelectors = null;
	    this._computedStyle = CssLogic.getComputedStyle(this.viewedElement);
	  },

	  /**
	   * Get the values of all the computed CSS properties for the highlighted
	   * element.
	   * @returns {object} The computed CSS properties for a selected element
	   */
	  get computedStyle() {
	    return this._computedStyle;
	  },

	  /**
	   * Get the source filter.
	   * @returns {string} The source filter being used.
	   */
	  get sourceFilter() {
	    return this._sourceFilter;
	  },

	  /**
	   * Source filter. Only display properties coming from the given source (web
	   * address). Note that in order to avoid information overload we DO NOT show
	   * unmatched system rules.
	   * @see CssLogic.FILTER.*
	   */
	  set sourceFilter(aValue) {
	    let oldValue = this._sourceFilter;
	    this._sourceFilter = aValue;

	    let ruleCount = 0;

	    // Update the CssSheet objects.
	    this.forEachSheet(function (aSheet) {
	      aSheet._sheetAllowed = -1;
	      if (aSheet.contentSheet && aSheet.sheetAllowed) {
	        ruleCount += aSheet.ruleCount;
	      }
	    }, this);

	    this._ruleCount = ruleCount;

	    // Full update is needed because the this.processMatchedSelectors() method
	    // skips UA stylesheets if the filter does not allow such sheets.
	    let needFullUpdate = oldValue == CssLogic.FILTER.UA || aValue == CssLogic.FILTER.UA;

	    if (needFullUpdate) {
	      this._matchedRules = null;
	      this._matchedSelectors = null;
	      this._propertyInfos = {};
	    } else {
	      // Update the CssPropertyInfo objects.
	      for (let property in this._propertyInfos) {
	        this._propertyInfos[property].needRefilter = true;
	      }
	    }
	  },

	  /**
	   * Return a CssPropertyInfo data structure for the currently viewed element
	   * and the specified CSS property. If there is no currently viewed element we
	   * return an empty object.
	   *
	   * @param {string} aProperty The CSS property to look for.
	   * @return {CssPropertyInfo} a CssPropertyInfo structure for the given
	   * property.
	   */
	  getPropertyInfo: function CssLogic_getPropertyInfo(aProperty) {
	    if (!this.viewedElement) {
	      return {};
	    }

	    let info = this._propertyInfos[aProperty];
	    if (!info) {
	      info = new CssPropertyInfo(this, aProperty);
	      this._propertyInfos[aProperty] = info;
	    }

	    return info;
	  },

	  /**
	   * Cache all the stylesheets in the inspected document
	   * @private
	   */
	  _cacheSheets: function CssLogic_cacheSheets() {
	    this._passId++;
	    this.reset();

	    // styleSheets isn't an array, but forEach can work on it anyway
	    Array.prototype.forEach.call(this.viewedDocument.styleSheets, this._cacheSheet, this);

	    this._sheetsCached = true;
	  },

	  /**
	   * Cache a stylesheet if it falls within the requirements: if it's enabled,
	   * and if the @media is allowed. This method also walks through the stylesheet
	   * cssRules to find @imported rules, to cache the stylesheets of those rules
	   * as well. In addition, the @keyframes rules in the stylesheet are cached.
	   *
	   * @private
	   * @param {CSSStyleSheet} aDomSheet the CSSStyleSheet object to cache.
	   */
	  _cacheSheet: function CssLogic_cacheSheet(aDomSheet) {
	    if (aDomSheet.disabled) {
	      return;
	    }

	    // Only work with stylesheets that have their media allowed.
	    if (!this.mediaMatches(aDomSheet)) {
	      return;
	    }

	    // Cache the sheet.
	    let cssSheet = this.getSheet(aDomSheet, this._sheetIndex++);
	    if (cssSheet._passId != this._passId) {
	      cssSheet._passId = this._passId;

	      // Find import and keyframes rules.
	      for (let aDomRule of aDomSheet.cssRules) {
	        if (aDomRule.type == Ci.nsIDOMCSSRule.IMPORT_RULE && aDomRule.styleSheet && this.mediaMatches(aDomRule)) {
	          this._cacheSheet(aDomRule.styleSheet);
	        } else if (aDomRule.type == Ci.nsIDOMCSSRule.KEYFRAMES_RULE) {
	          this._keyframesRules.push(aDomRule);
	        }
	      }
	    }
	  },

	  /**
	   * Retrieve the list of stylesheets in the document.
	   *
	   * @return {array} the list of stylesheets in the document.
	   */
	  get sheets() {
	    if (!this._sheetsCached) {
	      this._cacheSheets();
	    }

	    let sheets = [];
	    this.forEachSheet(function (aSheet) {
	      if (aSheet.contentSheet) {
	        sheets.push(aSheet);
	      }
	    }, this);

	    return sheets;
	  },

	  /**
	   * Retrieve the list of keyframes rules in the document.
	   *
	   * @ return {array} the list of keyframes rules in the document.
	   */
	  get keyframesRules() {
	    if (!this._sheetsCached) {
	      this._cacheSheets();
	    }
	    return this._keyframesRules;
	  },

	  /**
	   * Retrieve a CssSheet object for a given a CSSStyleSheet object. If the
	   * stylesheet is already cached, you get the existing CssSheet object,
	   * otherwise the new CSSStyleSheet object is cached.
	   *
	   * @param {CSSStyleSheet} aDomSheet the CSSStyleSheet object you want.
	   * @param {number} aIndex the index, within the document, of the stylesheet.
	   *
	   * @return {CssSheet} the CssSheet object for the given CSSStyleSheet object.
	   */
	  getSheet: function CL_getSheet(aDomSheet, aIndex) {
	    let cacheId = "";

	    if (aDomSheet.href) {
	      cacheId = aDomSheet.href;
	    } else if (aDomSheet.ownerNode && aDomSheet.ownerNode.ownerDocument) {
	      cacheId = aDomSheet.ownerNode.ownerDocument.location;
	    }

	    let sheet = null;
	    let sheetFound = false;

	    if (cacheId in this._sheets) {
	      for (let i = 0, numSheets = this._sheets[cacheId].length; i < numSheets; i++) {
	        sheet = this._sheets[cacheId][i];
	        if (sheet.domSheet === aDomSheet) {
	          if (aIndex != -1) {
	            sheet.index = aIndex;
	          }
	          sheetFound = true;
	          break;
	        }
	      }
	    }

	    if (!sheetFound) {
	      if (!(cacheId in this._sheets)) {
	        this._sheets[cacheId] = [];
	      }

	      sheet = new CssSheet(this, aDomSheet, aIndex);
	      if (sheet.sheetAllowed && sheet.contentSheet) {
	        this._ruleCount += sheet.ruleCount;
	      }

	      this._sheets[cacheId].push(sheet);
	    }

	    return sheet;
	  },

	  /**
	   * Process each cached stylesheet in the document using your callback.
	   *
	   * @param {function} aCallback the function you want executed for each of the
	   * CssSheet objects cached.
	   * @param {object} aScope the scope you want for the callback function. aScope
	   * will be the this object when aCallback executes.
	   */
	  forEachSheet: function CssLogic_forEachSheet(aCallback, aScope) {
	    for (let cacheId in this._sheets) {
	      let sheets = this._sheets[cacheId];
	      for (let i = 0; i < sheets.length; i++) {
	        // We take this as an opportunity to clean dead sheets
	        try {
	          let sheet = sheets[i];
	          sheet.domSheet; // If accessing domSheet raises an exception, then the
	          // style sheet is a dead object
	          aCallback.call(aScope, sheet, i, sheets);
	        } catch (e) {
	          sheets.splice(i, 1);
	          i--;
	        }
	      }
	    }
	  },

	  /**
	   * Process *some* cached stylesheets in the document using your callback. The
	   * callback function should return true in order to halt processing.
	   *
	   * @param {function} aCallback the function you want executed for some of the
	   * CssSheet objects cached.
	   * @param {object} aScope the scope you want for the callback function. aScope
	   * will be the this object when aCallback executes.
	   * @return {Boolean} true if aCallback returns true during any iteration,
	   * otherwise false is returned.
	   */
	  forSomeSheets: function CssLogic_forSomeSheets(aCallback, aScope) {
	    for (let cacheId in this._sheets) {
	      if (this._sheets[cacheId].some(aCallback, aScope)) {
	        return true;
	      }
	    }
	    return false;
	  },

	  /**
	   * Get the number nsIDOMCSSRule objects in the document, counted from all of
	   * the stylesheets. System sheets are excluded. If a filter is active, this
	   * tells only the number of nsIDOMCSSRule objects inside the selected
	   * CSSStyleSheet.
	   *
	   * WARNING: This only provides an estimate of the rule count, and the results
	   * could change at a later date. Todo remove this
	   *
	   * @return {number} the number of nsIDOMCSSRule (all rules).
	   */
	  get ruleCount() {
	    if (!this._sheetsCached) {
	      this._cacheSheets();
	    }

	    return this._ruleCount;
	  },

	  /**
	   * Process the CssSelector objects that match the highlighted element and its
	   * parent elements. aScope.aCallback() is executed for each CssSelector
	   * object, being passed the CssSelector object and the match status.
	   *
	   * This method also includes all of the element.style properties, for each
	   * highlighted element parent and for the highlighted element itself.
	   *
	   * Note that the matched selectors are cached, such that next time your
	   * callback is invoked for the cached list of CssSelector objects.
	   *
	   * @param {function} aCallback the function you want to execute for each of
	   * the matched selectors.
	   * @param {object} aScope the scope you want for the callback function. aScope
	   * will be the this object when aCallback executes.
	   */
	  processMatchedSelectors: function CL_processMatchedSelectors(aCallback, aScope) {
	    if (this._matchedSelectors) {
	      if (aCallback) {
	        this._passId++;
	        this._matchedSelectors.forEach(function (aValue) {
	          aCallback.call(aScope, aValue[0], aValue[1]);
	          aValue[0].cssRule._passId = this._passId;
	        }, this);
	      }
	      return;
	    }

	    if (!this._matchedRules) {
	      this._buildMatchedRules();
	    }

	    this._matchedSelectors = [];
	    this._passId++;

	    for (let i = 0; i < this._matchedRules.length; i++) {
	      let rule = this._matchedRules[i][0];
	      let status = this._matchedRules[i][1];

	      rule.selectors.forEach(function (aSelector) {
	        if (aSelector._matchId !== this._matchId && (aSelector.elementStyle || this.selectorMatchesElement(rule.domRule, aSelector.selectorIndex))) {

	          aSelector._matchId = this._matchId;
	          this._matchedSelectors.push([aSelector, status]);
	          if (aCallback) {
	            aCallback.call(aScope, aSelector, status);
	          }
	        }
	      }, this);

	      rule._passId = this._passId;
	    }
	  },

	  /**
	   * Check if the given selector matches the highlighted element or any of its
	   * parents.
	   *
	   * @private
	   * @param {DOMRule} domRule
	   *        The DOM Rule containing the selector.
	   * @param {Number} idx
	   *        The index of the selector within the DOMRule.
	   * @return {boolean}
	   *         true if the given selector matches the highlighted element or any
	   *         of its parents, otherwise false is returned.
	   */
	  selectorMatchesElement: function CL_selectorMatchesElement2(domRule, idx) {
	    let element = this.viewedElement;
	    do {
	      if (domUtils.selectorMatchesElement(element, domRule, idx)) {
	        return true;
	      }
	    } while ((element = element.parentNode) && element.nodeType === Ci.nsIDOMNode.ELEMENT_NODE);

	    return false;
	  },

	  /**
	   * Check if the highlighted element or it's parents have matched selectors.
	   *
	   * @param {array} aProperties The list of properties you want to check if they
	   * have matched selectors or not.
	   * @return {object} An object that tells for each property if it has matched
	   * selectors or not. Object keys are property names and values are booleans.
	   */
	  hasMatchedSelectors: function CL_hasMatchedSelectors(aProperties) {
	    if (!this._matchedRules) {
	      this._buildMatchedRules();
	    }

	    let result = {};

	    this._matchedRules.some(function (aValue) {
	      let rule = aValue[0];
	      let status = aValue[1];
	      aProperties = aProperties.filter(function (aProperty) {
	        // We just need to find if a rule has this property while it matches
	        // the viewedElement (or its parents).
	        if (rule.getPropertyValue(aProperty) && (status == CssLogic.STATUS.MATCHED || status == CssLogic.STATUS.PARENT_MATCH && domUtils.isInheritedProperty(aProperty))) {
	          result[aProperty] = true;
	          return false;
	        }
	        return true; // Keep the property for the next rule.
	      });
	      return aProperties.length == 0;
	    }, this);

	    return result;
	  },

	  /**
	   * Build the array of matched rules for the currently highlighted element.
	   * The array will hold rules that match the viewedElement and its parents.
	   *
	   * @private
	   */
	  _buildMatchedRules: function CL__buildMatchedRules() {
	    let domRules;
	    let element = this.viewedElement;
	    let filter = this.sourceFilter;
	    let sheetIndex = 0;

	    this._matchId++;
	    this._passId++;
	    this._matchedRules = [];

	    if (!element) {
	      return;
	    }

	    do {
	      let status = this.viewedElement === element ? CssLogic.STATUS.MATCHED : CssLogic.STATUS.PARENT_MATCH;

	      try {
	        // Handle finding rules on pseudo by reading style rules
	        // on the parent node with proper pseudo arg to getCSSStyleRules.

	        var _CssLogic$getBindingE = CssLogic.getBindingElementAndPseudo(element);

	        let bindingElement = _CssLogic$getBindingE.bindingElement;
	        let pseudo = _CssLogic$getBindingE.pseudo;

	        domRules = domUtils.getCSSStyleRules(bindingElement, pseudo);
	      } catch (ex) {
	        Services.console.logStringMessage("CL__buildMatchedRules error: " + ex);
	        continue;
	      }

	      // getCSSStyleRules can return null with a shadow DOM element.
	      let numDomRules = domRules ? domRules.Count() : 0;
	      for (let i = 0; i < numDomRules; i++) {
	        let domRule = domRules.GetElementAt(i);
	        if (domRule.type !== Ci.nsIDOMCSSRule.STYLE_RULE) {
	          continue;
	        }

	        let sheet = this.getSheet(domRule.parentStyleSheet, -1);
	        if (sheet._passId !== this._passId) {
	          sheet.index = sheetIndex++;
	          sheet._passId = this._passId;
	        }

	        if (filter === CssLogic.FILTER.USER && !sheet.contentSheet) {
	          continue;
	        }

	        let rule = sheet.getRule(domRule);
	        if (rule._passId === this._passId) {
	          continue;
	        }

	        rule._matchId = this._matchId;
	        rule._passId = this._passId;
	        this._matchedRules.push([rule, status]);
	      }

	      // Add element.style information.
	      if (element.style && element.style.length > 0) {
	        let rule = new CssRule(null, { style: element.style }, element);
	        rule._matchId = this._matchId;
	        rule._passId = this._passId;
	        this._matchedRules.push([rule, status]);
	      }
	    } while ((element = element.parentNode) && element.nodeType === Ci.nsIDOMNode.ELEMENT_NODE);
	  },

	  /**
	   * Tells if the given DOM CSS object matches the current view media.
	   *
	   * @param {object} aDomObject The DOM CSS object to check.
	   * @return {boolean} True if the DOM CSS object matches the current view
	   * media, or false otherwise.
	   */
	  mediaMatches: function CL_mediaMatches(aDomObject) {
	    let mediaText = aDomObject.media.mediaText;
	    return !mediaText || this.viewedDocument.defaultView.matchMedia(mediaText).matches;
	  }
	};

	/**
	 * If the element has an id, return '#id'. Otherwise return 'tagname[n]' where
	 * n is the index of this element in its siblings.
	 * <p>A technically more 'correct' output from the no-id case might be:
	 * 'tagname:nth-of-type(n)' however this is unlikely to be more understood
	 * and it is longer.
	 *
	 * @param {nsIDOMElement} aElement the element for which you want the short name.
	 * @return {string} the string to be displayed for aElement.
	 */
	CssLogic.getShortName = function CssLogic_getShortName(aElement) {
	  if (!aElement) {
	    return "null";
	  }
	  if (aElement.id) {
	    return "#" + aElement.id;
	  }
	  let priorSiblings = 0;
	  let temp = aElement;
	  while (temp = temp.previousElementSibling) {
	    priorSiblings++;
	  }
	  return aElement.tagName + "[" + priorSiblings + "]";
	};

	/**
	 * Get an array of short names from the given element to document.body.
	 *
	 * @param {nsIDOMElement} aElement the element for which you want the array of
	 * short names.
	 * @return {array} The array of elements.
	 * <p>Each element is an object of the form:
	 * <ul>
	 * <li>{ display: "what to display for the given (parent) element",
	 * <li>  element: referenceToTheElement }
	 * </ul>
	 */
	CssLogic.getShortNamePath = function CssLogic_getShortNamePath(aElement) {
	  let doc = aElement.ownerDocument;
	  let reply = [];

	  if (!aElement) {
	    return reply;
	  }

	  // We want to exclude nodes high up the tree (body/html) unless the user
	  // has selected that node, in which case we need to report something.
	  do {
	    reply.unshift({
	      display: CssLogic.getShortName(aElement),
	      element: aElement
	    });
	    aElement = aElement.parentNode;
	  } while (aElement && aElement != doc.body && aElement != doc.head && aElement != doc);

	  return reply;
	};

	/**
	 * Get a string list of selectors for a given DOMRule.
	 *
	 * @param {DOMRule} aDOMRule
	 *        The DOMRule to parse.
	 * @return {Array}
	 *         An array of string selectors.
	 */
	CssLogic.getSelectors = function CssLogic_getSelectors(aDOMRule) {
	  let selectors = [];

	  let len = domUtils.getSelectorCount(aDOMRule);
	  for (let i = 0; i < len; i++) {
	    let text = domUtils.getSelectorText(aDOMRule, i);
	    selectors.push(text);
	  }
	  return selectors;
	};

	/**
	 * Given a node, check to see if it is a ::before or ::after element.
	 * If so, return the node that is accessible from within the document
	 * (the parent of the anonymous node), along with which pseudo element
	 * it was.  Otherwise, return the node itself.
	 *
	 * @returns {Object}
	 *            - {DOMNode} node The non-anonymous node
	 *            - {string} pseudo One of ':before', ':after', or null.
	 */
	CssLogic.getBindingElementAndPseudo = function (node) {
	  let bindingElement = node;
	  let pseudo = null;
	  if (node.nodeName == "_moz_generated_content_before") {
	    bindingElement = node.parentNode;
	    pseudo = ":before";
	  } else if (node.nodeName == "_moz_generated_content_after") {
	    bindingElement = node.parentNode;
	    pseudo = ":after";
	  }
	  return {
	    bindingElement: bindingElement,
	    pseudo: pseudo
	  };
	};

	/**
	 * Get the computed style on a node.  Automatically handles reading
	 * computed styles on a ::before/::after element by reading on the
	 * parent node with the proper pseudo argument.
	 *
	 * @param {Node}
	 * @returns {CSSStyleDeclaration}
	 */
	CssLogic.getComputedStyle = function (node) {
	  if (!node || Cu.isDeadWrapper(node) || node.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView) {
	    return null;
	  }

	  var _CssLogic$getBindingE2 = CssLogic.getBindingElementAndPseudo(node);

	  let bindingElement = _CssLogic$getBindingE2.bindingElement;
	  let pseudo = _CssLogic$getBindingE2.pseudo;

	  return node.ownerDocument.defaultView.getComputedStyle(bindingElement, pseudo);
	};

	const _strings = Services.strings.createBundle(__webpack_require__(102));

	/**
	 * Memonized lookup of a l10n string from a string bundle.
	 * @param {string} aName The key to lookup.
	 * @returns A localized version of the given key.
	 */
	CssLogic.l10n = function (aName) {
	  return _strings.GetStringFromName(aName);
	};

	/**
	 * Is the given property sheet a content stylesheet?
	 *
	 * @param {CSSStyleSheet} aSheet a stylesheet
	 * @return {boolean} true if the given stylesheet is a content stylesheet,
	 * false otherwise.
	 */
	CssLogic.isContentStylesheet = function CssLogic_isContentStylesheet(aSheet) {
	  // All sheets with owner nodes have been included by content.
	  if (aSheet.ownerNode) {
	    return true;
	  }

	  // If the sheet has a CSSImportRule we need to check the parent stylesheet.
	  if (aSheet.ownerRule instanceof Ci.nsIDOMCSSImportRule) {
	    return CssLogic.isContentStylesheet(aSheet.parentStyleSheet);
	  }

	  return false;
	};

	/**
	 * Get a source for a stylesheet, taking into account embedded stylesheets
	 * for which we need to use document.defaultView.location.href rather than
	 * sheet.href
	 *
	 * @param {CSSStyleSheet} aSheet the DOM object for the style sheet.
	 * @return {string} the address of the stylesheet.
	 */
	CssLogic.href = function CssLogic_href(aSheet) {
	  let href = aSheet.href;
	  if (!href) {
	    href = aSheet.ownerNode.ownerDocument.location;
	  }

	  return href;
	};

	/**
	 * Return a shortened version of a style sheet's source.
	 *
	 * @param {CSSStyleSheet} aSheet the DOM object for the style sheet.
	 */
	CssLogic.shortSource = function CssLogic_shortSource(aSheet) {
	  // Use a string like "inline" if there is no source href
	  if (!aSheet || !aSheet.href) {
	    return CssLogic.l10n("rule.sourceInline");
	  }

	  // We try, in turn, the filename, filePath, query string, whole thing
	  let url = {};
	  try {
	    url = Services.io.newURI(aSheet.href, null, null);
	    url = url.QueryInterface(Ci.nsIURL);
	  } catch (ex) {
	    // Some UA-provided stylesheets are not valid URLs.
	  }

	  if (url.fileName) {
	    return url.fileName;
	  }

	  if (url.filePath) {
	    return url.filePath;
	  }

	  if (url.query) {
	    return url.query;
	  }

	  let dataUrl = aSheet.href.match(/^(data:[^,]*),/);
	  return dataUrl ? dataUrl[1] : aSheet.href;
	};

	/**
	 * Find the position of [element] in [nodeList].
	 * @returns an index of the match, or -1 if there is no match
	 */
	function positionInNodeList(element, nodeList) {
	  for (var i = 0; i < nodeList.length; i++) {
	    if (element === nodeList[i]) {
	      return i;
	    }
	  }
	  return -1;
	}

	/**
	 * Find a unique CSS selector for a given element
	 * @returns a string such that ele.ownerDocument.querySelector(reply) === ele
	 * and ele.ownerDocument.querySelectorAll(reply).length === 1
	 */
	CssLogic.findCssSelector = function CssLogic_findCssSelector(ele) {
	  ele = getRootBindingParent(ele);
	  var document = ele.ownerDocument;
	  if (!document || !document.contains(ele)) {
	    throw new Error('findCssSelector received element not inside document');
	  }

	  // document.querySelectorAll("#id") returns multiple if elements share an ID
	  if (ele.id && document.querySelectorAll('#' + CSS.escape(ele.id)).length === 1) {
	    return '#' + CSS.escape(ele.id);
	  }

	  // Inherently unique by tag name
	  var tagName = ele.localName;
	  if (tagName === 'html') {
	    return 'html';
	  }
	  if (tagName === 'head') {
	    return 'head';
	  }
	  if (tagName === 'body') {
	    return 'body';
	  }

	  // We might be able to find a unique class name
	  var selector, index, matches;
	  if (ele.classList.length > 0) {
	    for (var i = 0; i < ele.classList.length; i++) {
	      // Is this className unique by itself?
	      selector = '.' + CSS.escape(ele.classList.item(i));
	      matches = document.querySelectorAll(selector);
	      if (matches.length === 1) {
	        return selector;
	      }
	      // Maybe it's unique with a tag name?
	      selector = tagName + selector;
	      matches = document.querySelectorAll(selector);
	      if (matches.length === 1) {
	        return selector;
	      }
	      // Maybe it's unique using a tag name and nth-child
	      index = positionInNodeList(ele, ele.parentNode.children) + 1;
	      selector = selector + ':nth-child(' + index + ')';
	      matches = document.querySelectorAll(selector);
	      if (matches.length === 1) {
	        return selector;
	      }
	    }
	  }

	  // Not unique enough yet.  As long as it's not a child of the document,
	  // continue recursing up until it is unique enough.
	  if (ele.parentNode !== document) {
	    index = positionInNodeList(ele, ele.parentNode.children) + 1;
	    selector = CssLogic_findCssSelector(ele.parentNode) + ' > ' + tagName + ':nth-child(' + index + ')';
	  }

	  return selector;
	};

	const TAB_CHARS = "\t";

	/**
	 * Prettify minified CSS text.
	 * This prettifies CSS code where there is no indentation in usual places while
	 * keeping original indentation as-is elsewhere.
	 * @param string text The CSS source to prettify.
	 * @return string Prettified CSS source
	 */
	CssLogic.prettifyCSS = function (text, ruleCount) {
	  if (CssLogic.LINE_SEPARATOR == null) {
	    let os = Cc("@mozilla.org/xre/app-info;1").getService(Ci.nsIXULRuntime).OS;
	    CssLogic.LINE_SEPARATOR = os === "WINNT" ? "\r\n" : "\n";
	  }

	  // remove initial and terminating HTML comments and surrounding whitespace
	  text = text.replace(/(?:^\s*<!--[\r\n]*)|(?:\s*-->\s*$)/g, "");

	  // don't attempt to prettify if there's more than one line per rule.
	  let lineCount = text.split("\n").length - 1;
	  if (ruleCount !== null && lineCount >= ruleCount) {
	    return text;
	  }

	  // We reformat the text using a simple state machine.  The
	  // reformatting preserves most of the input text, changing only
	  // whitespace.  The rules are:
	  //
	  // * After a "{" or ";" symbol, ensure there is a newline and
	  //   indentation before the next non-comment, non-whitespace token.
	  // * Additionally after a "{" symbol, increase the indentation.
	  // * A "}" symbol ensures there is a preceding newline, and
	  //   decreases the indentation level.
	  // * Ensure there is whitespace before a "{".
	  //
	  // This approach can be confused sometimes, but should do ok on a
	  // minified file.
	  let indent = "";
	  let indentLevel = 0;
	  let tokens = domUtils.getCSSLexer(text);
	  let result = "";
	  let pushbackToken = undefined;

	  // A helper function that reads tokens, looking for the next
	  // non-comment, non-whitespace token.  Comment and whitespace tokens
	  // are appended to |result|.  If this encounters EOF, it returns
	  // null.  Otherwise it returns the last whitespace token that was
	  // seen.  This function also updates |pushbackToken|.
	  let readUntilSignificantToken = function () {
	    while (true) {
	      let token = tokens.nextToken();
	      if (!token || token.tokenType !== "whitespace") {
	        pushbackToken = token;
	        return token;
	      }
	      // Saw whitespace.  Before committing to it, check the next
	      // token.
	      let nextToken = tokens.nextToken();
	      if (!nextToken || nextToken.tokenType !== "comment") {
	        pushbackToken = nextToken;
	        return token;
	      }
	      // Saw whitespace + comment.  Update the result and continue.
	      result = result + text.substring(token.startOffset, nextToken.endOffset);
	    }
	  };

	  // State variables for readUntilNewlineNeeded.
	  //
	  // Starting index of the accumulated tokens.
	  let startIndex;
	  // Ending index of the accumulated tokens.
	  let endIndex;
	  // True if any non-whitespace token was seen.
	  let anyNonWS;
	  // True if the terminating token is "}".
	  let isCloseBrace;
	  // True if the token just before the terminating token was
	  // whitespace.
	  let lastWasWS;

	  // A helper function that reads tokens until there is a reason to
	  // insert a newline.  This updates the state variables as needed.
	  // If this encounters EOF, it returns null.  Otherwise it returns
	  // the final token read.  Note that if the returned token is "{",
	  // then it will not be included in the computed start/end token
	  // range.  This is used to handle whitespace insertion before a "{".
	  let readUntilNewlineNeeded = function () {
	    let token;
	    while (true) {
	      if (pushbackToken) {
	        token = pushbackToken;
	        pushbackToken = undefined;
	      } else {
	        token = tokens.nextToken();
	      }
	      if (!token) {
	        endIndex = text.length;
	        break;
	      }

	      // A "}" symbol must be inserted later, to deal with indentation
	      // and newline.
	      if (token.tokenType === "symbol" && token.text === "}") {
	        isCloseBrace = true;
	        break;
	      } else if (token.tokenType === "symbol" && token.text === "{") {
	        break;
	      }

	      if (token.tokenType !== "whitespace") {
	        anyNonWS = true;
	      }

	      if (startIndex === undefined) {
	        startIndex = token.startOffset;
	      }
	      endIndex = token.endOffset;

	      if (token.tokenType === "symbol" && token.text === ';') {
	        break;
	      }

	      lastWasWS = token.tokenType === "whitespace";
	    }
	    return token;
	  };

	  while (true) {
	    // Set the initial state.
	    startIndex = undefined;
	    endIndex = undefined;
	    anyNonWS = false;
	    isCloseBrace = false;
	    lastWasWS = false;

	    // Read tokens until we see a reason to insert a newline.
	    let token = readUntilNewlineNeeded();

	    // Append any saved up text to the result, applying indentation.
	    if (startIndex !== undefined) {
	      if (isCloseBrace && !anyNonWS) {
	        // If we saw only whitespace followed by a "}", then we don't
	        // need anything here.
	      } else {
	          result = result + indent + text.substring(startIndex, endIndex);
	          if (isCloseBrace) result += CssLogic.LINE_SEPARATOR;
	        }
	    }

	    if (isCloseBrace) {
	      indent = TAB_CHARS.repeat(--indentLevel);
	      result = result + indent + '}';
	    }

	    if (!token) {
	      break;
	    }

	    if (token.tokenType === "symbol" && token.text === '{') {
	      if (!lastWasWS) {
	        result += ' ';
	      }
	      result += '{';
	      indent = TAB_CHARS.repeat(++indentLevel);
	    }

	    // Now it is time to insert a newline.  However first we want to
	    // deal with any trailing comments.
	    token = readUntilSignificantToken();

	    // "Early" bail-out if the text does not appear to be minified.
	    // Here we ignore the case where whitespace appears at the end of
	    // the text.
	    if (pushbackToken && token && token.tokenType === "whitespace" && /\n/g.test(text.substring(token.startOffset, token.endOffset))) {
	      return text;
	    }

	    // Finally time for that newline.
	    result = result + CssLogic.LINE_SEPARATOR;

	    // Maybe we hit EOF.
	    if (!pushbackToken) {
	      break;
	    }
	  }

	  return result;
	};

	/**
	 * A safe way to access cached bits of information about a stylesheet.
	 *
	 * @constructor
	 * @param {CssLogic} aCssLogic pointer to the CssLogic instance working with
	 * this CssSheet object.
	 * @param {CSSStyleSheet} aDomSheet reference to a DOM CSSStyleSheet object.
	 * @param {number} aIndex tells the index/position of the stylesheet within the
	 * main document.
	 */
	function CssSheet(aCssLogic, aDomSheet, aIndex) {
	  this._cssLogic = aCssLogic;
	  this.domSheet = aDomSheet;
	  this.index = this.contentSheet ? aIndex : -100 * aIndex;

	  // Cache of the sheets href. Cached by the getter.
	  this._href = null;
	  // Short version of href for use in select boxes etc. Cached by getter.
	  this._shortSource = null;

	  // null for uncached.
	  this._sheetAllowed = null;

	  // Cached CssRules from the given stylesheet.
	  this._rules = {};

	  this._ruleCount = -1;
	}

	CssSheet.prototype = {
	  _passId: null,
	  _contentSheet: null,
	  _mediaMatches: null,

	  /**
	   * Tells if the stylesheet is provided by the browser or not.
	   *
	   * @return {boolean} false if this is a browser-provided stylesheet, or true
	   * otherwise.
	   */
	  get contentSheet() {
	    if (this._contentSheet === null) {
	      this._contentSheet = CssLogic.isContentStylesheet(this.domSheet);
	    }
	    return this._contentSheet;
	  },

	  /**
	   * Tells if the stylesheet is disabled or not.
	   * @return {boolean} true if this stylesheet is disabled, or false otherwise.
	   */
	  get disabled() {
	    return this.domSheet.disabled;
	  },

	  /**
	   * Tells if the stylesheet matches the current browser view media.
	   * @return {boolean} true if this stylesheet matches the current browser view
	   * media, or false otherwise.
	   */
	  get mediaMatches() {
	    if (this._mediaMatches === null) {
	      this._mediaMatches = this._cssLogic.mediaMatches(this.domSheet);
	    }
	    return this._mediaMatches;
	  },

	  /**
	   * Get a source for a stylesheet, using CssLogic.href
	   *
	   * @return {string} the address of the stylesheet.
	   */
	  get href() {
	    if (this._href) {
	      return this._href;
	    }

	    this._href = CssLogic.href(this.domSheet);
	    return this._href;
	  },

	  /**
	   * Create a shorthand version of the href of a stylesheet.
	   *
	   * @return {string} the shorthand source of the stylesheet.
	   */
	  get shortSource() {
	    if (this._shortSource) {
	      return this._shortSource;
	    }

	    this._shortSource = CssLogic.shortSource(this.domSheet);
	    return this._shortSource;
	  },

	  /**
	   * Tells if the sheet is allowed or not by the current CssLogic.sourceFilter.
	   *
	   * @return {boolean} true if the stylesheet is allowed by the sourceFilter, or
	   * false otherwise.
	   */
	  get sheetAllowed() {
	    if (this._sheetAllowed !== null) {
	      return this._sheetAllowed;
	    }

	    this._sheetAllowed = true;

	    let filter = this._cssLogic.sourceFilter;
	    if (filter === CssLogic.FILTER.USER && !this.contentSheet) {
	      this._sheetAllowed = false;
	    }
	    if (filter !== CssLogic.FILTER.USER && filter !== CssLogic.FILTER.UA) {
	      this._sheetAllowed = filter === this.href;
	    }

	    return this._sheetAllowed;
	  },

	  /**
	   * Retrieve the number of rules in this stylesheet.
	   *
	   * @return {number} the number of nsIDOMCSSRule objects in this stylesheet.
	   */
	  get ruleCount() {
	    return this._ruleCount > -1 ? this._ruleCount : this.domSheet.cssRules.length;
	  },

	  /**
	   * Retrieve a CssRule object for the given CSSStyleRule. The CssRule object is
	   * cached, such that subsequent retrievals return the same CssRule object for
	   * the same CSSStyleRule object.
	   *
	   * @param {CSSStyleRule} aDomRule the CSSStyleRule object for which you want a
	   * CssRule object.
	   * @return {CssRule} the cached CssRule object for the given CSSStyleRule
	   * object.
	   */
	  getRule: function CssSheet_getRule(aDomRule) {
	    let cacheId = aDomRule.type + aDomRule.selectorText;

	    let rule = null;
	    let ruleFound = false;

	    if (cacheId in this._rules) {
	      for (let i = 0, rulesLen = this._rules[cacheId].length; i < rulesLen; i++) {
	        rule = this._rules[cacheId][i];
	        if (rule.domRule === aDomRule) {
	          ruleFound = true;
	          break;
	        }
	      }
	    }

	    if (!ruleFound) {
	      if (!(cacheId in this._rules)) {
	        this._rules[cacheId] = [];
	      }

	      rule = new CssRule(this, aDomRule);
	      this._rules[cacheId].push(rule);
	    }

	    return rule;
	  },

	  /**
	   * Process each rule in this stylesheet using your callback function. Your
	   * function receives one argument: the CssRule object for each CSSStyleRule
	   * inside the stylesheet.
	   *
	   * Note that this method also iterates through @media rules inside the
	   * stylesheet.
	   *
	   * @param {function} aCallback the function you want to execute for each of
	   * the style rules.
	   * @param {object} aScope the scope you want for the callback function. aScope
	   * will be the this object when aCallback executes.
	   */
	  forEachRule: function CssSheet_forEachRule(aCallback, aScope) {
	    let ruleCount = 0;
	    let domRules = this.domSheet.cssRules;

	    function _iterator(aDomRule) {
	      if (aDomRule.type == Ci.nsIDOMCSSRule.STYLE_RULE) {
	        aCallback.call(aScope, this.getRule(aDomRule));
	        ruleCount++;
	      } else if (aDomRule.type == Ci.nsIDOMCSSRule.MEDIA_RULE && aDomRule.cssRules && this._cssLogic.mediaMatches(aDomRule)) {
	        Array.prototype.forEach.call(aDomRule.cssRules, _iterator, this);
	      }
	    }

	    Array.prototype.forEach.call(domRules, _iterator, this);

	    this._ruleCount = ruleCount;
	  },

	  /**
	   * Process *some* rules in this stylesheet using your callback function. Your
	   * function receives one argument: the CssRule object for each CSSStyleRule
	   * inside the stylesheet. In order to stop processing the callback function
	   * needs to return a value.
	   *
	   * Note that this method also iterates through @media rules inside the
	   * stylesheet.
	   *
	   * @param {function} aCallback the function you want to execute for each of
	   * the style rules.
	   * @param {object} aScope the scope you want for the callback function. aScope
	   * will be the this object when aCallback executes.
	   * @return {Boolean} true if aCallback returns true during any iteration,
	   * otherwise false is returned.
	   */
	  forSomeRules: function CssSheet_forSomeRules(aCallback, aScope) {
	    let domRules = this.domSheet.cssRules;
	    function _iterator(aDomRule) {
	      if (aDomRule.type == Ci.nsIDOMCSSRule.STYLE_RULE) {
	        return aCallback.call(aScope, this.getRule(aDomRule));
	      } else if (aDomRule.type == Ci.nsIDOMCSSRule.MEDIA_RULE && aDomRule.cssRules && this._cssLogic.mediaMatches(aDomRule)) {
	        return Array.prototype.some.call(aDomRule.cssRules, _iterator, this);
	      }
	      return false;
	    }
	    return Array.prototype.some.call(domRules, _iterator, this);
	  },

	  toString: function CssSheet_toString() {
	    return "CssSheet[" + this.shortSource + "]";
	  }
	};

	/**
	 * Information about a single CSSStyleRule.
	 *
	 * @param {CSSSheet|null} aCssSheet the CssSheet object of the stylesheet that
	 * holds the CSSStyleRule. If the rule comes from element.style, set this
	 * argument to null.
	 * @param {CSSStyleRule|object} aDomRule the DOM CSSStyleRule for which you want
	 * to cache data. If the rule comes from element.style, then provide
	 * an object of the form: {style: element.style}.
	 * @param {Element} [aElement] If the rule comes from element.style, then this
	 * argument must point to the element.
	 * @constructor
	 */
	function CssRule(aCssSheet, aDomRule, aElement) {
	  this._cssSheet = aCssSheet;
	  this.domRule = aDomRule;

	  let parentRule = aDomRule.parentRule;
	  if (parentRule && parentRule.type == Ci.nsIDOMCSSRule.MEDIA_RULE) {
	    this.mediaText = parentRule.media.mediaText;
	  }

	  if (this._cssSheet) {
	    // parse domRule.selectorText on call to this.selectors
	    this._selectors = null;
	    this.line = domUtils.getRuleLine(this.domRule);
	    this.source = this._cssSheet.shortSource + ":" + this.line;
	    if (this.mediaText) {
	      this.source += " @media " + this.mediaText;
	    }
	    this.href = this._cssSheet.href;
	    this.contentRule = this._cssSheet.contentSheet;
	  } else if (aElement) {
	    this._selectors = [new CssSelector(this, "@element.style", 0)];
	    this.line = -1;
	    this.source = CssLogic.l10n("rule.sourceElement");
	    this.href = "#";
	    this.contentRule = true;
	    this.sourceElement = aElement;
	  }
	}

	CssRule.prototype = {
	  _passId: null,

	  mediaText: "",

	  get isMediaRule() {
	    return !!this.mediaText;
	  },

	  /**
	   * Check if the parent stylesheet is allowed by the CssLogic.sourceFilter.
	   *
	   * @return {boolean} true if the parent stylesheet is allowed by the current
	   * sourceFilter, or false otherwise.
	   */
	  get sheetAllowed() {
	    return this._cssSheet ? this._cssSheet.sheetAllowed : true;
	  },

	  /**
	   * Retrieve the parent stylesheet index/position in the viewed document.
	   *
	   * @return {number} the parent stylesheet index/position in the viewed
	   * document.
	   */
	  get sheetIndex() {
	    return this._cssSheet ? this._cssSheet.index : 0;
	  },

	  /**
	   * Retrieve the style property value from the current CSSStyleRule.
	   *
	   * @param {string} aProperty the CSS property name for which you want the
	   * value.
	   * @return {string} the property value.
	   */
	  getPropertyValue: function (aProperty) {
	    return this.domRule.style.getPropertyValue(aProperty);
	  },

	  /**
	   * Retrieve the style property priority from the current CSSStyleRule.
	   *
	   * @param {string} aProperty the CSS property name for which you want the
	   * priority.
	   * @return {string} the property priority.
	   */
	  getPropertyPriority: function (aProperty) {
	    return this.domRule.style.getPropertyPriority(aProperty);
	  },

	  /**
	   * Retrieve the list of CssSelector objects for each of the parsed selectors
	   * of the current CSSStyleRule.
	   *
	   * @return {array} the array hold the CssSelector objects.
	   */
	  get selectors() {
	    if (this._selectors) {
	      return this._selectors;
	    }

	    // Parse the CSSStyleRule.selectorText string.
	    this._selectors = [];

	    if (!this.domRule.selectorText) {
	      return this._selectors;
	    }

	    let selectors = CssLogic.getSelectors(this.domRule);

	    for (let i = 0, len = selectors.length; i < len; i++) {
	      this._selectors.push(new CssSelector(this, selectors[i], i));
	    }

	    return this._selectors;
	  },

	  toString: function CssRule_toString() {
	    return "[CssRule " + this.domRule.selectorText + "]";
	  }
	};

	/**
	 * The CSS selector class allows us to document the ranking of various CSS
	 * selectors.
	 *
	 * @constructor
	 * @param {CssRule} aCssRule the CssRule instance from where the selector comes.
	 * @param {string} aSelector The selector that we wish to investigate.
	 * @param {Number} aIndex The index of the selector within it's rule.
	 */
	function CssSelector(aCssRule, aSelector, aIndex) {
	  this.cssRule = aCssRule;
	  this.text = aSelector;
	  this.elementStyle = this.text == "@element.style";
	  this._specificity = null;
	  this.selectorIndex = aIndex;
	}

	exports.CssSelector = CssSelector;

	CssSelector.prototype = {
	  _matchId: null,

	  /**
	   * Retrieve the CssSelector source, which is the source of the CssSheet owning
	   * the selector.
	   *
	   * @return {string} the selector source.
	   */
	  get source() {
	    return this.cssRule.source;
	  },

	  /**
	   * Retrieve the CssSelector source element, which is the source of the CssRule
	   * owning the selector. This is only available when the CssSelector comes from
	   * an element.style.
	   *
	   * @return {string} the source element selector.
	   */
	  get sourceElement() {
	    return this.cssRule.sourceElement;
	  },

	  /**
	   * Retrieve the address of the CssSelector. This points to the address of the
	   * CssSheet owning this selector.
	   *
	   * @return {string} the address of the CssSelector.
	   */
	  get href() {
	    return this.cssRule.href;
	  },

	  /**
	   * Check if the selector comes from a browser-provided stylesheet.
	   *
	   * @return {boolean} true if the selector comes from a content-provided
	   * stylesheet, or false otherwise.
	   */
	  get contentRule() {
	    return this.cssRule.contentRule;
	  },

	  /**
	   * Check if the parent stylesheet is allowed by the CssLogic.sourceFilter.
	   *
	   * @return {boolean} true if the parent stylesheet is allowed by the current
	   * sourceFilter, or false otherwise.
	   */
	  get sheetAllowed() {
	    return this.cssRule.sheetAllowed;
	  },

	  /**
	   * Retrieve the parent stylesheet index/position in the viewed document.
	   *
	   * @return {number} the parent stylesheet index/position in the viewed
	   * document.
	   */
	  get sheetIndex() {
	    return this.cssRule.sheetIndex;
	  },

	  /**
	   * Retrieve the line of the parent CSSStyleRule in the parent CSSStyleSheet.
	   *
	   * @return {number} the line of the parent CSSStyleRule in the parent
	   * stylesheet.
	   */
	  get ruleLine() {
	    return this.cssRule.line;
	  },

	  /**
	   * Retrieve the pseudo-elements that we support. This list should match the
	   * elements specified in layout/style/nsCSSPseudoElementList.h
	   */
	  get pseudoElements() {
	    if (!CssSelector._pseudoElements) {
	      CssSelector._pseudoElements = PSEUDO_ELEMENT_SET;
	    }
	    return CssSelector._pseudoElements;
	  },

	  /**
	   * Retrieve specificity information for the current selector.
	   *
	   * @see http://www.w3.org/TR/css3-selectors/#specificity
	   * @see http://www.w3.org/TR/CSS2/selector.html
	   *
	   * @return {Number} The selector's specificity.
	   */
	  get specificity() {
	    if (this.elementStyle) {
	      // We can't ask specificity from DOMUtils as element styles don't provide
	      // CSSStyleRule interface DOMUtils expect. However, specificity of element
	      // style is constant, 1,0,0,0 or 0x01000000, just return the constant
	      // directly. @see http://www.w3.org/TR/CSS2/cascade.html#specificity
	      return 0x01000000;
	    }

	    if (this._specificity) {
	      return this._specificity;
	    }

	    this._specificity = domUtils.getSpecificity(this.cssRule.domRule, this.selectorIndex);

	    return this._specificity;
	  },

	  toString: function CssSelector_toString() {
	    return this.text;
	  }
	};

	/**
	 * A cache of information about the matched rules, selectors and values attached
	 * to a CSS property, for the highlighted element.
	 *
	 * The heart of the CssPropertyInfo object is the _findMatchedSelectors()
	 * method. This are invoked when the PropertyView tries to access the
	 * .matchedSelectors array.
	 * Results are cached, for later reuse.
	 *
	 * @param {CssLogic} aCssLogic Reference to the parent CssLogic instance
	 * @param {string} aProperty The CSS property we are gathering information for
	 * @constructor
	 */
	function CssPropertyInfo(aCssLogic, aProperty) {
	  this._cssLogic = aCssLogic;
	  this.property = aProperty;
	  this._value = "";

	  // The number of matched rules holding the this.property style property.
	  // Additionally, only rules that come from allowed stylesheets are counted.
	  this._matchedRuleCount = 0;

	  // An array holding CssSelectorInfo objects for each of the matched selectors
	  // that are inside a CSS rule. Only rules that hold the this.property are
	  // counted. This includes rules that come from filtered stylesheets (those
	  // that have sheetAllowed = false).
	  this._matchedSelectors = null;
	}

	CssPropertyInfo.prototype = {
	  /**
	   * Retrieve the computed style value for the current property, for the
	   * highlighted element.
	   *
	   * @return {string} the computed style value for the current property, for the
	   * highlighted element.
	   */
	  get value() {
	    if (!this._value && this._cssLogic.computedStyle) {
	      try {
	        this._value = this._cssLogic.computedStyle.getPropertyValue(this.property);
	      } catch (ex) {
	        Services.console.logStringMessage('Error reading computed style for ' + this.property);
	        Services.console.logStringMessage(ex);
	      }
	    }
	    return this._value;
	  },

	  /**
	   * Retrieve the number of matched rules holding the this.property style
	   * property. Only rules that come from allowed stylesheets are counted.
	   *
	   * @return {number} the number of matched rules.
	   */
	  get matchedRuleCount() {
	    if (!this._matchedSelectors) {
	      this._findMatchedSelectors();
	    } else if (this.needRefilter) {
	      this._refilterSelectors();
	    }

	    return this._matchedRuleCount;
	  },

	  /**
	   * Retrieve the array holding CssSelectorInfo objects for each of the matched
	   * selectors, from each of the matched rules. Only selectors coming from
	   * allowed stylesheets are included in the array.
	   *
	   * @return {array} the list of CssSelectorInfo objects of selectors that match
	   * the highlighted element and its parents.
	   */
	  get matchedSelectors() {
	    if (!this._matchedSelectors) {
	      this._findMatchedSelectors();
	    } else if (this.needRefilter) {
	      this._refilterSelectors();
	    }

	    return this._matchedSelectors;
	  },

	  /**
	   * Find the selectors that match the highlighted element and its parents.
	   * Uses CssLogic.processMatchedSelectors() to find the matched selectors,
	   * passing in a reference to CssPropertyInfo._processMatchedSelector() to
	   * create CssSelectorInfo objects, which we then sort
	   * @private
	   */
	  _findMatchedSelectors: function CssPropertyInfo_findMatchedSelectors() {
	    this._matchedSelectors = [];
	    this._matchedRuleCount = 0;
	    this.needRefilter = false;

	    this._cssLogic.processMatchedSelectors(this._processMatchedSelector, this);

	    // Sort the selectors by how well they match the given element.
	    this._matchedSelectors.sort(function (aSelectorInfo1, aSelectorInfo2) {
	      if (aSelectorInfo1.status > aSelectorInfo2.status) {
	        return -1;
	      } else if (aSelectorInfo2.status > aSelectorInfo1.status) {
	        return 1;
	      } else {
	        return aSelectorInfo1.compareTo(aSelectorInfo2);
	      }
	    });

	    // Now we know which of the matches is best, we can mark it BEST_MATCH.
	    if (this._matchedSelectors.length > 0 && this._matchedSelectors[0].status > CssLogic.STATUS.UNMATCHED) {
	      this._matchedSelectors[0].status = CssLogic.STATUS.BEST;
	    }
	  },

	  /**
	   * Process a matched CssSelector object.
	   *
	   * @private
	   * @param {CssSelector} aSelector the matched CssSelector object.
	   * @param {CssLogic.STATUS} aStatus the CssSelector match status.
	   */
	  _processMatchedSelector: function CssPropertyInfo_processMatchedSelector(aSelector, aStatus) {
	    let cssRule = aSelector.cssRule;
	    let value = cssRule.getPropertyValue(this.property);
	    if (value && (aStatus == CssLogic.STATUS.MATCHED || aStatus == CssLogic.STATUS.PARENT_MATCH && domUtils.isInheritedProperty(this.property))) {
	      let selectorInfo = new CssSelectorInfo(aSelector, this.property, value, aStatus);
	      this._matchedSelectors.push(selectorInfo);
	      if (this._cssLogic._passId !== cssRule._passId && cssRule.sheetAllowed) {
	        this._matchedRuleCount++;
	      }
	    }
	  },

	  /**
	   * Refilter the matched selectors array when the CssLogic.sourceFilter
	   * changes. This allows for quick filter changes.
	   * @private
	   */
	  _refilterSelectors: function CssPropertyInfo_refilterSelectors() {
	    let passId = ++this._cssLogic._passId;
	    let ruleCount = 0;

	    let iterator = function (aSelectorInfo) {
	      let cssRule = aSelectorInfo.selector.cssRule;
	      if (cssRule._passId != passId) {
	        if (cssRule.sheetAllowed) {
	          ruleCount++;
	        }
	        cssRule._passId = passId;
	      }
	    };

	    if (this._matchedSelectors) {
	      this._matchedSelectors.forEach(iterator);
	      this._matchedRuleCount = ruleCount;
	    }

	    this.needRefilter = false;
	  },

	  toString: function CssPropertyInfo_toString() {
	    return "CssPropertyInfo[" + this.property + "]";
	  }
	};

	/**
	 * A class that holds information about a given CssSelector object.
	 *
	 * Instances of this class are given to CssHtmlTree in the array of matched
	 * selectors. Each such object represents a displayable row in the PropertyView
	 * objects. The information given by this object blends data coming from the
	 * CssSheet, CssRule and from the CssSelector that own this object.
	 *
	 * @param {CssSelector} aSelector The CssSelector object for which to present information.
	 * @param {string} aProperty The property for which information should be retrieved.
	 * @param {string} aValue The property value from the CssRule that owns the selector.
	 * @param {CssLogic.STATUS} aStatus The selector match status.
	 * @constructor
	 */
	function CssSelectorInfo(aSelector, aProperty, aValue, aStatus) {
	  this.selector = aSelector;
	  this.property = aProperty;
	  this.status = aStatus;
	  this.value = aValue;
	  let priority = this.selector.cssRule.getPropertyPriority(this.property);
	  this.important = priority === "important";
	}

	CssSelectorInfo.prototype = {
	  /**
	   * Retrieve the CssSelector source, which is the source of the CssSheet owning
	   * the selector.
	   *
	   * @return {string} the selector source.
	   */
	  get source() {
	    return this.selector.source;
	  },

	  /**
	   * Retrieve the CssSelector source element, which is the source of the CssRule
	   * owning the selector. This is only available when the CssSelector comes from
	   * an element.style.
	   *
	   * @return {string} the source element selector.
	   */
	  get sourceElement() {
	    return this.selector.sourceElement;
	  },

	  /**
	   * Retrieve the address of the CssSelector. This points to the address of the
	   * CssSheet owning this selector.
	   *
	   * @return {string} the address of the CssSelector.
	   */
	  get href() {
	    return this.selector.href;
	  },

	  /**
	   * Check if the CssSelector comes from element.style or not.
	   *
	   * @return {boolean} true if the CssSelector comes from element.style, or
	   * false otherwise.
	   */
	  get elementStyle() {
	    return this.selector.elementStyle;
	  },

	  /**
	   * Retrieve specificity information for the current selector.
	   *
	   * @return {object} an object holding specificity information for the current
	   * selector.
	   */
	  get specificity() {
	    return this.selector.specificity;
	  },

	  /**
	   * Retrieve the parent stylesheet index/position in the viewed document.
	   *
	   * @return {number} the parent stylesheet index/position in the viewed
	   * document.
	   */
	  get sheetIndex() {
	    return this.selector.sheetIndex;
	  },

	  /**
	   * Check if the parent stylesheet is allowed by the CssLogic.sourceFilter.
	   *
	   * @return {boolean} true if the parent stylesheet is allowed by the current
	   * sourceFilter, or false otherwise.
	   */
	  get sheetAllowed() {
	    return this.selector.sheetAllowed;
	  },

	  /**
	   * Retrieve the line of the parent CSSStyleRule in the parent CSSStyleSheet.
	   *
	   * @return {number} the line of the parent CSSStyleRule in the parent
	   * stylesheet.
	   */
	  get ruleLine() {
	    return this.selector.ruleLine;
	  },

	  /**
	   * Check if the selector comes from a browser-provided stylesheet.
	   *
	   * @return {boolean} true if the selector comes from a browser-provided
	   * stylesheet, or false otherwise.
	   */
	  get contentRule() {
	    return this.selector.contentRule;
	  },

	  /**
	   * Compare the current CssSelectorInfo instance to another instance, based on
	   * specificity information.
	   *
	   * @param {CssSelectorInfo} aThat The instance to compare ourselves against.
	   * @return number -1, 0, 1 depending on how aThat compares with this.
	   */
	  compareTo: function CssSelectorInfo_compareTo(aThat) {
	    if (!this.contentRule && aThat.contentRule) return 1;
	    if (this.contentRule && !aThat.contentRule) return -1;

	    if (this.elementStyle && !aThat.elementStyle) {
	      if (!this.important && aThat.important) return 1;else return -1;
	    }

	    if (!this.elementStyle && aThat.elementStyle) {
	      if (this.important && !aThat.important) return -1;else return 1;
	    }

	    if (this.important && !aThat.important) return -1;
	    if (aThat.important && !this.important) return 1;

	    if (this.specificity > aThat.specificity) return -1;
	    if (aThat.specificity > this.specificity) return 1;

	    if (this.sheetIndex > aThat.sheetIndex) return -1;
	    if (aThat.sheetIndex > this.sheetIndex) return 1;

	    if (this.ruleLine > aThat.ruleLine) return -1;
	    if (aThat.ruleLine > this.ruleLine) return 1;

	    return 0;
	  },

	  toString: function CssSelectorInfo_toString() {
	    return this.selector + " -> " + this.value;
	  }
	};

	// DevToolsUtils.defineLazyGetter(this, "domUtils", function() {
	//   return Cc("@mozilla.org/inspector/dom-utils;1").getService(Ci.inIDOMUtils);
	// });

/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = {
	  "panelTitle": "Style Inspector",
	  "rule.status.BEST": "Best Match",
	  "rule.status.MATCHED": "Matched",
	  "rule.status.PARENT_MATCH": "Parent Match",
	  "rule.sourceInline": "inline",
	  "rule.sourceElement": "element",
	  "rule.inheritedFrom": "Inherited from %S",
	  "rule.keyframe": "Keyframes %S",
	  "rule.userAgentStyles": "(user agent)",
	  "rule.pseudoElement": "Pseudo-elements",
	  "rule.selectedElement": "This Element",
	  "helpLinkTitle": "Read the documentation for this property",
	  "rule.warning.title": "Invalid property value",
	  "rule.filterProperty.title": "Filter rules containing this property",
	  "rule.empty": "No element selected.",
	  "rule.selectorHighlighter.tooltip": "Highlight all elements matching this selector",
	  "styleinspector.contextmenu.copyColor": "Copy Color",
	  "styleinspector.contextmenu.copyColor.accessKey": "L",
	  "styleinspector.contextmenu.copyUrl": "Copy URL",
	  "styleinspector.contextmenu.copyUrl.accessKey": "U",
	  "styleinspector.contextmenu.copyImageDataUrl": "Copy Image Data-URL",
	  "styleinspector.contextmenu.copyImageDataUrl.accessKey": "I",
	  "styleinspector.copyImageDataUrlError": "Failed to copy image Data-URL",
	  "styleinspector.contextmenu.toggleOrigSources": "Show Original Sources",
	  "styleinspector.contextmenu.toggleOrigSources.accessKey": "O",
	  "styleinspector.contextmenu.showMdnDocs": "Show MDN Docs",
	  "styleinspector.contextmenu.showMdnDocs.accessKey": "D",
	  "styleinspector.contextmenu.addNewRule": "Add New Rule",
	  "styleinspector.contextmenu.addNewRule.accessKey": "R",
	  "styleinspector.contextmenu.selectAll": "Select All",
	  "styleinspector.contextmenu.selectAll.accessKey": "A",
	  "styleinspector.contextmenu.copy": "Copy",
	  "styleinspector.contextmenu.copy.accessKey": "C",
	  "styleinspector.contextmenu.copyLocation": "Copy Location",
	  "styleinspector.contextmenu.copyPropertyDeclaration": "Copy Property Declaration",
	  "styleinspector.contextmenu.copyPropertyName": "Copy Property Name",
	  "styleinspector.contextmenu.copyPropertyValue": "Copy Property Value",
	  "styleinspector.contextmenu.copyRule": "Copy Rule",
	  "styleinspector.contextmenu.copySelector": "Copy Selector"
	}

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	var components = _require.components;
	var Cc = _require.Cc;
	var Ci = _require.Ci;
	var Cu = _require.Cu;

	var Services = __webpack_require__(9);

	var _require2 = __webpack_require__(15);

	const XPCOMUtils = _require2.XPCOMUtils;
	/*Cu.import("resource://gre/modules/NetUtil.jsm");
	Cu.import("resource://gre/modules/FileUtils.jsm");*/

	var _require3 = __webpack_require__(38);

	const Task = _require3.Task;

	const promise = __webpack_require__(6);
	const events = __webpack_require__(25);
	const protocol = __webpack_require__(79);
	const Arg = protocol.Arg;
	const Option = protocol.Option;
	const method = protocol.method;
	const RetVal = protocol.RetVal;
	const types = protocol.types;

	var _require4 = __webpack_require__(83);

	const LongStringActor = _require4.LongStringActor;
	const ShortLongString = _require4.ShortLongString;

	var _require5 = __webpack_require__(19);

	const fetch = _require5.fetch;

	var _require6 = __webpack_require__(104);

	const listenOnce = _require6.listenOnce;
	/*const {SourceMapConsumer} = require("source-map");*/

	/*loader.lazyGetter(this, "CssLogic", () => require("devtools/shared/styleinspector/css-logic").CssLogic);*/

	var _require7 = __webpack_require__(37);

	const getIndentationFromPrefs = _require7.getIndentationFromPrefs;
	const getIndentationFromString = _require7.getIndentationFromString;

	var TRANSITION_CLASS = "moz-styleeditor-transitioning";
	var TRANSITION_DURATION_MS = 500;
	var TRANSITION_BUFFER_MS = 1000;
	var TRANSITION_RULE_SELECTOR = ".moz-styleeditor-transitioning:root, .moz-styleeditor-transitioning:root *";
	var TRANSITION_RULE = TRANSITION_RULE_SELECTOR + " {\
	transition-duration: " + TRANSITION_DURATION_MS + "ms !important; \
	transition-delay: 0ms !important;\
	transition-timing-function: ease-out !important;\
	transition-property: all !important;\
	}";

	var LOAD_ERROR = "error-load";

	types.addActorType("stylesheet");
	types.addActorType("originalsource");

	// The possible kinds of style-applied events.
	// UPDATE_PRESERVING_RULES means that the update is guaranteed to
	// preserve the number and order of rules on the style sheet.
	// UPDATE_GENERAL covers any other kind of change to the style sheet.
	const UPDATE_PRESERVING_RULES = 0;
	exports.UPDATE_PRESERVING_RULES = UPDATE_PRESERVING_RULES;
	const UPDATE_GENERAL = 1;
	exports.UPDATE_GENERAL = UPDATE_GENERAL;

	// If the user edits a style sheet, we stash a copy of the edited text
	// here, keyed by the style sheet.  This way, if the tools are closed
	// and then reopened, the edited text will be available.  A weak map
	// is used so that navigation by the user will eventually cause the
	// edited text to be collected.
	let modifiedStyleSheets = new WeakMap();

	/**
	 * Creates a StyleSheetsActor. StyleSheetsActor provides remote access to the
	 * stylesheets of a document.
	 */
	var StyleSheetsActor = exports.StyleSheetsActor = protocol.ActorClass({
	  typeName: "stylesheets",

	  /**
	   * The window we work with, taken from the parent actor.
	   */
	  get window() {
	    return this.parentActor.window;
	  },

	  /**
	   * The current content document of the window we work with.
	   */
	  get document() {
	    return this.window.document;
	  },

	  form: function () {
	    return { actor: this.actorID };
	  },

	  initialize: function (conn, tabActor) {
	    protocol.Actor.prototype.initialize.call(this, null);

	    this.parentActor = tabActor;
	  },

	  /**
	   * Protocol method for getting a list of StyleSheetActors representing
	   * all the style sheets in this document.
	   */
	  getStyleSheets: method(Task.async(function* () {
	    // Iframe document can change during load (bug 1171919). Track their windows
	    // instead.
	    let windows = [this.window];
	    let actors = [];

	    for (let win of windows) {
	      let sheets = yield this._addStyleSheets(win);
	      actors = actors.concat(sheets);

	      // Recursively handle style sheets of the documents in iframes.
	      for (let iframe of win.document.querySelectorAll("iframe, browser, frame")) {
	        if (iframe.contentDocument && iframe.contentWindow) {
	          // Sometimes, iframes don't have any document, like the
	          // one that are over deeply nested (bug 285395)
	          windows.push(iframe.contentWindow);
	        }
	      }
	    }
	    return actors;
	  }), {
	    request: {},
	    response: { styleSheets: RetVal("array:stylesheet") }
	  }),

	  /**
	   * Check if we should be showing this stylesheet.
	   *
	   * @param {Document} doc
	   *        Document for which we're checking
	   * @param {DOMCSSStyleSheet} sheet
	   *        Stylesheet we're interested in
	   *
	   * @return boolean
	   *         Whether the stylesheet should be listed.
	   */
	  _shouldListSheet: function (doc, sheet) {
	    // Special case about:PreferenceStyleSheet, as it is generated on the
	    // fly and the URI is not registered with the about: handler.
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=935803#c37
	    if (sheet.href && sheet.href.toLowerCase() == "about:preferencestylesheet") {
	      return false;
	    }

	    return true;
	  },

	  /**
	   * Add all the stylesheets for the document in this window to the map and
	   * create an actor for each one if not already created.
	   *
	   * @param {Window} win
	   *        Window for which to add stylesheets
	   *
	   * @return {Promise}
	   *         Promise that resolves to an array of StyleSheetActors
	   */
	  _addStyleSheets: function (win) {
	    return Task.spawn((function* () {
	      let doc = win.document;
	      // readyState can be uninitialized if an iframe has just been created but
	      // it has not started to load yet.
	      if (doc.readyState === "loading" || doc.readyState === "uninitialized") {
	        // Wait for the document to load first.
	        yield listenOnce(win, "DOMContentLoaded", true);

	        // Make sure we have the actual document for this window. If the
	        // readyState was initially uninitialized, the initial dummy document
	        // was replaced with the actual document (bug 1171919).
	        doc = win.document;
	      }

	      let isChrome = Services.scriptSecurityManager.isSystemPrincipal(doc.nodePrincipal);
	      let styleSheets = isChrome ? DOMUtils.getAllStyleSheets(doc) : doc.styleSheets;
	      let actors = [];
	      for (let i = 0; i < styleSheets.length; i++) {
	        let sheet = styleSheets[i];
	        if (!this._shouldListSheet(doc, sheet)) {
	          continue;
	        }

	        let actor = this.parentActor.createStyleSheetActor(sheet);
	        actors.push(actor);

	        // Get all sheets, including imported ones
	        let imports = yield this._getImported(doc, actor);
	        actors = actors.concat(imports);
	      }
	      return actors;
	    }).bind(this));
	  },

	  /**
	   * Get all the stylesheets @imported from a stylesheet.
	   *
	   * @param  {Document} doc
	   *         The document including the stylesheet
	   * @param  {DOMStyleSheet} styleSheet
	   *         Style sheet to search
	   * @return {Promise}
	   *         A promise that resolves with an array of StyleSheetActors
	   */
	  _getImported: function (doc, styleSheet) {
	    return Task.spawn((function* () {
	      let rules = yield styleSheet.getCSSRules();
	      let imported = [];

	      for (let i = 0; i < rules.length; i++) {
	        let rule = rules[i];
	        if (rule.type == Ci.nsIDOMCSSRule.IMPORT_RULE) {
	          // Associated styleSheet may be null if it has already been seen due
	          // to duplicate @imports for the same URL.
	          if (!rule.styleSheet || !this._shouldListSheet(doc, rule.styleSheet)) {
	            continue;
	          }
	          let actor = this.parentActor.createStyleSheetActor(rule.styleSheet);
	          imported.push(actor);

	          // recurse imports in this stylesheet as well
	          let children = yield this._getImported(doc, actor);
	          imported = imported.concat(children);
	        } else if (rule.type != Ci.nsIDOMCSSRule.CHARSET_RULE) {
	          // @import rules must precede all others except @charset
	          break;
	        }
	      }

	      return imported;
	    }).bind(this));
	  },

	  /**
	   * Create a new style sheet in the document with the given text.
	   * Return an actor for it.
	   *
	   * @param  {object} request
	   *         Debugging protocol request object, with 'text property'
	   * @return {object}
	   *         Object with 'styelSheet' property for form on new actor.
	   */
	  addStyleSheet: method(function (text) {
	    let parent = this.document.documentElement;
	    let style = this.document.createElementNS("http://www.w3.org/1999/xhtml", "style");
	    style.setAttribute("type", "text/css");

	    if (text) {
	      style.appendChild(this.document.createTextNode(text));
	    }
	    parent.appendChild(style);

	    let actor = this.parentActor.createStyleSheetActor(style.sheet);
	    return actor;
	  }, {
	    request: { text: Arg(0, "string") },
	    response: { styleSheet: RetVal("stylesheet") }
	  })
	});

	/**
	 * The corresponding Front object for the StyleSheetsActor.
	 */
	var StyleSheetsFront = protocol.FrontClass(StyleSheetsActor, {
	  initialize: function (client, tabForm) {
	    protocol.Front.prototype.initialize.call(this, client);
	    this.actorID = tabForm.styleSheetsActor;
	    this.manage(this);
	  }
	});

	/**
	 * A MediaRuleActor lives on the server and provides access to properties
	 * of a DOM @media rule and emits events when it changes.
	 */
	var MediaRuleActor = protocol.ActorClass({
	  typeName: "mediarule",

	  events: {
	    "matches-change": {
	      type: "matchesChange",
	      matches: Arg(0, "boolean")
	    }
	  },

	  get window() {
	    return this.parentActor.window;
	  },

	  get document() {
	    return this.window.document;
	  },

	  get matches() {
	    return this.mql ? this.mql.matches : null;
	  },

	  initialize: function (aMediaRule, aParentActor) {
	    protocol.Actor.prototype.initialize.call(this, null);

	    this.rawRule = aMediaRule;
	    this.parentActor = aParentActor;
	    this.conn = this.parentActor.conn;

	    this._matchesChange = this._matchesChange.bind(this);

	    this.line = DOMUtils.getRuleLine(aMediaRule);
	    this.column = DOMUtils.getRuleColumn(aMediaRule);

	    try {
	      this.mql = this.window.matchMedia(aMediaRule.media.mediaText);
	    } catch (e) {}

	    if (this.mql) {
	      this.mql.addListener(this._matchesChange);
	    }
	  },

	  destroy: function () {
	    if (this.mql) {
	      this.mql.removeListener(this._matchesChange);
	    }

	    protocol.Actor.prototype.destroy.call(this);
	  },

	  form: function (detail) {
	    if (detail === "actorid") {
	      return this.actorID;
	    }

	    let form = {
	      actor: this.actorID, // actorID is set when this is added to a pool
	      mediaText: this.rawRule.media.mediaText,
	      conditionText: this.rawRule.conditionText,
	      matches: this.matches,
	      line: this.line,
	      column: this.column,
	      parentStyleSheet: this.parentActor.actorID
	    };

	    return form;
	  },

	  _matchesChange: function () {
	    events.emit(this, "matches-change", this.matches);
	  }
	});

	/**
	 * Cooresponding client-side front for a MediaRuleActor.
	 */
	var MediaRuleFront = protocol.FrontClass(MediaRuleActor, {
	  initialize: function (client, form) {
	    protocol.Front.prototype.initialize.call(this, client, form);

	    this._onMatchesChange = this._onMatchesChange.bind(this);
	    events.on(this, "matches-change", this._onMatchesChange);
	  },

	  _onMatchesChange: function (matches) {
	    this._form.matches = matches;
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	  },

	  get mediaText() {
	    return this._form.mediaText;
	  },
	  get conditionText() {
	    return this._form.conditionText;
	  },
	  get matches() {
	    return this._form.matches;
	  },
	  get line() {
	    return this._form.line || -1;
	  },
	  get column() {
	    return this._form.column || -1;
	  },
	  get parentStyleSheet() {
	    return this.conn.getActor(this._form.parentStyleSheet);
	  }
	});

	/**
	 * A StyleSheetActor represents a stylesheet on the server.
	 */
	var StyleSheetActor = protocol.ActorClass({
	  typeName: "stylesheet",

	  events: {
	    "property-change": {
	      type: "propertyChange",
	      property: Arg(0, "string"),
	      value: Arg(1, "json")
	    },
	    "style-applied": {
	      type: "styleApplied",
	      kind: Arg(0, "number"),
	      styleSheet: Arg(1, "stylesheet")
	    },
	    "media-rules-changed": {
	      type: "mediaRulesChanged",
	      rules: Arg(0, "array:mediarule")
	    }
	  },

	  /* List of original sources that generated this stylesheet */
	  _originalSources: null,

	  toString: function () {
	    return "[StyleSheetActor " + this.actorID + "]";
	  },

	  /**
	   * Window of target
	   */
	  get window() {
	    return this._window || this.parentActor.window;
	  },

	  /**
	   * Document of target.
	   */
	  get document() {
	    return this.window.document;
	  },

	  get ownerNode() {
	    return this.rawSheet.ownerNode;
	  },

	  /**
	   * URL of underlying stylesheet.
	   */
	  get href() {
	    return this.rawSheet.href;
	  },

	  /**
	   * Retrieve the index (order) of stylesheet in the document.
	   *
	   * @return number
	   */
	  get styleSheetIndex() {
	    if (this._styleSheetIndex == -1) {
	      for (let i = 0; i < this.document.styleSheets.length; i++) {
	        if (this.document.styleSheets[i] == this.rawSheet) {
	          this._styleSheetIndex = i;
	          break;
	        }
	      }
	    }
	    return this._styleSheetIndex;
	  },

	  initialize: function (aStyleSheet, aParentActor, aWindow) {
	    protocol.Actor.prototype.initialize.call(this, null);

	    this.rawSheet = aStyleSheet;
	    this.parentActor = aParentActor;
	    this.conn = this.parentActor.conn;

	    this._window = aWindow;

	    // text and index are unknown until source load
	    this.text = null;
	    this._styleSheetIndex = -1;

	    this._transitionRefCount = 0;
	  },

	  /**
	   * Get the raw stylesheet's cssRules once the sheet has been loaded.
	   *
	   * @return {Promise}
	   *         Promise that resolves with a CSSRuleList
	   */
	  getCSSRules: function () {
	    var _this = this;

	    let rules;
	    try {
	      rules = this.rawSheet.cssRules;
	    } catch (e) {
	      // sheet isn't loaded yet
	    }

	    if (rules) {
	      return promise.resolve(rules);
	    }

	    if (!this.ownerNode) {
	      return promise.resolve([]);
	    }

	    if (this._cssRules) {
	      return this._cssRules;
	    }

	    let deferred = promise.defer();

	    let onSheetLoaded = function (event) {
	      _this.ownerNode.removeEventListener("load", onSheetLoaded, false);

	      deferred.resolve(_this.rawSheet.cssRules);
	    };

	    this.ownerNode.addEventListener("load", onSheetLoaded, false);

	    // cache so we don't add many listeners if this is called multiple times.
	    this._cssRules = deferred.promise;

	    return this._cssRules;
	  },

	  /**
	   * Get the current state of the actor
	   *
	   * @return {object}
	   *         With properties of the underlying stylesheet, plus 'text',
	   *        'styleSheetIndex' and 'parentActor' if it's @imported
	   */
	  form: function (detail) {
	    var _this2 = this;

	    if (detail === "actorid") {
	      return this.actorID;
	    }

	    let docHref;
	    if (this.ownerNode) {
	      if (this.ownerNode instanceof Ci.nsIDOMHTMLDocument) {
	        docHref = this.ownerNode.location.href;
	      } else if (this.ownerNode.ownerDocument && this.ownerNode.ownerDocument.location) {
	        docHref = this.ownerNode.ownerDocument.location.href;
	      }
	    }

	    let form = {
	      actor: this.actorID, // actorID is set when this actor is added to a pool
	      href: this.href,
	      nodeHref: docHref,
	      disabled: this.rawSheet.disabled,
	      title: this.rawSheet.title,
	      system: !CssLogic.isContentStylesheet(this.rawSheet),
	      styleSheetIndex: this.styleSheetIndex
	    };

	    try {
	      form.ruleCount = this.rawSheet.cssRules.length;
	    } catch (e) {
	      // stylesheet had an @import rule that wasn't loaded yet
	      this.getCSSRules().then(function () {
	        _this2._notifyPropertyChanged("ruleCount");
	      });
	    }
	    return form;
	  },

	  /**
	   * Toggle the disabled property of the style sheet
	   *
	   * @return {object}
	   *         'disabled' - the disabled state after toggling.
	   */
	  toggleDisabled: method(function () {
	    this.rawSheet.disabled = !this.rawSheet.disabled;
	    this._notifyPropertyChanged("disabled");

	    return this.rawSheet.disabled;
	  }, {
	    response: { disabled: RetVal("boolean") }
	  }),

	  /**
	   * Send an event notifying that a property of the stylesheet
	   * has changed.
	   *
	   * @param  {string} property
	   *         Name of the changed property
	   */
	  _notifyPropertyChanged: function (property) {
	    events.emit(this, "property-change", property, this.form()[property]);
	  },

	  /**
	   * Protocol method to get the text of this stylesheet.
	   */
	  getText: method(function () {
	    var _this3 = this;

	    return this._getText().then(function (text) {
	      return new LongStringActor(_this3.conn, text || "");
	    });
	  }, {
	    response: {
	      text: RetVal("longstring")
	    }
	  }),

	  /**
	   * Fetch the text for this stylesheet from the cache or network. Return
	   * cached text if it's already been fetched.
	   *
	   * @return {Promise}
	   *         Promise that resolves with a string text of the stylesheet.
	   */
	  _getText: function () {
	    var _this4 = this;

	    if (typeof this.text === "string") {
	      return promise.resolve(this.text);
	    }

	    let cssText = modifiedStyleSheets.get(this.rawSheet);
	    if (cssText !== undefined) {
	      this.text = cssText;
	      return promise.resolve(cssText);
	    }

	    if (!this.href) {
	      // this is an inline <style> sheet
	      let content = this.ownerNode.textContent;
	      this.text = content;
	      return promise.resolve(content);
	    }

	    let options = {
	      loadFromCache: true,
	      policy: Ci.nsIContentPolicy.TYPE_INTERNAL_STYLESHEET,
	      window: this.window,
	      charset: this._getCSSCharset()
	    };

	    return fetch(this.href, options).then(function ({ content }) {
	      _this4.text = content;
	      return content;
	    });
	  },

	  /**
	   * Protocol method to get the original source (actors) for this
	   * stylesheet if it has uses source maps.
	   */
	  getOriginalSources: method(function () {
	    if (this._originalSources) {
	      return promise.resolve(this._originalSources);
	    }
	    return this._fetchOriginalSources();
	  }, {
	    request: {},
	    response: {
	      originalSources: RetVal("nullable:array:originalsource")
	    }
	  }),

	  /**
	   * Fetch the original sources (actors) for this style sheet using its
	   * source map. If they've already been fetched, returns cached array.
	   *
	   * @return {Promise}
	   *         Promise that resolves with an array of OriginalSourceActors
	   */
	  _fetchOriginalSources: function () {
	    var _this5 = this;

	    this._clearOriginalSources();
	    this._originalSources = [];

	    return this.getSourceMap().then(function (sourceMap) {
	      if (!sourceMap) {
	        return null;
	      }
	      for (let url of sourceMap.sources) {
	        let actor = new OriginalSourceActor(url, sourceMap, _this5);

	        _this5.manage(actor);
	        _this5._originalSources.push(actor);
	      }
	      return _this5._originalSources;
	    });
	  },

	  /**
	   * Get the SourceMapConsumer for this stylesheet's source map, if
	   * it exists. Saves the consumer for later queries.
	   *
	   * @return {Promise}
	   *         A promise that resolves with a SourceMapConsumer, or null.
	   */
	  getSourceMap: function () {
	    if (this._sourceMap) {
	      return this._sourceMap;
	    }
	    return this._fetchSourceMap();
	  },

	  /**
	   * Fetch the source map for this stylesheet.
	   *
	   * @return {Promise}
	   *         A promise that resolves with a SourceMapConsumer, or null.
	   */
	  _fetchSourceMap: function () {
	    var _this6 = this;

	    let deferred = promise.defer();

	    this._getText().then(function (content) {
	      let url = _this6._extractSourceMapUrl(content);
	      if (!url) {
	        // no source map for this stylesheet
	        deferred.resolve(null);
	        return;
	      };

	      url = normalize(url, _this6.href);
	      let options = {
	        loadFromCache: false,
	        policy: Ci.nsIContentPolicy.TYPE_INTERNAL_STYLESHEET,
	        window: _this6.window
	      };
	      let map = fetch(url, options).then(function ({ content }) {
	        let map = new SourceMapConsumer(content);
	        _this6._setSourceMapRoot(map, url, _this6.href);
	        _this6._sourceMap = promise.resolve(map);

	        deferred.resolve(map);
	        return map;
	      }, deferred.reject);

	      _this6._sourceMap = map;
	    }, deferred.reject);

	    return deferred.promise;
	  },

	  /**
	   * Clear and unmanage the original source actors for this stylesheet.
	   */
	  _clearOriginalSources: function () {
	    for (actor in this._originalSources) {
	      this.unmanage(actor);
	    }
	    this._originalSources = null;
	  },

	  /**
	   * Sets the source map's sourceRoot to be relative to the source map url.
	   */
	  _setSourceMapRoot: function (aSourceMap, aAbsSourceMapURL, aScriptURL) {
	    const base = dirname(aAbsSourceMapURL.startsWith("data:") ? aScriptURL : aAbsSourceMapURL);
	    aSourceMap.sourceRoot = aSourceMap.sourceRoot ? normalize(aSourceMap.sourceRoot, base) : base;
	  },

	  /**
	   * Get the source map url specified in the text of a stylesheet.
	   *
	   * @param  {string} content
	   *         The text of the style sheet.
	   * @return {string}
	   *         Url of source map.
	   */
	  _extractSourceMapUrl: function (content) {
	    var matches = /sourceMappingURL\=([^\s\*]*)/.exec(content);
	    if (matches) {
	      return matches[1];
	    }
	    return null;
	  },

	  /**
	   * Protocol method that gets the location in the original source of a
	   * line, column pair in this stylesheet, if its source mapped, otherwise
	   * a promise of the same location.
	   */
	  getOriginalLocation: method(function (line, column) {
	    var _this7 = this;

	    return this.getSourceMap().then(function (sourceMap) {
	      if (sourceMap) {
	        return sourceMap.originalPositionFor({ line: line, column: column });
	      }
	      return {
	        fromSourceMap: false,
	        source: _this7.href,
	        line: line,
	        column: column
	      };
	    });
	  }, {
	    request: {
	      line: Arg(0, "number"),
	      column: Arg(1, "number")
	    },
	    response: RetVal(types.addDictType("originallocationresponse", {
	      source: "string",
	      line: "number",
	      column: "number"
	    }))
	  }),

	  /**
	   * Protocol method to get the media rules for the stylesheet.
	   */
	  getMediaRules: method(function () {
	    return this._getMediaRules();
	  }, {
	    request: {},
	    response: {
	      mediaRules: RetVal("nullable:array:mediarule")
	    }
	  }),

	  /**
	   * Get all the @media rules in this stylesheet.
	   *
	   * @return {promise}
	   *         A promise that resolves with an array of MediaRuleActors.
	   */
	  _getMediaRules: function () {
	    var _this8 = this;

	    return this.getCSSRules().then(function (rules) {
	      let mediaRules = [];
	      for (let i = 0; i < rules.length; i++) {
	        let rule = rules[i];
	        if (rule.type != Ci.nsIDOMCSSRule.MEDIA_RULE) {
	          continue;
	        }
	        let actor = new MediaRuleActor(rule, _this8);
	        _this8.manage(actor);

	        mediaRules.push(actor);
	      }
	      return mediaRules;
	    });
	  },

	  /**
	   * Get the charset of the stylesheet according to the character set rules
	   * defined in <http://www.w3.org/TR/CSS2/syndata.html#charset>.
	   *
	   * @param string channelCharset
	   *        Charset of the source string if set by the HTTP channel.
	   */
	  _getCSSCharset: function (channelCharset) {
	    // StyleSheet's charset can be specified from multiple sources
	    if (channelCharset && channelCharset.length > 0) {
	      // step 1 of syndata.html: charset given in HTTP header.
	      return channelCharset;
	    }

	    let sheet = this.rawSheet;
	    if (sheet) {
	      // Do we have a @charset rule in the stylesheet?
	      // step 2 of syndata.html (without the BOM check).
	      if (sheet.cssRules) {
	        let rules = sheet.cssRules;
	        if (rules.length && rules.item(0).type == Ci.nsIDOMCSSRule.CHARSET_RULE) {
	          return rules.item(0).encoding;
	        }
	      }

	      // step 3: charset attribute of <link> or <style> element, if it exists
	      if (sheet.ownerNode && sheet.ownerNode.getAttribute) {
	        let linkCharset = sheet.ownerNode.getAttribute("charset");
	        if (linkCharset != null) {
	          return linkCharset;
	        }
	      }

	      // step 4 (1 of 2): charset of referring stylesheet.
	      let parentSheet = sheet.parentStyleSheet;
	      if (parentSheet && parentSheet.cssRules && parentSheet.cssRules[0].type == Ci.nsIDOMCSSRule.CHARSET_RULE) {
	        return parentSheet.cssRules[0].encoding;
	      }

	      // step 4 (2 of 2): charset of referring document.
	      if (sheet.ownerNode && sheet.ownerNode.ownerDocument.characterSet) {
	        return sheet.ownerNode.ownerDocument.characterSet;
	      }
	    }

	    // step 5: default to utf-8.
	    return "UTF-8";
	  },

	  /**
	   * Update the style sheet in place with new text.
	   *
	   * @param  {object} request
	   *         'text' - new text
	   *         'transition' - whether to do CSS transition for change.
	   *         'kind' - either UPDATE_PRESERVING_RULES or UPDATE_GENERAL
	   */
	  update: method(function (text, transition, kind = UPDATE_GENERAL) {
	    var _this9 = this;

	    DOMUtils.parseStyleSheet(this.rawSheet, text);

	    modifiedStyleSheets.set(this.rawSheet, text);

	    this.text = text;

	    this._notifyPropertyChanged("ruleCount");

	    if (transition) {
	      this._insertTransistionRule(kind);
	    } else {
	      events.emit(this, "style-applied", kind, this);
	    }

	    this._getMediaRules().then(function (rules) {
	      events.emit(_this9, "media-rules-changed", rules);
	    });
	  }, {
	    request: {
	      text: Arg(0, "string"),
	      transition: Arg(1, "boolean")
	    }
	  }),

	  /**
	   * Insert a catch-all transition rule into the document. Set a timeout
	   * to remove the rule after a certain time.
	   */
	  _insertTransistionRule: function (kind) {
	    this.document.documentElement.classList.add(TRANSITION_CLASS);

	    // We always add the rule since we've just reset all the rules
	    this.rawSheet.insertRule(TRANSITION_RULE, this.rawSheet.cssRules.length);

	    // Set up clean up and commit after transition duration (+buffer)
	    // @see _onTransitionEnd
	    this.window.clearTimeout(this._transitionTimeout);
	    this._transitionTimeout = this.window.setTimeout(this._onTransitionEnd.bind(this, kind), TRANSITION_DURATION_MS + TRANSITION_BUFFER_MS);
	  },

	  /**
	   * This cleans up class and rule added for transition effect and then
	   * notifies that the style has been applied.
	   */
	  _onTransitionEnd: function (kind) {
	    this.document.documentElement.classList.remove(TRANSITION_CLASS);

	    let index = this.rawSheet.cssRules.length - 1;
	    let rule = this.rawSheet.cssRules[index];
	    if (rule.selectorText == TRANSITION_RULE_SELECTOR) {
	      this.rawSheet.deleteRule(index);
	    }

	    events.emit(this, "style-applied", kind, this);
	  }
	});

	/**
	 * StyleSheetFront is the client-side counterpart to a StyleSheetActor.
	 */
	var StyleSheetFront = protocol.FrontClass(StyleSheetActor, {
	  initialize: function (conn, form) {
	    protocol.Front.prototype.initialize.call(this, conn, form);

	    this._onPropertyChange = this._onPropertyChange.bind(this);
	    events.on(this, "property-change", this._onPropertyChange);
	  },

	  destroy: function () {
	    events.off(this, "property-change", this._onPropertyChange);
	    protocol.Front.prototype.destroy.call(this);
	  },

	  _onPropertyChange: function (property, value) {
	    this._form[property] = value;
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	  },

	  get href() {
	    return this._form.href;
	  },
	  get nodeHref() {
	    return this._form.nodeHref;
	  },
	  get disabled() {
	    return !!this._form.disabled;
	  },
	  get title() {
	    return this._form.title;
	  },
	  get isSystem() {
	    return this._form.system;
	  },
	  get styleSheetIndex() {
	    return this._form.styleSheetIndex;
	  },
	  get ruleCount() {
	    return this._form.ruleCount;
	  },

	  /**
	   * Get the indentation to use for edits to this style sheet.
	   *
	   * @return {Promise} A promise that will resolve to a string that
	   * should be used to indent a block in this style sheet.
	   */
	  guessIndentation: function () {
	    let prefIndent = getIndentationFromPrefs();
	    if (prefIndent) {
	      let indentUnit = prefIndent.indentUnit;
	      let indentWithTabs = prefIndent.indentWithTabs;

	      return promise.resolve(indentWithTabs ? "\t" : " ".repeat(indentUnit));
	    }

	    return Task.spawn((function* () {
	      let longStr = yield this.getText();
	      let source = yield longStr.string();

	      var _getIndentationFromSt = getIndentationFromString(source);

	      let indentUnit = _getIndentationFromSt.indentUnit;
	      let indentWithTabs = _getIndentationFromSt.indentWithTabs;

	      return indentWithTabs ? "\t" : " ".repeat(indentUnit);
	    }).bind(this));
	  }
	});

	/**
	 * Actor representing an original source of a style sheet that was specified
	 * in a source map.
	 */
	var OriginalSourceActor = protocol.ActorClass({
	  typeName: "originalsource",

	  initialize: function (aUrl, aSourceMap, aParentActor) {
	    protocol.Actor.prototype.initialize.call(this, null);

	    this.url = aUrl;
	    this.sourceMap = aSourceMap;
	    this.parentActor = aParentActor;
	    this.conn = this.parentActor.conn;

	    this.text = null;
	  },

	  form: function () {
	    return {
	      actor: this.actorID, // actorID is set when it's added to a pool
	      url: this.url,
	      relatedStyleSheet: this.parentActor.form()
	    };
	  },

	  _getText: function () {
	    var _this10 = this;

	    if (this.text) {
	      return promise.resolve(this.text);
	    }
	    let content = this.sourceMap.sourceContentFor(this.url);
	    if (content) {
	      this.text = content;
	      return promise.resolve(content);
	    }
	    let options = {
	      policy: Ci.nsIContentPolicy.TYPE_INTERNAL_STYLESHEET,
	      window: this.window
	    };
	    return fetch(this.url, options).then(function ({ content }) {
	      _this10.text = content;
	      return content;
	    });
	  },

	  /**
	   * Protocol method to get the text of this source.
	   */
	  getText: method(function () {
	    var _this11 = this;

	    return this._getText().then(function (text) {
	      return new LongStringActor(_this11.conn, text || "");
	    });
	  }, {
	    response: {
	      text: RetVal("longstring")
	    }
	  })
	});

	/**
	 * The client-side counterpart for an OriginalSourceActor.
	 */
	var OriginalSourceFront = protocol.FrontClass(OriginalSourceActor, {
	  initialize: function (client, form) {
	    protocol.Front.prototype.initialize.call(this, client, form);

	    this.isOriginalSource = true;
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	  },

	  get href() {
	    return this._form.url;
	  },
	  get url() {
	    return this._form.url;
	  }
	});

	XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
	  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
	});

	exports.StyleSheetsActor = StyleSheetsActor;
	exports.StyleSheetsFront = StyleSheetsFront;

	exports.StyleSheetActor = StyleSheetActor;
	exports.StyleSheetFront = StyleSheetFront;

	/**
	 * Normalize multiple relative paths towards the base paths on the right.
	 */
	function normalize(...aURLs) {
	  let base = Services.io.newURI(aURLs.pop(), null, null);
	  let url;
	  while (url = aURLs.pop()) {
	    base = Services.io.newURI(url, null, base);
	  }
	  return base.spec;
	}

	function dirname(aPath) {
	  return Services.io.newURI(".", null, Services.io.newURI(aPath, null, null)).spec;
	}

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict"

	/**
	 * Helpers for async functions. Async functions are generator functions that are
	 * run by Tasks. An async function returns a Promise for the resolution of the
	 * function. When the function returns, the promise is resolved with the
	 * returned value. If it throws the promise rejects with the thrown error.
	 *
	 * See Task documentation at https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Task.jsm.
	 */

	;

	var _require = __webpack_require__(1);

	var Cu = _require.Cu;

	var _require2 = __webpack_require__(38);

	const Task = _require2.Task;

	var Promise = __webpack_require__(6);

	/**
	 * Create an async function that only executes once per instance of an object.
	 * Once called on a given object, the same promise will be returned for any
	 * future calls for that object.
	 *
	 * @param Function func
	 *        The generator function that to wrap as an async function.
	 * @return Function
	 *         The async function.
	 */
	exports.asyncOnce = function asyncOnce(func) {
	  const promises = new WeakMap();
	  return function (...args) {
	    let promise = promises.get(this);
	    if (!promise) {
	      promise = Task.spawn(func.apply(this, args));
	      promises.set(this, promise);
	    }
	    return promise;
	  };
	};

	/**
	 * Adds an event listener to the given element, and then removes its event
	 * listener once the event is called, returning the event object as a promise.
	 * @param  nsIDOMElement element
	 *         The DOM element to listen on
	 * @param  String event
	 *         The name of the event type to listen for
	 * @param  Boolean useCapture
	 *         Should we initiate the capture phase?
	 * @return Promise
	 *         The promise resolved with the event object when the event first
	 *         happens
	 */
	exports.listenOnce = function listenOnce(element, event, useCapture) {
	  return new Promise(function (resolve, reject) {
	    var onEvent = function (ev) {
	      element.removeEventListener(event, onEvent, useCapture);
	      resolve(ev);
	    };
	    element.addEventListener(event, onEvent, useCapture);
	  });
	};

	/**
	 * Call a function that expects a callback as the last argument and returns a
	 * promise for the result. This simplifies using callback APIs from tasks and
	 * async functions.
	 *
	 * @param Any obj
	 *        The |this| value to call the function on.
	 * @param Function func
	 *        The callback-expecting function to call.
	 * @param Array args
	 *        Additional arguments to pass to the method.
	 * @return Promise
	 *         The promise for the result. If the callback is called with only one
	 *         argument, it is used as the resolution value. If there's multiple
	 *         arguments, an array containing the arguments is the resolution value.
	 *         If the method throws, the promise is rejected with the thrown value.
	 */
	function promisify(obj, func, args) {
	  return new Promise(function (resolve) {
	    args.push(function (...results) {
	      resolve(results.length > 1 ? results : results[0]);
	    });
	    func.apply(obj, args);
	  });
	}

	/**
	 * Call a method that expects a callback as the last argument and returns a
	 * promise for the result.
	 *
	 * @see promisify
	 */
	exports.promiseInvoke = function promiseInvoke(obj, func, ...args) {
	  return promisify(obj, func, args);
	};

	/**
	 * Call a function that expects a callback as the last argument.
	 *
	 * @see promisify
	 */
	exports.promiseCall = function promiseCall(func, ...args) {
	  return promisify(undefined, func, args);
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Ci = _require.Ci;

	const EventEmitter = __webpack_require__(7);
	const events = __webpack_require__(25);
	const protocol = __webpack_require__(79);
	const Arg = protocol.Arg;
	const Option = protocol.Option;
	const method = protocol.method;
	const RetVal = protocol.RetVal;

	var _require2 = __webpack_require__(73);

	const isWindowIncluded = _require2.isWindowIncluded;
	/*const { isXUL, isNodeValid } = require("./highlighters/utils/markup");*/
	/*const { SimpleOutlineHighlighter } = require("./highlighters/simple-outline");*/

	const HIGHLIGHTER_PICKED_TIMER = 1000;

	/**
	 * The registration mechanism for highlighters provide a quick way to
	 * have modular highlighters, instead of a hard coded list.
	 * It allow us to split highlighers in sub modules, and add them dynamically
	 * using add-on (useful for 3rd party developers, or prototyping)
	 *
	 * Note that currently, highlighters added using add-ons, can only work on
	 * Firefox desktop, or Fennec if the same add-on is installed in both.
	 */
	const highlighterTypes = new Map();

	/**
	 * Returns `true` if a highlighter for the given `typeName` is registered,
	 * `false` otherwise.
	 */
	const isTypeRegistered = function (typeName) {
	  return highlighterTypes.has(typeName);
	};
	exports.isTypeRegistered = isTypeRegistered;

	/**
	 * Registers a given constructor as highlighter, for the `typeName` given.
	 * If no `typeName` is provided, is looking for a `typeName` property in
	 * the prototype's constructor.
	 */
	const register = function (constructor, typeName = constructor.prototype.typeName) {
	  if (!typeName) {
	    throw Error("No type's name found, or provided.");
	  }

	  if (highlighterTypes.has(typeName)) {
	    throw Error(`${ typeName } is already registered.`);
	  }

	  highlighterTypes.set(typeName, constructor);
	};
	exports.register = register;

	/**
	 * The Highlighter is the server-side entry points for any tool that wishes to
	 * highlight elements in some way in the content document.
	 *
	 * A little bit of vocabulary:
	 * - <something>HighlighterActor classes are the actors that can be used from
	 *   the client. They do very little else than instantiate a given
	 *   <something>Highlighter and use it to highlight elements.
	 * - <something>Highlighter classes aren't actors, they're just JS classes that
	 *   know how to create and attach the actual highlighter elements on top of the
	 *   content
	 *
	 * The most used highlighter actor is the HighlighterActor which can be
	 * conveniently retrieved via the InspectorActor's 'getHighlighter' method.
	 * The InspectorActor will always return the same instance of
	 * HighlighterActor if asked several times and this instance is used in the
	 * toolbox to highlighter elements's box-model from the markup-view,
	 * layout-view, console, debugger, ... as well as select elements with the
	 * pointer (pick).
	 *
	 * Other types of highlighter actors exist and can be accessed via the
	 * InspectorActor's 'getHighlighterByType' method.
	 */

	/**
	 * The HighlighterActor class
	 */
	var HighlighterActor = exports.HighlighterActor = protocol.ActorClass({
	  typeName: "highlighter",

	  initialize: function (inspector, autohide) {
	    protocol.Actor.prototype.initialize.call(this, null);

	    this._autohide = autohide;
	    this._inspector = inspector;
	    this._walker = this._inspector.walker;
	    this._tabActor = this._inspector.tabActor;
	    this._highlighterEnv = new HighlighterEnvironment();
	    this._highlighterEnv.initFromTabActor(this._tabActor);

	    this._highlighterReady = this._highlighterReady.bind(this);
	    this._highlighterHidden = this._highlighterHidden.bind(this);
	    this._onNavigate = this._onNavigate.bind(this);

	    this._createHighlighter();

	    // Listen to navigation events to switch from the BoxModelHighlighter to the
	    // SimpleOutlineHighlighter, and back, if the top level window changes.
	    events.on(this._tabActor, "navigate", this._onNavigate);
	  },

	  get conn() {
	    return this._inspector && this._inspector.conn;
	  },

	  form: function () {
	    return {
	      actor: this.actorID,
	      traits: {
	        autoHideOnDestroy: true
	      }
	    };
	  },

	  _createHighlighter: function () {
	    this._isPreviousWindowXUL = isXUL(this._tabActor.window);

	    if (!this._isPreviousWindowXUL) {
	      this._highlighter = new BoxModelHighlighter(this._highlighterEnv, this._inspector);
	      this._highlighter.on("ready", this._highlighterReady);
	      this._highlighter.on("hide", this._highlighterHidden);
	    } else {
	      this._highlighter = new SimpleOutlineHighlighter(this._highlighterEnv);
	    }
	  },

	  _destroyHighlighter: function () {
	    if (this._highlighter) {
	      if (!this._isPreviousWindowXUL) {
	        this._highlighter.off("ready", this._highlighterReady);
	        this._highlighter.off("hide", this._highlighterHidden);
	      }
	      this._highlighter.destroy();
	      this._highlighter = null;
	    }
	  },

	  _onNavigate: function ({ isTopLevel }) {
	    // Skip navigation events for non top-level windows, or if the document
	    // doesn't exist anymore.
	    if (!isTopLevel || !this._tabActor.window.document.documentElement) {
	      return;
	    }

	    // Only rebuild the highlighter if the window type changed.
	    if (isXUL(this._tabActor.window) !== this._isPreviousWindowXUL) {
	      this._destroyHighlighter();
	      this._createHighlighter();
	    }
	  },

	  destroy: function () {
	    protocol.Actor.prototype.destroy.call(this);

	    this.hideBoxModel();
	    this._destroyHighlighter();
	    events.off(this._tabActor, "navigate", this._onNavigate);

	    this._highlighterEnv.destroy();
	    this._highlighterEnv = null;

	    this._autohide = null;
	    this._inspector = null;
	    this._walker = null;
	    this._tabActor = null;
	  },

	  /**
	   * Display the box model highlighting on a given NodeActor.
	   * There is only one instance of the box model highlighter, so calling this
	   * method several times won't display several highlighters, it will just move
	   * the highlighter instance to these nodes.
	   *
	   * @param NodeActor The node to be highlighted
	   * @param Options See the request part for existing options. Note that not
	   * all options may be supported by all types of highlighters.
	   */
	  showBoxModel: method(function (node, options = {}) {
	    if (node && isNodeValid(node.rawNode)) {
	      this._highlighter.show(node.rawNode, options);
	    } else {
	      this._highlighter.hide();
	    }
	  }, {
	    request: {
	      node: Arg(0, "domnode"),
	      region: Option(1),
	      hideInfoBar: Option(1),
	      hideGuides: Option(1),
	      showOnly: Option(1),
	      onlyRegionArea: Option(1)
	    }
	  }),

	  /**
	   * Hide the box model highlighting if it was shown before
	   */
	  hideBoxModel: method(function () {
	    this._highlighter.hide();
	  }, {
	    request: {}
	  }),

	  /**
	   * Returns `true` if the event was dispatched from a window included in
	   * the current highlighter environment; or if the highlighter environment has
	   * chrome privileges
	   *
	   * The method is specifically useful on B2G, where we do not want that events
	   * from app or main process are processed if we're inspecting the content.
	   *
	   * @param {Event} event
	   *          The event to allow
	   * @return {Boolean}
	   */
	  _isEventAllowed: function ({ view }) {
	    let window = this._highlighterEnv.window;

	    return window instanceof Ci.nsIDOMChromeWindow || isWindowIncluded(window, view);
	  },

	  /**
	   * Pick a node on click, and highlight hovered nodes in the process.
	   *
	   * This method doesn't respond anything interesting, however, it starts
	   * mousemove, and click listeners on the content document to fire
	   * events and let connected clients know when nodes are hovered over or
	   * clicked.
	   *
	   * Once a node is picked, events will cease, and listeners will be removed.
	   */
	  _isPicking: false,
	  _hoveredNode: null,
	  _currentNode: null,

	  pick: method(function () {
	    var _this = this;

	    if (this._isPicking) {
	      return null;
	    }
	    this._isPicking = true;

	    this._preventContentEvent = function (event) {
	      event.stopPropagation();
	      event.preventDefault();
	    };

	    this._onPick = function (event) {
	      _this._preventContentEvent(event);

	      if (!_this._isEventAllowed(event)) {
	        return;
	      }

	      _this._stopPickerListeners();
	      _this._isPicking = false;
	      if (_this._autohide) {
	        _this._tabActor.window.setTimeout(function () {
	          _this._highlighter.hide();
	        }, HIGHLIGHTER_PICKED_TIMER);
	      }
	      if (!_this._currentNode) {
	        _this._currentNode = _this._findAndAttachElement(event);
	      }
	      events.emit(_this._walker, "picker-node-picked", _this._currentNode);
	    };

	    this._onHovered = function (event) {
	      _this._preventContentEvent(event);

	      if (!_this._isEventAllowed(event)) {
	        return;
	      }

	      _this._currentNode = _this._findAndAttachElement(event);
	      if (_this._hoveredNode !== _this._currentNode.node) {
	        _this._highlighter.show(_this._currentNode.node.rawNode);
	        events.emit(_this._walker, "picker-node-hovered", _this._currentNode);
	        _this._hoveredNode = _this._currentNode.node;
	      }
	    };

	    this._onKey = function (event) {
	      if (!_this._currentNode || !_this._isPicking) {
	        return;
	      }

	      _this._preventContentEvent(event);

	      if (!_this._isEventAllowed(event)) {
	        return;
	      }

	      let currentNode = _this._currentNode.node.rawNode;

	      /**
	       * KEY: Action/scope
	       * LEFT_KEY: wider or parent
	       * RIGHT_KEY: narrower or child
	       * ENTER/CARRIAGE_RETURN: Picks currentNode
	       * ESC: Cancels picker, picks currentNode
	       */
	      switch (event.keyCode) {
	        // Wider.
	        case Ci.nsIDOMKeyEvent.DOM_VK_LEFT:
	          if (!currentNode.parentElement) {
	            return;
	          }
	          currentNode = currentNode.parentElement;
	          break;

	        // Narrower.
	        case Ci.nsIDOMKeyEvent.DOM_VK_RIGHT:
	          if (!currentNode.children.length) {
	            return;
	          }

	          // Set firstElementChild by default
	          let child = currentNode.firstElementChild;
	          // If currentNode is parent of hoveredNode, then
	          // previously selected childNode is set
	          let hoveredNode = _this._hoveredNode.rawNode;
	          for (let sibling of currentNode.children) {
	            if (sibling.contains(hoveredNode) || sibling === hoveredNode) {
	              child = sibling;
	            }
	          }

	          currentNode = child;
	          break;

	        // Select the element.
	        case Ci.nsIDOMKeyEvent.DOM_VK_RETURN:
	          _this._onPick(event);
	          return;

	        // Cancel pick mode.
	        case Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE:
	          _this.cancelPick();
	          events.emit(_this._walker, "picker-node-canceled");
	          return;

	        default:
	          return;
	      }

	      // Store currently attached element
	      _this._currentNode = _this._walker.attachElement(currentNode);
	      _this._highlighter.show(_this._currentNode.node.rawNode);
	      events.emit(_this._walker, "picker-node-hovered", _this._currentNode);
	    };

	    this._tabActor.window.focus();
	    this._startPickerListeners();

	    return null;
	  }),

	  _findAndAttachElement: function (event) {
	    // originalTarget allows access to the "real" element before any retargeting
	    // is applied, such as in the case of XBL anonymous elements.  See also
	    // https://developer.mozilla.org/docs/XBL/XBL_1.0_Reference/Anonymous_Content#Event_Flow_and_Targeting
	    let node = event.originalTarget || event.target;
	    return this._walker.attachElement(node);
	  },

	  _startPickerListeners: function () {
	    let target = this._highlighterEnv.pageListenerTarget;
	    target.addEventListener("mousemove", this._onHovered, true);
	    target.addEventListener("click", this._onPick, true);
	    target.addEventListener("mousedown", this._preventContentEvent, true);
	    target.addEventListener("mouseup", this._preventContentEvent, true);
	    target.addEventListener("dblclick", this._preventContentEvent, true);
	    target.addEventListener("keydown", this._onKey, true);
	    target.addEventListener("keyup", this._preventContentEvent, true);
	  },

	  _stopPickerListeners: function () {
	    let target = this._highlighterEnv.pageListenerTarget;
	    target.removeEventListener("mousemove", this._onHovered, true);
	    target.removeEventListener("click", this._onPick, true);
	    target.removeEventListener("mousedown", this._preventContentEvent, true);
	    target.removeEventListener("mouseup", this._preventContentEvent, true);
	    target.removeEventListener("dblclick", this._preventContentEvent, true);
	    target.removeEventListener("keydown", this._onKey, true);
	    target.removeEventListener("keyup", this._preventContentEvent, true);
	  },

	  _highlighterReady: function () {
	    events.emit(this._inspector.walker, "highlighter-ready");
	  },

	  _highlighterHidden: function () {
	    events.emit(this._inspector.walker, "highlighter-hide");
	  },

	  cancelPick: method(function () {
	    if (this._isPicking) {
	      this._highlighter.hide();
	      this._stopPickerListeners();
	      this._isPicking = false;
	      this._hoveredNode = null;
	    }
	  })
	});

	var HighlighterFront = protocol.FrontClass(HighlighterActor, {
	  // Update the object given a form representation off the wire.
	  form: function (json) {
	    this.actorID = json.actor;
	    // FF42+ HighlighterActors starts exposing custom form, with traits object
	    this.traits = json.traits || {};
	  }
	});

	/**
	 * A generic highlighter actor class that instantiate a highlighter given its
	 * type name and allows to show/hide it.
	 */
	var CustomHighlighterActor = exports.CustomHighlighterActor = protocol.ActorClass({
	  typeName: "customhighlighter",

	  /**
	   * Create a highlighter instance given its typename
	   * The typename must be one of HIGHLIGHTER_CLASSES and the class must
	   * implement constructor(tabActor), show(node), hide(), destroy()
	   */
	  initialize: function (inspector, typeName) {
	    protocol.Actor.prototype.initialize.call(this, null);

	    this._inspector = inspector;

	    let constructor = highlighterTypes.get(typeName);
	    if (!constructor) {
	      let list = [...highlighterTypes.keys()];

	      throw new Error(`${ typeName } isn't a valid highlighter class (${ list })`);
	    }

	    // The assumption is that all custom highlighters need the canvasframe
	    // container to append their elements, so if this is a XUL window, bail out.
	    if (!isXUL(this._inspector.tabActor.window)) {
	      this._highlighterEnv = new HighlighterEnvironment();
	      this._highlighterEnv.initFromTabActor(inspector.tabActor);
	      this._highlighter = new constructor(this._highlighterEnv);
	    } else {
	      throw new Error("Custom " + typeName + "highlighter cannot be created in a XUL window");
	    }
	  },

	  get conn() {
	    return this._inspector && this._inspector.conn;
	  },

	  destroy: function () {
	    protocol.Actor.prototype.destroy.call(this);
	    this.finalize();
	    this._inspector = null;
	  },

	  /**
	   * Show the highlighter.
	   * This calls through to the highlighter instance's |show(node, options)|
	   * method.
	   *
	   * Most custom highlighters are made to highlight DOM nodes, hence the first
	   * NodeActor argument (NodeActor as in
	   * devtools/server/actor/inspector).
	   * Note however that some highlighters use this argument merely as a context
	   * node: the RectHighlighter for instance uses it to calculate the absolute
	   * position of the provided rect. The SelectHighlighter uses it as a base node
	   * to run the provided CSS selector on.
	   *
	   * @param {NodeActor} The node to be highlighted
	   * @param {Object} Options for the custom highlighter
	   * @return {Boolean} True, if the highlighter has been successfully shown
	   * (FF41+)
	   */
	  show: method(function (node, options) {
	    if (!node || !isNodeValid(node.rawNode) || !this._highlighter) {
	      return false;
	    }

	    return this._highlighter.show(node.rawNode, options);
	  }, {
	    request: {
	      node: Arg(0, "domnode"),
	      options: Arg(1, "nullable:json")
	    },
	    response: {
	      value: RetVal("nullable:boolean")
	    }
	  }),

	  /**
	   * Hide the highlighter if it was shown before
	   */
	  hide: method(function () {
	    if (this._highlighter) {
	      this._highlighter.hide();
	    }
	  }, {
	    request: {}
	  }),

	  /**
	   * Kill this actor. This method is called automatically just before the actor
	   * is destroyed.
	   */
	  finalize: method(function () {
	    if (this._highlighter) {
	      this._highlighter.destroy();
	      this._highlighter = null;
	    }

	    if (this._highlighterEnv) {
	      this._highlighterEnv.destroy();
	      this._highlighterEnv = null;
	    }
	  }, {
	    oneway: true
	  })
	});

	var CustomHighlighterFront = protocol.FrontClass(CustomHighlighterActor, {});

	/**
	 * The HighlighterEnvironment is an object that holds all the required data for
	 * highlighters to work: the window, docShell, event listener target, ...
	 * It also emits "will-navigate" and "navigate" events, similarly to the
	 * TabActor.
	 *
	 * It can be initialized either from a TabActor (which is the most frequent way
	 * of using it, since highlighters are usually initialized by the
	 * HighlighterActor or CustomHighlighterActor, which have a tabActor reference).
	 * It can also be initialized just with a window object (which is useful for
	 * when a highlighter is used outside of the debugger server context, for
	 * instance from a gcli command).
	 */
	function HighlighterEnvironment() {
	  this.relayTabActorNavigate = this.relayTabActorNavigate.bind(this);
	  this.relayTabActorWillNavigate = this.relayTabActorWillNavigate.bind(this);

	  EventEmitter.decorate(this);
	}

	exports.HighlighterEnvironment = HighlighterEnvironment;

	HighlighterEnvironment.prototype = {
	  initFromTabActor: function (tabActor) {
	    this._tabActor = tabActor;
	    events.on(this._tabActor, "navigate", this.relayTabActorNavigate);
	    events.on(this._tabActor, "will-navigate", this.relayTabActorWillNavigate);
	  },

	  initFromWindow: function (win) {
	    this._win = win;

	    // We need a progress listener to know when the window will navigate/has
	    // navigated.
	    let self = this;
	    this.listener = {
	      QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener, Ci.nsISupportsWeakReference, Ci.nsISupports]),

	      onStateChange: function (progress, request, flag) {
	        let isStart = flag & Ci.nsIWebProgressListener.STATE_START;
	        let isStop = flag & Ci.nsIWebProgressListener.STATE_STOP;
	        let isWindow = flag & Ci.nsIWebProgressListener.STATE_IS_WINDOW;
	        let isDocument = flag & Ci.nsIWebProgressListener.STATE_IS_DOCUMENT;

	        if (progress.DOMWindow !== win) {
	          return;
	        }

	        if (isDocument && isStart) {
	          // One of the earliest events that tells us a new URI is being loaded
	          // in this window.
	          self.emit("will-navigate", {
	            window: win,
	            isTopLevel: true
	          });
	        }
	        if (isWindow && isStop) {
	          self.emit("navigate", {
	            window: win,
	            isTopLevel: true
	          });
	        }
	      }
	    };

	    this.webProgress.addProgressListener(this.listener, Ci.nsIWebProgress.NOTIFY_STATUS | Ci.nsIWebProgress.NOTIFY_STATE_WINDOW | Ci.nsIWebProgress.NOTIFY_STATE_DOCUMENT);
	  },

	  get isInitialized() {
	    return this._win || this._tabActor;
	  },

	  get window() {
	    if (!this.isInitialized) {
	      throw new Error("Initialize HighlighterEnvironment with a tabActor " + "or window first");
	    }
	    return this._tabActor ? this._tabActor.window : this._win;
	  },

	  get document() {
	    return this.window.document;
	  },

	  get docShell() {
	    return this.window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocShell);
	  },

	  get webProgress() {
	    return this.docShell.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebProgress);
	  },

	  /**
	   * Get the right target for listening to events on the page.
	   * - If the environment was initialized from a TabActor *and* if we're in the
	   *   Browser Toolbox (to inspect firefox desktop): the tabActor is the
	   *   RootActor, in which case, the window property can be used to listen to
	   *   events.
	   * - With firefox desktop, that tabActor is a BrowserTabActor, and with B2G,
	   *   a ContentActor (which overrides BrowserTabActor). In both cases we use
	   *   the chromeEventHandler which gives us a target we can use to listen to
	   *   events, even from nested iframes.
	   * - If the environment was initialized from a window, we also use the
	   *   chromeEventHandler.
	   */
	  get pageListenerTarget() {
	    if (this._tabActor && this._tabActor.isRootActor) {
	      return this.window;
	    }
	    return this.docShell.chromeEventHandler;
	  },

	  relayTabActorNavigate: function (data) {
	    this.emit("navigate", data);
	  },

	  relayTabActorWillNavigate: function (data) {
	    this.emit("will-navigate", data);
	  },

	  destroy: function () {
	    if (this._tabActor) {
	      events.off(this._tabActor, "navigate", this.relayTabActorNavigate);
	      events.off(this._tabActor, "will-navigate", this.relayTabActorWillNavigate);
	    }

	    // In case the environment was initialized from a window, we need to remove
	    // the progress listener.
	    if (this._win) {
	      try {
	        this.webProgress.removeProgressListener(this.listener);
	      } catch (e) {
	        // Which may fail in case the window was already destroyed.
	      }
	    }

	    this._tabActor = null;
	    this._win = null;
	  }
	};

	/*const { BoxModelHighlighter } = require("./highlighters/box-model");
	register(BoxModelHighlighter);
	exports.BoxModelHighlighter = BoxModelHighlighter;

	const { CssTransformHighlighter } = require("./highlighters/css-transform");
	register(CssTransformHighlighter);
	exports.CssTransformHighlighter = CssTransformHighlighter;

	const { SelectorHighlighter } = require("./highlighters/selector");
	register(SelectorHighlighter);
	exports.SelectorHighlighter = SelectorHighlighter;

	const { RectHighlighter } = require("./highlighters/rect");
	register(RectHighlighter);
	exports.RectHighlighter = RectHighlighter;

	const { GeometryEditorHighlighter } = require("./highlighters/geometry-editor");
	register(GeometryEditorHighlighter);
	exports.GeometryEditorHighlighter = GeometryEditorHighlighter;

	const { RulersHighlighter } = require("./highlighters/rulers");
	register(RulersHighlighter);
	exports.RulersHighlighter = RulersHighlighter;

	const { MeasuringToolHighlighter } = require("./highlighters/measuring-tool");
	register(MeasuringToolHighlighter);
	exports.MeasuringToolHighlighter = MeasuringToolHighlighter;*/

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// This file contains event parsers that are then used by developer tools in
	// order to find information about events affecting an HTML element.

	"use strict";

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	/*loader.lazyGetter(this, "eventListenerService", () => {
	  return Cc("@mozilla.org/eventlistenerservice;1")
	           .getService(Ci.nsIEventListenerService);
	});*/

	var parsers = [{
	  id: "jQuery events",
	  getListeners: function (node) {
	    let global = node.ownerGlobal.wrappedJSObject;
	    let hasJQuery = global.jQuery && global.jQuery.fn && global.jQuery.fn.jquery;

	    if (!hasJQuery) {
	      return;
	    }

	    let jQuery = global.jQuery;
	    let handlers = [];

	    // jQuery 1.2+
	    let data = jQuery._data || jQuery.data;
	    if (data) {
	      let eventsObj = data(node, "events");
	      for (let type in eventsObj) {
	        let events = eventsObj[type];
	        for (let key in events) {
	          let event = events[key];
	          if (typeof event === "object" || typeof event === "function") {
	            let eventInfo = {
	              type: type,
	              handler: event.handler || event,
	              tags: "jQuery",
	              hide: {
	                capturing: true,
	                dom0: true
	              }
	            };

	            handlers.push(eventInfo);
	          }
	        }
	      }
	    }

	    // JQuery 1.0 & 1.1
	    let entry = jQuery(node)[0];

	    if (!entry) {
	      return handlers;
	    }

	    for (let type in entry.events) {
	      let events = entry.events[type];
	      for (let key in events) {
	        if (typeof events[key] === "function") {
	          let eventInfo = {
	            type: type,
	            handler: events[key],
	            tags: "jQuery",
	            hide: {
	              capturing: true,
	              dom0: true
	            }
	          };

	          handlers.push(eventInfo);
	        }
	      }
	    }

	    return handlers;
	  }
	}, {
	  id: "jQuery live events",
	  hasListeners: function (node) {
	    return jQueryLiveGetListeners(node, true);
	  },
	  getListeners: function (node) {
	    return jQueryLiveGetListeners(node, false);
	  },
	  normalizeHandler: function (handlerDO) {
	    let paths = [[".event.proxy/", ".event.proxy/", "*"], [".proxy/", "*"]];

	    let name = handlerDO.displayName;

	    if (!name) {
	      return handlerDO;
	    }

	    for (let path of paths) {
	      if (name.includes(path[0])) {
	        path.splice(0, 1);

	        for (let point of path) {
	          let names = handlerDO.environment.names();

	          for (let varName of names) {
	            let temp = handlerDO.environment.getVariable(varName);
	            if (!temp) {
	              continue;
	            }

	            let displayName = temp.displayName;
	            if (!displayName) {
	              continue;
	            }

	            if (temp.class === "Function" && (displayName.includes(point) || point === "*")) {
	              handlerDO = temp;
	              break;
	            }
	          }
	        }
	        break;
	      }
	    }

	    return handlerDO;
	  }
	}, {
	  id: "DOM events",
	  hasListeners: function (node) {
	    let listeners;

	    if (node.nodeName.toLowerCase() === "html") {
	      listeners = eventListenerService.getListenerInfoFor(node.ownerGlobal) || [];
	    } else {
	      listeners = eventListenerService.getListenerInfoFor(node) || [];
	    }

	    for (let listener of listeners) {
	      if (listener.listenerObject && listener.type) {
	        return true;
	      }
	    }

	    return false;
	  },
	  getListeners: function (node) {
	    let handlers = [];
	    let listeners = eventListenerService.getListenerInfoFor(node);

	    // The Node actor's getEventListenerInfo knows that when an html tag has
	    // been passed we need the window object so we don't need to account for
	    // event hoisting here as we did in hasListeners.

	    for (let listenerObj of listeners) {
	      let listener = listenerObj.listenerObject;

	      // If there is no JS event listener skip this.
	      if (!listener) {
	        continue;
	      }

	      let eventInfo = {
	        capturing: listenerObj.capturing,
	        type: listenerObj.type,
	        handler: listener
	      };

	      handlers.push(eventInfo);
	    }

	    return handlers;
	  }
	}];

	function jQueryLiveGetListeners(node, boolOnEventFound) {
	  let global = node.ownerGlobal.wrappedJSObject;
	  let hasJQuery = global.jQuery && global.jQuery.fn && global.jQuery.fn.jquery;

	  if (!hasJQuery) {
	    return;
	  }

	  let jQuery = global.jQuery;
	  let handlers = [];
	  let data = jQuery._data || jQuery.data;

	  if (data) {
	    // Live events are added to the document and bubble up to all elements.
	    // Any element matching the specified selector will trigger the live
	    // event.
	    let events = data(global.document, "events");

	    for (let type in events) {
	      let eventHolder = events[type];

	      for (let idx in eventHolder) {
	        if (typeof idx !== "string" || isNaN(parseInt(idx, 10))) {
	          continue;
	        }

	        let event = eventHolder[idx];
	        let selector = event.selector;

	        if (!selector && event.data) {
	          selector = event.data.selector || event.data || event.selector;
	        }

	        if (!selector || !node.ownerDocument) {
	          continue;
	        }

	        let matches;
	        try {
	          matches = node.matches && node.matches(selector);
	        } catch (e) {
	          // Invalid selector, do nothing.
	        }

	        if (boolOnEventFound && matches) {
	          return true;
	        }

	        if (!matches) {
	          continue;
	        }

	        if (!boolOnEventFound && (typeof event === "object" || typeof event === "function")) {
	          let eventInfo = {
	            type: event.origType || event.type.substr(selector.length + 1),
	            handler: event.handler || event,
	            tags: "jQuery,Live",
	            hide: {
	              dom0: true,
	              capturing: true
	            }
	          };

	          if (!eventInfo.type && event.data && event.data.live) {
	            eventInfo.type = event.data.live;
	          }

	          handlers.push(eventInfo);
	        }
	      }
	    }
	  }

	  if (boolOnEventFound) {
	    return false;
	  }
	  return handlers;
	}

	let EventParsers = this.EventParsers = function () {
	  if (this._eventParsers.size === 0) {
	    for (let parserObj of parsers) {
	      this.registerEventParser(parserObj);
	    }
	  }
	};

	exports.EventParsers = EventParsers;

	EventParsers.prototype = {
	  _eventParsers: new Map(), // NOTE: This is shared amongst all instances.

	  get parsers() {
	    return this._eventParsers;
	  },

	  /**
	   * Register a new event parser to be used in the processing of event info.
	   *
	   * @param {Object} parserObj
	   *        Each parser must contain the following properties:
	   *        - parser, which must take the following form:
	   *   {
	   *     id {String}: "jQuery events",         // Unique id.
	   *     getListeners: function(node) { },     // Function that takes a node and
	   *                                           // returns an array of eventInfo
	   *                                           // objects (see below).
	   *
	   *     hasListeners: function(node) { },     // Optional function that takes a
	   *                                           // node and returns a boolean
	   *                                           // indicating whether a node has
	   *                                           // listeners attached.
	   *
	   *     normalizeHandler: function(fnDO) { }, // Optional function that takes a
	   *                                           // Debugger.Object instance and
	   *                                           // climbs the scope chain to get
	   *                                           // the function that should be
	   *                                           // displayed in the event bubble
	   *                                           // see the following url for
	   *                                           // details:
	   *                                           //   https://developer.mozilla.org/
	   *                                           //   docs/Tools/Debugger-API/
	   *                                           //   Debugger.Object
	   *   }
	   *
	   * An eventInfo object should take the following form:
	   *   {
	   *     type {String}:      "click",
	   *     handler {Function}: event handler,
	   *     tags {String}:      "jQuery,Live", // These tags will be displayed as
	   *                                        // attributes in the events popup.
	   *     hide: {               // Hide or show fields:
	   *       debugger: false,    // Debugger icon
	   *       type: false,        // Event type e.g. click
	   *       filename: false,    // Filename
	   *       capturing: false,   // Capturing
	   *       dom0: false         // DOM 0
	   *     },
	   *
	   *     override: {                        // The following can be overridden:
	   *       type: "click",
	   *       origin: "http://www.mozilla.com",
	   *       searchString: 'onclick="doSomething()"',
	   *       DOM0: true,
	   *       capturing: true
	   *     }
	   *   }
	   */
	  registerEventParser: function (parserObj) {
	    let parserId = parserObj.id;

	    if (!parserId) {
	      throw new Error("Cannot register new event parser with id " + parserId);
	    }
	    if (this._eventParsers.has(parserId)) {
	      throw new Error("Duplicate event parser id " + parserId);
	    }

	    this._eventParsers.set(parserId, {
	      getListeners: parserObj.getListeners,
	      hasListeners: parserObj.hasListeners,
	      normalizeHandler: parserObj.normalizeHandler
	    });
	  },

	  /**
	   * Removes parser that matches a given parserId.
	   *
	   * @param {String} parserId
	   *        id of the event parser to unregister.
	   */
	  unregisterEventParser: function (parserId) {
	    this._eventParsers.delete(parserId);
	  },

	  /**
	   * Tidy up parsers.
	   */
	  destroy: function () {
	    for (let _ref of this._eventParsers) {
	      var _ref2 = _slicedToArray(_ref, 1);

	      let id = _ref2[0];

	      this.unregisterEventParser(id, true);
	    }
	  }
	};

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env browser */
	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// TODO: Get rid of this code once the marionette server loads transport.js as
	// an SDK module (see bug 1000814)

	"use strict";

	const DevToolsUtils = __webpack_require__(19);
	const dumpn = DevToolsUtils.dumpn;
	const dumpv = DevToolsUtils.dumpv;

	const StreamUtils = __webpack_require__(108);

	var _require = __webpack_require__(109);

	const Packet = _require.Packet;
	const JSONPacket = _require.JSONPacket;
	const BulkPacket = _require.BulkPacket;

	const promise = __webpack_require__(6);
	const EventEmitter = __webpack_require__(7);
	const utf8 = __webpack_require__(110);

	const PACKET_HEADER_MAX = 200;

	/**
	 * An adapter that handles data transfers between the debugger client and
	 * server. It can work with both nsIPipe and nsIServerSocket transports so
	 * long as the properly created input and output streams are specified.
	 * (However, for intra-process connections, LocalDebuggerTransport, below,
	 * is more efficient than using an nsIPipe pair with DebuggerTransport.)
	 *
	 * @param input nsIAsyncInputStream
	 *        The input stream.
	 * @param output nsIAsyncOutputStream
	 *        The output stream.
	 *
	 * Given a DebuggerTransport instance dt:
	 * 1) Set dt.hooks to a packet handler object (described below).
	 * 2) Call dt.ready() to begin watching for input packets.
	 * 3) Call dt.send() / dt.startBulkSend() to send packets.
	 * 4) Call dt.close() to close the connection, and disengage from the event
	 *    loop.
	 *
	 * A packet handler is an object with the following methods:
	 *
	 * - onPacket(packet) - called when we have received a complete packet.
	 *   |packet| is the parsed form of the packet --- a JavaScript value, not
	 *   a JSON-syntax string.
	 *
	 * - onBulkPacket(packet) - called when we have switched to bulk packet
	 *   receiving mode. |packet| is an object containing:
	 *   * actor:  Name of actor that will receive the packet
	 *   * type:   Name of actor's method that should be called on receipt
	 *   * length: Size of the data to be read
	 *   * stream: This input stream should only be used directly if you can ensure
	 *             that you will read exactly |length| bytes and will not close the
	 *             stream when reading is complete
	 *   * done:   If you use the stream directly (instead of |copyTo| below), you
	 *             must signal completion by resolving / rejecting this deferred.
	 *             If it's rejected, the transport will be closed.  If an Error is
	 *             supplied as a rejection value, it will be logged via |dumpn|.
	 *             If you do use |copyTo|, resolving is taken care of for you when
	 *             copying completes.
	 *   * copyTo: A helper function for getting your data out of the stream that
	 *             meets the stream handling requirements above, and has the
	 *             following signature:
	 *     @param  output nsIAsyncOutputStream
	 *             The stream to copy to.
	 *     @return Promise
	 *             The promise is resolved when copying completes or rejected if any
	 *             (unexpected) errors occur.
	 *             This object also emits "progress" events for each chunk that is
	 *             copied.  See stream-utils.js.
	 *
	 * - onClosed(reason) - called when the connection is closed. |reason| is
	 *   an optional nsresult or object, typically passed when the transport is
	 *   closed due to some error in a underlying stream.
	 *
	 * See ./packets.js and the Remote Debugging Protocol specification for more
	 * details on the format of these packets.
	 */
	function DebuggerTransport(socket) {
	  EventEmitter.decorate(this);

	  this._socket = socket;

	  // The current incoming (possibly partial) header, which will determine which
	  // type of Packet |_incoming| below will become.
	  this._incomingHeader = "";
	  // The current incoming Packet object
	  this._incoming = null;
	  // A queue of outgoing Packet objects
	  this._outgoing = [];

	  this.hooks = null;
	  this.active = false;

	  this._incomingEnabled = true;
	  this._outgoingEnabled = true;

	  this.close = this.close.bind(this);
	}

	DebuggerTransport.prototype = {
	  /**
	   * Transmit an object as a JSON packet.
	   *
	   * This method returns immediately, without waiting for the entire
	   * packet to be transmitted, registering event handlers as needed to
	   * transmit the entire packet. Packets are transmitted in the order
	   * they are passed to this method.
	   */
	  send: function (object) {
	    this.emit("send", object);

	    let packet = new JSONPacket(this);
	    packet.object = object;
	    this._outgoing.push(packet);
	    this._flushOutgoing();
	  },

	  /**
	   * Transmit streaming data via a bulk packet.
	   *
	   * This method initiates the bulk send process by queuing up the header data.
	   * The caller receives eventual access to a stream for writing.
	   *
	   * N.B.: Do *not* attempt to close the stream handed to you, as it will
	   * continue to be used by this transport afterwards.  Most users should
	   * instead use the provided |copyFrom| function instead.
	   *
	   * @param header Object
	   *        This is modeled after the format of JSON packets above, but does not
	   *        actually contain the data, but is instead just a routing header:
	   *          * actor:  Name of actor that will receive the packet
	   *          * type:   Name of actor's method that should be called on receipt
	   *          * length: Size of the data to be sent
	   * @return Promise
	   *         The promise will be resolved when you are allowed to write to the
	   *         stream with an object containing:
	   *           * stream:   This output stream should only be used directly if
	   *                       you can ensure that you will write exactly |length|
	   *                       bytes and will not close the stream when writing is
	   *                       complete
	   *           * done:     If you use the stream directly (instead of |copyFrom|
	   *                       below), you must signal completion by resolving /
	   *                       rejecting this deferred.  If it's rejected, the
	   *                       transport will be closed.  If an Error is supplied as
	   *                       a rejection value, it will be logged via |dumpn|.  If
	   *                       you do use |copyFrom|, resolving is taken care of for
	   *                       you when copying completes.
	   *           * copyFrom: A helper function for getting your data onto the
	   *                       stream that meets the stream handling requirements
	   *                       above, and has the following signature:
	   *             @param  input nsIAsyncInputStream
	   *                     The stream to copy from.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  startBulkSend: function (header) {
	    this.emit("startBulkSend", header);

	    let packet = new BulkPacket(this);
	    packet.header = header;
	    this._outgoing.push(packet);
	    this._flushOutgoing();
	    return packet.streamReadyForWriting;
	  },

	  /**
	   * Close the transport.
	   * @param reason nsresult / object (optional)
	   *        The status code or error message that corresponds to the reason for
	   *        closing the transport (likely because a stream closed or failed).
	   */
	  close: function (reason) {
	    this.emit("onClosed", reason);

	    this.active = false;
	    this._socket.close();
	    this._destroyIncoming();
	    this._destroyAllOutgoing();
	    if (this.hooks) {
	      this.hooks.onClosed(reason);
	      this.hooks = null;
	    }
	    if (reason) {
	      dumpn("Transport closed: " + DevToolsUtils.safeErrorString(reason));
	    } else {
	      dumpn("Transport closed.");
	    }
	  },

	  /**
	   * The currently outgoing packet (at the top of the queue).
	   */
	  get _currentOutgoing() {
	    return this._outgoing[0];
	  },

	  /**
	   * Flush data to the outgoing stream.  Waits until the output stream notifies
	   * us that it is ready to be written to (via onOutputStreamReady).
	   */
	  _flushOutgoing: function () {
	    if (!this._outgoingEnabled || this._outgoing.length === 0) {
	      return;
	    }

	    // If the top of the packet queue has nothing more to send, remove it.
	    if (this._currentOutgoing.done) {
	      this._finishCurrentOutgoing();
	    }

	    if (this._outgoing.length > 0) {
	      setTimeout(this.onOutputStreamReady.bind(this), 0);
	    }
	  },

	  /**
	   * Pause this transport's attempts to write to the output stream.  This is
	   * used when we've temporarily handed off our output stream for writing bulk
	   * data.
	   */
	  pauseOutgoing: function () {
	    this._outgoingEnabled = false;
	  },

	  /**
	   * Resume this transport's attempts to write to the output stream.
	   */
	  resumeOutgoing: function () {
	    this._outgoingEnabled = true;
	    this._flushOutgoing();
	  },

	  // nsIOutputStreamCallback
	  /**
	   * This is called when the output stream is ready for more data to be written.
	   * The current outgoing packet will attempt to write some amount of data, but
	   * may not complete.
	   */
	  onOutputStreamReady: DevToolsUtils.makeInfallible(function () {
	    var _this = this;

	    if (!this._outgoingEnabled || this._outgoing.length === 0) {
	      return;
	    }

	    try {
	      this._currentOutgoing.write({
	        write: function (data) {
	          let count = data.length;
	          _this._socket.send(data);
	          return count;
	        }
	      });
	    } catch (e) {
	      if (e.result != Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this.close(e.result);
	        return;
	      } else {
	        throw e;
	      }
	    }

	    this._flushOutgoing();
	  }, "DebuggerTransport.prototype.onOutputStreamReady"),

	  /**
	   * Remove the current outgoing packet from the queue upon completion.
	   */
	  _finishCurrentOutgoing: function () {
	    if (this._currentOutgoing) {
	      this._currentOutgoing.destroy();
	      this._outgoing.shift();
	    }
	  },

	  /**
	   * Clear the entire outgoing queue.
	   */
	  _destroyAllOutgoing: function () {
	    for (let packet of this._outgoing) {
	      packet.destroy();
	    }
	    this._outgoing = [];
	  },

	  /**
	   * Initialize the input stream for reading. Once this method has been called,
	   * we watch for packets on the input stream, and pass them to the appropriate
	   * handlers via this.hooks.
	   */
	  ready: function () {
	    this.active = true;
	    this._waitForIncoming();
	  },

	  /**
	   * Asks the input stream to notify us (via onInputStreamReady) when it is
	   * ready for reading.
	   */
	  _waitForIncoming: function () {
	    if (this._incomingEnabled && !this._socket.onmessage) {
	      this._socket.onmessage = this.onInputStreamReady.bind(this);
	    }
	  },

	  /**
	   * Pause this transport's attempts to read from the input stream.  This is
	   * used when we've temporarily handed off our input stream for reading bulk
	   * data.
	   */
	  pauseIncoming: function () {
	    this._incomingEnabled = false;
	  },

	  /**
	   * Resume this transport's attempts to read from the input stream.
	   */
	  resumeIncoming: function () {
	    this._incomingEnabled = true;
	    this._flushIncoming();
	    this._waitForIncoming();
	  },

	  // nsIInputStreamCallback
	  /**
	   * Called when the stream is either readable or closed.
	   */
	  onInputStreamReady: DevToolsUtils.makeInfallible(function (event) {
	    let data = event.data;
	    // TODO: ws-tcp-proxy decodes utf-8, but the transport expects to see the
	    // encoded bytes.  Simplest step is to re-encode for now.
	    data = utf8.encode(data);
	    let stream = {
	      available() {
	        return data.length;
	      },
	      readBytes(count) {
	        let result = data.slice(0, count);
	        data = data.slice(count);
	        return result;
	      }
	    };

	    try {
	      while (data && this._incomingEnabled && this._processIncoming(stream, stream.available())) {}
	      this._waitForIncoming();
	    } catch (e) {
	      if (e.result != Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this.close(e.result);
	      } else {
	        throw e;
	      }
	    }
	  }, "DebuggerTransport.prototype.onInputStreamReady"),

	  /**
	   * Process the incoming data.  Will create a new currently incoming Packet if
	   * needed.  Tells the incoming Packet to read as much data as it can, but
	   * reading may not complete.  The Packet signals that its data is ready for
	   * delivery by calling one of this transport's _on*Ready methods (see
	   * ./packets.js and the _on*Ready methods below).
	   * @return boolean
	   *         Whether incoming stream processing should continue for any
	   *         remaining data.
	   */
	  _processIncoming: function (stream, count) {
	    dumpv("Data available: " + count);

	    if (!count) {
	      dumpv("Nothing to read, skipping");
	      return false;
	    }

	    try {
	      if (!this._incoming) {
	        dumpv("Creating a new packet from incoming");

	        if (!this._readHeader(stream)) {
	          return false; // Not enough data to read packet type
	        }

	        // Attempt to create a new Packet by trying to parse each possible
	        // header pattern.
	        this._incoming = Packet.fromHeader(this._incomingHeader, this);
	        if (!this._incoming) {
	          throw new Error("No packet types for header: " + this._incomingHeader);
	        }
	      }

	      if (!this._incoming.done) {
	        // We have an incomplete packet, keep reading it.
	        dumpv("Existing packet incomplete, keep reading");
	        this._incoming.read(stream);
	      }
	    } catch (e) {
	      let msg = "Error reading incoming packet: (" + e + " - " + e.stack + ")";
	      dumpn(msg);

	      // Now in an invalid state, shut down the transport.
	      this.close();
	      return false;
	    }

	    if (!this._incoming.done) {
	      // Still not complete, we'll wait for more data.
	      dumpv("Packet not done, wait for more");
	      return true;
	    }

	    // Ready for next packet
	    this._flushIncoming();
	    return true;
	  },

	  /**
	   * Read as far as we can into the incoming data, attempting to build up a
	   * complete packet header (which terminates with ":").  We'll only read up to
	   * PACKET_HEADER_MAX characters.
	   * @return boolean
	   *         True if we now have a complete header.
	   */
	  _readHeader: function (stream) {
	    let amountToRead = PACKET_HEADER_MAX - this._incomingHeader.length;
	    this._incomingHeader += StreamUtils.delimitedRead(stream, ":", amountToRead);
	    if (dumpv.wantVerbose) {
	      dumpv("Header read: " + this._incomingHeader);
	    }

	    if (this._incomingHeader.endsWith(":")) {
	      if (dumpv.wantVerbose) {
	        dumpv("Found packet header successfully: " + this._incomingHeader);
	      }
	      return true;
	    }

	    if (this._incomingHeader.length >= PACKET_HEADER_MAX) {
	      throw new Error("Failed to parse packet header!");
	    }

	    // Not enough data yet.
	    return false;
	  },

	  /**
	   * If the incoming packet is done, log it as needed and clear the buffer.
	   */
	  _flushIncoming: function () {
	    if (!this._incoming.done) {
	      return;
	    }
	    if (dumpn.wantLogging) {
	      dumpn("Got: " + this._incoming);
	    }
	    this._destroyIncoming();
	  },

	  /**
	   * Handler triggered by an incoming JSONPacket completing it's |read| method.
	   * Delivers the packet to this.hooks.onPacket.
	   */
	  _onJSONObjectReady: function (object) {
	    var _this2 = this;

	    window.setTimeout(function () {
	      // Ensure the transport is still alive by the time this runs.
	      if (_this2.active) {
	        _this2.emit("onPacket", object);
	        _this2.hooks.onPacket(object);
	      }
	    }, 0);
	  },

	  /**
	   * Handler triggered by an incoming BulkPacket entering the |read| phase for
	   * the stream portion of the packet.  Delivers info about the incoming
	   * streaming data to this.hooks.onBulkPacket.  See the main comment on the
	   * transport at the top of this file for more details.
	   */
	  _onBulkReadReady: function (...args) {
	    var _this3 = this;

	    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(function () {
	      // Ensure the transport is still alive by the time this runs.
	      if (_this3.active) {
	        _this3.emit("onBulkPacket", ...args);
	        _this3.hooks.onBulkPacket(...args);
	      }
	    }, "DebuggerTransport instance's this.hooks.onBulkPacket"));
	  },

	  /**
	   * Remove all handlers and references related to the current incoming packet,
	   * either because it is now complete or because the transport is closing.
	   */
	  _destroyIncoming: function () {
	    if (this._incoming) {
	      this._incoming.destroy();
	    }
	    this._incomingHeader = "";
	    this._incoming = null;
	  }

	};

	exports.DebuggerTransport = DebuggerTransport;

	/**
	 * An adapter that handles data transfers between the debugger client and
	 * server when they both run in the same process. It presents the same API as
	 * DebuggerTransport, but instead of transmitting serialized messages across a
	 * connection it merely calls the packet dispatcher of the other side.
	 *
	 * @param other LocalDebuggerTransport
	 *        The other endpoint for this debugger connection.
	 *
	 * @see DebuggerTransport
	 */
	function LocalDebuggerTransport(other) {
	  EventEmitter.decorate(this);

	  this.other = other;
	  this.hooks = null;

	  /*
	   * A packet number, shared between this and this.other. This isn't used
	   * by the protocol at all, but it makes the packet traces a lot easier to
	   * follow.
	   */
	  this._serial = this.other ? this.other._serial : { count: 0 };
	  this.close = this.close.bind(this);
	}

	LocalDebuggerTransport.prototype = {
	  /**
	   * Transmit a message by directly calling the onPacket handler of the other
	   * endpoint.
	   */
	  send: function (packet) {
	    this.emit("send", packet);

	    let serial = this._serial.count++;
	    if (dumpn.wantLogging) {
	      /* Check 'from' first, as 'echo' packets have both. */
	      if (packet.from) {
	        dumpn("Packet " + serial + " sent from " + uneval(packet.from));
	      } else if (packet.to) {
	        dumpn("Packet " + serial + " sent to " + uneval(packet.to));
	      }
	    }
	    this._deepFreeze(packet);
	    let other = this.other;
	    if (other) {
	      DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(function () {
	        // Avoid the cost of JSON.stringify() when logging is disabled.
	        if (dumpn.wantLogging) {
	          dumpn("Received packet " + serial + ": " + JSON.stringify(packet, null, 2));
	        }
	        if (other.hooks) {
	          other.emit("onPacket", packet);
	          other.hooks.onPacket(packet);
	        }
	      }, "LocalDebuggerTransport instance's this.other.hooks.onPacket"));
	    }
	  },

	  /**
	   * Send a streaming bulk packet directly to the onBulkPacket handler of the
	   * other endpoint.
	   *
	   * This case is much simpler than the full DebuggerTransport, since there is
	   * no primary stream we have to worry about managing while we hand it off to
	   * others temporarily.  Instead, we can just make a single use pipe and be
	   * done with it.
	   */
	  startBulkSend: function ({ actor, type, length }) {
	    var _this4 = this;

	    this.emit("startBulkSend", { actor, type, length });

	    let serial = this._serial.count++;

	    dumpn("Sent bulk packet " + serial + " for actor " + actor);
	    if (!this.other) {
	      return;
	    }

	    let pipe = new Pipe(true, true, 0, 0, null);

	    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(function () {
	      dumpn("Received bulk packet " + serial);
	      if (!_this4.other.hooks) {
	        return;
	      }

	      // Receiver
	      let deferred = promise.defer();
	      let packet = {
	        actor: actor,
	        type: type,
	        length: length,
	        copyTo: function (output) {
	          let copying = StreamUtils.copyStream(pipe.inputStream, output, length);
	          deferred.resolve(copying);
	          return copying;
	        },
	        stream: pipe.inputStream,
	        done: deferred
	      };

	      _this4.other.emit("onBulkPacket", packet);
	      _this4.other.hooks.onBulkPacket(packet);

	      // Await the result of reading from the stream
	      deferred.promise.then(function () {
	        return pipe.inputStream.close();
	      }, _this4.close);
	    }, "LocalDebuggerTransport instance's this.other.hooks.onBulkPacket"));

	    // Sender
	    let sendDeferred = promise.defer();

	    // The remote transport is not capable of resolving immediately here, so we
	    // shouldn't be able to either.
	    DevToolsUtils.executeSoon(function () {
	      let copyDeferred = promise.defer();

	      sendDeferred.resolve({
	        copyFrom: function (input) {
	          let copying = StreamUtils.copyStream(input, pipe.outputStream, length);
	          copyDeferred.resolve(copying);
	          return copying;
	        },
	        stream: pipe.outputStream,
	        done: copyDeferred
	      });

	      // Await the result of writing to the stream
	      copyDeferred.promise.then(function () {
	        return pipe.outputStream.close();
	      }, _this4.close);
	    });

	    return sendDeferred.promise;
	  },

	  /**
	   * Close the transport.
	   */
	  close: function () {
	    this.emit("close");

	    if (this.other) {
	      // Remove the reference to the other endpoint before calling close(), to
	      // avoid infinite recursion.
	      let other = this.other;
	      this.other = null;
	      other.close();
	    }
	    if (this.hooks) {
	      try {
	        this.hooks.onClosed();
	      } catch (ex) {
	        Cu.reportError(ex);
	      }
	      this.hooks = null;
	    }
	  },

	  /**
	   * An empty method for emulating the DebuggerTransport API.
	   */
	  ready: function () {},

	  /**
	   * Helper function that makes an object fully immutable.
	   */
	  _deepFreeze: function (object) {
	    Object.freeze(object);
	    for (let prop in object) {
	      // Freeze the properties that are objects, not on the prototype, and not
	      // already frozen. Note that this might leave an unfrozen reference
	      // somewhere in the object if there is an already frozen object containing
	      // an unfrozen object.
	      if (object.hasOwnProperty(prop) && typeof object === "object" && !Object.isFrozen(object)) {
	        this._deepFreeze(o[prop]);
	      }
	    }
	  }
	};

	exports.LocalDebuggerTransport = LocalDebuggerTransport;

	/**
	 * A transport for the debugging protocol that uses nsIMessageSenders to
	 * exchange packets with servers running in child processes.
	 *
	 * In the parent process, |sender| should be the nsIMessageSender for the
	 * child process. In a child process, |sender| should be the child process
	 * message manager, which sends packets to the parent.
	 *
	 * |prefix| is a string included in the message names, to distinguish
	 * multiple servers running in the same child process.
	 *
	 * This transport exchanges messages named 'debug:<prefix>:packet', where
	 * <prefix> is |prefix|, whose data is the protocol packet.
	 */
	function ChildDebuggerTransport(sender, prefix) {
	  EventEmitter.decorate(this);

	  this._sender = sender.QueryInterface(Ci.nsIMessageSender);
	  this._messageName = "debug:" + prefix + ":packet";
	}

	/*
	 * To avoid confusion, we use 'message' to mean something that
	 * nsIMessageSender conveys, and 'packet' to mean a remote debugging
	 * protocol packet.
	 */
	ChildDebuggerTransport.prototype = {
	  constructor: ChildDebuggerTransport,

	  hooks: null,

	  ready: function () {
	    this._sender.addMessageListener(this._messageName, this);
	  },

	  close: function () {
	    this._sender.removeMessageListener(this._messageName, this);
	    this.emit("onClosed");
	    this.hooks.onClosed();
	  },

	  receiveMessage: function ({ data }) {
	    this.emit("onPacket", data);
	    this.hooks.onPacket(data);
	  },

	  send: function (packet) {
	    this.emit("send", packet);
	    this._sender.sendAsyncMessage(this._messageName, packet);
	  },

	  startBulkSend: function () {
	    throw new Error("Can't send bulk data to child processes.");
	  }
	};

	exports.ChildDebuggerTransport = ChildDebuggerTransport;

	// WorkerDebuggerTransport is defined differently depending on whether we are
	// on the main thread or a worker thread. In the former case, we are required
	// by the devtools loader, and isWorker will be false. Otherwise, we are
	// required by the worker loader, and isWorker will be true.
	//
	// Each worker debugger supports only a single connection to the main thread.
	// However, its theoretically possible for multiple servers to connect to the
	// same worker. Consequently, each transport has a connection id, to allow
	// messages from multiple connections to be multiplexed on a single channel.

	if (!this.isWorker) {
	  (function () {
	    // Main thread
	    /**
	     * A transport that uses a WorkerDebugger to send packets from the main
	     * thread to a worker thread.
	     */
	    function WorkerDebuggerTransport(dbg, id) {
	      this._dbg = dbg;
	      this._id = id;
	      this.onMessage = this._onMessage.bind(this);
	    }

	    WorkerDebuggerTransport.prototype = {
	      constructor: WorkerDebuggerTransport,

	      ready: function () {
	        this._dbg.addListener(this);
	      },

	      close: function () {
	        this._dbg.removeListener(this);
	        if (this.hooks) {
	          this.hooks.onClosed();
	        }
	      },

	      send: function (packet) {
	        this._dbg.postMessage(JSON.stringify({
	          type: "message",
	          id: this._id,
	          message: packet
	        }));
	      },

	      startBulkSend: function () {
	        throw new Error("Can't send bulk data from worker threads!");
	      },

	      _onMessage: function (message) {
	        let packet = JSON.parse(message);
	        if (packet.type !== "message" || packet.id !== this._id) {
	          return;
	        }

	        if (this.hooks) {
	          this.hooks.onPacket(packet.message);
	        }
	      }
	    };

	    exports.WorkerDebuggerTransport = WorkerDebuggerTransport;
	  }).call(this);
	} else {
	  (function () {
	    // Worker thread
	    /*
	     * A transport that uses a WorkerDebuggerGlobalScope to send packets from a
	     * worker thread to the main thread.
	     */
	    function WorkerDebuggerTransport(scope, id) {
	      this._scope = scope;
	      this._id = id;
	      this._onMessage = this._onMessage.bind(this);
	    }

	    WorkerDebuggerTransport.prototype = {
	      constructor: WorkerDebuggerTransport,

	      ready: function () {
	        this._scope.addEventListener("message", this._onMessage);
	      },

	      close: function () {
	        this._scope.removeEventListener("message", this._onMessage);
	        if (this.hooks) {
	          this.hooks.onClosed();
	        }
	      },

	      send: function (packet) {
	        this._scope.postMessage(JSON.stringify({
	          type: "message",
	          id: this._id,
	          message: packet
	        }));
	      },

	      startBulkSend: function () {
	        throw new Error("Can't send bulk data from worker threads!");
	      },

	      _onMessage: function (event) {
	        let packet = JSON.parse(event.data);
	        if (packet.type !== "message" || packet.id !== this._id) {
	          return;
	        }

	        if (this.hooks) {
	          this.hooks.onPacket(packet.message);
	        }
	      }
	    };

	    exports.WorkerDebuggerTransport = WorkerDebuggerTransport;
	  }).call(this);
	}

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(1);

	const Ci = _require.Ci;
	const Cc = _require.Cc;
	const Cu = _require.Cu;
	const Cr = _require.Cr;
	const CC = _require.CC;

	const Services = __webpack_require__(9);
	const DevToolsUtils = __webpack_require__(19);
	const dumpv = DevToolsUtils.dumpv;

	const EventEmitter = __webpack_require__(7);
	const promise = __webpack_require__(6);

	DevToolsUtils.defineLazyGetter(this, "IOUtil", function () {
	  return Cc("@mozilla.org/io-util;1").getService(Ci.nsIIOUtil);
	});

	DevToolsUtils.defineLazyGetter(this, "ScriptableInputStream", function () {
	  return CC("@mozilla.org/scriptableinputstream;1", "nsIScriptableInputStream", "init");
	});

	const BUFFER_SIZE = 0x8000;

	/**
	 * This helper function (and its companion object) are used by bulk senders and
	 * receivers to read and write data in and out of other streams.  Functions that
	 * make use of this tool are passed to callers when it is time to read or write
	 * bulk data.  It is highly recommended to use these copier functions instead of
	 * the stream directly because the copier enforces the agreed upon length.
	 * Since bulk mode reuses an existing stream, the sender and receiver must write
	 * and read exactly the agreed upon amount of data, or else the entire transport
	 * will be left in a invalid state.  Additionally, other methods of stream
	 * copying (such as NetUtil.asyncCopy) close the streams involved, which would
	 * terminate the debugging transport, and so it is avoided here.
	 *
	 * Overall, this *works*, but clearly the optimal solution would be able to just
	 * use the streams directly.  If it were possible to fully implement
	 * nsIInputStream / nsIOutputStream in JS, wrapper streams could be created to
	 * enforce the length and avoid closing, and consumers could use familiar stream
	 * utilities like NetUtil.asyncCopy.
	 *
	 * The function takes two async streams and copies a precise number of bytes
	 * from one to the other.  Copying begins immediately, but may complete at some
	 * future time depending on data size.  Use the returned promise to know when
	 * it's complete.
	 *
	 * @param input nsIAsyncInputStream
	 *        The stream to copy from.
	 * @param output nsIAsyncOutputStream
	 *        The stream to copy to.
	 * @param length Integer
	 *        The amount of data that needs to be copied.
	 * @return Promise
	 *         The promise is resolved when copying completes or rejected if any
	 *         (unexpected) errors occur.
	 */
	function copyStream(input, output, length) {
	  let copier = new StreamCopier(input, output, length);
	  return copier.copy();
	}

	function StreamCopier(input, output, length) {
	  EventEmitter.decorate(this);
	  this._id = StreamCopier._nextId++;
	  this.input = input;
	  // Save off the base output stream, since we know it's async as we've required
	  this.baseAsyncOutput = output;
	  if (IOUtil.outputStreamIsBuffered(output)) {
	    this.output = output;
	  } else {
	    this.output = Cc("@mozilla.org/network/buffered-output-stream;1").createInstance(Ci.nsIBufferedOutputStream);
	    this.output.init(output, BUFFER_SIZE);
	  }
	  this._length = length;
	  this._amountLeft = length;
	  this._deferred = promise.defer();

	  this._copy = this._copy.bind(this);
	  this._flush = this._flush.bind(this);
	  this._destroy = this._destroy.bind(this);

	  // Copy promise's then method up to this object.
	  // Allows the copier to offer a promise interface for the simple succeed or
	  // fail scenarios, but also emit events (due to the EventEmitter) for other
	  // states, like progress.
	  this.then = this._deferred.promise.then.bind(this._deferred.promise);
	  this.then(this._destroy, this._destroy);

	  // Stream ready callback starts as |_copy|, but may switch to |_flush| at end
	  // if flushing would block the output stream.
	  this._streamReadyCallback = this._copy;
	}
	StreamCopier._nextId = 0;

	StreamCopier.prototype = {

	  copy: function () {
	    var _this = this;

	    // Dispatch to the next tick so that it's possible to attach a progress
	    // event listener, even for extremely fast copies (like when testing).
	    Services.tm.currentThread.dispatch(function () {
	      try {
	        _this._copy();
	      } catch (e) {
	        _this._deferred.reject(e);
	      }
	    }, 0);
	    return this;
	  },

	  _copy: function () {
	    let bytesAvailable = this.input.available();
	    let amountToCopy = Math.min(bytesAvailable, this._amountLeft);
	    this._debug("Trying to copy: " + amountToCopy);

	    let bytesCopied;
	    try {
	      bytesCopied = this.output.writeFrom(this.input, amountToCopy);
	    } catch (e) {
	      if (e.result == Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this._debug("Base stream would block, will retry");
	        this._debug("Waiting for output stream");
	        this.baseAsyncOutput.asyncWait(this, 0, 0, Services.tm.currentThread);
	        return;
	      } else {
	        throw e;
	      }
	    }

	    this._amountLeft -= bytesCopied;
	    this._debug("Copied: " + bytesCopied + ", Left: " + this._amountLeft);
	    this._emitProgress();

	    if (this._amountLeft === 0) {
	      this._debug("Copy done!");
	      this._flush();
	      return;
	    }

	    this._debug("Waiting for input stream");
	    this.input.asyncWait(this, 0, 0, Services.tm.currentThread);
	  },

	  _emitProgress: function () {
	    this.emit("progress", {
	      bytesSent: this._length - this._amountLeft,
	      totalBytes: this._length
	    });
	  },

	  _flush: function () {
	    try {
	      this.output.flush();
	    } catch (e) {
	      if (e.result == Cr.NS_BASE_STREAM_WOULD_BLOCK || e.result == Cr.NS_ERROR_FAILURE) {
	        this._debug("Flush would block, will retry");
	        this._streamReadyCallback = this._flush;
	        this._debug("Waiting for output stream");
	        this.baseAsyncOutput.asyncWait(this, 0, 0, Services.tm.currentThread);
	        return;
	      } else {
	        throw e;
	      }
	    }
	    this._deferred.resolve();
	  },

	  _destroy: function () {
	    this._destroy = null;
	    this._copy = null;
	    this._flush = null;
	    this.input = null;
	    this.output = null;
	  },

	  // nsIInputStreamCallback
	  onInputStreamReady: function () {
	    this._streamReadyCallback();
	  },

	  // nsIOutputStreamCallback
	  onOutputStreamReady: function () {
	    this._streamReadyCallback();
	  },

	  _debug: function (msg) {
	    // Prefix logs with the copier ID, which makes logs much easier to
	    // understand when several copiers are running simultaneously
	    dumpv("Copier: " + this._id + " " + msg);
	  }

	};

	/**
	 * Read from a stream, one byte at a time, up to the next |delimiter|
	 * character, but stopping if we've read |count| without finding it.  Reading
	 * also terminates early if there are less than |count| bytes available on the
	 * stream.  In that case, we only read as many bytes as the stream currently has
	 * to offer.
	 * TODO: This implementation could be removed if bug 984651 is fixed, which
	 *       provides a native version of the same idea.
	 * @param stream nsIInputStream
	 *        The input stream to read from.
	 * @param delimiter string
	 *        The character we're trying to find.
	 * @param count integer
	 *        The max number of characters to read while searching.
	 * @return string
	 *         The data collected.  If the delimiter was found, this string will
	 *         end with it.
	 */
	function delimitedRead(stream, delimiter, count) {
	  dumpv("Starting delimited read for " + delimiter + " up to " + count + " bytes");

	  let scriptableStream;
	  if (stream.readBytes) {
	    scriptableStream = stream;
	  } else {
	    scriptableStream = new ScriptableInputStream(stream);
	  }

	  let data = "";

	  // Don't exceed what's available on the stream
	  count = Math.min(count, stream.available());

	  if (count <= 0) {
	    return data;
	  }

	  let char;
	  while (char !== delimiter && count > 0) {
	    char = scriptableStream.readBytes(1);
	    count--;
	    data += char;
	  }

	  return data;
	}

	module.exports = {
	  copyStream: copyStream,
	  delimitedRead: delimitedRead
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict"

	/**
	 * Packets contain read / write functionality for the different packet types
	 * supported by the debugging protocol, so that a transport can focus on
	 * delivery and queue management without worrying too much about the specific
	 * packet types.
	 *
	 * They are intended to be "one use only", so a new packet should be
	 * instantiated for each incoming or outgoing packet.
	 *
	 * A complete Packet type should expose at least the following:
	 *   * read(stream, scriptableStream)
	 *     Called when the input stream has data to read
	 *   * write(stream)
	 *     Called when the output stream is ready to write
	 *   * get done()
	 *     Returns true once the packet is done being read / written
	 *   * destroy()
	 *     Called to clean up at the end of use
	 */

	;

	var _require = __webpack_require__(1);

	const Cc = _require.Cc;
	const Ci = _require.Ci;
	const Cu = _require.Cu;

	const DevToolsUtils = __webpack_require__(19);
	const dumpn = DevToolsUtils.dumpn;
	const dumpv = DevToolsUtils.dumpv;

	const StreamUtils = __webpack_require__(108);
	const promise = __webpack_require__(6);

	/*DevToolsUtils.defineLazyGetter(this, "unicodeConverter", () => {
	  const unicodeConverter = Cc("@mozilla.org/intl/scriptableunicodeconverter")
	                           .createInstance(Ci.nsIScriptableUnicodeConverter);
	  unicodeConverter.charset = "UTF-8";
	  return unicodeConverter;
	});*/
	const utf8 = __webpack_require__(110);

	// The transport's previous check ensured the header length did not exceed 20
	// characters.  Here, we opt for the somewhat smaller, but still large limit of
	// 1 TiB.
	const PACKET_LENGTH_MAX = Math.pow(2, 40);

	/**
	 * A generic Packet processing object (extended by two subtypes below).
	 */
	function Packet(transport) {
	  this._transport = transport;
	  this._length = 0;
	}

	/**
	 * Attempt to initialize a new Packet based on the incoming packet header we've
	 * received so far.  We try each of the types in succession, trying JSON packets
	 * first since they are much more common.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return Packet
	 *         The parsed packet of the matching type, or null if no types matched.
	 */
	Packet.fromHeader = function (header, transport) {
	  return JSONPacket.fromHeader(header, transport) || BulkPacket.fromHeader(header, transport);
	};

	Packet.prototype = {

	  get length() {
	    return this._length;
	  },

	  set length(length) {
	    if (length > PACKET_LENGTH_MAX) {
	      throw Error("Packet length " + length + " exceeds the max length of " + PACKET_LENGTH_MAX);
	    }
	    this._length = length;
	  },

	  destroy: function () {
	    this._transport = null;
	  }

	};

	exports.Packet = Packet;

	/**
	 * With a JSON packet (the typical packet type sent via the transport), data is
	 * transferred as a JSON packet serialized into a string, with the string length
	 * prepended to the packet, followed by a colon ([length]:[packet]). The
	 * contents of the JSON packet are specified in the Remote Debugging Protocol
	 * specification.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 */
	function JSONPacket(transport) {
	  Packet.call(this, transport);
	  this._data = "";
	  this._done = false;
	}

	/**
	 * Attempt to initialize a new JSONPacket based on the incoming packet header
	 * we've received so far.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return JSONPacket
	 *         The parsed packet, or null if it's not a match.
	 */
	JSONPacket.fromHeader = function (header, transport) {
	  let match = this.HEADER_PATTERN.exec(header);

	  if (!match) {
	    return null;
	  }

	  dumpv("Header matches JSON packet");
	  let packet = new JSONPacket(transport);
	  packet.length = +match[1];
	  return packet;
	};

	JSONPacket.HEADER_PATTERN = /^(\d+):$/;

	JSONPacket.prototype = Object.create(Packet.prototype);

	Object.defineProperty(JSONPacket.prototype, "object", {
	  /**
	   * Gets the object (not the serialized string) being read or written.
	   */
	  get: function () {
	    return this._object;
	  },

	  /**
	   * Sets the object to be sent when write() is called.
	   */
	  set: function (object) {
	    this._object = object;
	    let data = JSON.stringify(object);
	    this._data = data;
	    this.length = this._data.length;
	  }
	});

	JSONPacket.prototype.read = function (stream, scriptableStream) {
	  dumpv("Reading JSON packet");

	  // Read in more packet data.
	  this._readData(stream, scriptableStream);

	  if (!this.done) {
	    // Don't have a complete packet yet.
	    return;
	  }

	  let json = this._data;
	  try {
	    json = utf8.decode(json);
	    this._object = JSON.parse(json);
	  } catch (e) {
	    let msg = "Error parsing incoming packet: " + json + " (" + e + " - " + e.stack + ")";
	    if (Cu.reportError) {
	      Cu.reportError(msg);
	    }
	    dumpn(msg);
	    return;
	  }

	  this._transport._onJSONObjectReady(this._object);
	};

	JSONPacket.prototype._readData = function (stream, scriptableStream) {
	  if (!scriptableStream) {
	    scriptableStream = stream;
	  }
	  if (dumpv.wantVerbose) {
	    dumpv("Reading JSON data: _l: " + this.length + " dL: " + this._data.length + " sA: " + stream.available());
	  }
	  let bytesToRead = Math.min(this.length - this._data.length, stream.available());
	  this._data += scriptableStream.readBytes(bytesToRead);
	  this._done = this._data.length === this.length;
	};

	JSONPacket.prototype.write = function (stream) {
	  dumpv("Writing JSON packet");

	  if (this._outgoing === undefined) {
	    // Format the serialized packet to a buffer
	    this._outgoing = this.length + ":" + this._data;
	  }

	  let written = stream.write(this._outgoing, this._outgoing.length);
	  this._outgoing = this._outgoing.slice(written);
	  this._done = !this._outgoing.length;
	};

	Object.defineProperty(JSONPacket.prototype, "done", {
	  get: function () {
	    return this._done;
	  }
	});

	JSONPacket.prototype.toString = function () {
	  return JSON.stringify(this._object, null, 2);
	};

	exports.JSONPacket = JSONPacket;

	/**
	 * With a bulk packet, data is transferred by temporarily handing over the
	 * transport's input or output stream to the application layer for writing data
	 * directly.  This can be much faster for large data sets, and avoids various
	 * stages of copies and data duplication inherent in the JSON packet type.  The
	 * bulk packet looks like:
	 *
	 * bulk [actor] [type] [length]:[data]
	 *
	 * The interpretation of the data portion depends on the kind of actor and the
	 * packet's type.  See the Remote Debugging Protocol Stream Transport spec for
	 * more details.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 */
	function BulkPacket(transport) {
	  Packet.call(this, transport);
	  this._done = false;
	  this._readyForWriting = promise.defer();
	}

	/**
	 * Attempt to initialize a new BulkPacket based on the incoming packet header
	 * we've received so far.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return BulkPacket
	 *         The parsed packet, or null if it's not a match.
	 */
	BulkPacket.fromHeader = function (header, transport) {
	  let match = this.HEADER_PATTERN.exec(header);

	  if (!match) {
	    return null;
	  }

	  dumpv("Header matches bulk packet");
	  let packet = new BulkPacket(transport);
	  packet.header = {
	    actor: match[1],
	    type: match[2],
	    length: +match[3]
	  };
	  return packet;
	};

	BulkPacket.HEADER_PATTERN = /^bulk ([^: ]+) ([^: ]+) (\d+):$/;

	BulkPacket.prototype = Object.create(Packet.prototype);

	BulkPacket.prototype.read = function (stream) {
	  var _this = this;

	  dumpv("Reading bulk packet, handing off input stream");

	  // Temporarily pause monitoring of the input stream
	  this._transport.pauseIncoming();

	  let deferred = promise.defer();

	  this._transport._onBulkReadReady({
	    actor: this.actor,
	    type: this.type,
	    length: this.length,
	    copyTo: function (output) {
	      dumpv("CT length: " + _this.length);
	      let copying = StreamUtils.copyStream(stream, output, _this.length);
	      deferred.resolve(copying);
	      return copying;
	    },
	    stream: stream,
	    done: deferred
	  });

	  // Await the result of reading from the stream
	  deferred.promise.then(function () {
	    dumpv("onReadDone called, ending bulk mode");
	    _this._done = true;
	    _this._transport.resumeIncoming();
	  }, this._transport.close);

	  // Ensure this is only done once
	  this.read = function () {
	    throw new Error("Tried to read() a BulkPacket's stream multiple times.");
	  };
	};

	BulkPacket.prototype.write = function (stream) {
	  var _this2 = this;

	  dumpv("Writing bulk packet");

	  if (this._outgoingHeader === undefined) {
	    dumpv("Serializing bulk packet header");
	    // Format the serialized packet header to a buffer
	    this._outgoingHeader = "bulk " + this.actor + " " + this.type + " " + this.length + ":";
	  }

	  // Write the header, or whatever's left of it to write.
	  if (this._outgoingHeader.length) {
	    dumpv("Writing bulk packet header");
	    let written = stream.write(this._outgoingHeader, this._outgoingHeader.length);
	    this._outgoingHeader = this._outgoingHeader.slice(written);
	    return;
	  }

	  dumpv("Handing off output stream");

	  // Temporarily pause the monitoring of the output stream
	  this._transport.pauseOutgoing();

	  let deferred = promise.defer();

	  this._readyForWriting.resolve({
	    copyFrom: function (input) {
	      dumpv("CF length: " + _this2.length);
	      let copying = StreamUtils.copyStream(input, stream, _this2.length);
	      deferred.resolve(copying);
	      return copying;
	    },
	    stream: stream,
	    done: deferred
	  });

	  // Await the result of writing to the stream
	  deferred.promise.then(function () {
	    dumpv("onWriteDone called, ending bulk mode");
	    _this2._done = true;
	    _this2._transport.resumeOutgoing();
	  }, this._transport.close);

	  // Ensure this is only done once
	  this.write = function () {
	    throw new Error("Tried to write() a BulkPacket's stream multiple times.");
	  };
	};

	Object.defineProperty(BulkPacket.prototype, "streamReadyForWriting", {
	  get: function () {
	    return this._readyForWriting.promise;
	  }
	});

	Object.defineProperty(BulkPacket.prototype, "header", {
	  get: function () {
	    return {
	      actor: this.actor,
	      type: this.type,
	      length: this.length
	    };
	  },

	  set: function (header) {
	    this.actor = header.actor;
	    this.type = header.type;
	    this.length = header.length;
	  }
	});

	Object.defineProperty(BulkPacket.prototype, "done", {
	  get: function () {
	    return this._done;
	  }
	});

	BulkPacket.prototype.toString = function () {
	  return "Bulk: " + JSON.stringify(this.header, null, 2);
	};

	exports.BulkPacket = BulkPacket;

	/**
	 * RawPacket is used to test the transport's error handling of malformed
	 * packets, by writing data directly onto the stream.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @param data string
	 *        The raw string to send out onto the stream.
	 */
	function RawPacket(transport, data) {
	  Packet.call(this, transport);
	  this._data = data;
	  this.length = data.length;
	  this._done = false;
	}

	RawPacket.prototype = Object.create(Packet.prototype);

	RawPacket.prototype.read = function (stream) {
	  // This hasn't yet been needed for testing.
	  throw Error("Not implmented.");
	};

	RawPacket.prototype.write = function (stream) {
	  let written = stream.write(this._data, this._data.length);
	  this._data = this._data.slice(written);
	  this._done = !this._data.length;
	};

	Object.defineProperty(RawPacket.prototype, "done", {
	  get: function () {
	    return this._done;
	  }
	});

	exports.RawPacket = RawPacket;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';

	/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function (root) {

		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;

		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;

		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}

		/*--------------------------------------------------------------------------*/

		var stringFromCharCode = String.fromCharCode;

		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}

		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
			}
		}
		/*--------------------------------------------------------------------------*/

		function createByte(codePoint, shift) {
			return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
		}

		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) {
				// 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) {
				// 2-byte sequence
				symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
			} else if ((codePoint & 0xFFFF0000) == 0) {
				// 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
				symbol += createByte(codePoint, 6);
			} else if ((codePoint & 0xFFE00000) == 0) {
				// 4-byte sequence
				symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
			return symbol;
		}

		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}

		/*--------------------------------------------------------------------------*/

		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}

			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}

			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}

		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;

			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}

			if (byteIndex == byteCount) {
				return false;
			}

			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}

			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = (byte1 & 0x1F) << 6 | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = (byte1 & 0x0F) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}

			throw Error('Invalid UTF-8 detected');
		}

		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}

		/*--------------------------------------------------------------------------*/

		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};

		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (true) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && !freeExports.nodeType) {
			if (freeModule) {
				// in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.utf8 = utf8;
		}
	})(this);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module), (function() { return this; }())))

/***/ }
/******/ ]);